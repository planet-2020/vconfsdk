// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enum.proto

package com.kedacom.mt.netmanage.protobuf;

public final class EnumPB {
  private EnumPB() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
  }
  /**
   * Protobuf enum {@code mt.EmAiMtFunction}
   *
   * <pre>
   *终端智能功能枚举
   * </pre>
   */
  public enum EmAiMtFunction
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVoiceAide = 0;</code>
     *
     * <pre>
     *语音助手
     * </pre>
     */
    emVoiceAide(0, 0),
    /**
     * <code>emConfRecord = 1;</code>
     *
     * <pre>
     *会议纪要
     * </pre>
     */
    emConfRecord(1, 1),
    /**
     * <code>emFaceSign = 2;</code>
     *
     * <pre>
     *人脸签到
     * </pre>
     */
    emFaceSign(2, 2),
    /**
     * <code>emPeopleCounting = 3;</code>
     *
     * <pre>
     *人数统计
     * </pre>
     */
    emPeopleCounting(3, 3),
    /**
     * <code>emPeopleLable = 4;</code>
     *
     * <pre>
     *人像标签
     * </pre>
     */
    emPeopleLable(4, 4),
    /**
     * <code>emNamePlate = 5;</code>
     *
     * <pre>
     *电子铭牌
     * </pre>
     */
    emNamePlate(5, 5),
    /**
     * <code>emGuideVideo = 6;</code>
     *
     * <pre>
     *智能导播
     * </pre>
     */
    emGuideVideo(6, 6),
    /**
     * <code>emConfCaption = 7;</code>
     *
     * <pre>
     *会议字幕
     * </pre>
     */
    emConfCaption(7, 7),
    /**
     * <code>emFaceUnLock = 8;</code>
     *
     * <pre>
     *人脸解锁
     * </pre>
     */
    emFaceUnLock(8, 8),
    /**
     * <code>emAdaptiveFraming = 9;</code>
     *
     * <pre>
     *自适应取景
     * </pre>
     */
    emAdaptiveFraming(9, 9),
    /**
     * <code>emIntellTrack = 10;</code>
     *
     * <pre>
     *智能跟踪
     * </pre>
     */
    emIntellTrack(10, 10),
    /**
     * <code>EmAiMtFunEnd = 20;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    EmAiMtFunEnd(11, 20),
    ;

    /**
     * <code>emVoiceAide = 0;</code>
     *
     * <pre>
     *语音助手
     * </pre>
     */
    public static final int emVoiceAide_VALUE = 0;
    /**
     * <code>emConfRecord = 1;</code>
     *
     * <pre>
     *会议纪要
     * </pre>
     */
    public static final int emConfRecord_VALUE = 1;
    /**
     * <code>emFaceSign = 2;</code>
     *
     * <pre>
     *人脸签到
     * </pre>
     */
    public static final int emFaceSign_VALUE = 2;
    /**
     * <code>emPeopleCounting = 3;</code>
     *
     * <pre>
     *人数统计
     * </pre>
     */
    public static final int emPeopleCounting_VALUE = 3;
    /**
     * <code>emPeopleLable = 4;</code>
     *
     * <pre>
     *人像标签
     * </pre>
     */
    public static final int emPeopleLable_VALUE = 4;
    /**
     * <code>emNamePlate = 5;</code>
     *
     * <pre>
     *电子铭牌
     * </pre>
     */
    public static final int emNamePlate_VALUE = 5;
    /**
     * <code>emGuideVideo = 6;</code>
     *
     * <pre>
     *智能导播
     * </pre>
     */
    public static final int emGuideVideo_VALUE = 6;
    /**
     * <code>emConfCaption = 7;</code>
     *
     * <pre>
     *会议字幕
     * </pre>
     */
    public static final int emConfCaption_VALUE = 7;
    /**
     * <code>emFaceUnLock = 8;</code>
     *
     * <pre>
     *人脸解锁
     * </pre>
     */
    public static final int emFaceUnLock_VALUE = 8;
    /**
     * <code>emAdaptiveFraming = 9;</code>
     *
     * <pre>
     *自适应取景
     * </pre>
     */
    public static final int emAdaptiveFraming_VALUE = 9;
    /**
     * <code>emIntellTrack = 10;</code>
     *
     * <pre>
     *智能跟踪
     * </pre>
     */
    public static final int emIntellTrack_VALUE = 10;
    /**
     * <code>EmAiMtFunEnd = 20;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    public static final int EmAiMtFunEnd_VALUE = 20;


    public final int getNumber() { return value; }

    public static EmAiMtFunction valueOf(int value) {
      switch (value) {
        case 0: return emVoiceAide;
        case 1: return emConfRecord;
        case 2: return emFaceSign;
        case 3: return emPeopleCounting;
        case 4: return emPeopleLable;
        case 5: return emNamePlate;
        case 6: return emGuideVideo;
        case 7: return emConfCaption;
        case 8: return emFaceUnLock;
        case 9: return emAdaptiveFraming;
        case 10: return emIntellTrack;
        case 20: return EmAiMtFunEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAiMtFunction>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAiMtFunction>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAiMtFunction>() {
            public EmAiMtFunction findValueByNumber(int number) {
              return EmAiMtFunction.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(0);
    }

    private static final EmAiMtFunction[] VALUES = values();

    public static EmAiMtFunction valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAiMtFunction(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAiMtFunction)
  }

  /**
   * Protobuf enum {@code mt.EmAiFaceSignMode}
   */
  public enum EmAiFaceSignMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAiAllHasSign = 0;</code>
     *
     * <pre>
     *所有已签到数据
     * </pre>
     */
    emAiAllHasSign(0, 0),
    /**
     * <code>emAiAllNotSign = 1;</code>
     *
     * <pre>
     *所有未签到数据
     * </pre>
     */
    emAiAllNotSign(1, 1),
    /**
     * <code>emAiAllSign = 2;</code>
     *
     * <pre>
     *所有数据
     * </pre>
     */
    emAiAllSign(2, 2),
    ;

    /**
     * <code>emAiAllHasSign = 0;</code>
     *
     * <pre>
     *所有已签到数据
     * </pre>
     */
    public static final int emAiAllHasSign_VALUE = 0;
    /**
     * <code>emAiAllNotSign = 1;</code>
     *
     * <pre>
     *所有未签到数据
     * </pre>
     */
    public static final int emAiAllNotSign_VALUE = 1;
    /**
     * <code>emAiAllSign = 2;</code>
     *
     * <pre>
     *所有数据
     * </pre>
     */
    public static final int emAiAllSign_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmAiFaceSignMode valueOf(int value) {
      switch (value) {
        case 0: return emAiAllHasSign;
        case 1: return emAiAllNotSign;
        case 2: return emAiAllSign;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAiFaceSignMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAiFaceSignMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAiFaceSignMode>() {
            public EmAiFaceSignMode findValueByNumber(int number) {
              return EmAiFaceSignMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(1);
    }

    private static final EmAiFaceSignMode[] VALUES = values();

    public static EmAiFaceSignMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAiFaceSignMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAiFaceSignMode)
  }

  /**
   * Protobuf enum {@code mt.EmHintCode}
   *
   * <pre>
   *提示码
   * </pre>
   */
  public enum EmHintCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emHintBegin = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    emHintBegin(0, 0),
    /**
     * <code>emFailtoSendDual = 1;</code>
     *
     * <pre>
     *对端不支持当前格式和分辨率下的桌面共享
     * </pre>
     */
    emFailtoSendDual(1, 1),
    /**
     * <code>emFailtoRecvDual = 2;</code>
     *
     * <pre>
     *带宽不足，不支持对端发起的桌面共享
     * </pre>
     */
    emFailtoRecvDual(2, 2),
    /**
     * <code>emFailtoVodLogin = 3;</code>
     *
     * <pre>
     *VOD 登录失败
     * </pre>
     */
    emFailtoVodLogin(3, 3),
    /**
     * <code>emDHCPTimeOut = 4;</code>
     *
     * <pre>
     *获取DHCP地址超时
     * </pre>
     */
    emDHCPTimeOut(4, 4),
    /**
     * <code>emPPPoEAuthorError = 5;</code>
     *
     * <pre>
     *PPPOE身份验证错误
     * </pre>
     */
    emPPPoEAuthorError(5, 5),
    /**
     * <code>emPPPoEAgentError = 6;</code>
     *
     * <pre>
     *PPPOE找不到ISP服务商
     * </pre>
     */
    emPPPoEAgentError(6, 6),
    /**
     * <code>emPPPoETimeOutError = 7;</code>
     *
     * <pre>
     *PPPOE拨号超时
     * </pre>
     */
    emPPPoETimeOutError(7, 7),
    /**
     * <code>emPPPoELinkDownError = 8;</code>
     *
     * <pre>
     *PPPOE断链
     * </pre>
     */
    emPPPoELinkDownError(8, 8),
    /**
     * <code>emPPPoEGeneralError = 9;</code>
     *
     * <pre>
     *PPPOE其他错误
     * </pre>
     */
    emPPPoEGeneralError(9, 9),
    /**
     * <code>emFailtoSendDualAsReject = 10;</code>
     *
     * <pre>
     *对端拒绝发起桌面共享,只有发言人可以发起桌面共享
     * </pre>
     */
    emFailtoSendDualAsReject(10, 10),
    /**
     * <code>emCallRateNotValidForMc = 11;</code>
     *
     * <pre>
     *呼叫码率过高,拒绝MC扩展
     * </pre>
     */
    emCallRateNotValidForMc(11, 11),
    /**
     * <code>emDualResNotMatchConfRes = 12;</code>
     *
     * <pre>
     *桌面共享分辨率与会议要求(%s)不匹配
     * </pre>
     */
    emDualResNotMatchConfRes(12, 12),
    /**
     * <code>emSuccedetoSendDual = 13;</code>
     *
     * <pre>
     *发起桌面共享成功
     * </pre>
     */
    emSuccedetoSendDual(13, 13),
    /**
     * <code>emSuccedetoRecvDual = 14;</code>
     *
     * <pre>
     *接收桌面共享成功
     * </pre>
     */
    emSuccedetoRecvDual(14, 14),
    /**
     * <code>emSateMtNoP2pPermission = 15;</code>
     *
     * <pre>
     *卫星终端没有点对点视频会议权限
     * </pre>
     */
    emSateMtNoP2pPermission(15, 15),
    /**
     * <code>emH323UpLoadBitrateLessThan64Ind = 16;</code>
     *
     * <pre>
     *上行码率小于等于64K
     * </pre>
     */
    emH323UpLoadBitrateLessThan64Ind(16, 16),
    /**
     * <code>emH323DownLoadBitrateLessThan64Ind = 17;</code>
     *
     * <pre>
     *下行码率小于等于64k
     * </pre>
     */
    emH323DownLoadBitrateLessThan64Ind(17, 17),
    /**
     * <code>emAssVidHasNoSignal = 18;</code>
     *
     * <pre>
     *辅视频没有信号
     * </pre>
     */
    emAssVidHasNoSignal(18, 18),
    /**
     * <code>emNotRegedToCallFailed = 19;</code>
     *
     * <pre>
     *gk或者sip注册失败导致别名或者e164号码呼叫失败
     * </pre>
     */
    emNotRegedToCallFailed(19, 19),
    /**
     * <code>emBePolledNext = 30;</code>
     *
     * <pre>
     *&#47;/mcu通知ter
     * </pre>
     */
    emBePolledNext(20, 30),
    /**
     * <code>emHintNoOpenDSChnnlNonSpeaker = 31;</code>
     *
     * <pre>
     *对端拒绝发起桌面共享,只有发言人可以发起桌面共享
     * </pre>
     */
    emHintNoOpenDSChnnlNonSpeaker(21, 31),
    /**
     * <code>emHintNoOpenDSChnnlNonCap = 32;</code>
     *
     * <pre>
     *能力集限制，桌面共享失败!
     * </pre>
     */
    emHintNoOpenDSChnnlNonCap(22, 32),
    /**
     * <code>emHintNoOpenDSChnnlBRLow64 = 33;</code>
     *
     * <pre>
     *码率小于64k，桌面共享失败!
     * </pre>
     */
    emHintNoOpenDSChnnlBRLow64(23, 33),
    /**
     * <code>emHintNoOpenDSChnnlFECType = 34;</code>
     *
     * <pre>
     *提示终端打开双流通道因FEC类型不匹配
     * </pre>
     */
    emHintNoOpenDSChnnlFECType(24, 34),
    /**
     * <code>emHintNoOpenDSChnnlNonMp = 35;</code>
     *
     * <pre>
     *提示终端打开双流通道因对应转发板不存在
     * </pre>
     */
    emHintNoOpenDSChnnlNonMp(25, 35),
    /**
     * <code>emHintNoOpenDSChnnlEncryptMode = 36;</code>
     *
     * <pre>
     *提示终端打开双流通道因加密模式不匹配
     * </pre>
     */
    emHintNoOpenDSChnnlEncryptMode(26, 36),
    /**
     * <code>emHintNoOpenDSChnnlOverSatDCastChnNum = 37;</code>
     *
     * <pre>
     *提示终端打开双流通道因超过了卫星分散会议的最大通道数
     * </pre>
     */
    emHintNoOpenDSChnnlOverSatDCastChnNum(27, 37),
    /**
     * <code>emHintNoOpenFSChnnlNonCap = 38;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因能力集限制失败
     * </pre>
     */
    emHintNoOpenFSChnnlNonCap(28, 38),
    /**
     * <code>emHintNoOpenFSChnnlBRLow64 = 39;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因通道码率小于64k
     * </pre>
     */
    emHintNoOpenFSChnnlBRLow64(29, 39),
    /**
     * <code>emHintNoOpenFSChnnlEncrpytMode = 40;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因加密模式不匹配
     * </pre>
     */
    emHintNoOpenFSChnnlEncrpytMode(30, 40),
    /**
     * <code>emHintNoOpenFSChnnlFECType = 41;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因FEC类型不匹配
     * </pre>
     */
    emHintNoOpenFSChnnlFECType(31, 41),
    /**
     * <code>emHintNoOpenFSChnnlNonMp = 42;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因对应的转发板不存在
     * </pre>
     */
    emHintNoOpenFSChnnlNonMp(32, 42),
    /**
     * <code>emHintNoOpenFSChnnlBROverflow = 43;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因码率过大
     * </pre>
     */
    emHintNoOpenFSChnnlBROverflow(33, 43),
    /**
     * <code>emHintNoOpenFSChnnlBothH263plus = 44;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因通道类型和动态载荷均为H263
     * </pre>
     */
    emHintNoOpenFSChnnlBothH263plus(34, 44),
    /**
     * <code>emHintNoOpenFSChnnlFormat = 45;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因分辨率过大
     * </pre>
     */
    emHintNoOpenFSChnnlFormat(35, 45),
    /**
     * <code>emHintNoOpenFSChnnlFPS = 46;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因帧率过大
     * </pre>
     */
    emHintNoOpenFSChnnlFPS(36, 46),
    /**
     * <code>emHintBRLessThanConf = 47;</code>
     *
     * <pre>
     *提示呼叫码率小于会议码率，请重新呼叫   { "wBitrate": 0}
     * </pre>
     */
    emHintBRLessThanConf(37, 47),
    /**
     * <code>emHintBRLargerThanConf = 48;</code>
     *
     * <pre>
     *提示呼叫码率大于会议码率，已自动调整
     * </pre>
     */
    emHintBRLargerThanConf(38, 48),
    /**
     * <code>emHintNoSupportOprForNoAuth = 49;</code>
     *
     * <pre>
     *提示不支持该操作，权限不足，请联系管理员
     * </pre>
     */
    emHintNoSupportOprForNoAuth(39, 49),
    /**
     * <code>emHintQueueConfNoIdleServer = 50;</code>
     *
     * <pre>
     *提示无空闲服务，请稍等
     * </pre>
     */
    emHintQueueConfNoIdleServer(40, 50),
    /**
     * <code>emHintQueueConfAllocatedServer = 51;</code>
     *
     * <pre>
     *提示正在接受服务
     * </pre>
     */
    emHintQueueConfAllocatedServer(41, 51),
    /**
     * <code>emHintOldStackNotSupportSpecVip = 52;</code>
     *
     * <pre>
     *提示老平台不支持主席指定Vip
     * </pre>
     */
    emHintOldStackNotSupportSpecVip(42, 52),
    /**
     * <code>emHintOldStackNotSupportModifyDumb = 53;</code>
     *
     * <pre>
     *提示老平台不支持会场哑音
     * </pre>
     */
    emHintOldStackNotSupportModifyDumb(43, 53),
    /**
     * <code>emHintOldStackNotSupportModifyConfPwd = 54;</code>
     *
     * <pre>
     *提示老平台不支持修改会议密码
     * </pre>
     */
    emHintOldStackNotSupportModifyConfPwd(44, 54),
    /**
     * <code>emHintOldStackNotSupportModifyConfNoDisturb = 55;</code>
     *
     * <pre>
     *提示老平台不支持设置会议免打扰
     * </pre>
     */
    emHintOldStackNotSupportModifyConfNoDisturb(45, 55),
    /**
     * <code>emHintOldStackNotSupportModifyDuration = 56;</code>
     *
     * <pre>
     *提示老平台不支持延长会议时间
     * </pre>
     */
    emHintOldStackNotSupportModifyDuration(46, 56),
    /**
     * <code>emHintOldStackNotSupportModifyConfName = 57;</code>
     *
     * <pre>
     *提示老平台不支持修改会议名称
     * </pre>
     */
    emHintOldStackNotSupportModifyConfName(47, 57),
    /**
     * <code>emHintOldStackNotSupportSetAssStreamSendMod = 58;</code>
     *
     * <pre>
     *提示老平台不支持修改内容共享权限
     * </pre>
     */
    emHintOldStackNotSupportSetAssStreamSendMod(48, 58),
    /**
     * <code>emHintAssVideoSourceIsSwitch = 59;</code>
     *
     * <pre>
     *辅视频源正在切换，不能发video双流
     * </pre>
     */
    emHintAssVideoSourceIsSwitch(49, 59),
    /**
     * <code>emHintNoSendAssOnVodPlayStatus = 60;</code>
     *
     * <pre>
     *点播状态的时候不允许发pc双流
     * </pre>
     */
    emHintNoSendAssOnVodPlayStatus(50, 60),
    /**
     * <code>emHintNoSendAssOnEnterPwdStatus = 61;</code>
     *
     * <pre>
     *入多点会议时，正在输入入会密码时不能发pc双流
     * </pre>
     */
    emHintNoSendAssOnEnterPwdStatus(51, 61),
    ;

    /**
     * <code>emHintBegin = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    public static final int emHintBegin_VALUE = 0;
    /**
     * <code>emFailtoSendDual = 1;</code>
     *
     * <pre>
     *对端不支持当前格式和分辨率下的桌面共享
     * </pre>
     */
    public static final int emFailtoSendDual_VALUE = 1;
    /**
     * <code>emFailtoRecvDual = 2;</code>
     *
     * <pre>
     *带宽不足，不支持对端发起的桌面共享
     * </pre>
     */
    public static final int emFailtoRecvDual_VALUE = 2;
    /**
     * <code>emFailtoVodLogin = 3;</code>
     *
     * <pre>
     *VOD 登录失败
     * </pre>
     */
    public static final int emFailtoVodLogin_VALUE = 3;
    /**
     * <code>emDHCPTimeOut = 4;</code>
     *
     * <pre>
     *获取DHCP地址超时
     * </pre>
     */
    public static final int emDHCPTimeOut_VALUE = 4;
    /**
     * <code>emPPPoEAuthorError = 5;</code>
     *
     * <pre>
     *PPPOE身份验证错误
     * </pre>
     */
    public static final int emPPPoEAuthorError_VALUE = 5;
    /**
     * <code>emPPPoEAgentError = 6;</code>
     *
     * <pre>
     *PPPOE找不到ISP服务商
     * </pre>
     */
    public static final int emPPPoEAgentError_VALUE = 6;
    /**
     * <code>emPPPoETimeOutError = 7;</code>
     *
     * <pre>
     *PPPOE拨号超时
     * </pre>
     */
    public static final int emPPPoETimeOutError_VALUE = 7;
    /**
     * <code>emPPPoELinkDownError = 8;</code>
     *
     * <pre>
     *PPPOE断链
     * </pre>
     */
    public static final int emPPPoELinkDownError_VALUE = 8;
    /**
     * <code>emPPPoEGeneralError = 9;</code>
     *
     * <pre>
     *PPPOE其他错误
     * </pre>
     */
    public static final int emPPPoEGeneralError_VALUE = 9;
    /**
     * <code>emFailtoSendDualAsReject = 10;</code>
     *
     * <pre>
     *对端拒绝发起桌面共享,只有发言人可以发起桌面共享
     * </pre>
     */
    public static final int emFailtoSendDualAsReject_VALUE = 10;
    /**
     * <code>emCallRateNotValidForMc = 11;</code>
     *
     * <pre>
     *呼叫码率过高,拒绝MC扩展
     * </pre>
     */
    public static final int emCallRateNotValidForMc_VALUE = 11;
    /**
     * <code>emDualResNotMatchConfRes = 12;</code>
     *
     * <pre>
     *桌面共享分辨率与会议要求(%s)不匹配
     * </pre>
     */
    public static final int emDualResNotMatchConfRes_VALUE = 12;
    /**
     * <code>emSuccedetoSendDual = 13;</code>
     *
     * <pre>
     *发起桌面共享成功
     * </pre>
     */
    public static final int emSuccedetoSendDual_VALUE = 13;
    /**
     * <code>emSuccedetoRecvDual = 14;</code>
     *
     * <pre>
     *接收桌面共享成功
     * </pre>
     */
    public static final int emSuccedetoRecvDual_VALUE = 14;
    /**
     * <code>emSateMtNoP2pPermission = 15;</code>
     *
     * <pre>
     *卫星终端没有点对点视频会议权限
     * </pre>
     */
    public static final int emSateMtNoP2pPermission_VALUE = 15;
    /**
     * <code>emH323UpLoadBitrateLessThan64Ind = 16;</code>
     *
     * <pre>
     *上行码率小于等于64K
     * </pre>
     */
    public static final int emH323UpLoadBitrateLessThan64Ind_VALUE = 16;
    /**
     * <code>emH323DownLoadBitrateLessThan64Ind = 17;</code>
     *
     * <pre>
     *下行码率小于等于64k
     * </pre>
     */
    public static final int emH323DownLoadBitrateLessThan64Ind_VALUE = 17;
    /**
     * <code>emAssVidHasNoSignal = 18;</code>
     *
     * <pre>
     *辅视频没有信号
     * </pre>
     */
    public static final int emAssVidHasNoSignal_VALUE = 18;
    /**
     * <code>emNotRegedToCallFailed = 19;</code>
     *
     * <pre>
     *gk或者sip注册失败导致别名或者e164号码呼叫失败
     * </pre>
     */
    public static final int emNotRegedToCallFailed_VALUE = 19;
    /**
     * <code>emBePolledNext = 30;</code>
     *
     * <pre>
     *&#47;/mcu通知ter
     * </pre>
     */
    public static final int emBePolledNext_VALUE = 30;
    /**
     * <code>emHintNoOpenDSChnnlNonSpeaker = 31;</code>
     *
     * <pre>
     *对端拒绝发起桌面共享,只有发言人可以发起桌面共享
     * </pre>
     */
    public static final int emHintNoOpenDSChnnlNonSpeaker_VALUE = 31;
    /**
     * <code>emHintNoOpenDSChnnlNonCap = 32;</code>
     *
     * <pre>
     *能力集限制，桌面共享失败!
     * </pre>
     */
    public static final int emHintNoOpenDSChnnlNonCap_VALUE = 32;
    /**
     * <code>emHintNoOpenDSChnnlBRLow64 = 33;</code>
     *
     * <pre>
     *码率小于64k，桌面共享失败!
     * </pre>
     */
    public static final int emHintNoOpenDSChnnlBRLow64_VALUE = 33;
    /**
     * <code>emHintNoOpenDSChnnlFECType = 34;</code>
     *
     * <pre>
     *提示终端打开双流通道因FEC类型不匹配
     * </pre>
     */
    public static final int emHintNoOpenDSChnnlFECType_VALUE = 34;
    /**
     * <code>emHintNoOpenDSChnnlNonMp = 35;</code>
     *
     * <pre>
     *提示终端打开双流通道因对应转发板不存在
     * </pre>
     */
    public static final int emHintNoOpenDSChnnlNonMp_VALUE = 35;
    /**
     * <code>emHintNoOpenDSChnnlEncryptMode = 36;</code>
     *
     * <pre>
     *提示终端打开双流通道因加密模式不匹配
     * </pre>
     */
    public static final int emHintNoOpenDSChnnlEncryptMode_VALUE = 36;
    /**
     * <code>emHintNoOpenDSChnnlOverSatDCastChnNum = 37;</code>
     *
     * <pre>
     *提示终端打开双流通道因超过了卫星分散会议的最大通道数
     * </pre>
     */
    public static final int emHintNoOpenDSChnnlOverSatDCastChnNum_VALUE = 37;
    /**
     * <code>emHintNoOpenFSChnnlNonCap = 38;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因能力集限制失败
     * </pre>
     */
    public static final int emHintNoOpenFSChnnlNonCap_VALUE = 38;
    /**
     * <code>emHintNoOpenFSChnnlBRLow64 = 39;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因通道码率小于64k
     * </pre>
     */
    public static final int emHintNoOpenFSChnnlBRLow64_VALUE = 39;
    /**
     * <code>emHintNoOpenFSChnnlEncrpytMode = 40;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因加密模式不匹配
     * </pre>
     */
    public static final int emHintNoOpenFSChnnlEncrpytMode_VALUE = 40;
    /**
     * <code>emHintNoOpenFSChnnlFECType = 41;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因FEC类型不匹配
     * </pre>
     */
    public static final int emHintNoOpenFSChnnlFECType_VALUE = 41;
    /**
     * <code>emHintNoOpenFSChnnlNonMp = 42;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因对应的转发板不存在
     * </pre>
     */
    public static final int emHintNoOpenFSChnnlNonMp_VALUE = 42;
    /**
     * <code>emHintNoOpenFSChnnlBROverflow = 43;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因码率过大
     * </pre>
     */
    public static final int emHintNoOpenFSChnnlBROverflow_VALUE = 43;
    /**
     * <code>emHintNoOpenFSChnnlBothH263plus = 44;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因通道类型和动态载荷均为H263
     * </pre>
     */
    public static final int emHintNoOpenFSChnnlBothH263plus_VALUE = 44;
    /**
     * <code>emHintNoOpenFSChnnlFormat = 45;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因分辨率过大
     * </pre>
     */
    public static final int emHintNoOpenFSChnnlFormat_VALUE = 45;
    /**
     * <code>emHintNoOpenFSChnnlFPS = 46;</code>
     *
     * <pre>
     *提示终端打开第一路视频通道因帧率过大
     * </pre>
     */
    public static final int emHintNoOpenFSChnnlFPS_VALUE = 46;
    /**
     * <code>emHintBRLessThanConf = 47;</code>
     *
     * <pre>
     *提示呼叫码率小于会议码率，请重新呼叫   { "wBitrate": 0}
     * </pre>
     */
    public static final int emHintBRLessThanConf_VALUE = 47;
    /**
     * <code>emHintBRLargerThanConf = 48;</code>
     *
     * <pre>
     *提示呼叫码率大于会议码率，已自动调整
     * </pre>
     */
    public static final int emHintBRLargerThanConf_VALUE = 48;
    /**
     * <code>emHintNoSupportOprForNoAuth = 49;</code>
     *
     * <pre>
     *提示不支持该操作，权限不足，请联系管理员
     * </pre>
     */
    public static final int emHintNoSupportOprForNoAuth_VALUE = 49;
    /**
     * <code>emHintQueueConfNoIdleServer = 50;</code>
     *
     * <pre>
     *提示无空闲服务，请稍等
     * </pre>
     */
    public static final int emHintQueueConfNoIdleServer_VALUE = 50;
    /**
     * <code>emHintQueueConfAllocatedServer = 51;</code>
     *
     * <pre>
     *提示正在接受服务
     * </pre>
     */
    public static final int emHintQueueConfAllocatedServer_VALUE = 51;
    /**
     * <code>emHintOldStackNotSupportSpecVip = 52;</code>
     *
     * <pre>
     *提示老平台不支持主席指定Vip
     * </pre>
     */
    public static final int emHintOldStackNotSupportSpecVip_VALUE = 52;
    /**
     * <code>emHintOldStackNotSupportModifyDumb = 53;</code>
     *
     * <pre>
     *提示老平台不支持会场哑音
     * </pre>
     */
    public static final int emHintOldStackNotSupportModifyDumb_VALUE = 53;
    /**
     * <code>emHintOldStackNotSupportModifyConfPwd = 54;</code>
     *
     * <pre>
     *提示老平台不支持修改会议密码
     * </pre>
     */
    public static final int emHintOldStackNotSupportModifyConfPwd_VALUE = 54;
    /**
     * <code>emHintOldStackNotSupportModifyConfNoDisturb = 55;</code>
     *
     * <pre>
     *提示老平台不支持设置会议免打扰
     * </pre>
     */
    public static final int emHintOldStackNotSupportModifyConfNoDisturb_VALUE = 55;
    /**
     * <code>emHintOldStackNotSupportModifyDuration = 56;</code>
     *
     * <pre>
     *提示老平台不支持延长会议时间
     * </pre>
     */
    public static final int emHintOldStackNotSupportModifyDuration_VALUE = 56;
    /**
     * <code>emHintOldStackNotSupportModifyConfName = 57;</code>
     *
     * <pre>
     *提示老平台不支持修改会议名称
     * </pre>
     */
    public static final int emHintOldStackNotSupportModifyConfName_VALUE = 57;
    /**
     * <code>emHintOldStackNotSupportSetAssStreamSendMod = 58;</code>
     *
     * <pre>
     *提示老平台不支持修改内容共享权限
     * </pre>
     */
    public static final int emHintOldStackNotSupportSetAssStreamSendMod_VALUE = 58;
    /**
     * <code>emHintAssVideoSourceIsSwitch = 59;</code>
     *
     * <pre>
     *辅视频源正在切换，不能发video双流
     * </pre>
     */
    public static final int emHintAssVideoSourceIsSwitch_VALUE = 59;
    /**
     * <code>emHintNoSendAssOnVodPlayStatus = 60;</code>
     *
     * <pre>
     *点播状态的时候不允许发pc双流
     * </pre>
     */
    public static final int emHintNoSendAssOnVodPlayStatus_VALUE = 60;
    /**
     * <code>emHintNoSendAssOnEnterPwdStatus = 61;</code>
     *
     * <pre>
     *入多点会议时，正在输入入会密码时不能发pc双流
     * </pre>
     */
    public static final int emHintNoSendAssOnEnterPwdStatus_VALUE = 61;


    public final int getNumber() { return value; }

    public static EmHintCode valueOf(int value) {
      switch (value) {
        case 0: return emHintBegin;
        case 1: return emFailtoSendDual;
        case 2: return emFailtoRecvDual;
        case 3: return emFailtoVodLogin;
        case 4: return emDHCPTimeOut;
        case 5: return emPPPoEAuthorError;
        case 6: return emPPPoEAgentError;
        case 7: return emPPPoETimeOutError;
        case 8: return emPPPoELinkDownError;
        case 9: return emPPPoEGeneralError;
        case 10: return emFailtoSendDualAsReject;
        case 11: return emCallRateNotValidForMc;
        case 12: return emDualResNotMatchConfRes;
        case 13: return emSuccedetoSendDual;
        case 14: return emSuccedetoRecvDual;
        case 15: return emSateMtNoP2pPermission;
        case 16: return emH323UpLoadBitrateLessThan64Ind;
        case 17: return emH323DownLoadBitrateLessThan64Ind;
        case 18: return emAssVidHasNoSignal;
        case 19: return emNotRegedToCallFailed;
        case 30: return emBePolledNext;
        case 31: return emHintNoOpenDSChnnlNonSpeaker;
        case 32: return emHintNoOpenDSChnnlNonCap;
        case 33: return emHintNoOpenDSChnnlBRLow64;
        case 34: return emHintNoOpenDSChnnlFECType;
        case 35: return emHintNoOpenDSChnnlNonMp;
        case 36: return emHintNoOpenDSChnnlEncryptMode;
        case 37: return emHintNoOpenDSChnnlOverSatDCastChnNum;
        case 38: return emHintNoOpenFSChnnlNonCap;
        case 39: return emHintNoOpenFSChnnlBRLow64;
        case 40: return emHintNoOpenFSChnnlEncrpytMode;
        case 41: return emHintNoOpenFSChnnlFECType;
        case 42: return emHintNoOpenFSChnnlNonMp;
        case 43: return emHintNoOpenFSChnnlBROverflow;
        case 44: return emHintNoOpenFSChnnlBothH263plus;
        case 45: return emHintNoOpenFSChnnlFormat;
        case 46: return emHintNoOpenFSChnnlFPS;
        case 47: return emHintBRLessThanConf;
        case 48: return emHintBRLargerThanConf;
        case 49: return emHintNoSupportOprForNoAuth;
        case 50: return emHintQueueConfNoIdleServer;
        case 51: return emHintQueueConfAllocatedServer;
        case 52: return emHintOldStackNotSupportSpecVip;
        case 53: return emHintOldStackNotSupportModifyDumb;
        case 54: return emHintOldStackNotSupportModifyConfPwd;
        case 55: return emHintOldStackNotSupportModifyConfNoDisturb;
        case 56: return emHintOldStackNotSupportModifyDuration;
        case 57: return emHintOldStackNotSupportModifyConfName;
        case 58: return emHintOldStackNotSupportSetAssStreamSendMod;
        case 59: return emHintAssVideoSourceIsSwitch;
        case 60: return emHintNoSendAssOnVodPlayStatus;
        case 61: return emHintNoSendAssOnEnterPwdStatus;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHintCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHintCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHintCode>() {
            public EmHintCode findValueByNumber(int number) {
              return EmHintCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(2);
    }

    private static final EmHintCode[] VALUES = values();

    public static EmHintCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHintCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHintCode)
  }

  /**
   * Protobuf enum {@code mt.EmStackInitFailReason}
   *
   * <pre>
   *&#47;协议栈初始化
   * </pre>
   */
  public enum EmStackInitFailReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emH323InitSuccess = 1;</code>
     */
    emH323InitSuccess(0, 1),
    /**
     * <code>emH323InitFailed_MemoryProblem = 2;</code>
     */
    emH323InitFailed_MemoryProblem(1, 2),
    /**
     * <code>emH323InitFailed_ConfigProblem = 3;</code>
     */
    emH323InitFailed_ConfigProblem(2, 3),
    /**
     * <code>emH323InitFailed_NetWorkProblem = 4;</code>
     */
    emH323InitFailed_NetWorkProblem(3, 4),
    /**
     * <code>emH323InitFailed_InitAgain = 5;</code>
     */
    emH323InitFailed_InitAgain(4, 5),
    /**
     * <code>emH323InitFailed_GenConfigFail = 6;</code>
     */
    emH323InitFailed_GenConfigFail(5, 6),
    /**
     * <code>emH323InitFailed_InitSemFail = 7;</code>
     */
    emH323InitFailed_InitSemFail(6, 7),
    /**
     * <code>emH323InitFailed_NewConnInfoFail = 8;</code>
     */
    emH323InitFailed_NewConnInfoFail(7, 8),
    /**
     * <code>emH323InitFailed_SetCBFail = 9;</code>
     */
    emH323InitFailed_SetCBFail(8, 9),
    /**
     * <code>emH323InitFailed_Unknown = 10;</code>
     */
    emH323InitFailed_Unknown(9, 10),
    /**
     * <code>emSipInitSuccess = 30;</code>
     *
     * <pre>
     *&#47;//sip初始化结果 
     * </pre>
     */
    emSipInitSuccess(10, 30),
    /**
     * <code>emSipInitFailed = 31;</code>
     */
    emSipInitFailed(11, 31),
    /**
     * <code>emH323PxyClient_Running = 50;</code>
     *
     * <pre>
     *&#47;//323pxy 初始化结果
     * </pre>
     */
    emH323PxyClient_Running(12, 50),
    /**
     * <code>emH323PxyClient_NotRunning = 51;</code>
     *
     * <pre>
     *&#47;运行失败，有可能没有连接server,
     * </pre>
     */
    emH323PxyClient_NotRunning(13, 51),
    ;

    /**
     * <code>emH323InitSuccess = 1;</code>
     */
    public static final int emH323InitSuccess_VALUE = 1;
    /**
     * <code>emH323InitFailed_MemoryProblem = 2;</code>
     */
    public static final int emH323InitFailed_MemoryProblem_VALUE = 2;
    /**
     * <code>emH323InitFailed_ConfigProblem = 3;</code>
     */
    public static final int emH323InitFailed_ConfigProblem_VALUE = 3;
    /**
     * <code>emH323InitFailed_NetWorkProblem = 4;</code>
     */
    public static final int emH323InitFailed_NetWorkProblem_VALUE = 4;
    /**
     * <code>emH323InitFailed_InitAgain = 5;</code>
     */
    public static final int emH323InitFailed_InitAgain_VALUE = 5;
    /**
     * <code>emH323InitFailed_GenConfigFail = 6;</code>
     */
    public static final int emH323InitFailed_GenConfigFail_VALUE = 6;
    /**
     * <code>emH323InitFailed_InitSemFail = 7;</code>
     */
    public static final int emH323InitFailed_InitSemFail_VALUE = 7;
    /**
     * <code>emH323InitFailed_NewConnInfoFail = 8;</code>
     */
    public static final int emH323InitFailed_NewConnInfoFail_VALUE = 8;
    /**
     * <code>emH323InitFailed_SetCBFail = 9;</code>
     */
    public static final int emH323InitFailed_SetCBFail_VALUE = 9;
    /**
     * <code>emH323InitFailed_Unknown = 10;</code>
     */
    public static final int emH323InitFailed_Unknown_VALUE = 10;
    /**
     * <code>emSipInitSuccess = 30;</code>
     *
     * <pre>
     *&#47;//sip初始化结果 
     * </pre>
     */
    public static final int emSipInitSuccess_VALUE = 30;
    /**
     * <code>emSipInitFailed = 31;</code>
     */
    public static final int emSipInitFailed_VALUE = 31;
    /**
     * <code>emH323PxyClient_Running = 50;</code>
     *
     * <pre>
     *&#47;//323pxy 初始化结果
     * </pre>
     */
    public static final int emH323PxyClient_Running_VALUE = 50;
    /**
     * <code>emH323PxyClient_NotRunning = 51;</code>
     *
     * <pre>
     *&#47;运行失败，有可能没有连接server,
     * </pre>
     */
    public static final int emH323PxyClient_NotRunning_VALUE = 51;


    public final int getNumber() { return value; }

    public static EmStackInitFailReason valueOf(int value) {
      switch (value) {
        case 1: return emH323InitSuccess;
        case 2: return emH323InitFailed_MemoryProblem;
        case 3: return emH323InitFailed_ConfigProblem;
        case 4: return emH323InitFailed_NetWorkProblem;
        case 5: return emH323InitFailed_InitAgain;
        case 6: return emH323InitFailed_GenConfigFail;
        case 7: return emH323InitFailed_InitSemFail;
        case 8: return emH323InitFailed_NewConnInfoFail;
        case 9: return emH323InitFailed_SetCBFail;
        case 10: return emH323InitFailed_Unknown;
        case 30: return emSipInitSuccess;
        case 31: return emSipInitFailed;
        case 50: return emH323PxyClient_Running;
        case 51: return emH323PxyClient_NotRunning;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmStackInitFailReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmStackInitFailReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmStackInitFailReason>() {
            public EmStackInitFailReason findValueByNumber(int number) {
              return EmStackInitFailReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(3);
    }

    private static final EmStackInitFailReason[] VALUES = values();

    public static EmStackInitFailReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmStackInitFailReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmStackInitFailReason)
  }

  /**
   * Protobuf enum {@code mt.EmKdvMtModel}
   *
   * <pre>
   *产品簇型号(大型号)
   * </pre>
   */
  public enum EmKdvMtModel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emKdvMtModelBeg = 0;</code>
     */
    emKdvMtModelBeg(0, 0),
    /**
     * <code>emKdvMtModelX500TI = 1;</code>
     */
    emKdvMtModelX500TI(1, 1),
    /**
     * <code>emKdvMtModelX700 = 2;</code>
     */
    emKdvMtModelX700(2, 2),
    /**
     * <code>emKdvMtModelX300 = 3;</code>
     */
    emKdvMtModelX300(3, 3),
    /**
     * <code>emKdvMtModelSky300 = 4;</code>
     */
    emKdvMtModelSky300(4, 4),
    /**
     * <code>emKdvMtModelSky100 = 5;</code>
     */
    emKdvMtModelSky100(5, 5),
    /**
     * <code>emKdvMtModelEnd = 9;</code>
     */
    emKdvMtModelEnd(6, 9),
    ;

    /**
     * <code>emKdvMtModelBeg = 0;</code>
     */
    public static final int emKdvMtModelBeg_VALUE = 0;
    /**
     * <code>emKdvMtModelX500TI = 1;</code>
     */
    public static final int emKdvMtModelX500TI_VALUE = 1;
    /**
     * <code>emKdvMtModelX700 = 2;</code>
     */
    public static final int emKdvMtModelX700_VALUE = 2;
    /**
     * <code>emKdvMtModelX300 = 3;</code>
     */
    public static final int emKdvMtModelX300_VALUE = 3;
    /**
     * <code>emKdvMtModelSky300 = 4;</code>
     */
    public static final int emKdvMtModelSky300_VALUE = 4;
    /**
     * <code>emKdvMtModelSky100 = 5;</code>
     */
    public static final int emKdvMtModelSky100_VALUE = 5;
    /**
     * <code>emKdvMtModelEnd = 9;</code>
     */
    public static final int emKdvMtModelEnd_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmKdvMtModel valueOf(int value) {
      switch (value) {
        case 0: return emKdvMtModelBeg;
        case 1: return emKdvMtModelX500TI;
        case 2: return emKdvMtModelX700;
        case 3: return emKdvMtModelX300;
        case 4: return emKdvMtModelSky300;
        case 5: return emKdvMtModelSky100;
        case 9: return emKdvMtModelEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmKdvMtModel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmKdvMtModel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmKdvMtModel>() {
            public EmKdvMtModel findValueByNumber(int number) {
              return EmKdvMtModel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(4);
    }

    private static final EmKdvMtModel[] VALUES = values();

    public static EmKdvMtModel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmKdvMtModel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmKdvMtModel)
  }

  /**
   * Protobuf enum {@code mt.EmMtModel}
   *
   * <pre>
   *产品型号(具体子型号)
   * </pre>
   */
  public enum EmMtModel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emModelBegin = 0;</code>
     *
     * <pre>
     *无效值，
     * </pre>
     */
    emModelBegin(0, 0),
    /**
     * <code>emSkyWindows = 1;</code>
     *
     * <pre>
     *桌面终端 自建
     * </pre>
     */
    emSkyWindows(1, 1),
    /**
     * <code>emSkyIPad = 2;</code>
     *
     * <pre>
     *移动终端ipad 自建
     * </pre>
     */
    emSkyIPad(2, 2),
    /**
     * <code>emSkyIPhone = 3;</code>
     *
     * <pre>
     *移动终端iphone 自建
     * </pre>
     */
    emSkyIPhone(3, 3),
    /**
     * <code>emSkyAndroidPad = 7;</code>
     *
     * <pre>
     *移动终端androidpad 自建
     * </pre>
     */
    emSkyAndroidPad(4, 7),
    /**
     * <code>emSkyAndroidPhone = 8;</code>
     *
     * <pre>
     *移动终端androidphone 自建
     * </pre>
     */
    emSkyAndroidPhone(5, 8),
    /**
     * <code>emX500_1080P60 = 9;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    emX500_1080P60(6, 9),
    /**
     * <code>emX500_1080P30 = 10;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    emX500_1080P30(7, 10),
    /**
     * <code>emX500_720P60 = 11;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    emX500_720P60(8, 11),
    /**
     * <code>emX500_mo_1080P = 12;</code>
     *
     * <pre>
     *硬终端 租赁
     * </pre>
     */
    emX500_mo_1080P(9, 12),
    /**
     * <code>emX500_mo_720P = 13;</code>
     *
     * <pre>
     *硬终端 租赁
     * </pre>
     */
    emX500_mo_720P(10, 13),
    /**
     * <code>emX500_oem_1080P = 14;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    emX500_oem_1080P(11, 14),
    /**
     * <code>emX500_oem_mo_1080P = 15;</code>
     *
     * <pre>
     *硬终端 租赁
     * </pre>
     */
    emX500_oem_mo_1080P(12, 15),
    /**
     * <code>emTrueLink = 16;</code>
     *
     * <pre>
     *桌面终端 租赁
     * </pre>
     */
    emTrueLink(13, 16),
    /**
     * <code>emTrueTouchIpad = 17;</code>
     *
     * <pre>
     *移动终端ipad 租赁
     * </pre>
     */
    emTrueTouchIpad(14, 17),
    /**
     * <code>emTrueTouchIphone = 18;</code>
     *
     * <pre>
     *移动终端iphone 租赁
     * </pre>
     */
    emTrueTouchIphone(15, 18),
    /**
     * <code>emTrueTouchAndroidPhone = 19;</code>
     *
     * <pre>
     *移动终端androidphone 租赁	
     * </pre>
     */
    emTrueTouchAndroidPhone(16, 19),
    /**
     * <code>emTrueTouchAndroidPad = 20;</code>
     *
     * <pre>
     *移动终端androidpad   租赁
     * </pre>
     */
    emTrueTouchAndroidPad(17, 20),
    /**
     * <code>emH950_1080P60 = 21;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    emH950_1080P60(18, 21),
    /**
     * <code>emTrueLinkTV = 22;</code>
     *
     * <pre>
     *TV盒子 租赁
     * </pre>
     */
    emTrueLinkTV(19, 22),
    /**
     * <code>emX700_4k30 = 23;</code>
     *
     * <pre>
     *x700-4k30 自建
     * </pre>
     */
    emX700_4k30(20, 23),
    /**
     * <code>emX700_oem_4k30 = 24;</code>
     *
     * <pre>
     *x700-4k30 oem 自建
     * </pre>
     */
    emX700_oem_4k30(21, 24),
    /**
     * <code>emX500_4k30 = 25;</code>
     *
     * <pre>
     *x500-4k30 自建
     * </pre>
     */
    emX500_4k30(22, 25),
    /**
     * <code>emX500_oem_4k30 = 26;</code>
     *
     * <pre>
     *x500-4k30 oem 自建
     * </pre>
     */
    emX500_oem_4k30(23, 26),
    /**
     * <code>emX300_1080P60 = 27;</code>
     *
     * <pre>
     *x300-1080P60  自建
     * </pre>
     */
    emX300_1080P60(24, 27),
    /**
     * <code>emX300_1080P30 = 28;</code>
     *
     * <pre>
     *x300-1080P30  自建
     * </pre>
     */
    emX300_1080P30(25, 28),
    /**
     * <code>emX300_720P60 = 29;</code>
     *
     * <pre>
     *x300-720P60   自建
     * </pre>
     */
    emX300_720P60(26, 29),
    /**
     * <code>emX300_oem_1080P60 = 30;</code>
     *
     * <pre>
     *x300-1080P60 oem 自建
     * </pre>
     */
    emX300_oem_1080P60(27, 30),
    /**
     * <code>emX500_1080P_60 = 31;</code>
     *
     * <pre>
     *x500-1080P-1080P60  自建  SKY X500-1080P 终端 和从9-15的x500终端不一样，芯片不一样
     * </pre>
     */
    emX500_1080P_60(28, 31),
    /**
     * <code>emX500_1080P_30 = 32;</code>
     *
     * <pre>
     *x500-1080P-1080P30  自建
     * </pre>
     */
    emX500_1080P_30(29, 32),
    /**
     * <code>emX500_oem_1080P_60 = 33;</code>
     *
     * <pre>
     *x500-1080P-1080P60  oem 自建
     * </pre>
     */
    emX500_oem_1080P_60(30, 33),
    /**
     * <code>em300_1080P30 = 34;</code>
     *
     * <pre>
     *300-1080P30  自建
     * </pre>
     */
    em300_1080P30(31, 34),
    /**
     * <code>em300_720P60 = 35;</code>
     *
     * <pre>
     *300-720P60   自建
     * </pre>
     */
    em300_720P60(32, 35),
    /**
     * <code>em300_oem_1080P30 = 36;</code>
     *
     * <pre>
     *300-1080P30  oem 自建
     * </pre>
     */
    em300_oem_1080P30(33, 36),
    /**
     * <code>em300L_1080P30 = 37;</code>
     *
     * <pre>
     *300L-1080P30 自建
     * </pre>
     */
    em300L_1080P30(34, 37),
    /**
     * <code>em300L_720P60 = 38;</code>
     *
     * <pre>
     *300L-720P60  自建
     * </pre>
     */
    em300L_720P60(35, 38),
    /**
     * <code>em300L_oem_1080P30 = 39;</code>
     *
     * <pre>
     *300L-1080P30 oem 自建
     * </pre>
     */
    em300L_oem_1080P30(36, 39),
    /**
     * <code>em300_1080P60 = 40;</code>
     *
     * <pre>
     *300-1080P60  自建
     * </pre>
     */
    em300_1080P60(37, 40),
    /**
     * <code>em300_720P30 = 41;</code>
     *
     * <pre>
     *300-720P30   自建
     * </pre>
     */
    em300_720P30(38, 41),
    /**
     * <code>em300L_1080P60 = 42;</code>
     *
     * <pre>
     *300-1080P60  自建
     * </pre>
     */
    em300L_1080P60(39, 42),
    /**
     * <code>em300L_720P30 = 43;</code>
     *
     * <pre>
     *300-720P30   自建
     * </pre>
     */
    em300L_720P30(40, 43),
    /**
     * <code>emX300_720P30 = 44;</code>
     *
     * <pre>
     *x300-720P30   自建
     * </pre>
     */
    emX300_720P30(41, 44),
    /**
     * <code>emX500_720P_30 = 45;</code>
     *
     * <pre>
     *x500-720P-720P30  自建
     * </pre>
     */
    emX500_720P_30(42, 45),
    /**
     * <code>emX500_720P_60 = 46;</code>
     *
     * <pre>
     *x500-720P-720P60  自建
     * </pre>
     */
    emX500_720P_60(43, 46),
    /**
     * <code>em100_1080P30_12X = 47;</code>
     *
     * <pre>
     *100_1080P30_12X
     * </pre>
     */
    em100_1080P30_12X(44, 47),
    /**
     * <code>em100_1080P30_3X = 48;</code>
     *
     * <pre>
     *100_1080P30_3X
     * </pre>
     */
    em100_1080P30_3X(45, 48),
    /**
     * <code>em100L_720P = 49;</code>
     *
     * <pre>
     *100L_720P
     * </pre>
     */
    em100L_720P(46, 49),
    /**
     * <code>em100_oem_1080P30_3X = 50;</code>
     *
     * <pre>
     *100_oem_1080P30_3X
     * </pre>
     */
    em100_oem_1080P30_3X(47, 50),
    /**
     * <code>emSkyWindows_s = 51;</code>
     *
     * <pre>
     *&#47;&lt; 商密桌面终端 自建
     * </pre>
     */
    emSkyWindows_s(48, 51),
    /**
     * <code>emSkyIPad_s = 52;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端ipad 自建
     * </pre>
     */
    emSkyIPad_s(49, 52),
    /**
     * <code>emSkyIPhone_s = 53;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端iphone 自建
     * </pre>
     */
    emSkyIPhone_s(50, 53),
    /**
     * <code>emSkyAndroidPad_s = 54;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端androidpad 自建
     * </pre>
     */
    emSkyAndroidPad_s(51, 54),
    /**
     * <code>emSkyAndroidPhone_s = 55;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端androidphone 自建
     * </pre>
     */
    emSkyAndroidPhone_s(52, 55),
    /**
     * <code>emX300_1080P60_s = 56;</code>
     *
     * <pre>
     * 商密硬终端 sky_x300_1080P60_s 
     * </pre>
     */
    emX300_1080P60_s(53, 56),
    /**
     * <code>emX500_1080P60_s = 57;</code>
     *
     * <pre>
     * 商密硬终端 sky_x500_1080P60_s
     * </pre>
     */
    emX500_1080P60_s(54, 57),
    /**
     * <code>em300_1080P60_s = 58;</code>
     *
     * <pre>
     * 商密硬终端 sky_300_1080P60_s
     * </pre>
     */
    em300_1080P60_s(55, 58),
    /**
     * <code>emX700_s = 59;</code>
     *
     * <pre>
     * 商密硬终端 sky_x700_s
     * </pre>
     */
    emX700_s(56, 59),
    /**
     * <code>emX500_4K_s = 60;</code>
     *
     * <pre>
     * 商密硬终端 sky_x500_4k_s
     * </pre>
     */
    emX500_4K_s(57, 60),
    /**
     * <code>em100_1080P30_12X_s = 61;</code>
     *
     * <pre>
     * 商密硬终端 sky_100_1080P30_12x_s
     * </pre>
     */
    em100_1080P30_12X_s(58, 61),
    /**
     * <code>emX300_1080P60_cs = 62;</code>
     *
     * <pre>
     * 渠道版本 sky_x300_1080P60_cs 
     * </pre>
     */
    emX300_1080P60_cs(59, 62),
    /**
     * <code>emX500_1080P60_cs = 63;</code>
     *
     * <pre>
     * 渠道版本 sky_x500_1080P60_cs
     * </pre>
     */
    emX500_1080P60_cs(60, 63),
    /**
     * <code>em300_1080P60_cs = 64;</code>
     *
     * <pre>
     * 渠道版本 sky_300_1080P60_cs
     * </pre>
     */
    em300_1080P60_cs(61, 64),
    /**
     * <code>emX700_cs = 65;</code>
     *
     * <pre>
     * 渠道版本 sky_x700_cs
     * </pre>
     */
    emX700_cs(62, 65),
    /**
     * <code>emX500_4K_cs = 66;</code>
     *
     * <pre>
     * 渠道版本 sky_x500_4k_cs
     * </pre>
     */
    emX500_4K_cs(63, 66),
    /**
     * <code>em100_1080P30_12X_cs = 67;</code>
     *
     * <pre>
     * 渠道版本 sky_100_1080P30_12x_cs
     * </pre>
     */
    em100_1080P30_12X_cs(64, 67),
    /**
     * <code>em100_1080P30_12X_H5 = 68;</code>
     *
     * <pre>
     * SKY 100-1080P30-12x-H5,支持H265
     * </pre>
     */
    em100_1080P30_12X_H5(65, 68),
    /**
     * <code>em100_1080P30_3X_H5 = 69;</code>
     *
     * <pre>
     * SKY 100-1080P30-3x-H5
     * </pre>
     */
    em100_1080P30_3X_H5(66, 69),
    /**
     * <code>em100_DX_1080P30_12X = 70;</code>
     *
     * <pre>
     *SKY 100-DX-1080P30-12x（不支持WIFI）
     * </pre>
     */
    em100_DX_1080P30_12X(67, 70),
    /**
     * <code>em100_DX_1080P30_3X = 71;</code>
     */
    em100_DX_1080P30_3X(68, 71),
    /**
     * <code>em100L_DX_720P = 72;</code>
     */
    em100L_DX_720P(69, 72),
    /**
     * <code>emX310_1080P60 = 73;</code>
     */
    emX310_1080P60(70, 73),
    /**
     * <code>emX310_1080P60_S = 74;</code>
     */
    emX310_1080P60_S(71, 74),
    /**
     * <code>emX310_1080P30 = 75;</code>
     */
    emX310_1080P30(72, 75),
    /**
     * <code>emX510_1080P60 = 76;</code>
     */
    emX510_1080P60(73, 76),
    /**
     * <code>emX510_1080P60_S = 77;</code>
     */
    emX510_1080P60_S(74, 77),
    /**
     * <code>emX510_1080P30 = 78;</code>
     */
    emX510_1080P30(75, 78),
    /**
     * <code>emX510_4K = 79;</code>
     */
    emX510_4K(76, 79),
    /**
     * <code>emX510_4K_S = 80;</code>
     */
    emX510_4K_S(77, 80),
    /**
     * <code>em310I_1080P60_12X = 81;</code>
     */
    em310I_1080P60_12X(78, 81),
    /**
     * <code>em310I_1080P60_12X_S = 82;</code>
     */
    em310I_1080P60_12X_S(79, 82),
    /**
     * <code>em310_1080P30_12X = 83;</code>
     */
    em310_1080P30_12X(80, 83),
    /**
     * <code>em310_1080P30_12X_S = 84;</code>
     */
    em310_1080P30_12X_S(81, 84),
    /**
     * <code>em310_1080P30_5X = 85;</code>
     */
    em310_1080P30_5X(82, 85),
    ;

    /**
     * <code>emModelBegin = 0;</code>
     *
     * <pre>
     *无效值，
     * </pre>
     */
    public static final int emModelBegin_VALUE = 0;
    /**
     * <code>emSkyWindows = 1;</code>
     *
     * <pre>
     *桌面终端 自建
     * </pre>
     */
    public static final int emSkyWindows_VALUE = 1;
    /**
     * <code>emSkyIPad = 2;</code>
     *
     * <pre>
     *移动终端ipad 自建
     * </pre>
     */
    public static final int emSkyIPad_VALUE = 2;
    /**
     * <code>emSkyIPhone = 3;</code>
     *
     * <pre>
     *移动终端iphone 自建
     * </pre>
     */
    public static final int emSkyIPhone_VALUE = 3;
    /**
     * <code>emSkyAndroidPad = 7;</code>
     *
     * <pre>
     *移动终端androidpad 自建
     * </pre>
     */
    public static final int emSkyAndroidPad_VALUE = 7;
    /**
     * <code>emSkyAndroidPhone = 8;</code>
     *
     * <pre>
     *移动终端androidphone 自建
     * </pre>
     */
    public static final int emSkyAndroidPhone_VALUE = 8;
    /**
     * <code>emX500_1080P60 = 9;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    public static final int emX500_1080P60_VALUE = 9;
    /**
     * <code>emX500_1080P30 = 10;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    public static final int emX500_1080P30_VALUE = 10;
    /**
     * <code>emX500_720P60 = 11;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    public static final int emX500_720P60_VALUE = 11;
    /**
     * <code>emX500_mo_1080P = 12;</code>
     *
     * <pre>
     *硬终端 租赁
     * </pre>
     */
    public static final int emX500_mo_1080P_VALUE = 12;
    /**
     * <code>emX500_mo_720P = 13;</code>
     *
     * <pre>
     *硬终端 租赁
     * </pre>
     */
    public static final int emX500_mo_720P_VALUE = 13;
    /**
     * <code>emX500_oem_1080P = 14;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    public static final int emX500_oem_1080P_VALUE = 14;
    /**
     * <code>emX500_oem_mo_1080P = 15;</code>
     *
     * <pre>
     *硬终端 租赁
     * </pre>
     */
    public static final int emX500_oem_mo_1080P_VALUE = 15;
    /**
     * <code>emTrueLink = 16;</code>
     *
     * <pre>
     *桌面终端 租赁
     * </pre>
     */
    public static final int emTrueLink_VALUE = 16;
    /**
     * <code>emTrueTouchIpad = 17;</code>
     *
     * <pre>
     *移动终端ipad 租赁
     * </pre>
     */
    public static final int emTrueTouchIpad_VALUE = 17;
    /**
     * <code>emTrueTouchIphone = 18;</code>
     *
     * <pre>
     *移动终端iphone 租赁
     * </pre>
     */
    public static final int emTrueTouchIphone_VALUE = 18;
    /**
     * <code>emTrueTouchAndroidPhone = 19;</code>
     *
     * <pre>
     *移动终端androidphone 租赁	
     * </pre>
     */
    public static final int emTrueTouchAndroidPhone_VALUE = 19;
    /**
     * <code>emTrueTouchAndroidPad = 20;</code>
     *
     * <pre>
     *移动终端androidpad   租赁
     * </pre>
     */
    public static final int emTrueTouchAndroidPad_VALUE = 20;
    /**
     * <code>emH950_1080P60 = 21;</code>
     *
     * <pre>
     *硬终端 自建
     * </pre>
     */
    public static final int emH950_1080P60_VALUE = 21;
    /**
     * <code>emTrueLinkTV = 22;</code>
     *
     * <pre>
     *TV盒子 租赁
     * </pre>
     */
    public static final int emTrueLinkTV_VALUE = 22;
    /**
     * <code>emX700_4k30 = 23;</code>
     *
     * <pre>
     *x700-4k30 自建
     * </pre>
     */
    public static final int emX700_4k30_VALUE = 23;
    /**
     * <code>emX700_oem_4k30 = 24;</code>
     *
     * <pre>
     *x700-4k30 oem 自建
     * </pre>
     */
    public static final int emX700_oem_4k30_VALUE = 24;
    /**
     * <code>emX500_4k30 = 25;</code>
     *
     * <pre>
     *x500-4k30 自建
     * </pre>
     */
    public static final int emX500_4k30_VALUE = 25;
    /**
     * <code>emX500_oem_4k30 = 26;</code>
     *
     * <pre>
     *x500-4k30 oem 自建
     * </pre>
     */
    public static final int emX500_oem_4k30_VALUE = 26;
    /**
     * <code>emX300_1080P60 = 27;</code>
     *
     * <pre>
     *x300-1080P60  自建
     * </pre>
     */
    public static final int emX300_1080P60_VALUE = 27;
    /**
     * <code>emX300_1080P30 = 28;</code>
     *
     * <pre>
     *x300-1080P30  自建
     * </pre>
     */
    public static final int emX300_1080P30_VALUE = 28;
    /**
     * <code>emX300_720P60 = 29;</code>
     *
     * <pre>
     *x300-720P60   自建
     * </pre>
     */
    public static final int emX300_720P60_VALUE = 29;
    /**
     * <code>emX300_oem_1080P60 = 30;</code>
     *
     * <pre>
     *x300-1080P60 oem 自建
     * </pre>
     */
    public static final int emX300_oem_1080P60_VALUE = 30;
    /**
     * <code>emX500_1080P_60 = 31;</code>
     *
     * <pre>
     *x500-1080P-1080P60  自建  SKY X500-1080P 终端 和从9-15的x500终端不一样，芯片不一样
     * </pre>
     */
    public static final int emX500_1080P_60_VALUE = 31;
    /**
     * <code>emX500_1080P_30 = 32;</code>
     *
     * <pre>
     *x500-1080P-1080P30  自建
     * </pre>
     */
    public static final int emX500_1080P_30_VALUE = 32;
    /**
     * <code>emX500_oem_1080P_60 = 33;</code>
     *
     * <pre>
     *x500-1080P-1080P60  oem 自建
     * </pre>
     */
    public static final int emX500_oem_1080P_60_VALUE = 33;
    /**
     * <code>em300_1080P30 = 34;</code>
     *
     * <pre>
     *300-1080P30  自建
     * </pre>
     */
    public static final int em300_1080P30_VALUE = 34;
    /**
     * <code>em300_720P60 = 35;</code>
     *
     * <pre>
     *300-720P60   自建
     * </pre>
     */
    public static final int em300_720P60_VALUE = 35;
    /**
     * <code>em300_oem_1080P30 = 36;</code>
     *
     * <pre>
     *300-1080P30  oem 自建
     * </pre>
     */
    public static final int em300_oem_1080P30_VALUE = 36;
    /**
     * <code>em300L_1080P30 = 37;</code>
     *
     * <pre>
     *300L-1080P30 自建
     * </pre>
     */
    public static final int em300L_1080P30_VALUE = 37;
    /**
     * <code>em300L_720P60 = 38;</code>
     *
     * <pre>
     *300L-720P60  自建
     * </pre>
     */
    public static final int em300L_720P60_VALUE = 38;
    /**
     * <code>em300L_oem_1080P30 = 39;</code>
     *
     * <pre>
     *300L-1080P30 oem 自建
     * </pre>
     */
    public static final int em300L_oem_1080P30_VALUE = 39;
    /**
     * <code>em300_1080P60 = 40;</code>
     *
     * <pre>
     *300-1080P60  自建
     * </pre>
     */
    public static final int em300_1080P60_VALUE = 40;
    /**
     * <code>em300_720P30 = 41;</code>
     *
     * <pre>
     *300-720P30   自建
     * </pre>
     */
    public static final int em300_720P30_VALUE = 41;
    /**
     * <code>em300L_1080P60 = 42;</code>
     *
     * <pre>
     *300-1080P60  自建
     * </pre>
     */
    public static final int em300L_1080P60_VALUE = 42;
    /**
     * <code>em300L_720P30 = 43;</code>
     *
     * <pre>
     *300-720P30   自建
     * </pre>
     */
    public static final int em300L_720P30_VALUE = 43;
    /**
     * <code>emX300_720P30 = 44;</code>
     *
     * <pre>
     *x300-720P30   自建
     * </pre>
     */
    public static final int emX300_720P30_VALUE = 44;
    /**
     * <code>emX500_720P_30 = 45;</code>
     *
     * <pre>
     *x500-720P-720P30  自建
     * </pre>
     */
    public static final int emX500_720P_30_VALUE = 45;
    /**
     * <code>emX500_720P_60 = 46;</code>
     *
     * <pre>
     *x500-720P-720P60  自建
     * </pre>
     */
    public static final int emX500_720P_60_VALUE = 46;
    /**
     * <code>em100_1080P30_12X = 47;</code>
     *
     * <pre>
     *100_1080P30_12X
     * </pre>
     */
    public static final int em100_1080P30_12X_VALUE = 47;
    /**
     * <code>em100_1080P30_3X = 48;</code>
     *
     * <pre>
     *100_1080P30_3X
     * </pre>
     */
    public static final int em100_1080P30_3X_VALUE = 48;
    /**
     * <code>em100L_720P = 49;</code>
     *
     * <pre>
     *100L_720P
     * </pre>
     */
    public static final int em100L_720P_VALUE = 49;
    /**
     * <code>em100_oem_1080P30_3X = 50;</code>
     *
     * <pre>
     *100_oem_1080P30_3X
     * </pre>
     */
    public static final int em100_oem_1080P30_3X_VALUE = 50;
    /**
     * <code>emSkyWindows_s = 51;</code>
     *
     * <pre>
     *&#47;&lt; 商密桌面终端 自建
     * </pre>
     */
    public static final int emSkyWindows_s_VALUE = 51;
    /**
     * <code>emSkyIPad_s = 52;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端ipad 自建
     * </pre>
     */
    public static final int emSkyIPad_s_VALUE = 52;
    /**
     * <code>emSkyIPhone_s = 53;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端iphone 自建
     * </pre>
     */
    public static final int emSkyIPhone_s_VALUE = 53;
    /**
     * <code>emSkyAndroidPad_s = 54;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端androidpad 自建
     * </pre>
     */
    public static final int emSkyAndroidPad_s_VALUE = 54;
    /**
     * <code>emSkyAndroidPhone_s = 55;</code>
     *
     * <pre>
     *&#47;&lt; 商密移动终端androidphone 自建
     * </pre>
     */
    public static final int emSkyAndroidPhone_s_VALUE = 55;
    /**
     * <code>emX300_1080P60_s = 56;</code>
     *
     * <pre>
     * 商密硬终端 sky_x300_1080P60_s 
     * </pre>
     */
    public static final int emX300_1080P60_s_VALUE = 56;
    /**
     * <code>emX500_1080P60_s = 57;</code>
     *
     * <pre>
     * 商密硬终端 sky_x500_1080P60_s
     * </pre>
     */
    public static final int emX500_1080P60_s_VALUE = 57;
    /**
     * <code>em300_1080P60_s = 58;</code>
     *
     * <pre>
     * 商密硬终端 sky_300_1080P60_s
     * </pre>
     */
    public static final int em300_1080P60_s_VALUE = 58;
    /**
     * <code>emX700_s = 59;</code>
     *
     * <pre>
     * 商密硬终端 sky_x700_s
     * </pre>
     */
    public static final int emX700_s_VALUE = 59;
    /**
     * <code>emX500_4K_s = 60;</code>
     *
     * <pre>
     * 商密硬终端 sky_x500_4k_s
     * </pre>
     */
    public static final int emX500_4K_s_VALUE = 60;
    /**
     * <code>em100_1080P30_12X_s = 61;</code>
     *
     * <pre>
     * 商密硬终端 sky_100_1080P30_12x_s
     * </pre>
     */
    public static final int em100_1080P30_12X_s_VALUE = 61;
    /**
     * <code>emX300_1080P60_cs = 62;</code>
     *
     * <pre>
     * 渠道版本 sky_x300_1080P60_cs 
     * </pre>
     */
    public static final int emX300_1080P60_cs_VALUE = 62;
    /**
     * <code>emX500_1080P60_cs = 63;</code>
     *
     * <pre>
     * 渠道版本 sky_x500_1080P60_cs
     * </pre>
     */
    public static final int emX500_1080P60_cs_VALUE = 63;
    /**
     * <code>em300_1080P60_cs = 64;</code>
     *
     * <pre>
     * 渠道版本 sky_300_1080P60_cs
     * </pre>
     */
    public static final int em300_1080P60_cs_VALUE = 64;
    /**
     * <code>emX700_cs = 65;</code>
     *
     * <pre>
     * 渠道版本 sky_x700_cs
     * </pre>
     */
    public static final int emX700_cs_VALUE = 65;
    /**
     * <code>emX500_4K_cs = 66;</code>
     *
     * <pre>
     * 渠道版本 sky_x500_4k_cs
     * </pre>
     */
    public static final int emX500_4K_cs_VALUE = 66;
    /**
     * <code>em100_1080P30_12X_cs = 67;</code>
     *
     * <pre>
     * 渠道版本 sky_100_1080P30_12x_cs
     * </pre>
     */
    public static final int em100_1080P30_12X_cs_VALUE = 67;
    /**
     * <code>em100_1080P30_12X_H5 = 68;</code>
     *
     * <pre>
     * SKY 100-1080P30-12x-H5,支持H265
     * </pre>
     */
    public static final int em100_1080P30_12X_H5_VALUE = 68;
    /**
     * <code>em100_1080P30_3X_H5 = 69;</code>
     *
     * <pre>
     * SKY 100-1080P30-3x-H5
     * </pre>
     */
    public static final int em100_1080P30_3X_H5_VALUE = 69;
    /**
     * <code>em100_DX_1080P30_12X = 70;</code>
     *
     * <pre>
     *SKY 100-DX-1080P30-12x（不支持WIFI）
     * </pre>
     */
    public static final int em100_DX_1080P30_12X_VALUE = 70;
    /**
     * <code>em100_DX_1080P30_3X = 71;</code>
     */
    public static final int em100_DX_1080P30_3X_VALUE = 71;
    /**
     * <code>em100L_DX_720P = 72;</code>
     */
    public static final int em100L_DX_720P_VALUE = 72;
    /**
     * <code>emX310_1080P60 = 73;</code>
     */
    public static final int emX310_1080P60_VALUE = 73;
    /**
     * <code>emX310_1080P60_S = 74;</code>
     */
    public static final int emX310_1080P60_S_VALUE = 74;
    /**
     * <code>emX310_1080P30 = 75;</code>
     */
    public static final int emX310_1080P30_VALUE = 75;
    /**
     * <code>emX510_1080P60 = 76;</code>
     */
    public static final int emX510_1080P60_VALUE = 76;
    /**
     * <code>emX510_1080P60_S = 77;</code>
     */
    public static final int emX510_1080P60_S_VALUE = 77;
    /**
     * <code>emX510_1080P30 = 78;</code>
     */
    public static final int emX510_1080P30_VALUE = 78;
    /**
     * <code>emX510_4K = 79;</code>
     */
    public static final int emX510_4K_VALUE = 79;
    /**
     * <code>emX510_4K_S = 80;</code>
     */
    public static final int emX510_4K_S_VALUE = 80;
    /**
     * <code>em310I_1080P60_12X = 81;</code>
     */
    public static final int em310I_1080P60_12X_VALUE = 81;
    /**
     * <code>em310I_1080P60_12X_S = 82;</code>
     */
    public static final int em310I_1080P60_12X_S_VALUE = 82;
    /**
     * <code>em310_1080P30_12X = 83;</code>
     */
    public static final int em310_1080P30_12X_VALUE = 83;
    /**
     * <code>em310_1080P30_12X_S = 84;</code>
     */
    public static final int em310_1080P30_12X_S_VALUE = 84;
    /**
     * <code>em310_1080P30_5X = 85;</code>
     */
    public static final int em310_1080P30_5X_VALUE = 85;


    public final int getNumber() { return value; }

    public static EmMtModel valueOf(int value) {
      switch (value) {
        case 0: return emModelBegin;
        case 1: return emSkyWindows;
        case 2: return emSkyIPad;
        case 3: return emSkyIPhone;
        case 7: return emSkyAndroidPad;
        case 8: return emSkyAndroidPhone;
        case 9: return emX500_1080P60;
        case 10: return emX500_1080P30;
        case 11: return emX500_720P60;
        case 12: return emX500_mo_1080P;
        case 13: return emX500_mo_720P;
        case 14: return emX500_oem_1080P;
        case 15: return emX500_oem_mo_1080P;
        case 16: return emTrueLink;
        case 17: return emTrueTouchIpad;
        case 18: return emTrueTouchIphone;
        case 19: return emTrueTouchAndroidPhone;
        case 20: return emTrueTouchAndroidPad;
        case 21: return emH950_1080P60;
        case 22: return emTrueLinkTV;
        case 23: return emX700_4k30;
        case 24: return emX700_oem_4k30;
        case 25: return emX500_4k30;
        case 26: return emX500_oem_4k30;
        case 27: return emX300_1080P60;
        case 28: return emX300_1080P30;
        case 29: return emX300_720P60;
        case 30: return emX300_oem_1080P60;
        case 31: return emX500_1080P_60;
        case 32: return emX500_1080P_30;
        case 33: return emX500_oem_1080P_60;
        case 34: return em300_1080P30;
        case 35: return em300_720P60;
        case 36: return em300_oem_1080P30;
        case 37: return em300L_1080P30;
        case 38: return em300L_720P60;
        case 39: return em300L_oem_1080P30;
        case 40: return em300_1080P60;
        case 41: return em300_720P30;
        case 42: return em300L_1080P60;
        case 43: return em300L_720P30;
        case 44: return emX300_720P30;
        case 45: return emX500_720P_30;
        case 46: return emX500_720P_60;
        case 47: return em100_1080P30_12X;
        case 48: return em100_1080P30_3X;
        case 49: return em100L_720P;
        case 50: return em100_oem_1080P30_3X;
        case 51: return emSkyWindows_s;
        case 52: return emSkyIPad_s;
        case 53: return emSkyIPhone_s;
        case 54: return emSkyAndroidPad_s;
        case 55: return emSkyAndroidPhone_s;
        case 56: return emX300_1080P60_s;
        case 57: return emX500_1080P60_s;
        case 58: return em300_1080P60_s;
        case 59: return emX700_s;
        case 60: return emX500_4K_s;
        case 61: return em100_1080P30_12X_s;
        case 62: return emX300_1080P60_cs;
        case 63: return emX500_1080P60_cs;
        case 64: return em300_1080P60_cs;
        case 65: return emX700_cs;
        case 66: return emX500_4K_cs;
        case 67: return em100_1080P30_12X_cs;
        case 68: return em100_1080P30_12X_H5;
        case 69: return em100_1080P30_3X_H5;
        case 70: return em100_DX_1080P30_12X;
        case 71: return em100_DX_1080P30_3X;
        case 72: return em100L_DX_720P;
        case 73: return emX310_1080P60;
        case 74: return emX310_1080P60_S;
        case 75: return emX310_1080P30;
        case 76: return emX510_1080P60;
        case 77: return emX510_1080P60_S;
        case 78: return emX510_1080P30;
        case 79: return emX510_4K;
        case 80: return emX510_4K_S;
        case 81: return em310I_1080P60_12X;
        case 82: return em310I_1080P60_12X_S;
        case 83: return em310_1080P30_12X;
        case 84: return em310_1080P30_12X_S;
        case 85: return em310_1080P30_5X;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtModel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtModel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtModel>() {
            public EmMtModel findValueByNumber(int number) {
              return EmMtModel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(5);
    }

    private static final EmMtModel[] VALUES = values();

    public static EmMtModel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtModel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtModel)
  }

  /**
   * Protobuf enum {@code mt.EmConfProtocol}
   *
   * <pre>
   *会议协议
   * </pre>
   */
  public enum EmConfProtocol
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emProtocolBegin = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    emProtocolBegin(0, 0),
    /**
     * <code>em323 = 1;</code>
     */
    em323(1, 1),
    /**
     * <code>emsip = 2;</code>
     */
    emsip(2, 2),
    /**
     * <code>emsat = 3;</code>
     */
    emsat(3, 3),
    /**
     * <code>emtip = 4;</code>
     */
    emtip(4, 4),
    /**
     * <code>emrtc = 5;</code>
     *
     * <pre>
     *webrtc协议
     * </pre>
     */
    emrtc(5, 5),
    ;

    /**
     * <code>emProtocolBegin = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    public static final int emProtocolBegin_VALUE = 0;
    /**
     * <code>em323 = 1;</code>
     */
    public static final int em323_VALUE = 1;
    /**
     * <code>emsip = 2;</code>
     */
    public static final int emsip_VALUE = 2;
    /**
     * <code>emsat = 3;</code>
     */
    public static final int emsat_VALUE = 3;
    /**
     * <code>emtip = 4;</code>
     */
    public static final int emtip_VALUE = 4;
    /**
     * <code>emrtc = 5;</code>
     *
     * <pre>
     *webrtc协议
     * </pre>
     */
    public static final int emrtc_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmConfProtocol valueOf(int value) {
      switch (value) {
        case 0: return emProtocolBegin;
        case 1: return em323;
        case 2: return emsip;
        case 3: return emsat;
        case 4: return emtip;
        case 5: return emrtc;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmConfProtocol>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmConfProtocol>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmConfProtocol>() {
            public EmConfProtocol findValueByNumber(int number) {
              return EmConfProtocol.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(6);
    }

    private static final EmConfProtocol[] VALUES = values();

    public static EmConfProtocol valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmConfProtocol(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmConfProtocol)
  }

  /**
   * Protobuf enum {@code mt.EmCodecComponent}
   *
   * <pre>
   *codec组件
   * </pre>
   */
  public enum EmCodecComponent
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVidMainEncoder = 0;</code>
     */
    emVidMainEncoder(0, 0),
    /**
     * <code>emVidMainDecoder = 1;</code>
     */
    emVidMainDecoder(1, 1),
    /**
     * <code>emAudMainEncoder = 2;</code>
     */
    emAudMainEncoder(2, 2),
    /**
     * <code>emAudMainDecoder = 3;</code>
     */
    emAudMainDecoder(3, 3),
    /**
     * <code>emAudMainMixer = 4;</code>
     */
    emAudMainMixer(4, 4),
    /**
     * <code>emVidMainMixer = 5;</code>
     */
    emVidMainMixer(5, 5),
    /**
     * <code>emVidAssEncoder = 6;</code>
     */
    emVidAssEncoder(6, 6),
    /**
     * <code>emVidAssDecoder = 7;</code>
     */
    emVidAssDecoder(7, 7),
    /**
     * <code>emAudAssEncoder = 8;</code>
     */
    emAudAssEncoder(8, 8),
    /**
     * <code>emAudAssDecoder = 9;</code>
     */
    emAudAssDecoder(9, 9),
    /**
     * <code>emAudAssMixer = 10;</code>
     */
    emAudAssMixer(10, 10),
    /**
     * <code>emVidAssMixer = 11;</code>
     */
    emVidAssMixer(11, 11),
    /**
     * <code>emVidMainSecondEncoder = 12;</code>
     *
     * <pre>
     *主二编码，废弃掉
     * </pre>
     */
    emVidMainSecondEncoder(12, 12),
    /**
     * <code>emVidMainSecondDecoder = 13;</code>
     *
     * <pre>
     *主二解码，废弃掉
     * </pre>
     */
    emVidMainSecondDecoder(13, 13),
    /**
     * <code>emCodecInvalid = 20;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    emCodecInvalid(14, 20),
    ;

    /**
     * <code>emVidMainEncoder = 0;</code>
     */
    public static final int emVidMainEncoder_VALUE = 0;
    /**
     * <code>emVidMainDecoder = 1;</code>
     */
    public static final int emVidMainDecoder_VALUE = 1;
    /**
     * <code>emAudMainEncoder = 2;</code>
     */
    public static final int emAudMainEncoder_VALUE = 2;
    /**
     * <code>emAudMainDecoder = 3;</code>
     */
    public static final int emAudMainDecoder_VALUE = 3;
    /**
     * <code>emAudMainMixer = 4;</code>
     */
    public static final int emAudMainMixer_VALUE = 4;
    /**
     * <code>emVidMainMixer = 5;</code>
     */
    public static final int emVidMainMixer_VALUE = 5;
    /**
     * <code>emVidAssEncoder = 6;</code>
     */
    public static final int emVidAssEncoder_VALUE = 6;
    /**
     * <code>emVidAssDecoder = 7;</code>
     */
    public static final int emVidAssDecoder_VALUE = 7;
    /**
     * <code>emAudAssEncoder = 8;</code>
     */
    public static final int emAudAssEncoder_VALUE = 8;
    /**
     * <code>emAudAssDecoder = 9;</code>
     */
    public static final int emAudAssDecoder_VALUE = 9;
    /**
     * <code>emAudAssMixer = 10;</code>
     */
    public static final int emAudAssMixer_VALUE = 10;
    /**
     * <code>emVidAssMixer = 11;</code>
     */
    public static final int emVidAssMixer_VALUE = 11;
    /**
     * <code>emVidMainSecondEncoder = 12;</code>
     *
     * <pre>
     *主二编码，废弃掉
     * </pre>
     */
    public static final int emVidMainSecondEncoder_VALUE = 12;
    /**
     * <code>emVidMainSecondDecoder = 13;</code>
     *
     * <pre>
     *主二解码，废弃掉
     * </pre>
     */
    public static final int emVidMainSecondDecoder_VALUE = 13;
    /**
     * <code>emCodecInvalid = 20;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    public static final int emCodecInvalid_VALUE = 20;


    public final int getNumber() { return value; }

    public static EmCodecComponent valueOf(int value) {
      switch (value) {
        case 0: return emVidMainEncoder;
        case 1: return emVidMainDecoder;
        case 2: return emAudMainEncoder;
        case 3: return emAudMainDecoder;
        case 4: return emAudMainMixer;
        case 5: return emVidMainMixer;
        case 6: return emVidAssEncoder;
        case 7: return emVidAssDecoder;
        case 8: return emAudAssEncoder;
        case 9: return emAudAssDecoder;
        case 10: return emAudAssMixer;
        case 11: return emVidAssMixer;
        case 12: return emVidMainSecondEncoder;
        case 13: return emVidMainSecondDecoder;
        case 20: return emCodecInvalid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCodecComponent>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCodecComponent>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCodecComponent>() {
            public EmCodecComponent findValueByNumber(int number) {
              return EmCodecComponent.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(7);
    }

    private static final EmCodecComponent[] VALUES = values();

    public static EmCodecComponent valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCodecComponent(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCodecComponent)
  }

  /**
   * Protobuf enum {@code mt.EmCodecComponentIndex}
   *
   * <pre>
   *codec组件码流索引
   * </pre>
   */
  public enum EmCodecComponentIndex
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>em1st = 0;</code>
     */
    em1st(0, 0),
    /**
     * <code>em2nd = 1;</code>
     */
    em2nd(1, 1),
    /**
     * <code>em3rd = 2;</code>
     */
    em3rd(2, 2),
    /**
     * <code>em4th = 3;</code>
     */
    em4th(3, 3),
    /**
     * <code>em5th = 4;</code>
     */
    em5th(4, 4),
    /**
     * <code>em6th = 5;</code>
     */
    em6th(5, 5),
    /**
     * <code>em7th = 6;</code>
     */
    em7th(6, 6),
    /**
     * <code>em8th = 7;</code>
     */
    em8th(7, 7),
    /**
     * <code>em9th = 8;</code>
     */
    em9th(8, 8),
    ;

    /**
     * <code>em1st = 0;</code>
     */
    public static final int em1st_VALUE = 0;
    /**
     * <code>em2nd = 1;</code>
     */
    public static final int em2nd_VALUE = 1;
    /**
     * <code>em3rd = 2;</code>
     */
    public static final int em3rd_VALUE = 2;
    /**
     * <code>em4th = 3;</code>
     */
    public static final int em4th_VALUE = 3;
    /**
     * <code>em5th = 4;</code>
     */
    public static final int em5th_VALUE = 4;
    /**
     * <code>em6th = 5;</code>
     */
    public static final int em6th_VALUE = 5;
    /**
     * <code>em7th = 6;</code>
     */
    public static final int em7th_VALUE = 6;
    /**
     * <code>em8th = 7;</code>
     */
    public static final int em8th_VALUE = 7;
    /**
     * <code>em9th = 8;</code>
     */
    public static final int em9th_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmCodecComponentIndex valueOf(int value) {
      switch (value) {
        case 0: return em1st;
        case 1: return em2nd;
        case 2: return em3rd;
        case 3: return em4th;
        case 4: return em5th;
        case 5: return em6th;
        case 6: return em7th;
        case 7: return em8th;
        case 8: return em9th;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCodecComponentIndex>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCodecComponentIndex>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCodecComponentIndex>() {
            public EmCodecComponentIndex findValueByNumber(int number) {
              return EmCodecComponentIndex.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(8);
    }

    private static final EmCodecComponentIndex[] VALUES = values();

    public static EmCodecComponentIndex valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCodecComponentIndex(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCodecComponentIndex)
  }

  /**
   * Protobuf enum {@code mt.EmVidFormat}
   *
   * <pre>
   *视频格式
   * </pre>
   */
  public enum EmVidFormat
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVH261 = 0;</code>
     */
    emVH261(0, 0),
    /**
     * <code>emVH262 = 1;</code>
     */
    emVH262(1, 1),
    /**
     * <code>emVH263 = 2;</code>
     */
    emVH263(2, 2),
    /**
     * <code>emVH263plus = 3;</code>
     */
    emVH263plus(3, 3),
    /**
     * <code>emVH264 = 4;</code>
     */
    emVH264(4, 4),
    /**
     * <code>emVMPEG4 = 5;</code>
     */
    emVMPEG4(5, 5),
    /**
     * <code>emVH265 = 6;</code>
     *
     * <pre>
     *暂未实现
     * </pre>
     */
    emVH265(6, 6),
    /**
     * <code>emVEnd = 7;</code>
     */
    emVEnd(7, 7),
    ;

    /**
     * <code>emVH261 = 0;</code>
     */
    public static final int emVH261_VALUE = 0;
    /**
     * <code>emVH262 = 1;</code>
     */
    public static final int emVH262_VALUE = 1;
    /**
     * <code>emVH263 = 2;</code>
     */
    public static final int emVH263_VALUE = 2;
    /**
     * <code>emVH263plus = 3;</code>
     */
    public static final int emVH263plus_VALUE = 3;
    /**
     * <code>emVH264 = 4;</code>
     */
    public static final int emVH264_VALUE = 4;
    /**
     * <code>emVMPEG4 = 5;</code>
     */
    public static final int emVMPEG4_VALUE = 5;
    /**
     * <code>emVH265 = 6;</code>
     *
     * <pre>
     *暂未实现
     * </pre>
     */
    public static final int emVH265_VALUE = 6;
    /**
     * <code>emVEnd = 7;</code>
     */
    public static final int emVEnd_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmVidFormat valueOf(int value) {
      switch (value) {
        case 0: return emVH261;
        case 1: return emVH262;
        case 2: return emVH263;
        case 3: return emVH263plus;
        case 4: return emVH264;
        case 5: return emVMPEG4;
        case 6: return emVH265;
        case 7: return emVEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVidFormat>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVidFormat>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVidFormat>() {
            public EmVidFormat findValueByNumber(int number) {
              return EmVidFormat.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(9);
    }

    private static final EmVidFormat[] VALUES = values();

    public static EmVidFormat valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVidFormat(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVidFormat)
  }

  /**
   * Protobuf enum {@code mt.EmAudFormat}
   *
   * <pre>
   *音频格式
   * </pre>
   */
  public enum EmAudFormat
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAG711a = 0;</code>
     */
    emAG711a(0, 0),
    /**
     * <code>emAG711u = 1;</code>
     */
    emAG711u(1, 1),
    /**
     * <code>emAG722 = 2;</code>
     */
    emAG722(2, 2),
    /**
     * <code>emAG7231 = 3;</code>
     */
    emAG7231(3, 3),
    /**
     * <code>emAG728 = 4;</code>
     */
    emAG728(4, 4),
    /**
     * <code>emAG729 = 5;</code>
     */
    emAG729(5, 5),
    /**
     * <code>emAMP3 = 6;</code>
     */
    emAMP3(6, 6),
    /**
     * <code>emAG721 = 7;</code>
     */
    emAG721(7, 7),
    /**
     * <code>emAG7221 = 8;</code>
     */
    emAG7221(8, 8),
    /**
     * <code>emAG719 = 9;</code>
     */
    emAG719(9, 9),
    /**
     * <code>emAMpegAACLC = 10;</code>
     */
    emAMpegAACLC(10, 10),
    /**
     * <code>emAMpegAACLD = 11;</code>
     */
    emAMpegAACLD(11, 11),
    /**
     * <code>emAOpus = 12;</code>
     */
    emAOpus(12, 12),
    /**
     * <code>emAudEnd = 13;</code>
     */
    emAudEnd(13, 13),
    ;

    /**
     * <code>emAG711a = 0;</code>
     */
    public static final int emAG711a_VALUE = 0;
    /**
     * <code>emAG711u = 1;</code>
     */
    public static final int emAG711u_VALUE = 1;
    /**
     * <code>emAG722 = 2;</code>
     */
    public static final int emAG722_VALUE = 2;
    /**
     * <code>emAG7231 = 3;</code>
     */
    public static final int emAG7231_VALUE = 3;
    /**
     * <code>emAG728 = 4;</code>
     */
    public static final int emAG728_VALUE = 4;
    /**
     * <code>emAG729 = 5;</code>
     */
    public static final int emAG729_VALUE = 5;
    /**
     * <code>emAMP3 = 6;</code>
     */
    public static final int emAMP3_VALUE = 6;
    /**
     * <code>emAG721 = 7;</code>
     */
    public static final int emAG721_VALUE = 7;
    /**
     * <code>emAG7221 = 8;</code>
     */
    public static final int emAG7221_VALUE = 8;
    /**
     * <code>emAG719 = 9;</code>
     */
    public static final int emAG719_VALUE = 9;
    /**
     * <code>emAMpegAACLC = 10;</code>
     */
    public static final int emAMpegAACLC_VALUE = 10;
    /**
     * <code>emAMpegAACLD = 11;</code>
     */
    public static final int emAMpegAACLD_VALUE = 11;
    /**
     * <code>emAOpus = 12;</code>
     */
    public static final int emAOpus_VALUE = 12;
    /**
     * <code>emAudEnd = 13;</code>
     */
    public static final int emAudEnd_VALUE = 13;


    public final int getNumber() { return value; }

    public static EmAudFormat valueOf(int value) {
      switch (value) {
        case 0: return emAG711a;
        case 1: return emAG711u;
        case 2: return emAG722;
        case 3: return emAG7231;
        case 4: return emAG728;
        case 5: return emAG729;
        case 6: return emAMP3;
        case 7: return emAG721;
        case 8: return emAG7221;
        case 9: return emAG719;
        case 10: return emAMpegAACLC;
        case 11: return emAMpegAACLD;
        case 12: return emAOpus;
        case 13: return emAudEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAudFormat>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAudFormat>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAudFormat>() {
            public EmAudFormat findValueByNumber(int number) {
              return EmAudFormat.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(10);
    }

    private static final EmAudFormat[] VALUES = values();

    public static EmAudFormat valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAudFormat(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAudFormat)
  }

  /**
   * Protobuf enum {@code mt.EmEncodeMode}
   */
  public enum EmEncodeMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emQualityFirst = 0;</code>
     */
    emQualityFirst(0, 0),
    /**
     * <code>emSpeedFirst = 1;</code>
     */
    emSpeedFirst(1, 1),
    ;

    /**
     * <code>emQualityFirst = 0;</code>
     */
    public static final int emQualityFirst_VALUE = 0;
    /**
     * <code>emSpeedFirst = 1;</code>
     */
    public static final int emSpeedFirst_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmEncodeMode valueOf(int value) {
      switch (value) {
        case 0: return emQualityFirst;
        case 1: return emSpeedFirst;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEncodeMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEncodeMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEncodeMode>() {
            public EmEncodeMode findValueByNumber(int number) {
              return EmEncodeMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(11);
    }

    private static final EmEncodeMode[] VALUES = values();

    public static EmEncodeMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEncodeMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmEncodeMode)
  }

  /**
   * Protobuf enum {@code mt.EmTermSwitchMode}
   *
   * <pre>
   *&#47;切换模式
   * </pre>
   */
  public enum EmTermSwitchMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emModeBegin = 0;</code>
     */
    emModeBegin(0, 0),
    /**
     * <code>emAudioAndAssMode = 1;</code>
     *
     * <pre>
     * 音频 + 双流模式
     * </pre>
     */
    emAudioAndAssMode(1, 1),
    ;

    /**
     * <code>emModeBegin = 0;</code>
     */
    public static final int emModeBegin_VALUE = 0;
    /**
     * <code>emAudioAndAssMode = 1;</code>
     *
     * <pre>
     * 音频 + 双流模式
     * </pre>
     */
    public static final int emAudioAndAssMode_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmTermSwitchMode valueOf(int value) {
      switch (value) {
        case 0: return emModeBegin;
        case 1: return emAudioAndAssMode;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmTermSwitchMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmTermSwitchMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmTermSwitchMode>() {
            public EmTermSwitchMode findValueByNumber(int number) {
              return EmTermSwitchMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(12);
    }

    private static final EmTermSwitchMode[] VALUES = values();

    public static EmTermSwitchMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmTermSwitchMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmTermSwitchMode)
  }

  /**
   * Protobuf enum {@code mt.EmMtResolution}
   *
   * <pre>
   *0-39分辨率和mcu定义的分辨率对应起来，后面的对应不起来
   * </pre>
   */
  public enum EmMtResolution
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMtResAuto = 0;</code>
     *
     * <pre>
     *自适应
     * </pre>
     */
    emMtResAuto(0, 0),
    /**
     * <code>emMtSQCIF = 1;</code>
     *
     * <pre>
     *SQCIF 128*96
     * </pre>
     */
    emMtSQCIF(1, 1),
    /**
     * <code>emMtQCIF = 2;</code>
     *
     * <pre>
     *QCIF 176x144
     * </pre>
     */
    emMtQCIF(2, 2),
    /**
     * <code>emMtCIF = 3;</code>
     *
     * <pre>
     *CIF 352x288
     * </pre>
     */
    emMtCIF(3, 3),
    /**
     * <code>emMt2CIF = 4;</code>
     *
     * <pre>
     *2CIF 352x576
     * </pre>
     */
    emMt2CIF(4, 4),
    /**
     * <code>emMt4CIF = 5;</code>
     *
     * <pre>
     *4CIF 704x576
     * </pre>
     */
    emMt4CIF(5, 5),
    /**
     * <code>emMt16CIF = 6;</code>
     *
     * <pre>
     *16CIF 1408x1152
     * </pre>
     */
    emMt16CIF(6, 6),
    /**
     * <code>emMtVGA352x240 = 7;</code>
     *
     * <pre>
     *352x240  对应平台SIF
     * </pre>
     */
    emMtVGA352x240(7, 7),
    /**
     * <code>emMt2SIF = 8;</code>
     *
     * <pre>
     *对应平台2SIF，具体不知道多少*多少                  
     * </pre>
     */
    emMt2SIF(8, 8),
    /**
     * <code>emMtVGA704x480 = 9;</code>
     *
     * <pre>
     *704x480  对应平台4SIF
     * </pre>
     */
    emMtVGA704x480(9, 9),
    /**
     * <code>emMtVGA640x480 = 10;</code>
     *
     * <pre>
     *VGA 640x480                   
     * </pre>
     */
    emMtVGA640x480(10, 10),
    /**
     * <code>emMtVGA800x600 = 11;</code>
     *
     * <pre>
     *SVGA 800x600                     
     * </pre>
     */
    emMtVGA800x600(11, 11),
    /**
     * <code>emMtVGA1024x768 = 12;</code>
     *
     * <pre>
     *XGA 1024x768                     
     * </pre>
     */
    emMtVGA1024x768(12, 12),
    /**
     * <code>emMtVWCIF = 13;</code>
     *
     * <pre>
     *WCIF 512*288
     * </pre>
     */
    emMtVWCIF(13, 13),
    /**
     * <code>emMtVSQCIF112x96 = 14;</code>
     *
     * <pre>
     *仅用于终端分辨率改变	
     * </pre>
     */
    emMtVSQCIF112x96(14, 14),
    /**
     * <code>emMtVSQCIF96x80 = 15;</code>
     *
     * <pre>
     *SQCIF(96*80) 
     * </pre>
     */
    emMtVSQCIF96x80(15, 15),
    /**
     * <code>emMtVW4CIF = 16;</code>
     *
     * <pre>
     *&#47;///高清分辨率
     * </pre>
     */
    emMtVW4CIF(16, 16),
    /**
     * <code>emMtHD720p1280x720 = 17;</code>
     *
     * <pre>
     *720p 1280x720
     * </pre>
     */
    emMtHD720p1280x720(17, 17),
    /**
     * <code>emMtVGA1280x1024 = 18;</code>
     *
     * <pre>
     *SXGA 1280x1024
     * </pre>
     */
    emMtVGA1280x1024(18, 18),
    /**
     * <code>emMtVGA1600x1200 = 19;</code>
     *
     * <pre>
     *UXGA 1600x1200
     * </pre>
     */
    emMtVGA1600x1200(19, 19),
    /**
     * <code>emMtHD1080i1920x1080 = 20;</code>
     *
     * <pre>
     *1080i 1920x1080
     * </pre>
     */
    emMtHD1080i1920x1080(20, 20),
    /**
     * <code>emMtHD1080p1920x1080 = 21;</code>
     *
     * <pre>
     *1080p 1920x1080          
     * </pre>
     */
    emMtHD1080p1920x1080(21, 21),
    /**
     * <code>emMtVGA1280x800 = 22;</code>
     *
     * <pre>
     *WXGA 1280x800
     * </pre>
     */
    emMtVGA1280x800(22, 22),
    /**
     * <code>emMtVGA1440x900 = 23;</code>
     *
     * <pre>
     *WSXGA 1440x900                     
     * </pre>
     */
    emMtVGA1440x900(23, 23),
    /**
     * <code>emMtVGA1280x960 = 24;</code>
     *
     * <pre>
     *XVGA  1280x960                     
     * </pre>
     */
    emMtVGA1280x960(24, 24),
    /**
     * <code>emMtV1440x816 = 25;</code>
     *
     * <pre>
     *非标分辨率（1080p底图）－用于终端分辨率改变                     
     * </pre>
     */
    emMtV1440x816(25, 25),
    /**
     * <code>emMt1280x720 = 26;</code>
     *
     * <pre>
     *1280×720(2/3)
     * </pre>
     */
    emMt1280x720(26, 26),
    /**
     * <code>emMtV960x544 = 27;</code>
     *
     * <pre>
     *960×544(1/2)
     * </pre>
     */
    emMtV960x544(27, 27),
    /**
     * <code>emMtV640x368 = 28;</code>
     *
     * <pre>
     *640×368(1/3)
     * </pre>
     */
    emMtV640x368(28, 28),
    /**
     * <code>emMtV480x272 = 29;</code>
     *
     * <pre>
     *480×272(1/4)
     * </pre>
     */
    emMtV480x272(29, 29),
    /**
     * <code>emMt384x272 = 30;</code>
     *
     * <pre>
     *384×272(1/5)
     * </pre>
     */
    emMt384x272(30, 30),
    /**
     * <code>emMt640x544 = 31;</code>
     *
     * <pre>
     *640x544                       
     * </pre>
     */
    emMt640x544(31, 31),
    /**
     * <code>emMt320x272 = 32;</code>
     *
     * <pre>
     *320x272
     * </pre>
     */
    emMt320x272(32, 32),
    /**
     * <code>emMt_720_960x544 = 33;</code>
     *
     * <pre>
     *非标分辨率（720p底图） －用于终端分辨率改变
     * </pre>
     */
    emMt_720_960x544(33, 33),
    /**
     * <code>emMt_720_864x480 = 34;</code>
     *
     * <pre>
     *864×480(2/3)
     * </pre>
     */
    emMt_720_864x480(34, 34),
    /**
     * <code>emMt_720_640x368 = 35;</code>
     *
     * <pre>
     *640×368(1/2)
     * </pre>
     */
    emMt_720_640x368(35, 35),
    /**
     * <code>emMt_720_432x240 = 36;</code>
     *
     * <pre>
     *432×240(1/3)
     * </pre>
     */
    emMt_720_432x240(36, 36),
    /**
     * <code>emMt_720_320x192 = 37;</code>
     *
     * <pre>
     *320×192(1/4)
     * </pre>
     */
    emMt_720_320x192(37, 37),
    /**
     * <code>emMtVGA480x352 = 38;</code>
     *
     * <pre>
     *非标分辨率
     * </pre>
     */
    emMtVGA480x352(38, 38),
    /**
     * <code>emMtHD480i720x480 = 39;</code>
     *
     * <pre>
     *480i720x480
     * </pre>
     */
    emMtHD480i720x480(39, 39),
    /**
     * <code>emMtHD480p720x480 = 40;</code>
     *
     * <pre>
     *480p720x480
     * </pre>
     */
    emMtHD480p720x480(40, 40),
    /**
     * <code>emMtHD576i720x576 = 41;</code>
     *
     * <pre>
     *576i720x576
     * </pre>
     */
    emMtHD576i720x576(41, 41),
    /**
     * <code>emMtHD576p720x576 = 42;</code>
     *
     * <pre>
     *576p720x576              
     * </pre>
     */
    emMtHD576p720x576(42, 42),
    /**
     * <code>emMtVGA1280x768 = 43;</code>
     *
     * <pre>
     *WXGA1280x768
     * </pre>
     */
    emMtVGA1280x768(43, 43),
    /**
     * <code>emMtVGA1366x768 = 44;</code>
     *
     * <pre>
     *WXGA1366x768
     * </pre>
     */
    emMtVGA1366x768(44, 44),
    /**
     * <code>emMtVGA1280x854 = 45;</code>
     *
     * <pre>
     *WSXGA1280x854
     * </pre>
     */
    emMtVGA1280x854(45, 45),
    /**
     * <code>emMtVGA1680x1050 = 46;</code>
     *
     * <pre>
     *WSXGA+1680x1050
     * </pre>
     */
    emMtVGA1680x1050(46, 46),
    /**
     * <code>emMtVGA1920x1200 = 47;</code>
     *
     * <pre>
     *WUXGA1920x1200
     * </pre>
     */
    emMtVGA1920x1200(47, 47),
    /**
     * <code>emMtV3840x2160 = 48;</code>
     *
     * <pre>
     *4Kx2K3840x2160
     * </pre>
     */
    emMtV3840x2160(48, 48),
    /**
     * <code>emMt1280x600 = 49;</code>
     *
     * <pre>
     *1280*600
     * </pre>
     */
    emMt1280x600(49, 49),
    /**
     * <code>emMt1360x768 = 50;</code>
     *
     * <pre>
     *1360*768
     * </pre>
     */
    emMt1360x768(50, 50),
    /**
     * <code>emMtVRes3840x2160 = 51;</code>
     *
     * <pre>
     *3840x2160
     * </pre>
     */
    emMtVRes3840x2160(51, 51),
    /**
     * <code>emMtVRes4096x2048 = 52;</code>
     *
     * <pre>
     *4096*2048
     * </pre>
     */
    emMtVRes4096x2048(52, 52),
    /**
     * <code>emMtVRes4096x2160 = 53;</code>
     *
     * <pre>
     *4096*2160
     * </pre>
     */
    emMtVRes4096x2160(53, 53),
    /**
     * <code>emMtVRes4096x2304 = 54;</code>
     *
     * <pre>
     *4096*2304
     * </pre>
     */
    emMtVRes4096x2304(54, 54),
    /**
     * <code>emMt960x540 = 55;</code>
     */
    emMt960x540(55, 55),
    /**
     * <code>emMt480x270 = 56;</code>
     */
    emMt480x270(56, 56),
    /**
     * <code>emMtVResEnd = 100;</code>
     */
    emMtVResEnd(57, 100),
    ;

    /**
     * <code>emMtResAuto = 0;</code>
     *
     * <pre>
     *自适应
     * </pre>
     */
    public static final int emMtResAuto_VALUE = 0;
    /**
     * <code>emMtSQCIF = 1;</code>
     *
     * <pre>
     *SQCIF 128*96
     * </pre>
     */
    public static final int emMtSQCIF_VALUE = 1;
    /**
     * <code>emMtQCIF = 2;</code>
     *
     * <pre>
     *QCIF 176x144
     * </pre>
     */
    public static final int emMtQCIF_VALUE = 2;
    /**
     * <code>emMtCIF = 3;</code>
     *
     * <pre>
     *CIF 352x288
     * </pre>
     */
    public static final int emMtCIF_VALUE = 3;
    /**
     * <code>emMt2CIF = 4;</code>
     *
     * <pre>
     *2CIF 352x576
     * </pre>
     */
    public static final int emMt2CIF_VALUE = 4;
    /**
     * <code>emMt4CIF = 5;</code>
     *
     * <pre>
     *4CIF 704x576
     * </pre>
     */
    public static final int emMt4CIF_VALUE = 5;
    /**
     * <code>emMt16CIF = 6;</code>
     *
     * <pre>
     *16CIF 1408x1152
     * </pre>
     */
    public static final int emMt16CIF_VALUE = 6;
    /**
     * <code>emMtVGA352x240 = 7;</code>
     *
     * <pre>
     *352x240  对应平台SIF
     * </pre>
     */
    public static final int emMtVGA352x240_VALUE = 7;
    /**
     * <code>emMt2SIF = 8;</code>
     *
     * <pre>
     *对应平台2SIF，具体不知道多少*多少                  
     * </pre>
     */
    public static final int emMt2SIF_VALUE = 8;
    /**
     * <code>emMtVGA704x480 = 9;</code>
     *
     * <pre>
     *704x480  对应平台4SIF
     * </pre>
     */
    public static final int emMtVGA704x480_VALUE = 9;
    /**
     * <code>emMtVGA640x480 = 10;</code>
     *
     * <pre>
     *VGA 640x480                   
     * </pre>
     */
    public static final int emMtVGA640x480_VALUE = 10;
    /**
     * <code>emMtVGA800x600 = 11;</code>
     *
     * <pre>
     *SVGA 800x600                     
     * </pre>
     */
    public static final int emMtVGA800x600_VALUE = 11;
    /**
     * <code>emMtVGA1024x768 = 12;</code>
     *
     * <pre>
     *XGA 1024x768                     
     * </pre>
     */
    public static final int emMtVGA1024x768_VALUE = 12;
    /**
     * <code>emMtVWCIF = 13;</code>
     *
     * <pre>
     *WCIF 512*288
     * </pre>
     */
    public static final int emMtVWCIF_VALUE = 13;
    /**
     * <code>emMtVSQCIF112x96 = 14;</code>
     *
     * <pre>
     *仅用于终端分辨率改变	
     * </pre>
     */
    public static final int emMtVSQCIF112x96_VALUE = 14;
    /**
     * <code>emMtVSQCIF96x80 = 15;</code>
     *
     * <pre>
     *SQCIF(96*80) 
     * </pre>
     */
    public static final int emMtVSQCIF96x80_VALUE = 15;
    /**
     * <code>emMtVW4CIF = 16;</code>
     *
     * <pre>
     *&#47;///高清分辨率
     * </pre>
     */
    public static final int emMtVW4CIF_VALUE = 16;
    /**
     * <code>emMtHD720p1280x720 = 17;</code>
     *
     * <pre>
     *720p 1280x720
     * </pre>
     */
    public static final int emMtHD720p1280x720_VALUE = 17;
    /**
     * <code>emMtVGA1280x1024 = 18;</code>
     *
     * <pre>
     *SXGA 1280x1024
     * </pre>
     */
    public static final int emMtVGA1280x1024_VALUE = 18;
    /**
     * <code>emMtVGA1600x1200 = 19;</code>
     *
     * <pre>
     *UXGA 1600x1200
     * </pre>
     */
    public static final int emMtVGA1600x1200_VALUE = 19;
    /**
     * <code>emMtHD1080i1920x1080 = 20;</code>
     *
     * <pre>
     *1080i 1920x1080
     * </pre>
     */
    public static final int emMtHD1080i1920x1080_VALUE = 20;
    /**
     * <code>emMtHD1080p1920x1080 = 21;</code>
     *
     * <pre>
     *1080p 1920x1080          
     * </pre>
     */
    public static final int emMtHD1080p1920x1080_VALUE = 21;
    /**
     * <code>emMtVGA1280x800 = 22;</code>
     *
     * <pre>
     *WXGA 1280x800
     * </pre>
     */
    public static final int emMtVGA1280x800_VALUE = 22;
    /**
     * <code>emMtVGA1440x900 = 23;</code>
     *
     * <pre>
     *WSXGA 1440x900                     
     * </pre>
     */
    public static final int emMtVGA1440x900_VALUE = 23;
    /**
     * <code>emMtVGA1280x960 = 24;</code>
     *
     * <pre>
     *XVGA  1280x960                     
     * </pre>
     */
    public static final int emMtVGA1280x960_VALUE = 24;
    /**
     * <code>emMtV1440x816 = 25;</code>
     *
     * <pre>
     *非标分辨率（1080p底图）－用于终端分辨率改变                     
     * </pre>
     */
    public static final int emMtV1440x816_VALUE = 25;
    /**
     * <code>emMt1280x720 = 26;</code>
     *
     * <pre>
     *1280×720(2/3)
     * </pre>
     */
    public static final int emMt1280x720_VALUE = 26;
    /**
     * <code>emMtV960x544 = 27;</code>
     *
     * <pre>
     *960×544(1/2)
     * </pre>
     */
    public static final int emMtV960x544_VALUE = 27;
    /**
     * <code>emMtV640x368 = 28;</code>
     *
     * <pre>
     *640×368(1/3)
     * </pre>
     */
    public static final int emMtV640x368_VALUE = 28;
    /**
     * <code>emMtV480x272 = 29;</code>
     *
     * <pre>
     *480×272(1/4)
     * </pre>
     */
    public static final int emMtV480x272_VALUE = 29;
    /**
     * <code>emMt384x272 = 30;</code>
     *
     * <pre>
     *384×272(1/5)
     * </pre>
     */
    public static final int emMt384x272_VALUE = 30;
    /**
     * <code>emMt640x544 = 31;</code>
     *
     * <pre>
     *640x544                       
     * </pre>
     */
    public static final int emMt640x544_VALUE = 31;
    /**
     * <code>emMt320x272 = 32;</code>
     *
     * <pre>
     *320x272
     * </pre>
     */
    public static final int emMt320x272_VALUE = 32;
    /**
     * <code>emMt_720_960x544 = 33;</code>
     *
     * <pre>
     *非标分辨率（720p底图） －用于终端分辨率改变
     * </pre>
     */
    public static final int emMt_720_960x544_VALUE = 33;
    /**
     * <code>emMt_720_864x480 = 34;</code>
     *
     * <pre>
     *864×480(2/3)
     * </pre>
     */
    public static final int emMt_720_864x480_VALUE = 34;
    /**
     * <code>emMt_720_640x368 = 35;</code>
     *
     * <pre>
     *640×368(1/2)
     * </pre>
     */
    public static final int emMt_720_640x368_VALUE = 35;
    /**
     * <code>emMt_720_432x240 = 36;</code>
     *
     * <pre>
     *432×240(1/3)
     * </pre>
     */
    public static final int emMt_720_432x240_VALUE = 36;
    /**
     * <code>emMt_720_320x192 = 37;</code>
     *
     * <pre>
     *320×192(1/4)
     * </pre>
     */
    public static final int emMt_720_320x192_VALUE = 37;
    /**
     * <code>emMtVGA480x352 = 38;</code>
     *
     * <pre>
     *非标分辨率
     * </pre>
     */
    public static final int emMtVGA480x352_VALUE = 38;
    /**
     * <code>emMtHD480i720x480 = 39;</code>
     *
     * <pre>
     *480i720x480
     * </pre>
     */
    public static final int emMtHD480i720x480_VALUE = 39;
    /**
     * <code>emMtHD480p720x480 = 40;</code>
     *
     * <pre>
     *480p720x480
     * </pre>
     */
    public static final int emMtHD480p720x480_VALUE = 40;
    /**
     * <code>emMtHD576i720x576 = 41;</code>
     *
     * <pre>
     *576i720x576
     * </pre>
     */
    public static final int emMtHD576i720x576_VALUE = 41;
    /**
     * <code>emMtHD576p720x576 = 42;</code>
     *
     * <pre>
     *576p720x576              
     * </pre>
     */
    public static final int emMtHD576p720x576_VALUE = 42;
    /**
     * <code>emMtVGA1280x768 = 43;</code>
     *
     * <pre>
     *WXGA1280x768
     * </pre>
     */
    public static final int emMtVGA1280x768_VALUE = 43;
    /**
     * <code>emMtVGA1366x768 = 44;</code>
     *
     * <pre>
     *WXGA1366x768
     * </pre>
     */
    public static final int emMtVGA1366x768_VALUE = 44;
    /**
     * <code>emMtVGA1280x854 = 45;</code>
     *
     * <pre>
     *WSXGA1280x854
     * </pre>
     */
    public static final int emMtVGA1280x854_VALUE = 45;
    /**
     * <code>emMtVGA1680x1050 = 46;</code>
     *
     * <pre>
     *WSXGA+1680x1050
     * </pre>
     */
    public static final int emMtVGA1680x1050_VALUE = 46;
    /**
     * <code>emMtVGA1920x1200 = 47;</code>
     *
     * <pre>
     *WUXGA1920x1200
     * </pre>
     */
    public static final int emMtVGA1920x1200_VALUE = 47;
    /**
     * <code>emMtV3840x2160 = 48;</code>
     *
     * <pre>
     *4Kx2K3840x2160
     * </pre>
     */
    public static final int emMtV3840x2160_VALUE = 48;
    /**
     * <code>emMt1280x600 = 49;</code>
     *
     * <pre>
     *1280*600
     * </pre>
     */
    public static final int emMt1280x600_VALUE = 49;
    /**
     * <code>emMt1360x768 = 50;</code>
     *
     * <pre>
     *1360*768
     * </pre>
     */
    public static final int emMt1360x768_VALUE = 50;
    /**
     * <code>emMtVRes3840x2160 = 51;</code>
     *
     * <pre>
     *3840x2160
     * </pre>
     */
    public static final int emMtVRes3840x2160_VALUE = 51;
    /**
     * <code>emMtVRes4096x2048 = 52;</code>
     *
     * <pre>
     *4096*2048
     * </pre>
     */
    public static final int emMtVRes4096x2048_VALUE = 52;
    /**
     * <code>emMtVRes4096x2160 = 53;</code>
     *
     * <pre>
     *4096*2160
     * </pre>
     */
    public static final int emMtVRes4096x2160_VALUE = 53;
    /**
     * <code>emMtVRes4096x2304 = 54;</code>
     *
     * <pre>
     *4096*2304
     * </pre>
     */
    public static final int emMtVRes4096x2304_VALUE = 54;
    /**
     * <code>emMt960x540 = 55;</code>
     */
    public static final int emMt960x540_VALUE = 55;
    /**
     * <code>emMt480x270 = 56;</code>
     */
    public static final int emMt480x270_VALUE = 56;
    /**
     * <code>emMtVResEnd = 100;</code>
     */
    public static final int emMtVResEnd_VALUE = 100;


    public final int getNumber() { return value; }

    public static EmMtResolution valueOf(int value) {
      switch (value) {
        case 0: return emMtResAuto;
        case 1: return emMtSQCIF;
        case 2: return emMtQCIF;
        case 3: return emMtCIF;
        case 4: return emMt2CIF;
        case 5: return emMt4CIF;
        case 6: return emMt16CIF;
        case 7: return emMtVGA352x240;
        case 8: return emMt2SIF;
        case 9: return emMtVGA704x480;
        case 10: return emMtVGA640x480;
        case 11: return emMtVGA800x600;
        case 12: return emMtVGA1024x768;
        case 13: return emMtVWCIF;
        case 14: return emMtVSQCIF112x96;
        case 15: return emMtVSQCIF96x80;
        case 16: return emMtVW4CIF;
        case 17: return emMtHD720p1280x720;
        case 18: return emMtVGA1280x1024;
        case 19: return emMtVGA1600x1200;
        case 20: return emMtHD1080i1920x1080;
        case 21: return emMtHD1080p1920x1080;
        case 22: return emMtVGA1280x800;
        case 23: return emMtVGA1440x900;
        case 24: return emMtVGA1280x960;
        case 25: return emMtV1440x816;
        case 26: return emMt1280x720;
        case 27: return emMtV960x544;
        case 28: return emMtV640x368;
        case 29: return emMtV480x272;
        case 30: return emMt384x272;
        case 31: return emMt640x544;
        case 32: return emMt320x272;
        case 33: return emMt_720_960x544;
        case 34: return emMt_720_864x480;
        case 35: return emMt_720_640x368;
        case 36: return emMt_720_432x240;
        case 37: return emMt_720_320x192;
        case 38: return emMtVGA480x352;
        case 39: return emMtHD480i720x480;
        case 40: return emMtHD480p720x480;
        case 41: return emMtHD576i720x576;
        case 42: return emMtHD576p720x576;
        case 43: return emMtVGA1280x768;
        case 44: return emMtVGA1366x768;
        case 45: return emMtVGA1280x854;
        case 46: return emMtVGA1680x1050;
        case 47: return emMtVGA1920x1200;
        case 48: return emMtV3840x2160;
        case 49: return emMt1280x600;
        case 50: return emMt1360x768;
        case 51: return emMtVRes3840x2160;
        case 52: return emMtVRes4096x2048;
        case 53: return emMtVRes4096x2160;
        case 54: return emMtVRes4096x2304;
        case 55: return emMt960x540;
        case 56: return emMt480x270;
        case 100: return emMtVResEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtResolution>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtResolution>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtResolution>() {
            public EmMtResolution findValueByNumber(int number) {
              return EmMtResolution.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(13);
    }

    private static final EmMtResolution[] VALUES = values();

    public static EmMtResolution valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtResolution(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtResolution)
  }

  /**
   * Protobuf enum {@code mt.EmVidPort}
   *
   * <pre>
   *视频端口
   * </pre>
   */
  public enum EmVidPort
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emH600VidInHDMI = 0;</code>
     */
    emH600VidInHDMI(0, 0),
    /**
     * <code>emH600VidInVGA = 1;</code>
     */
    emH600VidInVGA(1, 1),
    /**
     * <code>emH600VidInC = 2;</code>
     */
    emH600VidInC(2, 2),
    /**
     * <code>emH600VidOutDVI = 3;</code>
     */
    emH600VidOutDVI(3, 3),
    /**
     * <code>emH600VidOutHDMI = 4;</code>
     */
    emH600VidOutHDMI(4, 4),
    /**
     * <code>emH700VidInDVI = 5;</code>
     */
    emH700VidInDVI(5, 5),
    ;

    /**
     * <code>emH600VidInHDMI = 0;</code>
     */
    public static final int emH600VidInHDMI_VALUE = 0;
    /**
     * <code>emH600VidInVGA = 1;</code>
     */
    public static final int emH600VidInVGA_VALUE = 1;
    /**
     * <code>emH600VidInC = 2;</code>
     */
    public static final int emH600VidInC_VALUE = 2;
    /**
     * <code>emH600VidOutDVI = 3;</code>
     */
    public static final int emH600VidOutDVI_VALUE = 3;
    /**
     * <code>emH600VidOutHDMI = 4;</code>
     */
    public static final int emH600VidOutHDMI_VALUE = 4;
    /**
     * <code>emH700VidInDVI = 5;</code>
     */
    public static final int emH700VidInDVI_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmVidPort valueOf(int value) {
      switch (value) {
        case 0: return emH600VidInHDMI;
        case 1: return emH600VidInVGA;
        case 2: return emH600VidInC;
        case 3: return emH600VidOutDVI;
        case 4: return emH600VidOutHDMI;
        case 5: return emH700VidInDVI;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVidPort>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVidPort>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVidPort>() {
            public EmVidPort findValueByNumber(int number) {
              return EmVidPort.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(14);
    }

    private static final EmVidPort[] VALUES = values();

    public static EmVidPort valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVidPort(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVidPort)
  }

  /**
   * Protobuf enum {@code mt.EmAudPort}
   *
   * <pre>
   *音频端口
   * </pre>
   */
  public enum EmAudPort
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emH600AudInRCA = 0;</code>
     */
    emH600AudInRCA(0, 0),
    /**
     * <code>emH600AudOutRCA = 1;</code>
     */
    emH600AudOutRCA(1, 1),
    ;

    /**
     * <code>emH600AudInRCA = 0;</code>
     */
    public static final int emH600AudInRCA_VALUE = 0;
    /**
     * <code>emH600AudOutRCA = 1;</code>
     */
    public static final int emH600AudOutRCA_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmAudPort valueOf(int value) {
      switch (value) {
        case 0: return emH600AudInRCA;
        case 1: return emH600AudOutRCA;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAudPort>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAudPort>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAudPort>() {
            public EmAudPort findValueByNumber(int number) {
              return EmAudPort.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(15);
    }

    private static final EmAudPort[] VALUES = values();

    public static EmAudPort valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAudPort(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAudPort)
  }

  /**
   * Protobuf enum {@code mt.EmLostPackStrategy}
   *
   * <pre>
   *解码器丢包恢复策略
   * </pre>
   */
  public enum EmLostPackStrategy
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emLPSQualityFirst = 0;</code>
     */
    emLPSQualityFirst(0, 0),
    /**
     * <code>emLPSSpeedSlow = 1;</code>
     */
    emLPSSpeedSlow(1, 1),
    /**
     * <code>emLPSSpeedNormal = 2;</code>
     */
    emLPSSpeedNormal(2, 2),
    /**
     * <code>emLPSSpeedFast = 3;</code>
     */
    emLPSSpeedFast(3, 3),
    ;

    /**
     * <code>emLPSQualityFirst = 0;</code>
     */
    public static final int emLPSQualityFirst_VALUE = 0;
    /**
     * <code>emLPSSpeedSlow = 1;</code>
     */
    public static final int emLPSSpeedSlow_VALUE = 1;
    /**
     * <code>emLPSSpeedNormal = 2;</code>
     */
    public static final int emLPSSpeedNormal_VALUE = 2;
    /**
     * <code>emLPSSpeedFast = 3;</code>
     */
    public static final int emLPSSpeedFast_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmLostPackStrategy valueOf(int value) {
      switch (value) {
        case 0: return emLPSQualityFirst;
        case 1: return emLPSSpeedSlow;
        case 2: return emLPSSpeedNormal;
        case 3: return emLPSSpeedFast;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmLostPackStrategy>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmLostPackStrategy>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmLostPackStrategy>() {
            public EmLostPackStrategy findValueByNumber(int number) {
              return EmLostPackStrategy.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(16);
    }

    private static final EmLostPackStrategy[] VALUES = values();

    public static EmLostPackStrategy valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmLostPackStrategy(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmLostPackStrategy)
  }

  /**
   * Protobuf enum {@code mt.EmIpAddrType}
   *
   * <pre>
   *IP地址类型
   * </pre>
   */
  public enum EmIpAddrType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emIpV4 = 0;</code>
     */
    emIpV4(0, 0),
    /**
     * <code>emIpV6 = 1;</code>
     */
    emIpV6(1, 1),
    ;

    /**
     * <code>emIpV4 = 0;</code>
     */
    public static final int emIpV4_VALUE = 0;
    /**
     * <code>emIpV6 = 1;</code>
     */
    public static final int emIpV6_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmIpAddrType valueOf(int value) {
      switch (value) {
        case 0: return emIpV4;
        case 1: return emIpV6;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmIpAddrType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmIpAddrType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmIpAddrType>() {
            public EmIpAddrType findValueByNumber(int number) {
              return EmIpAddrType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(17);
    }

    private static final EmIpAddrType[] VALUES = values();

    public static EmIpAddrType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmIpAddrType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmIpAddrType)
  }

  /**
   * Protobuf enum {@code mt.EmStopBits}
   *
   * <pre>
   *串口停止位
   * </pre>
   */
  public enum EmStopBits
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>em0StopBit = 0;</code>
     */
    em0StopBit(0, 0),
    /**
     * <code>em1StopBit = 1;</code>
     */
    em1StopBit(1, 1),
    /**
     * <code>em2StopBit = 2;</code>
     */
    em2StopBit(2, 2),
    /**
     * <code>em1HalfStopBit = 3;</code>
     */
    em1HalfStopBit(3, 3),
    ;

    /**
     * <code>em0StopBit = 0;</code>
     */
    public static final int em0StopBit_VALUE = 0;
    /**
     * <code>em1StopBit = 1;</code>
     */
    public static final int em1StopBit_VALUE = 1;
    /**
     * <code>em2StopBit = 2;</code>
     */
    public static final int em2StopBit_VALUE = 2;
    /**
     * <code>em1HalfStopBit = 3;</code>
     */
    public static final int em1HalfStopBit_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmStopBits valueOf(int value) {
      switch (value) {
        case 0: return em0StopBit;
        case 1: return em1StopBit;
        case 2: return em2StopBit;
        case 3: return em1HalfStopBit;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmStopBits>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmStopBits>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmStopBits>() {
            public EmStopBits findValueByNumber(int number) {
              return EmStopBits.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(18);
    }

    private static final EmStopBits[] VALUES = values();

    public static EmStopBits valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmStopBits(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmStopBits)
  }

  /**
   * Protobuf enum {@code mt.EmParityCheck}
   *
   * <pre>
   *串口校验位
   * </pre>
   */
  public enum EmParityCheck
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNoCheck = 0;</code>
     */
    emNoCheck(0, 0),
    /**
     * <code>emOddCheck = 1;</code>
     */
    emOddCheck(1, 1),
    /**
     * <code>emEvenCheck = 2;</code>
     */
    emEvenCheck(2, 2),
    ;

    /**
     * <code>emNoCheck = 0;</code>
     */
    public static final int emNoCheck_VALUE = 0;
    /**
     * <code>emOddCheck = 1;</code>
     */
    public static final int emOddCheck_VALUE = 1;
    /**
     * <code>emEvenCheck = 2;</code>
     */
    public static final int emEvenCheck_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmParityCheck valueOf(int value) {
      switch (value) {
        case 0: return emNoCheck;
        case 1: return emOddCheck;
        case 2: return emEvenCheck;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmParityCheck>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmParityCheck>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmParityCheck>() {
            public EmParityCheck findValueByNumber(int number) {
              return EmParityCheck.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(19);
    }

    private static final EmParityCheck[] VALUES = values();

    public static EmParityCheck valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmParityCheck(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmParityCheck)
  }

  /**
   * Protobuf enum {@code mt.EmSerialType}
   *
   * <pre>
   *串口类型
   * </pre>
   */
  public enum EmSerialType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRS232 = 0;</code>
     */
    emRS232(0, 0),
    /**
     * <code>emRS422 = 1;</code>
     */
    emRS422(1, 1),
    /**
     * <code>emRS485 = 2;</code>
     */
    emRS485(2, 2),
    /**
     * <code>emSerialInfrared = 3;</code>
     */
    emSerialInfrared(3, 3),
    /**
     * <code>emHDBaseT1 = 4;</code>
     */
    emHDBaseT1(4, 4),
    /**
     * <code>emHDBaseT2 = 5;</code>
     */
    emHDBaseT2(5, 5),
    /**
     * <code>emRS232_2 = 6;</code>
     */
    emRS232_2(6, 6),
    ;

    /**
     * <code>emRS232 = 0;</code>
     */
    public static final int emRS232_VALUE = 0;
    /**
     * <code>emRS422 = 1;</code>
     */
    public static final int emRS422_VALUE = 1;
    /**
     * <code>emRS485 = 2;</code>
     */
    public static final int emRS485_VALUE = 2;
    /**
     * <code>emSerialInfrared = 3;</code>
     */
    public static final int emSerialInfrared_VALUE = 3;
    /**
     * <code>emHDBaseT1 = 4;</code>
     */
    public static final int emHDBaseT1_VALUE = 4;
    /**
     * <code>emHDBaseT2 = 5;</code>
     */
    public static final int emHDBaseT2_VALUE = 5;
    /**
     * <code>emRS232_2 = 6;</code>
     */
    public static final int emRS232_2_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmSerialType valueOf(int value) {
      switch (value) {
        case 0: return emRS232;
        case 1: return emRS422;
        case 2: return emRS485;
        case 3: return emSerialInfrared;
        case 4: return emHDBaseT1;
        case 5: return emHDBaseT2;
        case 6: return emRS232_2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSerialType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSerialType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSerialType>() {
            public EmSerialType findValueByNumber(int number) {
              return EmSerialType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(20);
    }

    private static final EmSerialType[] VALUES = values();

    public static EmSerialType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSerialType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSerialType)
  }

  /**
   * Protobuf enum {@code mt.EmDisplayRatio}
   *
   * <pre>
   *显示比例
   * </pre>
   */
  public enum EmDisplayRatio
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emDR4to3 = 0;</code>
     */
    emDR4to3(0, 0),
    /**
     * <code>emDR16to9 = 1;</code>
     */
    emDR16to9(1, 1),
    /**
     * <code>emDRAuto = 2;</code>
     */
    emDRAuto(2, 2),
    ;

    /**
     * <code>emDR4to3 = 0;</code>
     */
    public static final int emDR4to3_VALUE = 0;
    /**
     * <code>emDR16to9 = 1;</code>
     */
    public static final int emDR16to9_VALUE = 1;
    /**
     * <code>emDRAuto = 2;</code>
     */
    public static final int emDRAuto_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmDisplayRatio valueOf(int value) {
      switch (value) {
        case 0: return emDR4to3;
        case 1: return emDR16to9;
        case 2: return emDRAuto;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDisplayRatio>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDisplayRatio>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDisplayRatio>() {
            public EmDisplayRatio findValueByNumber(int number) {
              return EmDisplayRatio.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(21);
    }

    private static final EmDisplayRatio[] VALUES = values();

    public static EmDisplayRatio valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDisplayRatio(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDisplayRatio)
  }

  /**
   * Protobuf enum {@code mt.EmAnswerMode}
   *
   * <pre>
   *应答方式
   * </pre>
   */
  public enum EmAnswerMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAnswerModeAuto = 0;</code>
     */
    emAnswerModeAuto(0, 0),
    /**
     * <code>emAnswerModeManu = 1;</code>
     */
    emAnswerModeManu(1, 1),
    /**
     * <code>emAnswerModeNegative = 2;</code>
     */
    emAnswerModeNegative(2, 2),
    ;

    /**
     * <code>emAnswerModeAuto = 0;</code>
     */
    public static final int emAnswerModeAuto_VALUE = 0;
    /**
     * <code>emAnswerModeManu = 1;</code>
     */
    public static final int emAnswerModeManu_VALUE = 1;
    /**
     * <code>emAnswerModeNegative = 2;</code>
     */
    public static final int emAnswerModeNegative_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmAnswerMode valueOf(int value) {
      switch (value) {
        case 0: return emAnswerModeAuto;
        case 1: return emAnswerModeManu;
        case 2: return emAnswerModeNegative;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAnswerMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAnswerMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAnswerMode>() {
            public EmAnswerMode findValueByNumber(int number) {
              return EmAnswerMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(22);
    }

    private static final EmAnswerMode[] VALUES = values();

    public static EmAnswerMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAnswerMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAnswerMode)
  }

  /**
   * Protobuf enum {@code mt.EmH264AdditionalModes}
   */
  public enum EmH264AdditionalModes
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emModeNone = 0;</code>
     */
    emModeNone(0, 0),
    /**
     * <code>emModeRCD0 = 64;</code>
     *
     * <pre>
     *RCD0
     * </pre>
     */
    emModeRCD0(1, 64),
    /**
     * <code>emModeSBP = 32;</code>
     *
     * <pre>
     *SCALABLE bp
     * </pre>
     */
    emModeSBP(2, 32),
    /**
     * <code>emModeSHP = 16;</code>
     *
     * <pre>
     *SCALABLE hp
     * </pre>
     */
    emModeSHP(3, 16),
    ;

    /**
     * <code>emModeNone = 0;</code>
     */
    public static final int emModeNone_VALUE = 0;
    /**
     * <code>emModeRCD0 = 64;</code>
     *
     * <pre>
     *RCD0
     * </pre>
     */
    public static final int emModeRCD0_VALUE = 64;
    /**
     * <code>emModeSBP = 32;</code>
     *
     * <pre>
     *SCALABLE bp
     * </pre>
     */
    public static final int emModeSBP_VALUE = 32;
    /**
     * <code>emModeSHP = 16;</code>
     *
     * <pre>
     *SCALABLE hp
     * </pre>
     */
    public static final int emModeSHP_VALUE = 16;


    public final int getNumber() { return value; }

    public static EmH264AdditionalModes valueOf(int value) {
      switch (value) {
        case 0: return emModeNone;
        case 64: return emModeRCD0;
        case 32: return emModeSBP;
        case 16: return emModeSHP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmH264AdditionalModes>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmH264AdditionalModes>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmH264AdditionalModes>() {
            public EmH264AdditionalModes findValueByNumber(int number) {
              return EmH264AdditionalModes.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(23);
    }

    private static final EmH264AdditionalModes[] VALUES = values();

    public static EmH264AdditionalModes valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmH264AdditionalModes(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmH264AdditionalModes)
  }

  /**
   * Protobuf enum {@code mt.EmH264Profile}
   *
   * <pre>
   *h.264profile
   * </pre>
   */
  public enum EmH264Profile
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emInvalid = 0;</code>
     */
    emInvalid(0, 0),
    /**
     * <code>emBaseline = 1;</code>
     */
    emBaseline(1, 1),
    /**
     * <code>emMain = 2;</code>
     */
    emMain(2, 2),
    /**
     * <code>emExtended = 4;</code>
     */
    emExtended(3, 4),
    /**
     * <code>emHigh = 8;</code>
     */
    emHigh(4, 8),
    /**
     * <code>emHigh10 = 16;</code>
     */
    emHigh10(5, 16),
    /**
     * <code>emHigh422 = 32;</code>
     */
    emHigh422(6, 32),
    /**
     * <code>emHigh444 = 64;</code>
     */
    emHigh444(7, 64),
    ;

    /**
     * <code>emInvalid = 0;</code>
     */
    public static final int emInvalid_VALUE = 0;
    /**
     * <code>emBaseline = 1;</code>
     */
    public static final int emBaseline_VALUE = 1;
    /**
     * <code>emMain = 2;</code>
     */
    public static final int emMain_VALUE = 2;
    /**
     * <code>emExtended = 4;</code>
     */
    public static final int emExtended_VALUE = 4;
    /**
     * <code>emHigh = 8;</code>
     */
    public static final int emHigh_VALUE = 8;
    /**
     * <code>emHigh10 = 16;</code>
     */
    public static final int emHigh10_VALUE = 16;
    /**
     * <code>emHigh422 = 32;</code>
     */
    public static final int emHigh422_VALUE = 32;
    /**
     * <code>emHigh444 = 64;</code>
     */
    public static final int emHigh444_VALUE = 64;


    public final int getNumber() { return value; }

    public static EmH264Profile valueOf(int value) {
      switch (value) {
        case 0: return emInvalid;
        case 1: return emBaseline;
        case 2: return emMain;
        case 4: return emExtended;
        case 8: return emHigh;
        case 16: return emHigh10;
        case 32: return emHigh422;
        case 64: return emHigh444;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmH264Profile>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmH264Profile>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmH264Profile>() {
            public EmH264Profile findValueByNumber(int number) {
              return EmH264Profile.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(24);
    }

    private static final EmH264Profile[] VALUES = values();

    public static EmH264Profile valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmH264Profile(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmH264Profile)
  }

  /**
   * Protobuf enum {@code mt.EmH265Profile}
   */
  public enum EmH265Profile
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emProfileMain = 0;</code>
     */
    emProfileMain(0, 0),
    /**
     * <code>emProfileMain10 = 1;</code>
     */
    emProfileMain10(1, 1),
    /**
     * <code>emProfileMainStill = 2;</code>
     */
    emProfileMainStill(2, 2),
    ;

    /**
     * <code>emProfileMain = 0;</code>
     */
    public static final int emProfileMain_VALUE = 0;
    /**
     * <code>emProfileMain10 = 1;</code>
     */
    public static final int emProfileMain10_VALUE = 1;
    /**
     * <code>emProfileMainStill = 2;</code>
     */
    public static final int emProfileMainStill_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmH265Profile valueOf(int value) {
      switch (value) {
        case 0: return emProfileMain;
        case 1: return emProfileMain10;
        case 2: return emProfileMainStill;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmH265Profile>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmH265Profile>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmH265Profile>() {
            public EmH265Profile findValueByNumber(int number) {
              return EmH265Profile.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(25);
    }

    private static final EmH265Profile[] VALUES = values();

    public static EmH265Profile valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmH265Profile(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmH265Profile)
  }

  /**
   * Protobuf enum {@code mt.EmDirection}
   *
   * <pre>
   *方向
   * </pre>
   */
  public enum EmDirection
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUP = 0;</code>
     */
    emUP(0, 0),
    /**
     * <code>emDown = 1;</code>
     */
    emDown(1, 1),
    /**
     * <code>emLeft = 2;</code>
     */
    emLeft(2, 2),
    /**
     * <code>emRight = 3;</code>
     */
    emRight(3, 3),
    /**
     * <code>emDirInvalid = 10;</code>
     */
    emDirInvalid(4, 10),
    ;

    /**
     * <code>emUP = 0;</code>
     */
    public static final int emUP_VALUE = 0;
    /**
     * <code>emDown = 1;</code>
     */
    public static final int emDown_VALUE = 1;
    /**
     * <code>emLeft = 2;</code>
     */
    public static final int emLeft_VALUE = 2;
    /**
     * <code>emRight = 3;</code>
     */
    public static final int emRight_VALUE = 3;
    /**
     * <code>emDirInvalid = 10;</code>
     */
    public static final int emDirInvalid_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmDirection valueOf(int value) {
      switch (value) {
        case 0: return emUP;
        case 1: return emDown;
        case 2: return emLeft;
        case 3: return emRight;
        case 10: return emDirInvalid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDirection>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDirection>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDirection>() {
            public EmDirection findValueByNumber(int number) {
              return EmDirection.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(26);
    }

    private static final EmDirection[] VALUES = values();

    public static EmDirection valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDirection(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDirection)
  }

  /**
   * Protobuf enum {@code mt.EmFeccPTFZRequest}
   *
   * <pre>
   *严格对应协议栈的 feccPTFZRequest,   EmFeccPTFZRequest， EmFeccAction， EmFeccCMEMsgType 对应协议栈的远摇枚举定义
   * </pre>
   */
  public enum EmFeccPTFZRequest
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFeccRequestInvalid = 0;</code>
     */
    emFeccRequestInvalid(0, 0),
    /**
     * <code>emFeccPanLeft = 128;</code>
     *
     * <pre>
     *向左移动
     * </pre>
     */
    emFeccPanLeft(1, 128),
    /**
     * <code>emFeccPanRight = 192;</code>
     *
     * <pre>
     *向右移动
     * </pre>
     */
    emFeccPanRight(2, 192),
    /**
     * <code>emFeccTiltUp = 48;</code>
     *
     * <pre>
     *向上移动
     * </pre>
     */
    emFeccTiltUp(3, 48),
    /**
     * <code>emFeccTiltDown = 32;</code>
     *
     * <pre>
     *向下移动
     * </pre>
     */
    emFeccTiltDown(4, 32),
    /**
     * <code>emFeccFocusIn = 3;</code>
     *
     * <pre>
     *近焦
     * </pre>
     */
    emFeccFocusIn(5, 3),
    /**
     * <code>emFeccFocusOut = 2;</code>
     *
     * <pre>
     *远焦
     * </pre>
     */
    emFeccFocusOut(6, 2),
    /**
     * <code>emFeccZoomIn = 12;</code>
     *
     * <pre>
     *视野变小
     * </pre>
     */
    emFeccZoomIn(7, 12),
    /**
     * <code>emFeccZoomOut = 8;</code>
     *
     * <pre>
     *视野变大
     * </pre>
     */
    emFeccZoomOut(8, 8),
    /**
     * <code>emFeccBrightnessUp = 1;</code>
     *
     * <pre>
     *亮度加(nonstandard)
     * </pre>
     */
    emFeccBrightnessUp(9, 1),
    /**
     * <code>emFeccBrightnessDown = 4;</code>
     *
     * <pre>
     *亮度减(nonstandard)
     * </pre>
     */
    emFeccBrightnessDown(10, 4),
    ;

    /**
     * <code>emFeccRequestInvalid = 0;</code>
     */
    public static final int emFeccRequestInvalid_VALUE = 0;
    /**
     * <code>emFeccPanLeft = 128;</code>
     *
     * <pre>
     *向左移动
     * </pre>
     */
    public static final int emFeccPanLeft_VALUE = 128;
    /**
     * <code>emFeccPanRight = 192;</code>
     *
     * <pre>
     *向右移动
     * </pre>
     */
    public static final int emFeccPanRight_VALUE = 192;
    /**
     * <code>emFeccTiltUp = 48;</code>
     *
     * <pre>
     *向上移动
     * </pre>
     */
    public static final int emFeccTiltUp_VALUE = 48;
    /**
     * <code>emFeccTiltDown = 32;</code>
     *
     * <pre>
     *向下移动
     * </pre>
     */
    public static final int emFeccTiltDown_VALUE = 32;
    /**
     * <code>emFeccFocusIn = 3;</code>
     *
     * <pre>
     *近焦
     * </pre>
     */
    public static final int emFeccFocusIn_VALUE = 3;
    /**
     * <code>emFeccFocusOut = 2;</code>
     *
     * <pre>
     *远焦
     * </pre>
     */
    public static final int emFeccFocusOut_VALUE = 2;
    /**
     * <code>emFeccZoomIn = 12;</code>
     *
     * <pre>
     *视野变小
     * </pre>
     */
    public static final int emFeccZoomIn_VALUE = 12;
    /**
     * <code>emFeccZoomOut = 8;</code>
     *
     * <pre>
     *视野变大
     * </pre>
     */
    public static final int emFeccZoomOut_VALUE = 8;
    /**
     * <code>emFeccBrightnessUp = 1;</code>
     *
     * <pre>
     *亮度加(nonstandard)
     * </pre>
     */
    public static final int emFeccBrightnessUp_VALUE = 1;
    /**
     * <code>emFeccBrightnessDown = 4;</code>
     *
     * <pre>
     *亮度减(nonstandard)
     * </pre>
     */
    public static final int emFeccBrightnessDown_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmFeccPTFZRequest valueOf(int value) {
      switch (value) {
        case 0: return emFeccRequestInvalid;
        case 128: return emFeccPanLeft;
        case 192: return emFeccPanRight;
        case 48: return emFeccTiltUp;
        case 32: return emFeccTiltDown;
        case 3: return emFeccFocusIn;
        case 2: return emFeccFocusOut;
        case 12: return emFeccZoomIn;
        case 8: return emFeccZoomOut;
        case 1: return emFeccBrightnessUp;
        case 4: return emFeccBrightnessDown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFeccPTFZRequest>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFeccPTFZRequest>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFeccPTFZRequest>() {
            public EmFeccPTFZRequest findValueByNumber(int number) {
              return EmFeccPTFZRequest.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(27);
    }

    private static final EmFeccPTFZRequest[] VALUES = values();

    public static EmFeccPTFZRequest valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFeccPTFZRequest(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFeccPTFZRequest)
  }

  /**
   * Protobuf enum {@code mt.EmFeccAction}
   *
   * <pre>
   *&#47;严格对应协议栈的feccAction
   * </pre>
   */
  public enum EmFeccAction
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFeccActionInvalid = 0;</code>
     */
    emFeccActionInvalid(0, 0),
    /**
     * <code>emFeccActionStart = 1;</code>
     *
     * <pre>
     *开始
     * </pre>
     */
    emFeccActionStart(1, 1),
    /**
     * <code>emFeccActionContinue = 2;</code>
     *
     * <pre>
     *继续
     * </pre>
     */
    emFeccActionContinue(2, 2),
    /**
     * <code>emFeccActionStop = 3;</code>
     *
     * <pre>
     *停止
     * </pre>
     */
    emFeccActionStop(3, 3),
    /**
     * <code>emFeccActionSelectVideoSource = 4;</code>
     *
     * <pre>
     *选择视频源
     * </pre>
     */
    emFeccActionSelectVideoSource(4, 4),
    /**
     * <code>emFeccActionVideoSourceSwitched = 5;</code>
     *
     * <pre>
     *切换视频源
     * </pre>
     */
    emFeccActionVideoSourceSwitched(5, 5),
    /**
     * <code>emFeccActionStoreAsPreset = 6;</code>
     *
     * <pre>
     *存储预置位
     * </pre>
     */
    emFeccActionStoreAsPreset(6, 6),
    /**
     * <code>emFeccActionActivatePreset = 7;</code>
     *
     * <pre>
     *恢复到预置位
     * </pre>
     */
    emFeccActionActivatePreset(7, 7),
    /**
     * <code>emFeccActionAutoFocus = 17;</code>
     *
     * <pre>
     *自动调焦
     * </pre>
     */
    emFeccActionAutoFocus(8, 17),
    ;

    /**
     * <code>emFeccActionInvalid = 0;</code>
     */
    public static final int emFeccActionInvalid_VALUE = 0;
    /**
     * <code>emFeccActionStart = 1;</code>
     *
     * <pre>
     *开始
     * </pre>
     */
    public static final int emFeccActionStart_VALUE = 1;
    /**
     * <code>emFeccActionContinue = 2;</code>
     *
     * <pre>
     *继续
     * </pre>
     */
    public static final int emFeccActionContinue_VALUE = 2;
    /**
     * <code>emFeccActionStop = 3;</code>
     *
     * <pre>
     *停止
     * </pre>
     */
    public static final int emFeccActionStop_VALUE = 3;
    /**
     * <code>emFeccActionSelectVideoSource = 4;</code>
     *
     * <pre>
     *选择视频源
     * </pre>
     */
    public static final int emFeccActionSelectVideoSource_VALUE = 4;
    /**
     * <code>emFeccActionVideoSourceSwitched = 5;</code>
     *
     * <pre>
     *切换视频源
     * </pre>
     */
    public static final int emFeccActionVideoSourceSwitched_VALUE = 5;
    /**
     * <code>emFeccActionStoreAsPreset = 6;</code>
     *
     * <pre>
     *存储预置位
     * </pre>
     */
    public static final int emFeccActionStoreAsPreset_VALUE = 6;
    /**
     * <code>emFeccActionActivatePreset = 7;</code>
     *
     * <pre>
     *恢复到预置位
     * </pre>
     */
    public static final int emFeccActionActivatePreset_VALUE = 7;
    /**
     * <code>emFeccActionAutoFocus = 17;</code>
     *
     * <pre>
     *自动调焦
     * </pre>
     */
    public static final int emFeccActionAutoFocus_VALUE = 17;


    public final int getNumber() { return value; }

    public static EmFeccAction valueOf(int value) {
      switch (value) {
        case 0: return emFeccActionInvalid;
        case 1: return emFeccActionStart;
        case 2: return emFeccActionContinue;
        case 3: return emFeccActionStop;
        case 4: return emFeccActionSelectVideoSource;
        case 5: return emFeccActionVideoSourceSwitched;
        case 6: return emFeccActionStoreAsPreset;
        case 7: return emFeccActionActivatePreset;
        case 17: return emFeccActionAutoFocus;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFeccAction>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFeccAction>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFeccAction>() {
            public EmFeccAction findValueByNumber(int number) {
              return EmFeccAction.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(28);
    }

    private static final EmFeccAction[] VALUES = values();

    public static EmFeccAction valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFeccAction(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFeccAction)
  }

  /**
   * Protobuf enum {@code mt.EmFeccCMEMsgType}
   *
   * <pre>
   *&#47;/CME message type
   * </pre>
   */
  public enum EmFeccCMEMsgType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFeccCMEInvalid = 0;</code>
     *
     * <pre>
     *无效
     * </pre>
     */
    emFeccCMEInvalid(0, 0),
    /**
     * <code>emFeccCMEClientListInfo = 1;</code>
     *
     * <pre>
     *客户列表消息通知
     * </pre>
     */
    emFeccCMEClientListInfo(1, 1),
    /**
     * <code>emFeccCMEClientListCommond = 2;</code>
     *
     * <pre>
     *请求客户列表
     * </pre>
     */
    emFeccCMEClientListCommond(2, 2),
    /**
     * <code>emFeccCMEExtraCapInfo = 3;</code>
     *
     * <pre>
     *额外能力信息通知
     * </pre>
     */
    emFeccCMEExtraCapInfo(3, 3),
    /**
     * <code>emFeccCMEExtraCapCommond = 4;</code>
     *
     * <pre>
     *请求额外能力
     * </pre>
     */
    emFeccCMEExtraCapCommond(4, 4),
    ;

    /**
     * <code>emFeccCMEInvalid = 0;</code>
     *
     * <pre>
     *无效
     * </pre>
     */
    public static final int emFeccCMEInvalid_VALUE = 0;
    /**
     * <code>emFeccCMEClientListInfo = 1;</code>
     *
     * <pre>
     *客户列表消息通知
     * </pre>
     */
    public static final int emFeccCMEClientListInfo_VALUE = 1;
    /**
     * <code>emFeccCMEClientListCommond = 2;</code>
     *
     * <pre>
     *请求客户列表
     * </pre>
     */
    public static final int emFeccCMEClientListCommond_VALUE = 2;
    /**
     * <code>emFeccCMEExtraCapInfo = 3;</code>
     *
     * <pre>
     *额外能力信息通知
     * </pre>
     */
    public static final int emFeccCMEExtraCapInfo_VALUE = 3;
    /**
     * <code>emFeccCMEExtraCapCommond = 4;</code>
     *
     * <pre>
     *请求额外能力
     * </pre>
     */
    public static final int emFeccCMEExtraCapCommond_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmFeccCMEMsgType valueOf(int value) {
      switch (value) {
        case 0: return emFeccCMEInvalid;
        case 1: return emFeccCMEClientListInfo;
        case 2: return emFeccCMEClientListCommond;
        case 3: return emFeccCMEExtraCapInfo;
        case 4: return emFeccCMEExtraCapCommond;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFeccCMEMsgType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFeccCMEMsgType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFeccCMEMsgType>() {
            public EmFeccCMEMsgType findValueByNumber(int number) {
              return EmFeccCMEMsgType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(29);
    }

    private static final EmFeccCMEMsgType[] VALUES = values();

    public static EmFeccCMEMsgType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFeccCMEMsgType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFeccCMEMsgType)
  }

  /**
   * Protobuf enum {@code mt.EmMtSysStartMod}
   *
   * <pre>
   *子系统启动方式
   * </pre>
   */
  public enum EmMtSysStartMod
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSysStartMod_By_lib = 0;</code>
     *
     * <pre>
     * 静态库加载
     * </pre>
     */
    emSysStartMod_By_lib(0, 0),
    /**
     * <code>emSysStartMod_By_Dll = 1;</code>
     *
     * <pre>
     * 动态库加载
     * </pre>
     */
    emSysStartMod_By_Dll(1, 1),
    /**
     * <code>emSysStartMod_By_Process = 2;</code>
     *
     * <pre>
     * 进程加载
     * </pre>
     */
    emSysStartMod_By_Process(2, 2),
    /**
     * <code>emSysStartMod_End = 3;</code>
     */
    emSysStartMod_End(3, 3),
    ;

    /**
     * <code>emSysStartMod_By_lib = 0;</code>
     *
     * <pre>
     * 静态库加载
     * </pre>
     */
    public static final int emSysStartMod_By_lib_VALUE = 0;
    /**
     * <code>emSysStartMod_By_Dll = 1;</code>
     *
     * <pre>
     * 动态库加载
     * </pre>
     */
    public static final int emSysStartMod_By_Dll_VALUE = 1;
    /**
     * <code>emSysStartMod_By_Process = 2;</code>
     *
     * <pre>
     * 进程加载
     * </pre>
     */
    public static final int emSysStartMod_By_Process_VALUE = 2;
    /**
     * <code>emSysStartMod_End = 3;</code>
     */
    public static final int emSysStartMod_End_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMtSysStartMod valueOf(int value) {
      switch (value) {
        case 0: return emSysStartMod_By_lib;
        case 1: return emSysStartMod_By_Dll;
        case 2: return emSysStartMod_By_Process;
        case 3: return emSysStartMod_End;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtSysStartMod>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtSysStartMod>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtSysStartMod>() {
            public EmMtSysStartMod findValueByNumber(int number) {
              return EmMtSysStartMod.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(30);
    }

    private static final EmMtSysStartMod[] VALUES = values();

    public static EmMtSysStartMod valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtSysStartMod(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtSysStartMod)
  }

  /**
   * Protobuf enum {@code mt.EmMtSysStartModFromUI}
   *
   * <pre>
   *子系统启动方式
   * </pre>
   */
  public enum EmMtSysStartModFromUI
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSysStart_By_Dll = 0;</code>
     *
     * <pre>
     * 动态库加载
     * </pre>
     */
    emSysStart_By_Dll(0, 0),
    /**
     * <code>emSysStart_By_Process = 1;</code>
     *
     * <pre>
     * 进程加载
     * </pre>
     */
    emSysStart_By_Process(1, 1),
    /**
     * <code>emSysStart_End = 2;</code>
     */
    emSysStart_End(2, 2),
    ;

    /**
     * <code>emSysStart_By_Dll = 0;</code>
     *
     * <pre>
     * 动态库加载
     * </pre>
     */
    public static final int emSysStart_By_Dll_VALUE = 0;
    /**
     * <code>emSysStart_By_Process = 1;</code>
     *
     * <pre>
     * 进程加载
     * </pre>
     */
    public static final int emSysStart_By_Process_VALUE = 1;
    /**
     * <code>emSysStart_End = 2;</code>
     */
    public static final int emSysStart_End_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtSysStartModFromUI valueOf(int value) {
      switch (value) {
        case 0: return emSysStart_By_Dll;
        case 1: return emSysStart_By_Process;
        case 2: return emSysStart_End;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtSysStartModFromUI>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtSysStartModFromUI>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtSysStartModFromUI>() {
            public EmMtSysStartModFromUI findValueByNumber(int number) {
              return EmMtSysStartModFromUI.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(31);
    }

    private static final EmMtSysStartModFromUI[] VALUES = values();

    public static EmMtSysStartModFromUI valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtSysStartModFromUI(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtSysStartModFromUI)
  }

  /**
   * Protobuf enum {@code mt.EmMtSysSrvState}
   *
   * <pre>
   * 子系统运行状态
   * </pre>
   */
  public enum EmMtSysSrvState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSysSrvState_Idle = 0;</code>
     *
     * <pre>
     * 空闲
     * </pre>
     */
    emSysSrvState_Idle(0, 0),
    /**
     * <code>emSysSrvState_Binded = 1;</code>
     *
     * <pre>
     * 是否绑定
     * </pre>
     */
    emSysSrvState_Binded(1, 1),
    /**
     * <code>emSysSrvState_Running = 2;</code>
     *
     * <pre>
     * 运行
     * </pre>
     */
    emSysSrvState_Running(2, 2),
    /**
     * <code>emSysSrvState_Stop = 3;</code>
     *
     * <pre>
     * 停止
     * </pre>
     */
    emSysSrvState_Stop(3, 3),
    /**
     * <code>emSysSrvState_Err = 4;</code>
     *
     * <pre>
     * 异常
     * </pre>
     */
    emSysSrvState_Err(4, 4),
    ;

    /**
     * <code>emSysSrvState_Idle = 0;</code>
     *
     * <pre>
     * 空闲
     * </pre>
     */
    public static final int emSysSrvState_Idle_VALUE = 0;
    /**
     * <code>emSysSrvState_Binded = 1;</code>
     *
     * <pre>
     * 是否绑定
     * </pre>
     */
    public static final int emSysSrvState_Binded_VALUE = 1;
    /**
     * <code>emSysSrvState_Running = 2;</code>
     *
     * <pre>
     * 运行
     * </pre>
     */
    public static final int emSysSrvState_Running_VALUE = 2;
    /**
     * <code>emSysSrvState_Stop = 3;</code>
     *
     * <pre>
     * 停止
     * </pre>
     */
    public static final int emSysSrvState_Stop_VALUE = 3;
    /**
     * <code>emSysSrvState_Err = 4;</code>
     *
     * <pre>
     * 异常
     * </pre>
     */
    public static final int emSysSrvState_Err_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmMtSysSrvState valueOf(int value) {
      switch (value) {
        case 0: return emSysSrvState_Idle;
        case 1: return emSysSrvState_Binded;
        case 2: return emSysSrvState_Running;
        case 3: return emSysSrvState_Stop;
        case 4: return emSysSrvState_Err;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtSysSrvState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtSysSrvState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtSysSrvState>() {
            public EmMtSysSrvState findValueByNumber(int number) {
              return EmMtSysSrvState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(32);
    }

    private static final EmMtSysSrvState[] VALUES = values();

    public static EmMtSysSrvState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtSysSrvState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtSysSrvState)
  }

  /**
   * Protobuf enum {@code mt.EmMtSysKeepLiveState}
   *
   * <pre>
   * 子系统存活状态
   * </pre>
   */
  public enum EmMtSysKeepLiveState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSysKLState_Ready = 0;</code>
     *
     * <pre>
     * 准备就绪
     * </pre>
     */
    emSysKLState_Ready(0, 0),
    /**
     * <code>emSysKLState_Alive = 1;</code>
     *
     * <pre>
     * 存活
     * </pre>
     */
    emSysKLState_Alive(1, 1),
    /**
     * <code>emSysKLState_Err = 2;</code>
     *
     * <pre>
     * 异常
     * </pre>
     */
    emSysKLState_Err(2, 2),
    ;

    /**
     * <code>emSysKLState_Ready = 0;</code>
     *
     * <pre>
     * 准备就绪
     * </pre>
     */
    public static final int emSysKLState_Ready_VALUE = 0;
    /**
     * <code>emSysKLState_Alive = 1;</code>
     *
     * <pre>
     * 存活
     * </pre>
     */
    public static final int emSysKLState_Alive_VALUE = 1;
    /**
     * <code>emSysKLState_Err = 2;</code>
     *
     * <pre>
     * 异常
     * </pre>
     */
    public static final int emSysKLState_Err_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtSysKeepLiveState valueOf(int value) {
      switch (value) {
        case 0: return emSysKLState_Ready;
        case 1: return emSysKLState_Alive;
        case 2: return emSysKLState_Err;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtSysKeepLiveState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtSysKeepLiveState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtSysKeepLiveState>() {
            public EmMtSysKeepLiveState findValueByNumber(int number) {
              return EmMtSysKeepLiveState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(33);
    }

    private static final EmMtSysKeepLiveState[] VALUES = values();

    public static EmMtSysKeepLiveState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtSysKeepLiveState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtSysKeepLiveState)
  }

  /**
   * Protobuf enum {@code mt.EmMtChanType}
   *
   * <pre>
   *会议模块涉及枚举
   *通道类型
   * </pre>
   */
  public enum EmMtChanType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emChanSendAudio = 0;</code>
     */
    emChanSendAudio(0, 0),
    /**
     * <code>emChanRecvAudio = 1;</code>
     */
    emChanRecvAudio(1, 1),
    /**
     * <code>emChanSendVideo = 2;</code>
     */
    emChanSendVideo(2, 2),
    /**
     * <code>emChanRecvVideo = 3;</code>
     */
    emChanRecvVideo(3, 3),
    /**
     * <code>emChanSendAssAudio = 4;</code>
     *
     * <pre>
     *音频辅流
     * </pre>
     */
    emChanSendAssAudio(4, 4),
    /**
     * <code>emChanRecvAssAudio = 5;</code>
     *
     * <pre>
     *音频辅流
     * </pre>
     */
    emChanRecvAssAudio(5, 5),
    /**
     * <code>emChanSendAssVideo = 6;</code>
     *
     * <pre>
     *视频辅流
     * </pre>
     */
    emChanSendAssVideo(6, 6),
    /**
     * <code>emChanRecvAssVideo = 7;</code>
     *
     * <pre>
     *视频辅流
     * </pre>
     */
    emChanRecvAssVideo(7, 7),
    /**
     * <code>emChanSendFecc = 8;</code>
     */
    emChanSendFecc(8, 8),
    /**
     * <code>emChanRecvFecc = 9;</code>
     */
    emChanRecvFecc(9, 9),
    /**
     * <code>emChanSendT120 = 10;</code>
     */
    emChanSendT120(10, 10),
    /**
     * <code>emChanRecvT120 = 11;</code>
     */
    emChanRecvT120(11, 11),
    /**
     * <code>emChanTypeEnd = 12;</code>
     */
    emChanTypeEnd(12, 12),
    ;

    /**
     * <code>emChanSendAudio = 0;</code>
     */
    public static final int emChanSendAudio_VALUE = 0;
    /**
     * <code>emChanRecvAudio = 1;</code>
     */
    public static final int emChanRecvAudio_VALUE = 1;
    /**
     * <code>emChanSendVideo = 2;</code>
     */
    public static final int emChanSendVideo_VALUE = 2;
    /**
     * <code>emChanRecvVideo = 3;</code>
     */
    public static final int emChanRecvVideo_VALUE = 3;
    /**
     * <code>emChanSendAssAudio = 4;</code>
     *
     * <pre>
     *音频辅流
     * </pre>
     */
    public static final int emChanSendAssAudio_VALUE = 4;
    /**
     * <code>emChanRecvAssAudio = 5;</code>
     *
     * <pre>
     *音频辅流
     * </pre>
     */
    public static final int emChanRecvAssAudio_VALUE = 5;
    /**
     * <code>emChanSendAssVideo = 6;</code>
     *
     * <pre>
     *视频辅流
     * </pre>
     */
    public static final int emChanSendAssVideo_VALUE = 6;
    /**
     * <code>emChanRecvAssVideo = 7;</code>
     *
     * <pre>
     *视频辅流
     * </pre>
     */
    public static final int emChanRecvAssVideo_VALUE = 7;
    /**
     * <code>emChanSendFecc = 8;</code>
     */
    public static final int emChanSendFecc_VALUE = 8;
    /**
     * <code>emChanRecvFecc = 9;</code>
     */
    public static final int emChanRecvFecc_VALUE = 9;
    /**
     * <code>emChanSendT120 = 10;</code>
     */
    public static final int emChanSendT120_VALUE = 10;
    /**
     * <code>emChanRecvT120 = 11;</code>
     */
    public static final int emChanRecvT120_VALUE = 11;
    /**
     * <code>emChanTypeEnd = 12;</code>
     */
    public static final int emChanTypeEnd_VALUE = 12;


    public final int getNumber() { return value; }

    public static EmMtChanType valueOf(int value) {
      switch (value) {
        case 0: return emChanSendAudio;
        case 1: return emChanRecvAudio;
        case 2: return emChanSendVideo;
        case 3: return emChanRecvVideo;
        case 4: return emChanSendAssAudio;
        case 5: return emChanRecvAssAudio;
        case 6: return emChanSendAssVideo;
        case 7: return emChanRecvAssVideo;
        case 8: return emChanSendFecc;
        case 9: return emChanRecvFecc;
        case 10: return emChanSendT120;
        case 11: return emChanRecvT120;
        case 12: return emChanTypeEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtChanType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtChanType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtChanType>() {
            public EmMtChanType findValueByNumber(int number) {
              return EmMtChanType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(34);
    }

    private static final EmMtChanType[] VALUES = values();

    public static EmMtChanType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtChanType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtChanType)
  }

  /**
   * Protobuf enum {@code mt.EmMtAssStreamType}
   *
   * <pre>
   *双流类型
   * </pre>
   */
  public enum EmMtAssStreamType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAssStreamBegin = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    emAssStreamBegin(0, 0),
    /**
     * <code>emPcAssStream = 1;</code>
     *
     * <pre>
     *pc辅流
     * </pre>
     */
    emPcAssStream(1, 1),
    /**
     * <code>emVideoAssStream = 2;</code>
     *
     * <pre>
     *video辅流
     * </pre>
     */
    emVideoAssStream(2, 2),
    ;

    /**
     * <code>emAssStreamBegin = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    public static final int emAssStreamBegin_VALUE = 0;
    /**
     * <code>emPcAssStream = 1;</code>
     *
     * <pre>
     *pc辅流
     * </pre>
     */
    public static final int emPcAssStream_VALUE = 1;
    /**
     * <code>emVideoAssStream = 2;</code>
     *
     * <pre>
     *video辅流
     * </pre>
     */
    public static final int emVideoAssStream_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtAssStreamType valueOf(int value) {
      switch (value) {
        case 0: return emAssStreamBegin;
        case 1: return emPcAssStream;
        case 2: return emVideoAssStream;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtAssStreamType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtAssStreamType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtAssStreamType>() {
            public EmMtAssStreamType findValueByNumber(int number) {
              return EmMtAssStreamType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(35);
    }

    private static final EmMtAssStreamType[] VALUES = values();

    public static EmMtAssStreamType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtAssStreamType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtAssStreamType)
  }

  /**
   * Protobuf enum {@code mt.EmMtVidLabel}
   *
   * <pre>
   *vid能力标签
   * </pre>
   */
  public enum EmMtVidLabel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVidLabBegin = 0;</code>
     */
    emVidLabBegin(0, 0),
    /**
     * <code>emPcStreamVidLab = 20;</code>
     *
     * <pre>
     *辅流的标签
     * </pre>
     */
    emPcStreamVidLab(1, 20),
    /**
     * <code>emVideoStreamVidLab = 21;</code>
     *
     * <pre>
     *video双流能力
     * </pre>
     */
    emVideoStreamVidLab(2, 21),
    /**
     * <code>emQkStreamVidLab = 22;</code>
     *
     * <pre>
     *投屏器双流能力
     * </pre>
     */
    emQkStreamVidLab(3, 22),
    ;

    /**
     * <code>emVidLabBegin = 0;</code>
     */
    public static final int emVidLabBegin_VALUE = 0;
    /**
     * <code>emPcStreamVidLab = 20;</code>
     *
     * <pre>
     *辅流的标签
     * </pre>
     */
    public static final int emPcStreamVidLab_VALUE = 20;
    /**
     * <code>emVideoStreamVidLab = 21;</code>
     *
     * <pre>
     *video双流能力
     * </pre>
     */
    public static final int emVideoStreamVidLab_VALUE = 21;
    /**
     * <code>emQkStreamVidLab = 22;</code>
     *
     * <pre>
     *投屏器双流能力
     * </pre>
     */
    public static final int emQkStreamVidLab_VALUE = 22;


    public final int getNumber() { return value; }

    public static EmMtVidLabel valueOf(int value) {
      switch (value) {
        case 0: return emVidLabBegin;
        case 20: return emPcStreamVidLab;
        case 21: return emVideoStreamVidLab;
        case 22: return emQkStreamVidLab;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtVidLabel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtVidLabel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtVidLabel>() {
            public EmMtVidLabel findValueByNumber(int number) {
              return EmMtVidLabel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(36);
    }

    private static final EmMtVidLabel[] VALUES = values();

    public static EmMtVidLabel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtVidLabel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtVidLabel)
  }

  /**
   * Protobuf enum {@code mt.EmMtAudLabel}
   *
   * <pre>
   *aud 能力标签
   * </pre>
   */
  public enum EmMtAudLabel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAudLabBegin = 0;</code>
     */
    emAudLabBegin(0, 0),
    ;

    /**
     * <code>emAudLabBegin = 0;</code>
     */
    public static final int emAudLabBegin_VALUE = 0;


    public final int getNumber() { return value; }

    public static EmMtAudLabel valueOf(int value) {
      switch (value) {
        case 0: return emAudLabBegin;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtAudLabel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtAudLabel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtAudLabel>() {
            public EmMtAudLabel findValueByNumber(int number) {
              return EmMtAudLabel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(37);
    }

    private static final EmMtAudLabel[] VALUES = values();

    public static EmMtAudLabel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtAudLabel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtAudLabel)
  }

  /**
   * Protobuf enum {@code mt.EmMtConfType}
   *
   * <pre>
   * 会议类型
   * </pre>
   */
  public enum EmMtConfType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConfType_Video = 0;</code>
     *
     * <pre>
     *视频 或 共享模式
     * </pre>
     */
    emConfType_Video(0, 0),
    /**
     * <code>emConfType_Audio = 1;</code>
     *
     * <pre>
     *纯音频
     * </pre>
     */
    emConfType_Audio(1, 1),
    ;

    /**
     * <code>emConfType_Video = 0;</code>
     *
     * <pre>
     *视频 或 共享模式
     * </pre>
     */
    public static final int emConfType_Video_VALUE = 0;
    /**
     * <code>emConfType_Audio = 1;</code>
     *
     * <pre>
     *纯音频
     * </pre>
     */
    public static final int emConfType_Audio_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmMtConfType valueOf(int value) {
      switch (value) {
        case 0: return emConfType_Video;
        case 1: return emConfType_Audio;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtConfType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtConfType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtConfType>() {
            public EmMtConfType findValueByNumber(int number) {
              return EmMtConfType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(38);
    }

    private static final EmMtConfType[] VALUES = values();

    public static EmMtConfType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtConfType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtConfType)
  }

  /**
   * Protobuf enum {@code mt.EmMtMediaType}
   *
   * <pre>
   * 媒体类型
   * </pre>
   */
  public enum EmMtMediaType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMediaBegin = 0;</code>
     *
     * <pre>
     *非音视频
     * </pre>
     */
    emMediaBegin(0, 0),
    /**
     * <code>emMediaVideo = 1;</code>
     *
     * <pre>
     *视频
     * </pre>
     */
    emMediaVideo(1, 1),
    /**
     * <code>emMediaAudio = 2;</code>
     *
     * <pre>
     *音频
     * </pre>
     */
    emMediaAudio(2, 2),
    /**
     * <code>emMediaAV = 3;</code>
     *
     * <pre>
     *音频和视频
     * </pre>
     */
    emMediaAV(3, 3),
    /**
     * <code>emMediaAssVideo = 4;</code>
     *
     * <pre>
     *辅流
     * </pre>
     */
    emMediaAssVideo(4, 4),
    ;

    /**
     * <code>emMediaBegin = 0;</code>
     *
     * <pre>
     *非音视频
     * </pre>
     */
    public static final int emMediaBegin_VALUE = 0;
    /**
     * <code>emMediaVideo = 1;</code>
     *
     * <pre>
     *视频
     * </pre>
     */
    public static final int emMediaVideo_VALUE = 1;
    /**
     * <code>emMediaAudio = 2;</code>
     *
     * <pre>
     *音频
     * </pre>
     */
    public static final int emMediaAudio_VALUE = 2;
    /**
     * <code>emMediaAV = 3;</code>
     *
     * <pre>
     *音频和视频
     * </pre>
     */
    public static final int emMediaAV_VALUE = 3;
    /**
     * <code>emMediaAssVideo = 4;</code>
     *
     * <pre>
     *辅流
     * </pre>
     */
    public static final int emMediaAssVideo_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmMtMediaType valueOf(int value) {
      switch (value) {
        case 0: return emMediaBegin;
        case 1: return emMediaVideo;
        case 2: return emMediaAudio;
        case 3: return emMediaAV;
        case 4: return emMediaAssVideo;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtMediaType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtMediaType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtMediaType>() {
            public EmMtMediaType findValueByNumber(int number) {
              return EmMtMediaType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(39);
    }

    private static final EmMtMediaType[] VALUES = values();

    public static EmMtMediaType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtMediaType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtMediaType)
  }

  /**
   * Protobuf enum {@code mt.EmMediaModeDef}
   *
   * <pre>
   *对应平台 CBB_EmMediaModeDef 
   * </pre>
   */
  public enum EmMediaModeDef
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMediaMdoeNone = 0;</code>
     *
     * <pre>
     *无媒体
     * </pre>
     */
    emMediaMdoeNone(0, 0),
    /**
     * <code>emMediaMdoeVideo = 1;</code>
     *
     * <pre>
     *视频
     * </pre>
     */
    emMediaMdoeVideo(1, 1),
    /**
     * <code>emMediaMdoeAudio = 2;</code>
     *
     * <pre>
     *音频
     * </pre>
     */
    emMediaMdoeAudio(2, 2),
    /**
     * <code>emMediaMdoeBoth = 3;</code>
     *
     * <pre>
     *音视频
     * </pre>
     */
    emMediaMdoeBoth(3, 3),
    /**
     * <code>emMediaMdoeData = 4;</code>
     *
     * <pre>
     *数据 
     * </pre>
     */
    emMediaMdoeData(4, 4),
    /**
     * <code>emMediaMdoeSecvideo = 5;</code>
     *
     * <pre>
     *双流
     * </pre>
     */
    emMediaMdoeSecvideo(5, 5),
    ;

    /**
     * <code>emMediaMdoeNone = 0;</code>
     *
     * <pre>
     *无媒体
     * </pre>
     */
    public static final int emMediaMdoeNone_VALUE = 0;
    /**
     * <code>emMediaMdoeVideo = 1;</code>
     *
     * <pre>
     *视频
     * </pre>
     */
    public static final int emMediaMdoeVideo_VALUE = 1;
    /**
     * <code>emMediaMdoeAudio = 2;</code>
     *
     * <pre>
     *音频
     * </pre>
     */
    public static final int emMediaMdoeAudio_VALUE = 2;
    /**
     * <code>emMediaMdoeBoth = 3;</code>
     *
     * <pre>
     *音视频
     * </pre>
     */
    public static final int emMediaMdoeBoth_VALUE = 3;
    /**
     * <code>emMediaMdoeData = 4;</code>
     *
     * <pre>
     *数据 
     * </pre>
     */
    public static final int emMediaMdoeData_VALUE = 4;
    /**
     * <code>emMediaMdoeSecvideo = 5;</code>
     *
     * <pre>
     *双流
     * </pre>
     */
    public static final int emMediaMdoeSecvideo_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmMediaModeDef valueOf(int value) {
      switch (value) {
        case 0: return emMediaMdoeNone;
        case 1: return emMediaMdoeVideo;
        case 2: return emMediaMdoeAudio;
        case 3: return emMediaMdoeBoth;
        case 4: return emMediaMdoeData;
        case 5: return emMediaMdoeSecvideo;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMediaModeDef>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMediaModeDef>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMediaModeDef>() {
            public EmMediaModeDef findValueByNumber(int number) {
              return EmMediaModeDef.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(40);
    }

    private static final EmMediaModeDef[] VALUES = values();

    public static EmMediaModeDef valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMediaModeDef(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMediaModeDef)
  }

  /**
   * Protobuf enum {@code mt.EmSite}
   *
   * <pre>
   *位置
   * </pre>
   */
  public enum EmSite
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emLocal = 0;</code>
     *
     * <pre>
     *本地
     * </pre>
     */
    emLocal(0, 0),
    /**
     * <code>emRemote = 1;</code>
     *
     * <pre>
     *远端
     * </pre>
     */
    emRemote(1, 1),
    ;

    /**
     * <code>emLocal = 0;</code>
     *
     * <pre>
     *本地
     * </pre>
     */
    public static final int emLocal_VALUE = 0;
    /**
     * <code>emRemote = 1;</code>
     *
     * <pre>
     *远端
     * </pre>
     */
    public static final int emRemote_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmSite valueOf(int value) {
      switch (value) {
        case 0: return emLocal;
        case 1: return emRemote;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSite>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSite>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSite>() {
            public EmSite findValueByNumber(int number) {
              return EmSite.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(41);
    }

    private static final EmSite[] VALUES = values();

    public static EmSite valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSite(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSite)
  }

  /**
   * Protobuf enum {@code mt.EmMtMediaDirection}
   */
  public enum EmMtMediaDirection
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emDirectionBegin = 0;</code>
     */
    emDirectionBegin(0, 0),
    /**
     * <code>emChannelSend = 1;</code>
     */
    emChannelSend(1, 1),
    /**
     * <code>emChannelRecv = 2;</code>
     */
    emChannelRecv(2, 2),
    ;

    /**
     * <code>emDirectionBegin = 0;</code>
     */
    public static final int emDirectionBegin_VALUE = 0;
    /**
     * <code>emChannelSend = 1;</code>
     */
    public static final int emChannelSend_VALUE = 1;
    /**
     * <code>emChannelRecv = 2;</code>
     */
    public static final int emChannelRecv_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtMediaDirection valueOf(int value) {
      switch (value) {
        case 0: return emDirectionBegin;
        case 1: return emChannelSend;
        case 2: return emChannelRecv;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtMediaDirection>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtMediaDirection>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtMediaDirection>() {
            public EmMtMediaDirection findValueByNumber(int number) {
              return EmMtMediaDirection.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(42);
    }

    private static final EmMtMediaDirection[] VALUES = values();

    public static EmMtMediaDirection valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtMediaDirection(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtMediaDirection)
  }

  /**
   * Protobuf enum {@code mt.EmAacChnlNum}
   *
   * <pre>
   *aaclc、aacld的声道数
   * </pre>
   */
  public enum EmAacChnlNum
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCnNumCust = 0;</code>
     */
    emCnNumCust(0, 0),
    /**
     * <code>emCnNum1 = 1;</code>
     */
    emCnNum1(1, 1),
    /**
     * <code>emCnNum2 = 2;</code>
     */
    emCnNum2(2, 2),
    /**
     * <code>emCnNum3 = 4;</code>
     */
    emCnNum3(3, 4),
    /**
     * <code>emCnNum4 = 8;</code>
     */
    emCnNum4(4, 8),
    /**
     * <code>emCnNum5 = 16;</code>
     */
    emCnNum5(5, 16),
    /**
     * <code>emCnNum5dot1 = 32;</code>
     */
    emCnNum5dot1(6, 32),
    /**
     * <code>emCnNum7dot1 = 64;</code>
     */
    emCnNum7dot1(7, 64),
    ;

    /**
     * <code>emCnNumCust = 0;</code>
     */
    public static final int emCnNumCust_VALUE = 0;
    /**
     * <code>emCnNum1 = 1;</code>
     */
    public static final int emCnNum1_VALUE = 1;
    /**
     * <code>emCnNum2 = 2;</code>
     */
    public static final int emCnNum2_VALUE = 2;
    /**
     * <code>emCnNum3 = 4;</code>
     */
    public static final int emCnNum3_VALUE = 4;
    /**
     * <code>emCnNum4 = 8;</code>
     */
    public static final int emCnNum4_VALUE = 8;
    /**
     * <code>emCnNum5 = 16;</code>
     */
    public static final int emCnNum5_VALUE = 16;
    /**
     * <code>emCnNum5dot1 = 32;</code>
     */
    public static final int emCnNum5dot1_VALUE = 32;
    /**
     * <code>emCnNum7dot1 = 64;</code>
     */
    public static final int emCnNum7dot1_VALUE = 64;


    public final int getNumber() { return value; }

    public static EmAacChnlNum valueOf(int value) {
      switch (value) {
        case 0: return emCnNumCust;
        case 1: return emCnNum1;
        case 2: return emCnNum2;
        case 4: return emCnNum3;
        case 8: return emCnNum4;
        case 16: return emCnNum5;
        case 32: return emCnNum5dot1;
        case 64: return emCnNum7dot1;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAacChnlNum>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAacChnlNum>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAacChnlNum>() {
            public EmAacChnlNum findValueByNumber(int number) {
              return EmAacChnlNum.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(43);
    }

    private static final EmAacChnlNum[] VALUES = values();

    public static EmAacChnlNum valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAacChnlNum(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAacChnlNum)
  }

  /**
   * Protobuf enum {@code mt.EmAacSampFreq}
   *
   * <pre>
   *aaclc、aacld采样码率
   * </pre>
   */
  public enum EmAacSampFreq
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emASF96000 = 0;</code>
     */
    emASF96000(0, 0),
    /**
     * <code>emASF88200 = 1;</code>
     */
    emASF88200(1, 1),
    /**
     * <code>emASF64000 = 2;</code>
     */
    emASF64000(2, 2),
    /**
     * <code>emASF48000 = 3;</code>
     */
    emASF48000(3, 3),
    /**
     * <code>emASF44100 = 4;</code>
     */
    emASF44100(4, 4),
    /**
     * <code>emASF32000 = 5;</code>
     */
    emASF32000(5, 5),
    /**
     * <code>emASF24000 = 6;</code>
     */
    emASF24000(6, 6),
    /**
     * <code>emASF22050 = 7;</code>
     */
    emASF22050(7, 7),
    /**
     * <code>emASF16000 = 8;</code>
     */
    emASF16000(8, 8),
    /**
     * <code>emASF12000 = 9;</code>
     */
    emASF12000(9, 9),
    /**
     * <code>emASF11025 = 10;</code>
     */
    emASF11025(10, 10),
    /**
     * <code>emASF8000 = 11;</code>
     */
    emASF8000(11, 11),
    ;

    /**
     * <code>emASF96000 = 0;</code>
     */
    public static final int emASF96000_VALUE = 0;
    /**
     * <code>emASF88200 = 1;</code>
     */
    public static final int emASF88200_VALUE = 1;
    /**
     * <code>emASF64000 = 2;</code>
     */
    public static final int emASF64000_VALUE = 2;
    /**
     * <code>emASF48000 = 3;</code>
     */
    public static final int emASF48000_VALUE = 3;
    /**
     * <code>emASF44100 = 4;</code>
     */
    public static final int emASF44100_VALUE = 4;
    /**
     * <code>emASF32000 = 5;</code>
     */
    public static final int emASF32000_VALUE = 5;
    /**
     * <code>emASF24000 = 6;</code>
     */
    public static final int emASF24000_VALUE = 6;
    /**
     * <code>emASF22050 = 7;</code>
     */
    public static final int emASF22050_VALUE = 7;
    /**
     * <code>emASF16000 = 8;</code>
     */
    public static final int emASF16000_VALUE = 8;
    /**
     * <code>emASF12000 = 9;</code>
     */
    public static final int emASF12000_VALUE = 9;
    /**
     * <code>emASF11025 = 10;</code>
     */
    public static final int emASF11025_VALUE = 10;
    /**
     * <code>emASF8000 = 11;</code>
     */
    public static final int emASF8000_VALUE = 11;


    public final int getNumber() { return value; }

    public static EmAacSampFreq valueOf(int value) {
      switch (value) {
        case 0: return emASF96000;
        case 1: return emASF88200;
        case 2: return emASF64000;
        case 3: return emASF48000;
        case 4: return emASF44100;
        case 5: return emASF32000;
        case 6: return emASF24000;
        case 7: return emASF22050;
        case 8: return emASF16000;
        case 9: return emASF12000;
        case 10: return emASF11025;
        case 11: return emASF8000;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAacSampFreq>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAacSampFreq>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAacSampFreq>() {
            public EmAacSampFreq findValueByNumber(int number) {
              return EmAacSampFreq.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(44);
    }

    private static final EmAacSampFreq[] VALUES = values();

    public static EmAacSampFreq valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAacSampFreq(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAacSampFreq)
  }

  /**
   * Protobuf enum {@code mt.EmMtChanState}
   */
  public enum EmMtChanState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emChanIdle = 0;</code>
     */
    emChanIdle(0, 0),
    /**
     * <code>emChanConnected = 1;</code>
     */
    emChanConnected(1, 1),
    ;

    /**
     * <code>emChanIdle = 0;</code>
     */
    public static final int emChanIdle_VALUE = 0;
    /**
     * <code>emChanConnected = 1;</code>
     */
    public static final int emChanConnected_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmMtChanState valueOf(int value) {
      switch (value) {
        case 0: return emChanIdle;
        case 1: return emChanConnected;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtChanState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtChanState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtChanState>() {
            public EmMtChanState findValueByNumber(int number) {
              return EmMtChanState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(45);
    }

    private static final EmMtChanState[] VALUES = values();

    public static EmMtChanState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtChanState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtChanState)
  }

  /**
   * Protobuf enum {@code mt.EmMtCallingType}
   */
  public enum EmMtCallingType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emJoinConf = 0;</code>
     *
     * <pre>
     *&#47;&lt;加入会议，等待mcu 呼叫  
     * </pre>
     */
    emJoinConf(0, 0),
    /**
     * <code>emCreateConf = 1;</code>
     *
     * <pre>
     *&#47;&lt;创建会议，等待mcu 呼叫
     * </pre>
     */
    emCreateConf(1, 1),
    /**
     * <code>emOutCall = 2;</code>
     *
     * <pre>
     *&#47;&lt;呼出
     * </pre>
     */
    emOutCall(2, 2),
    /**
     * <code>emIncomingCall = 3;</code>
     *
     * <pre>
     *&#47;&lt;呼入
     * </pre>
     */
    emIncomingCall(3, 3),
    ;

    /**
     * <code>emJoinConf = 0;</code>
     *
     * <pre>
     *&#47;&lt;加入会议，等待mcu 呼叫  
     * </pre>
     */
    public static final int emJoinConf_VALUE = 0;
    /**
     * <code>emCreateConf = 1;</code>
     *
     * <pre>
     *&#47;&lt;创建会议，等待mcu 呼叫
     * </pre>
     */
    public static final int emCreateConf_VALUE = 1;
    /**
     * <code>emOutCall = 2;</code>
     *
     * <pre>
     *&#47;&lt;呼出
     * </pre>
     */
    public static final int emOutCall_VALUE = 2;
    /**
     * <code>emIncomingCall = 3;</code>
     *
     * <pre>
     *&#47;&lt;呼入
     * </pre>
     */
    public static final int emIncomingCall_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMtCallingType valueOf(int value) {
      switch (value) {
        case 0: return emJoinConf;
        case 1: return emCreateConf;
        case 2: return emOutCall;
        case 3: return emIncomingCall;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtCallingType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtCallingType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtCallingType>() {
            public EmMtCallingType findValueByNumber(int number) {
              return EmMtCallingType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(46);
    }

    private static final EmMtCallingType[] VALUES = values();

    public static EmMtCallingType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtCallingType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtCallingType)
  }

  /**
   * Protobuf enum {@code mt.EmMtCallState}
   */
  public enum EmMtCallState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCallIdle = 0;</code>
     */
    emCallIdle(0, 0),
    /**
     * <code>emCallRasConfJoining = 1;</code>
     *
     * <pre>
     *ras非标加入会议，等待mcu 呼叫  
     * </pre>
     */
    emCallRasConfJoining(1, 1),
    /**
     * <code>emCallRasConfCreating = 2;</code>
     *
     * <pre>
     *ras非标创建会议，等待mcu 呼叫
     * </pre>
     */
    emCallRasConfCreating(2, 2),
    /**
     * <code>emCallOuting = 3;</code>
     */
    emCallOuting(3, 3),
    /**
     * <code>emCallIncoming = 4;</code>
     */
    emCallIncoming(4, 4),
    /**
     * <code>emCallAccepted = 5;</code>
     */
    emCallAccepted(5, 5),
    /**
     * <code>emCallHanging = 6;</code>
     */
    emCallHanging(6, 6),
    /**
     * <code>emCallConnected = 7;</code>
     *
     * <pre>
     *h323 是 225connected, sip是呼叫信令交互完
     * </pre>
     */
    emCallConnected(7, 7),
    /**
     * <code>emCallP2P = 8;</code>
     */
    emCallP2P(8, 8),
    /**
     * <code>emCallMCC = 9;</code>
     */
    emCallMCC(9, 9),
    ;

    /**
     * <code>emCallIdle = 0;</code>
     */
    public static final int emCallIdle_VALUE = 0;
    /**
     * <code>emCallRasConfJoining = 1;</code>
     *
     * <pre>
     *ras非标加入会议，等待mcu 呼叫  
     * </pre>
     */
    public static final int emCallRasConfJoining_VALUE = 1;
    /**
     * <code>emCallRasConfCreating = 2;</code>
     *
     * <pre>
     *ras非标创建会议，等待mcu 呼叫
     * </pre>
     */
    public static final int emCallRasConfCreating_VALUE = 2;
    /**
     * <code>emCallOuting = 3;</code>
     */
    public static final int emCallOuting_VALUE = 3;
    /**
     * <code>emCallIncoming = 4;</code>
     */
    public static final int emCallIncoming_VALUE = 4;
    /**
     * <code>emCallAccepted = 5;</code>
     */
    public static final int emCallAccepted_VALUE = 5;
    /**
     * <code>emCallHanging = 6;</code>
     */
    public static final int emCallHanging_VALUE = 6;
    /**
     * <code>emCallConnected = 7;</code>
     *
     * <pre>
     *h323 是 225connected, sip是呼叫信令交互完
     * </pre>
     */
    public static final int emCallConnected_VALUE = 7;
    /**
     * <code>emCallP2P = 8;</code>
     */
    public static final int emCallP2P_VALUE = 8;
    /**
     * <code>emCallMCC = 9;</code>
     */
    public static final int emCallMCC_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmMtCallState valueOf(int value) {
      switch (value) {
        case 0: return emCallIdle;
        case 1: return emCallRasConfJoining;
        case 2: return emCallRasConfCreating;
        case 3: return emCallOuting;
        case 4: return emCallIncoming;
        case 5: return emCallAccepted;
        case 6: return emCallHanging;
        case 7: return emCallConnected;
        case 8: return emCallP2P;
        case 9: return emCallMCC;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtCallState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtCallState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtCallState>() {
            public EmMtCallState findValueByNumber(int number) {
              return EmMtCallState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(47);
    }

    private static final EmMtCallState[] VALUES = values();

    public static EmMtCallState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtCallState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtCallState)
  }

  /**
   * Protobuf enum {@code mt.EmH323ChanState}
   */
  public enum EmH323ChanState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emChanStateIdle = 0;</code>
     */
    emChanStateIdle(0, 0),
    /**
     * <code>emChanStateCreating = 1;</code>
     *
     * <pre>
     *发送通道创建成功
     * </pre>
     */
    emChanStateCreating(1, 1),
    /**
     * <code>emChanStateOpening = 2;</code>
     *
     * <pre>
     *发送通道请求发送出去,或接收通道ack出去
     * </pre>
     */
    emChanStateOpening(2, 2),
    /**
     * <code>emChanStateRejected = 3;</code>
     *
     * <pre>
     *对端拒绝
     * </pre>
     */
    emChanStateRejected(3, 3),
    /**
     * <code>emChanStateOffering = 4;</code>
     *
     * <pre>
     *收到chanincoming
     * </pre>
     */
    emChanStateOffering(4, 4),
    /**
     * <code>emChanStateConnected = 5;</code>
     *
     * <pre>
     *收到connected
     * </pre>
     */
    emChanStateConnected(5, 5),
    /**
     * <code>emChanStateReopening = 6;</code>
     *
     * <pre>
     *重新打开
     * </pre>
     */
    emChanStateReopening(6, 6),
    /**
     * <code>emChanStateDisconnecting = 7;</code>
     *
     * <pre>
     *正在关闭状态
     * </pre>
     */
    emChanStateDisconnecting(7, 7),
    ;

    /**
     * <code>emChanStateIdle = 0;</code>
     */
    public static final int emChanStateIdle_VALUE = 0;
    /**
     * <code>emChanStateCreating = 1;</code>
     *
     * <pre>
     *发送通道创建成功
     * </pre>
     */
    public static final int emChanStateCreating_VALUE = 1;
    /**
     * <code>emChanStateOpening = 2;</code>
     *
     * <pre>
     *发送通道请求发送出去,或接收通道ack出去
     * </pre>
     */
    public static final int emChanStateOpening_VALUE = 2;
    /**
     * <code>emChanStateRejected = 3;</code>
     *
     * <pre>
     *对端拒绝
     * </pre>
     */
    public static final int emChanStateRejected_VALUE = 3;
    /**
     * <code>emChanStateOffering = 4;</code>
     *
     * <pre>
     *收到chanincoming
     * </pre>
     */
    public static final int emChanStateOffering_VALUE = 4;
    /**
     * <code>emChanStateConnected = 5;</code>
     *
     * <pre>
     *收到connected
     * </pre>
     */
    public static final int emChanStateConnected_VALUE = 5;
    /**
     * <code>emChanStateReopening = 6;</code>
     *
     * <pre>
     *重新打开
     * </pre>
     */
    public static final int emChanStateReopening_VALUE = 6;
    /**
     * <code>emChanStateDisconnecting = 7;</code>
     *
     * <pre>
     *正在关闭状态
     * </pre>
     */
    public static final int emChanStateDisconnecting_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmH323ChanState valueOf(int value) {
      switch (value) {
        case 0: return emChanStateIdle;
        case 1: return emChanStateCreating;
        case 2: return emChanStateOpening;
        case 3: return emChanStateRejected;
        case 4: return emChanStateOffering;
        case 5: return emChanStateConnected;
        case 6: return emChanStateReopening;
        case 7: return emChanStateDisconnecting;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmH323ChanState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmH323ChanState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmH323ChanState>() {
            public EmH323ChanState findValueByNumber(int number) {
              return EmH323ChanState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(48);
    }

    private static final EmH323ChanState[] VALUES = values();

    public static EmH323ChanState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmH323ChanState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmH323ChanState)
  }

  /**
   * Protobuf enum {@code mt.EmH323CallState}
   */
  public enum EmH323CallState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCallStateIdle = 0;</code>
     *
     * <pre>
     *空闲状态
     * </pre>
     */
    emCallStateIdle(0, 0),
    /**
     * <code>emCallState460Out = 1;</code>
     *
     * <pre>
     *终端发出460call之后状态，等待对端setup过来
     * </pre>
     */
    emCallState460Out(1, 1),
    /**
     * <code>emCallStateCreating = 2;</code>
     *
     * <pre>
     *创建呼叫
     * </pre>
     */
    emCallStateCreating(2, 2),
    /**
     * <code>emCallStateArqOutgoing = 3;</code>
     *
     * <pre>
     *发出arq状态
     * </pre>
     */
    emCallStateArqOutgoing(3, 3),
    /**
     * <code>emCallStateCallOuting = 4;</code>
     *
     * <pre>
     *呼出状态
     * </pre>
     */
    emCallStateCallOuting(4, 4),
    /**
     * <code>emCallStateCallincoming = 5;</code>
     *
     * <pre>
     *呼入状态
     * </pre>
     */
    emCallStateCallincoming(5, 5),
    /**
     * <code>emCallStateCallAccepted = 6;</code>
     *
     * <pre>
     *UI同意呼叫状态
     * </pre>
     */
    emCallStateCallAccepted(6, 6),
    /**
     * <code>emCallStateHanguping = 7;</code>
     *
     * <pre>
     *主动挂断，等待底层挂断
     * </pre>
     */
    emCallStateHanguping(7, 7),
    /**
     * <code>emCallStateConnected = 8;</code>
     *
     * <pre>
     *h225建立成功状态
     * </pre>
     */
    emCallStateConnected(8, 8),
    /**
     * <code>emCallStateOpenChanReady = 9;</code>
     *
     * <pre>
     *收到能力集，主从决定后，进入到开通道操作
     * </pre>
     */
    emCallStateOpenChanReady(9, 9),
    ;

    /**
     * <code>emCallStateIdle = 0;</code>
     *
     * <pre>
     *空闲状态
     * </pre>
     */
    public static final int emCallStateIdle_VALUE = 0;
    /**
     * <code>emCallState460Out = 1;</code>
     *
     * <pre>
     *终端发出460call之后状态，等待对端setup过来
     * </pre>
     */
    public static final int emCallState460Out_VALUE = 1;
    /**
     * <code>emCallStateCreating = 2;</code>
     *
     * <pre>
     *创建呼叫
     * </pre>
     */
    public static final int emCallStateCreating_VALUE = 2;
    /**
     * <code>emCallStateArqOutgoing = 3;</code>
     *
     * <pre>
     *发出arq状态
     * </pre>
     */
    public static final int emCallStateArqOutgoing_VALUE = 3;
    /**
     * <code>emCallStateCallOuting = 4;</code>
     *
     * <pre>
     *呼出状态
     * </pre>
     */
    public static final int emCallStateCallOuting_VALUE = 4;
    /**
     * <code>emCallStateCallincoming = 5;</code>
     *
     * <pre>
     *呼入状态
     * </pre>
     */
    public static final int emCallStateCallincoming_VALUE = 5;
    /**
     * <code>emCallStateCallAccepted = 6;</code>
     *
     * <pre>
     *UI同意呼叫状态
     * </pre>
     */
    public static final int emCallStateCallAccepted_VALUE = 6;
    /**
     * <code>emCallStateHanguping = 7;</code>
     *
     * <pre>
     *主动挂断，等待底层挂断
     * </pre>
     */
    public static final int emCallStateHanguping_VALUE = 7;
    /**
     * <code>emCallStateConnected = 8;</code>
     *
     * <pre>
     *h225建立成功状态
     * </pre>
     */
    public static final int emCallStateConnected_VALUE = 8;
    /**
     * <code>emCallStateOpenChanReady = 9;</code>
     *
     * <pre>
     *收到能力集，主从决定后，进入到开通道操作
     * </pre>
     */
    public static final int emCallStateOpenChanReady_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmH323CallState valueOf(int value) {
      switch (value) {
        case 0: return emCallStateIdle;
        case 1: return emCallState460Out;
        case 2: return emCallStateCreating;
        case 3: return emCallStateArqOutgoing;
        case 4: return emCallStateCallOuting;
        case 5: return emCallStateCallincoming;
        case 6: return emCallStateCallAccepted;
        case 7: return emCallStateHanguping;
        case 8: return emCallStateConnected;
        case 9: return emCallStateOpenChanReady;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmH323CallState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmH323CallState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmH323CallState>() {
            public EmH323CallState findValueByNumber(int number) {
              return EmH323CallState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(49);
    }

    private static final EmH323CallState[] VALUES = values();

    public static EmH323CallState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmH323CallState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmH323CallState)
  }

  /**
   * Protobuf enum {@code mt.EmEndpointType}
   *
   * <pre>
   *终端类型
   * </pre>
   */
  public enum EmEndpointType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEndpointTypeUnknown = 0;</code>
     */
    emEndpointTypeUnknown(0, 0),
    /**
     * <code>emEndpointTypeMT = 1;</code>
     */
    emEndpointTypeMT(1, 1),
    /**
     * <code>emEndpointTypeMCU = 2;</code>
     */
    emEndpointTypeMCU(2, 2),
    /**
     * <code>emEndpointTypeGK = 4;</code>
     */
    emEndpointTypeGK(3, 4),
    ;

    /**
     * <code>emEndpointTypeUnknown = 0;</code>
     */
    public static final int emEndpointTypeUnknown_VALUE = 0;
    /**
     * <code>emEndpointTypeMT = 1;</code>
     */
    public static final int emEndpointTypeMT_VALUE = 1;
    /**
     * <code>emEndpointTypeMCU = 2;</code>
     */
    public static final int emEndpointTypeMCU_VALUE = 2;
    /**
     * <code>emEndpointTypeGK = 4;</code>
     */
    public static final int emEndpointTypeGK_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmEndpointType valueOf(int value) {
      switch (value) {
        case 0: return emEndpointTypeUnknown;
        case 1: return emEndpointTypeMT;
        case 2: return emEndpointTypeMCU;
        case 4: return emEndpointTypeGK;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEndpointType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEndpointType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEndpointType>() {
            public EmEndpointType findValueByNumber(int number) {
              return EmEndpointType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(50);
    }

    private static final EmEndpointType[] VALUES = values();

    public static EmEndpointType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEndpointType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmEndpointType)
  }

  /**
   * Protobuf enum {@code mt.EmSMSType}
   *
   * <pre>
   *短消息业务类型
   * </pre>
   */
  public enum EmSMSType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSMSSingleLine = 0;</code>
     *
     * <pre>
     *短消息
     * </pre>
     */
    emSMSSingleLine(0, 0),
    /**
     * <code>emSMSPageTitle = 1;</code>
     *
     * <pre>
     * 翻页字幕
     * </pre>
     */
    emSMSPageTitle(1, 1),
    /**
     * <code>emSMSRollTitle = 2;</code>
     *
     * <pre>
     * 滚动字幕
     * </pre>
     */
    emSMSRollTitle(2, 2),
    /**
     * <code>emSMSStaticTitle = 3;</code>
     *
     * <pre>
     * 静态字幕
     * </pre>
     */
    emSMSStaticTitle(3, 3),
    /**
     * <code>emSMSUpRollTitle = 4;</code>
     *
     * <pre>
     * 向上滚动短消息
     * </pre>
     */
    emSMSUpRollTitle(4, 4),
    ;

    /**
     * <code>emSMSSingleLine = 0;</code>
     *
     * <pre>
     *短消息
     * </pre>
     */
    public static final int emSMSSingleLine_VALUE = 0;
    /**
     * <code>emSMSPageTitle = 1;</code>
     *
     * <pre>
     * 翻页字幕
     * </pre>
     */
    public static final int emSMSPageTitle_VALUE = 1;
    /**
     * <code>emSMSRollTitle = 2;</code>
     *
     * <pre>
     * 滚动字幕
     * </pre>
     */
    public static final int emSMSRollTitle_VALUE = 2;
    /**
     * <code>emSMSStaticTitle = 3;</code>
     *
     * <pre>
     * 静态字幕
     * </pre>
     */
    public static final int emSMSStaticTitle_VALUE = 3;
    /**
     * <code>emSMSUpRollTitle = 4;</code>
     *
     * <pre>
     * 向上滚动短消息
     * </pre>
     */
    public static final int emSMSUpRollTitle_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmSMSType valueOf(int value) {
      switch (value) {
        case 0: return emSMSSingleLine;
        case 1: return emSMSPageTitle;
        case 2: return emSMSRollTitle;
        case 3: return emSMSStaticTitle;
        case 4: return emSMSUpRollTitle;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSMSType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSMSType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSMSType>() {
            public EmSMSType findValueByNumber(int number) {
              return EmSMSType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(51);
    }

    private static final EmSMSType[] VALUES = values();

    public static EmSMSType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSMSType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSMSType)
  }

  /**
   * Protobuf enum {@code mt.EmRollMsgSpeed}
   */
  public enum EmRollMsgSpeed
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emROLL_SPEED_1 = 1;</code>
     *
     * <pre>
     * 最慢
     * </pre>
     */
    emROLL_SPEED_1(0, 1),
    /**
     * <code>emROLL_SPEED_2 = 2;</code>
     *
     * <pre>
     * 稍慢
     * </pre>
     */
    emROLL_SPEED_2(1, 2),
    /**
     * <code>emROLL_SPEED_3 = 3;</code>
     *
     * <pre>
     * 中速
     * </pre>
     */
    emROLL_SPEED_3(2, 3),
    /**
     * <code>emROLL_SPEED_4 = 4;</code>
     *
     * <pre>
     * 稍快
     * </pre>
     */
    emROLL_SPEED_4(3, 4),
    /**
     * <code>emROLL_SPEED_5 = 5;</code>
     *
     * <pre>
     * 最快
     * </pre>
     */
    emROLL_SPEED_5(4, 5),
    ;

    /**
     * <code>emROLL_SPEED_1 = 1;</code>
     *
     * <pre>
     * 最慢
     * </pre>
     */
    public static final int emROLL_SPEED_1_VALUE = 1;
    /**
     * <code>emROLL_SPEED_2 = 2;</code>
     *
     * <pre>
     * 稍慢
     * </pre>
     */
    public static final int emROLL_SPEED_2_VALUE = 2;
    /**
     * <code>emROLL_SPEED_3 = 3;</code>
     *
     * <pre>
     * 中速
     * </pre>
     */
    public static final int emROLL_SPEED_3_VALUE = 3;
    /**
     * <code>emROLL_SPEED_4 = 4;</code>
     *
     * <pre>
     * 稍快
     * </pre>
     */
    public static final int emROLL_SPEED_4_VALUE = 4;
    /**
     * <code>emROLL_SPEED_5 = 5;</code>
     *
     * <pre>
     * 最快
     * </pre>
     */
    public static final int emROLL_SPEED_5_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmRollMsgSpeed valueOf(int value) {
      switch (value) {
        case 1: return emROLL_SPEED_1;
        case 2: return emROLL_SPEED_2;
        case 3: return emROLL_SPEED_3;
        case 4: return emROLL_SPEED_4;
        case 5: return emROLL_SPEED_5;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRollMsgSpeed>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRollMsgSpeed>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRollMsgSpeed>() {
            public EmRollMsgSpeed findValueByNumber(int number) {
              return EmRollMsgSpeed.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(52);
    }

    private static final EmRollMsgSpeed[] VALUES = values();

    public static EmRollMsgSpeed valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRollMsgSpeed(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRollMsgSpeed)
  }

  /**
   * Protobuf enum {@code mt.EmMtVideoPort}
   *
   * <pre>
   *终端视频输入端口
   * </pre>
   */
  public enum EmMtVideoPort
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMtVidInvalid = 0;</code>
     *
     * <pre>
     * X500                   X700-4K|X500-4K        X500-1080P|X300        SKY300
     * </pre>
     */
    emMtVidInvalid(0, 0),
    /**
     * <code>emMtVidMultiView = 1;</code>
     *
     * <pre>
     * 多视                   多视                   多视                   ...
     * </pre>
     */
    emMtVidMultiView(1, 1),
    /**
     * <code>emMtVidInnerCamera = 2;</code>
     *
     * <pre>
     * ...                    ...                    ...                   InnerCamera
     * </pre>
     */
    emMtVidInnerCamera(2, 2),
    /**
     * <code>emMtVidDVI1 = 3;</code>
     *
     * <pre>
     * DVI/YPbPr/VGA/HDMI_3   DVI/HDMI/VGA/YPbPr_5   DVI/HDMI/VGA/YPbPr_1
     * </pre>
     */
    emMtVidDVI1(3, 3),
    /**
     * <code>emMtVidDVI2 = 4;</code>
     */
    emMtVidDVI2(4, 4),
    /**
     * <code>emMtVidDVI3 = 5;</code>
     */
    emMtVidDVI3(5, 5),
    /**
     * <code>emMtVidDVI4 = 6;</code>
     */
    emMtVidDVI4(6, 6),
    /**
     * <code>emMtVidHDMI1 = 7;</code>
     *
     * <pre>
     * HDMI_4                 HDMI_6                 HDMI_3|HDMI_2          HDMI_2
     * </pre>
     */
    emMtVidHDMI1(7, 7),
    /**
     * <code>emMtVidHDMI2 = 8;</code>
     *
     * <pre>
     * ...                    HDMI_1|...
     * </pre>
     */
    emMtVidHDMI2(8, 8),
    /**
     * <code>emMtVidHDMI3 = 9;</code>
     *
     * <pre>
     * ...                    HDMI_2|...
     * </pre>
     */
    emMtVidHDMI3(9, 9),
    /**
     * <code>emMtVidHDMI4 = 10;</code>
     */
    emMtVidHDMI4(10, 10),
    /**
     * <code>emMtVidYPbPr1 = 11;</code>
     */
    emMtVidYPbPr1(11, 11),
    /**
     * <code>emMtVidYPbPr2 = 12;</code>
     */
    emMtVidYPbPr2(12, 12),
    /**
     * <code>emMtVidYPbPr3 = 13;</code>
     */
    emMtVidYPbPr3(13, 13),
    /**
     * <code>emMtVidYPbPr4 = 14;</code>
     */
    emMtVidYPbPr4(14, 14),
    /**
     * <code>emMtVidVGA1 = 15;</code>
     *
     * <pre>
     * VGA/YPbPr_4            VGA/YPbPr_6          VGA/YPbPr_3|VGA/YPbPr_2  VGA/YPbPr_1
     * </pre>
     */
    emMtVidVGA1(15, 15),
    /**
     * <code>emMtVidVGA2 = 16;</code>
     */
    emMtVidVGA2(16, 16),
    /**
     * <code>emMtVidVGA3 = 17;</code>
     */
    emMtVidVGA3(17, 17),
    /**
     * <code>emMtVidVGA4 = 18;</code>
     */
    emMtVidVGA4(18, 18),
    /**
     * <code>emMtVidC1 = 19;</code>
     *
     * <pre>
     * CVBS_5
     * </pre>
     */
    emMtVidC1(19, 19),
    /**
     * <code>emMtVidC2 = 20;</code>
     */
    emMtVidC2(20, 20),
    /**
     * <code>emMtVidC3 = 21;</code>
     */
    emMtVidC3(21, 21),
    /**
     * <code>emMtVidS1 = 22;</code>
     */
    emMtVidS1(22, 22),
    /**
     * <code>emMtVidS2 = 23;</code>
     */
    emMtVidS2(23, 23),
    /**
     * <code>emMtVidS3 = 24;</code>
     */
    emMtVidS3(24, 24),
    /**
     * <code>emMtVidHDBaseT1 = 25;</code>
     *
     * <pre>
     * HDBaseT_1              HDBaseT_1              HDBaseT_1
     * </pre>
     */
    emMtVidHDBaseT1(25, 25),
    /**
     * <code>emMtVidHDBaseT2 = 26;</code>
     *
     * <pre>
     * HDBaseT_2              HDBaseT_2              HDBaseT_2|...
     * </pre>
     */
    emMtVidHDBaseT2(26, 26),
    /**
     * <code>emMtVidHDBaseT3 = 27;</code>
     */
    emMtVidHDBaseT3(27, 27),
    /**
     * <code>emMtVidHDBaseT4 = 28;</code>
     */
    emMtVidHDBaseT4(28, 28),
    /**
     * <code>emMtVidSDI1 = 29;</code>
     *
     * <pre>
     * SDI_1                  SDI_3                  SDI_2|...
     * </pre>
     */
    emMtVidSDI1(29, 29),
    /**
     * <code>emMtVidSDI2 = 30;</code>
     *
     * <pre>
     * SDI_2                  SDI_4
     * </pre>
     */
    emMtVidSDI2(30, 30),
    /**
     * <code>emMtVidSDI3 = 31;</code>
     */
    emMtVidSDI3(31, 31),
    /**
     * <code>emMtVidSDI4 = 32;</code>
     */
    emMtVidSDI4(32, 32),
    /**
     * <code>emMtVidInnerCamera2 = 33;</code>
     *
     * <pre>
     * ...                    ...                    ...                   InnerCamera2
     * </pre>
     */
    emMtVidInnerCamera2(33, 33),
    /**
     * <code>emMtVidInnerCamera3 = 34;</code>
     *
     * <pre>
     * ...                    ...                    ...                   InnerCamera3
     * </pre>
     */
    emMtVidInnerCamera3(34, 34),
    /**
     * <code>emMtVidInnerCamera4 = 35;</code>
     *
     * <pre>
     * ...                    ...                    ...                   InnerCamera4
     * </pre>
     */
    emMtVidInnerCamera4(35, 35),
    ;

    /**
     * <code>emMtVidInvalid = 0;</code>
     *
     * <pre>
     * X500                   X700-4K|X500-4K        X500-1080P|X300        SKY300
     * </pre>
     */
    public static final int emMtVidInvalid_VALUE = 0;
    /**
     * <code>emMtVidMultiView = 1;</code>
     *
     * <pre>
     * 多视                   多视                   多视                   ...
     * </pre>
     */
    public static final int emMtVidMultiView_VALUE = 1;
    /**
     * <code>emMtVidInnerCamera = 2;</code>
     *
     * <pre>
     * ...                    ...                    ...                   InnerCamera
     * </pre>
     */
    public static final int emMtVidInnerCamera_VALUE = 2;
    /**
     * <code>emMtVidDVI1 = 3;</code>
     *
     * <pre>
     * DVI/YPbPr/VGA/HDMI_3   DVI/HDMI/VGA/YPbPr_5   DVI/HDMI/VGA/YPbPr_1
     * </pre>
     */
    public static final int emMtVidDVI1_VALUE = 3;
    /**
     * <code>emMtVidDVI2 = 4;</code>
     */
    public static final int emMtVidDVI2_VALUE = 4;
    /**
     * <code>emMtVidDVI3 = 5;</code>
     */
    public static final int emMtVidDVI3_VALUE = 5;
    /**
     * <code>emMtVidDVI4 = 6;</code>
     */
    public static final int emMtVidDVI4_VALUE = 6;
    /**
     * <code>emMtVidHDMI1 = 7;</code>
     *
     * <pre>
     * HDMI_4                 HDMI_6                 HDMI_3|HDMI_2          HDMI_2
     * </pre>
     */
    public static final int emMtVidHDMI1_VALUE = 7;
    /**
     * <code>emMtVidHDMI2 = 8;</code>
     *
     * <pre>
     * ...                    HDMI_1|...
     * </pre>
     */
    public static final int emMtVidHDMI2_VALUE = 8;
    /**
     * <code>emMtVidHDMI3 = 9;</code>
     *
     * <pre>
     * ...                    HDMI_2|...
     * </pre>
     */
    public static final int emMtVidHDMI3_VALUE = 9;
    /**
     * <code>emMtVidHDMI4 = 10;</code>
     */
    public static final int emMtVidHDMI4_VALUE = 10;
    /**
     * <code>emMtVidYPbPr1 = 11;</code>
     */
    public static final int emMtVidYPbPr1_VALUE = 11;
    /**
     * <code>emMtVidYPbPr2 = 12;</code>
     */
    public static final int emMtVidYPbPr2_VALUE = 12;
    /**
     * <code>emMtVidYPbPr3 = 13;</code>
     */
    public static final int emMtVidYPbPr3_VALUE = 13;
    /**
     * <code>emMtVidYPbPr4 = 14;</code>
     */
    public static final int emMtVidYPbPr4_VALUE = 14;
    /**
     * <code>emMtVidVGA1 = 15;</code>
     *
     * <pre>
     * VGA/YPbPr_4            VGA/YPbPr_6          VGA/YPbPr_3|VGA/YPbPr_2  VGA/YPbPr_1
     * </pre>
     */
    public static final int emMtVidVGA1_VALUE = 15;
    /**
     * <code>emMtVidVGA2 = 16;</code>
     */
    public static final int emMtVidVGA2_VALUE = 16;
    /**
     * <code>emMtVidVGA3 = 17;</code>
     */
    public static final int emMtVidVGA3_VALUE = 17;
    /**
     * <code>emMtVidVGA4 = 18;</code>
     */
    public static final int emMtVidVGA4_VALUE = 18;
    /**
     * <code>emMtVidC1 = 19;</code>
     *
     * <pre>
     * CVBS_5
     * </pre>
     */
    public static final int emMtVidC1_VALUE = 19;
    /**
     * <code>emMtVidC2 = 20;</code>
     */
    public static final int emMtVidC2_VALUE = 20;
    /**
     * <code>emMtVidC3 = 21;</code>
     */
    public static final int emMtVidC3_VALUE = 21;
    /**
     * <code>emMtVidS1 = 22;</code>
     */
    public static final int emMtVidS1_VALUE = 22;
    /**
     * <code>emMtVidS2 = 23;</code>
     */
    public static final int emMtVidS2_VALUE = 23;
    /**
     * <code>emMtVidS3 = 24;</code>
     */
    public static final int emMtVidS3_VALUE = 24;
    /**
     * <code>emMtVidHDBaseT1 = 25;</code>
     *
     * <pre>
     * HDBaseT_1              HDBaseT_1              HDBaseT_1
     * </pre>
     */
    public static final int emMtVidHDBaseT1_VALUE = 25;
    /**
     * <code>emMtVidHDBaseT2 = 26;</code>
     *
     * <pre>
     * HDBaseT_2              HDBaseT_2              HDBaseT_2|...
     * </pre>
     */
    public static final int emMtVidHDBaseT2_VALUE = 26;
    /**
     * <code>emMtVidHDBaseT3 = 27;</code>
     */
    public static final int emMtVidHDBaseT3_VALUE = 27;
    /**
     * <code>emMtVidHDBaseT4 = 28;</code>
     */
    public static final int emMtVidHDBaseT4_VALUE = 28;
    /**
     * <code>emMtVidSDI1 = 29;</code>
     *
     * <pre>
     * SDI_1                  SDI_3                  SDI_2|...
     * </pre>
     */
    public static final int emMtVidSDI1_VALUE = 29;
    /**
     * <code>emMtVidSDI2 = 30;</code>
     *
     * <pre>
     * SDI_2                  SDI_4
     * </pre>
     */
    public static final int emMtVidSDI2_VALUE = 30;
    /**
     * <code>emMtVidSDI3 = 31;</code>
     */
    public static final int emMtVidSDI3_VALUE = 31;
    /**
     * <code>emMtVidSDI4 = 32;</code>
     */
    public static final int emMtVidSDI4_VALUE = 32;
    /**
     * <code>emMtVidInnerCamera2 = 33;</code>
     *
     * <pre>
     * ...                    ...                    ...                   InnerCamera2
     * </pre>
     */
    public static final int emMtVidInnerCamera2_VALUE = 33;
    /**
     * <code>emMtVidInnerCamera3 = 34;</code>
     *
     * <pre>
     * ...                    ...                    ...                   InnerCamera3
     * </pre>
     */
    public static final int emMtVidInnerCamera3_VALUE = 34;
    /**
     * <code>emMtVidInnerCamera4 = 35;</code>
     *
     * <pre>
     * ...                    ...                    ...                   InnerCamera4
     * </pre>
     */
    public static final int emMtVidInnerCamera4_VALUE = 35;


    public final int getNumber() { return value; }

    public static EmMtVideoPort valueOf(int value) {
      switch (value) {
        case 0: return emMtVidInvalid;
        case 1: return emMtVidMultiView;
        case 2: return emMtVidInnerCamera;
        case 3: return emMtVidDVI1;
        case 4: return emMtVidDVI2;
        case 5: return emMtVidDVI3;
        case 6: return emMtVidDVI4;
        case 7: return emMtVidHDMI1;
        case 8: return emMtVidHDMI2;
        case 9: return emMtVidHDMI3;
        case 10: return emMtVidHDMI4;
        case 11: return emMtVidYPbPr1;
        case 12: return emMtVidYPbPr2;
        case 13: return emMtVidYPbPr3;
        case 14: return emMtVidYPbPr4;
        case 15: return emMtVidVGA1;
        case 16: return emMtVidVGA2;
        case 17: return emMtVidVGA3;
        case 18: return emMtVidVGA4;
        case 19: return emMtVidC1;
        case 20: return emMtVidC2;
        case 21: return emMtVidC3;
        case 22: return emMtVidS1;
        case 23: return emMtVidS2;
        case 24: return emMtVidS3;
        case 25: return emMtVidHDBaseT1;
        case 26: return emMtVidHDBaseT2;
        case 27: return emMtVidHDBaseT3;
        case 28: return emMtVidHDBaseT4;
        case 29: return emMtVidSDI1;
        case 30: return emMtVidSDI2;
        case 31: return emMtVidSDI3;
        case 32: return emMtVidSDI4;
        case 33: return emMtVidInnerCamera2;
        case 34: return emMtVidInnerCamera3;
        case 35: return emMtVidInnerCamera4;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtVideoPort>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtVideoPort>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtVideoPort>() {
            public EmMtVideoPort findValueByNumber(int number) {
              return EmMtVideoPort.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(53);
    }

    private static final EmMtVideoPort[] VALUES = values();

    public static EmMtVideoPort valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtVideoPort(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtVideoPort)
  }

  /**
   * Protobuf enum {@code mt.EmMtJoinCreateConfRsp}
   */
  public enum EmMtJoinCreateConfRsp
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emJoinCreat_Success = 0;</code>
     */
    emJoinCreat_Success(0, 0),
    /**
     * <code>emJoinCreat_Serdb_err = 1;</code>
     */
    emJoinCreat_Serdb_err(1, 1),
    /**
     * <code>emJoinCreat_Timeout_err = 2;</code>
     */
    emJoinCreat_Timeout_err(2, 2),
    /**
     * <code>emJoinCreat_Note164_err = 3;</code>
     */
    emJoinCreat_Note164_err(3, 3),
    /**
     * <code>emJoinCreat_Data_err = 4;</code>
     */
    emJoinCreat_Data_err(4, 4),
    /**
     * <code>emJoinCreat_Mcu_noidlevpu = 5;</code>
     *
     * <pre>
     * 没有足够能力的空闲媒体处理器 5.0不需要
     * </pre>
     */
    emJoinCreat_Mcu_noidlevpu(5, 5),
    /**
     * <code>emJoinCreat_Mcu_minimediaconfmtnum = 6;</code>
     *
     * <pre>
     * 超过小型媒体会议入会终端限制 5.0不需要
     * </pre>
     */
    emJoinCreat_Mcu_minimediaconfmtnum(6, 6),
    /**
     * <code>emJoinCreat_Mcu_maxconfnum = 7;</code>
     *
     * <pre>
     * 已达最大会议数
     * </pre>
     */
    emJoinCreat_Mcu_maxconfnum(7, 7),
    /**
     * <code>emJoinCreat_Mcu_encrypeerr = 8;</code>
     *
     * <pre>
     * 与会议加密模式不符   5.0不需要
     * </pre>
     */
    emJoinCreat_Mcu_encrypeerr(8, 8),
    /**
     * <code>emJoinCreat_Mcu_confnotexist = 9;</code>
     *
     * <pre>
     * 会议不存在
     * </pre>
     */
    emJoinCreat_Mcu_confnotexist(9, 9),
    /**
     * <code>emJoinCreat_Mcu_undefined = 10;</code>
     *
     * <pre>
     * 没有定义 
     * </pre>
     */
    emJoinCreat_Mcu_undefined(10, 10),
    /**
     * <code>emJoinCreat_Gk_mpcd_disconnected = 11;</code>
     *
     * <pre>
     * mpcd热备重启
     * </pre>
     */
    emJoinCreat_Gk_mpcd_disconnected(11, 11),
    /**
     * <code>emJoinCreat_Mcu_maxmtnum = 12;</code>
     *
     * <pre>
     * 终端数已达最大上限
     * </pre>
     */
    emJoinCreat_Mcu_maxmtnum(12, 12),
    /**
     * <code>emJoinCreat_Mcu_pwderr = 13;</code>
     *
     * <pre>
     * 密码错误
     * </pre>
     */
    emJoinCreat_Mcu_pwderr(13, 13),
    /**
     * <code>emJoinCreat_Mcu_nsatpms = 14;</code>
     *
     * <pre>
     * 无卫星权限
     * </pre>
     */
    emJoinCreat_Mcu_nsatpms(14, 14),
    /**
     * <code>emJoinCreat_Mcu_nsatdaddr = 15;</code>
     *
     * <pre>
     * 没有组播地址
     * </pre>
     */
    emJoinCreat_Mcu_nsatdaddr(15, 15),
    /**
     * <code>emJoinCreat_E164_repeat = 16;</code>
     *
     * <pre>
     *e164号码重复
     * </pre>
     */
    emJoinCreat_E164_repeat(16, 16),
    /**
     * <code>emJoinCreat_CallerNum_exceed = 17;</code>
     *
     * <pre>
     *呼叫数超限          5.0不需要
     * </pre>
     */
    emJoinCreat_CallerNum_exceed(17, 17),
    /**
     * <code>emJoinCreat_Mcu_NoDisturbReject = 18;</code>
     *
     * <pre>
     *会议免打扰拒绝
     * </pre>
     */
    emJoinCreat_Mcu_NoDisturbReject(18, 18),
    /**
     * <code>emJoinCreat_Mcu_ConfResuming = 19;</code>
     *
     * <pre>
     *mcu正在恢复中
     * </pre>
     */
    emJoinCreat_Mcu_ConfResuming(19, 19),
    /**
     * <code>emJoinCreat_Mcu_NoPermission = 20;</code>
     *
     * <pre>
     *没有创会权限
     * </pre>
     */
    emJoinCreat_Mcu_NoPermission(20, 20),
    ;

    /**
     * <code>emJoinCreat_Success = 0;</code>
     */
    public static final int emJoinCreat_Success_VALUE = 0;
    /**
     * <code>emJoinCreat_Serdb_err = 1;</code>
     */
    public static final int emJoinCreat_Serdb_err_VALUE = 1;
    /**
     * <code>emJoinCreat_Timeout_err = 2;</code>
     */
    public static final int emJoinCreat_Timeout_err_VALUE = 2;
    /**
     * <code>emJoinCreat_Note164_err = 3;</code>
     */
    public static final int emJoinCreat_Note164_err_VALUE = 3;
    /**
     * <code>emJoinCreat_Data_err = 4;</code>
     */
    public static final int emJoinCreat_Data_err_VALUE = 4;
    /**
     * <code>emJoinCreat_Mcu_noidlevpu = 5;</code>
     *
     * <pre>
     * 没有足够能力的空闲媒体处理器 5.0不需要
     * </pre>
     */
    public static final int emJoinCreat_Mcu_noidlevpu_VALUE = 5;
    /**
     * <code>emJoinCreat_Mcu_minimediaconfmtnum = 6;</code>
     *
     * <pre>
     * 超过小型媒体会议入会终端限制 5.0不需要
     * </pre>
     */
    public static final int emJoinCreat_Mcu_minimediaconfmtnum_VALUE = 6;
    /**
     * <code>emJoinCreat_Mcu_maxconfnum = 7;</code>
     *
     * <pre>
     * 已达最大会议数
     * </pre>
     */
    public static final int emJoinCreat_Mcu_maxconfnum_VALUE = 7;
    /**
     * <code>emJoinCreat_Mcu_encrypeerr = 8;</code>
     *
     * <pre>
     * 与会议加密模式不符   5.0不需要
     * </pre>
     */
    public static final int emJoinCreat_Mcu_encrypeerr_VALUE = 8;
    /**
     * <code>emJoinCreat_Mcu_confnotexist = 9;</code>
     *
     * <pre>
     * 会议不存在
     * </pre>
     */
    public static final int emJoinCreat_Mcu_confnotexist_VALUE = 9;
    /**
     * <code>emJoinCreat_Mcu_undefined = 10;</code>
     *
     * <pre>
     * 没有定义 
     * </pre>
     */
    public static final int emJoinCreat_Mcu_undefined_VALUE = 10;
    /**
     * <code>emJoinCreat_Gk_mpcd_disconnected = 11;</code>
     *
     * <pre>
     * mpcd热备重启
     * </pre>
     */
    public static final int emJoinCreat_Gk_mpcd_disconnected_VALUE = 11;
    /**
     * <code>emJoinCreat_Mcu_maxmtnum = 12;</code>
     *
     * <pre>
     * 终端数已达最大上限
     * </pre>
     */
    public static final int emJoinCreat_Mcu_maxmtnum_VALUE = 12;
    /**
     * <code>emJoinCreat_Mcu_pwderr = 13;</code>
     *
     * <pre>
     * 密码错误
     * </pre>
     */
    public static final int emJoinCreat_Mcu_pwderr_VALUE = 13;
    /**
     * <code>emJoinCreat_Mcu_nsatpms = 14;</code>
     *
     * <pre>
     * 无卫星权限
     * </pre>
     */
    public static final int emJoinCreat_Mcu_nsatpms_VALUE = 14;
    /**
     * <code>emJoinCreat_Mcu_nsatdaddr = 15;</code>
     *
     * <pre>
     * 没有组播地址
     * </pre>
     */
    public static final int emJoinCreat_Mcu_nsatdaddr_VALUE = 15;
    /**
     * <code>emJoinCreat_E164_repeat = 16;</code>
     *
     * <pre>
     *e164号码重复
     * </pre>
     */
    public static final int emJoinCreat_E164_repeat_VALUE = 16;
    /**
     * <code>emJoinCreat_CallerNum_exceed = 17;</code>
     *
     * <pre>
     *呼叫数超限          5.0不需要
     * </pre>
     */
    public static final int emJoinCreat_CallerNum_exceed_VALUE = 17;
    /**
     * <code>emJoinCreat_Mcu_NoDisturbReject = 18;</code>
     *
     * <pre>
     *会议免打扰拒绝
     * </pre>
     */
    public static final int emJoinCreat_Mcu_NoDisturbReject_VALUE = 18;
    /**
     * <code>emJoinCreat_Mcu_ConfResuming = 19;</code>
     *
     * <pre>
     *mcu正在恢复中
     * </pre>
     */
    public static final int emJoinCreat_Mcu_ConfResuming_VALUE = 19;
    /**
     * <code>emJoinCreat_Mcu_NoPermission = 20;</code>
     *
     * <pre>
     *没有创会权限
     * </pre>
     */
    public static final int emJoinCreat_Mcu_NoPermission_VALUE = 20;


    public final int getNumber() { return value; }

    public static EmMtJoinCreateConfRsp valueOf(int value) {
      switch (value) {
        case 0: return emJoinCreat_Success;
        case 1: return emJoinCreat_Serdb_err;
        case 2: return emJoinCreat_Timeout_err;
        case 3: return emJoinCreat_Note164_err;
        case 4: return emJoinCreat_Data_err;
        case 5: return emJoinCreat_Mcu_noidlevpu;
        case 6: return emJoinCreat_Mcu_minimediaconfmtnum;
        case 7: return emJoinCreat_Mcu_maxconfnum;
        case 8: return emJoinCreat_Mcu_encrypeerr;
        case 9: return emJoinCreat_Mcu_confnotexist;
        case 10: return emJoinCreat_Mcu_undefined;
        case 11: return emJoinCreat_Gk_mpcd_disconnected;
        case 12: return emJoinCreat_Mcu_maxmtnum;
        case 13: return emJoinCreat_Mcu_pwderr;
        case 14: return emJoinCreat_Mcu_nsatpms;
        case 15: return emJoinCreat_Mcu_nsatdaddr;
        case 16: return emJoinCreat_E164_repeat;
        case 17: return emJoinCreat_CallerNum_exceed;
        case 18: return emJoinCreat_Mcu_NoDisturbReject;
        case 19: return emJoinCreat_Mcu_ConfResuming;
        case 20: return emJoinCreat_Mcu_NoPermission;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtJoinCreateConfRsp>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtJoinCreateConfRsp>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtJoinCreateConfRsp>() {
            public EmMtJoinCreateConfRsp findValueByNumber(int number) {
              return EmMtJoinCreateConfRsp.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(54);
    }

    private static final EmMtJoinCreateConfRsp[] VALUES = values();

    public static EmMtJoinCreateConfRsp valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtJoinCreateConfRsp(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtJoinCreateConfRsp)
  }

  /**
   * Protobuf enum {@code mt.EmMtConfDetailErr}
   */
  public enum EmMtConfDetailErr
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConfDetail_Err_Success = 0;</code>
     *
     * <pre>
     *获取会议详细信息成功
     * </pre>
     */
    emConfDetail_Err_Success(0, 0),
    /**
     * <code>emConfDetail_Err_Ser_db = 1;</code>
     *
     * <pre>
     *数据库错误
     * </pre>
     */
    emConfDetail_Err_Ser_db(1, 1),
    /**
     * <code>emConfDetail_Err_Timeout = 2;</code>
     *
     * <pre>
     *服务器响应超时
     * </pre>
     */
    emConfDetail_Err_Timeout(2, 2),
    /**
     * <code>emConfDetail_Err_Note164 = 3;</code>
     *
     * <pre>
     *通知E164号错误
     * </pre>
     */
    emConfDetail_Err_Note164(3, 3),
    /**
     * <code>emConfDetail_Err_Data = 4;</code>
     *
     * <pre>
     *数据错误
     * </pre>
     */
    emConfDetail_Err_Data(4, 4),
    /**
     * <code>emConfDetail_Err_Isover = 5;</code>
     *
     * <pre>
     *会议已结束
     * </pre>
     */
    emConfDetail_Err_Isover(5, 5),
    /**
     * <code>emConfDetail_Err_Unknown = 6;</code>
     *
     * <pre>
     *未知
     * </pre>
     */
    emConfDetail_Err_Unknown(6, 6),
    ;

    /**
     * <code>emConfDetail_Err_Success = 0;</code>
     *
     * <pre>
     *获取会议详细信息成功
     * </pre>
     */
    public static final int emConfDetail_Err_Success_VALUE = 0;
    /**
     * <code>emConfDetail_Err_Ser_db = 1;</code>
     *
     * <pre>
     *数据库错误
     * </pre>
     */
    public static final int emConfDetail_Err_Ser_db_VALUE = 1;
    /**
     * <code>emConfDetail_Err_Timeout = 2;</code>
     *
     * <pre>
     *服务器响应超时
     * </pre>
     */
    public static final int emConfDetail_Err_Timeout_VALUE = 2;
    /**
     * <code>emConfDetail_Err_Note164 = 3;</code>
     *
     * <pre>
     *通知E164号错误
     * </pre>
     */
    public static final int emConfDetail_Err_Note164_VALUE = 3;
    /**
     * <code>emConfDetail_Err_Data = 4;</code>
     *
     * <pre>
     *数据错误
     * </pre>
     */
    public static final int emConfDetail_Err_Data_VALUE = 4;
    /**
     * <code>emConfDetail_Err_Isover = 5;</code>
     *
     * <pre>
     *会议已结束
     * </pre>
     */
    public static final int emConfDetail_Err_Isover_VALUE = 5;
    /**
     * <code>emConfDetail_Err_Unknown = 6;</code>
     *
     * <pre>
     *未知
     * </pre>
     */
    public static final int emConfDetail_Err_Unknown_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmMtConfDetailErr valueOf(int value) {
      switch (value) {
        case 0: return emConfDetail_Err_Success;
        case 1: return emConfDetail_Err_Ser_db;
        case 2: return emConfDetail_Err_Timeout;
        case 3: return emConfDetail_Err_Note164;
        case 4: return emConfDetail_Err_Data;
        case 5: return emConfDetail_Err_Isover;
        case 6: return emConfDetail_Err_Unknown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtConfDetailErr>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtConfDetailErr>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtConfDetailErr>() {
            public EmMtConfDetailErr findValueByNumber(int number) {
              return EmMtConfDetailErr.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(55);
    }

    private static final EmMtConfDetailErr[] VALUES = values();

    public static EmMtConfDetailErr valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtConfDetailErr(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtConfDetailErr)
  }

  /**
   * Protobuf enum {@code mt.EmMtDualMode}
   */
  public enum EmMtDualMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MT_DUAL_MODE_SPEAKER = 0;</code>
     *
     * <pre>
     * 只有发言人能发双流
     * </pre>
     */
    MT_DUAL_MODE_SPEAKER(0, 0),
    /**
     * <code>MT_DUAL_MODE_EVERYONE = 1;</code>
     *
     * <pre>
     * 任何人都能发双流
     * </pre>
     */
    MT_DUAL_MODE_EVERYONE(1, 1),
    /**
     * <code>MT_DUAL_MODE_INVALID = 2;</code>
     */
    MT_DUAL_MODE_INVALID(2, 2),
    ;

    /**
     * <code>MT_DUAL_MODE_SPEAKER = 0;</code>
     *
     * <pre>
     * 只有发言人能发双流
     * </pre>
     */
    public static final int MT_DUAL_MODE_SPEAKER_VALUE = 0;
    /**
     * <code>MT_DUAL_MODE_EVERYONE = 1;</code>
     *
     * <pre>
     * 任何人都能发双流
     * </pre>
     */
    public static final int MT_DUAL_MODE_EVERYONE_VALUE = 1;
    /**
     * <code>MT_DUAL_MODE_INVALID = 2;</code>
     */
    public static final int MT_DUAL_MODE_INVALID_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtDualMode valueOf(int value) {
      switch (value) {
        case 0: return MT_DUAL_MODE_SPEAKER;
        case 1: return MT_DUAL_MODE_EVERYONE;
        case 2: return MT_DUAL_MODE_INVALID;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtDualMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtDualMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtDualMode>() {
            public EmMtDualMode findValueByNumber(int number) {
              return EmMtDualMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(56);
    }

    private static final EmMtDualMode[] VALUES = values();

    public static EmMtDualMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtDualMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtDualMode)
  }

  /**
   * Protobuf enum {@code mt.EmMtPollModeDef}
   */
  public enum EmMtPollModeDef
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPOLL_MODE_NONE = 0;</code>
     *
     * <pre>
     *不轮询广播 
     * </pre>
     */
    emPOLL_MODE_NONE(0, 0),
    /**
     * <code>emOLL_MODE_VIDEO = 1;</code>
     *
     * <pre>
     *仅图像轮询广播 到本地
     * </pre>
     */
    emOLL_MODE_VIDEO(1, 1),
    /**
     * <code>emPOLL_MODE_SPEAKER = 2;</code>
     *
     * <pre>
     *轮流发言       到本地
     * </pre>
     */
    emPOLL_MODE_SPEAKER(2, 2),
    /**
     * <code>emPOLL_MODE_VIDEO_SPY = 3;</code>
     *
     * <pre>
     *仅图像轮询广播 到回传
     * </pre>
     */
    emPOLL_MODE_VIDEO_SPY(3, 3),
    /**
     * <code>emPOLL_MODE_SPEAKER_SPY = 4;</code>
     *
     * <pre>
     *轮流发言       到回传
     * </pre>
     */
    emPOLL_MODE_SPEAKER_SPY(4, 4),
    /**
     * <code>emPOLL_MODE_VIDEO_BOTH = 5;</code>
     *
     * <pre>
     *仅图像轮询广播 到本地和回传
     * </pre>
     */
    emPOLL_MODE_VIDEO_BOTH(5, 5),
    /**
     * <code>emPOLL_MODE_SPEAKER_BOTH = 6;</code>
     *
     * <pre>
     *轮流发言       到本地和回传
     * </pre>
     */
    emPOLL_MODE_SPEAKER_BOTH(6, 6),
    /**
     * <code>emPOLL_MODE_VIDEO_CHAIRMAN = 7;</code>
     *
     * <pre>
     *只带视频的“主席轮询选看”轮询模式
     * </pre>
     */
    emPOLL_MODE_VIDEO_CHAIRMAN(7, 7),
    /**
     * <code>emPOLL_MODE_BOTH_CHAIRMAN = 8;</code>
     *
     * <pre>
     *带音频的“主席轮询选看”轮询模式
     * </pre>
     */
    emPOLL_MODE_BOTH_CHAIRMAN(8, 8),
    ;

    /**
     * <code>emPOLL_MODE_NONE = 0;</code>
     *
     * <pre>
     *不轮询广播 
     * </pre>
     */
    public static final int emPOLL_MODE_NONE_VALUE = 0;
    /**
     * <code>emOLL_MODE_VIDEO = 1;</code>
     *
     * <pre>
     *仅图像轮询广播 到本地
     * </pre>
     */
    public static final int emOLL_MODE_VIDEO_VALUE = 1;
    /**
     * <code>emPOLL_MODE_SPEAKER = 2;</code>
     *
     * <pre>
     *轮流发言       到本地
     * </pre>
     */
    public static final int emPOLL_MODE_SPEAKER_VALUE = 2;
    /**
     * <code>emPOLL_MODE_VIDEO_SPY = 3;</code>
     *
     * <pre>
     *仅图像轮询广播 到回传
     * </pre>
     */
    public static final int emPOLL_MODE_VIDEO_SPY_VALUE = 3;
    /**
     * <code>emPOLL_MODE_SPEAKER_SPY = 4;</code>
     *
     * <pre>
     *轮流发言       到回传
     * </pre>
     */
    public static final int emPOLL_MODE_SPEAKER_SPY_VALUE = 4;
    /**
     * <code>emPOLL_MODE_VIDEO_BOTH = 5;</code>
     *
     * <pre>
     *仅图像轮询广播 到本地和回传
     * </pre>
     */
    public static final int emPOLL_MODE_VIDEO_BOTH_VALUE = 5;
    /**
     * <code>emPOLL_MODE_SPEAKER_BOTH = 6;</code>
     *
     * <pre>
     *轮流发言       到本地和回传
     * </pre>
     */
    public static final int emPOLL_MODE_SPEAKER_BOTH_VALUE = 6;
    /**
     * <code>emPOLL_MODE_VIDEO_CHAIRMAN = 7;</code>
     *
     * <pre>
     *只带视频的“主席轮询选看”轮询模式
     * </pre>
     */
    public static final int emPOLL_MODE_VIDEO_CHAIRMAN_VALUE = 7;
    /**
     * <code>emPOLL_MODE_BOTH_CHAIRMAN = 8;</code>
     *
     * <pre>
     *带音频的“主席轮询选看”轮询模式
     * </pre>
     */
    public static final int emPOLL_MODE_BOTH_CHAIRMAN_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmMtPollModeDef valueOf(int value) {
      switch (value) {
        case 0: return emPOLL_MODE_NONE;
        case 1: return emOLL_MODE_VIDEO;
        case 2: return emPOLL_MODE_SPEAKER;
        case 3: return emPOLL_MODE_VIDEO_SPY;
        case 4: return emPOLL_MODE_SPEAKER_SPY;
        case 5: return emPOLL_MODE_VIDEO_BOTH;
        case 6: return emPOLL_MODE_SPEAKER_BOTH;
        case 7: return emPOLL_MODE_VIDEO_CHAIRMAN;
        case 8: return emPOLL_MODE_BOTH_CHAIRMAN;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtPollModeDef>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtPollModeDef>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtPollModeDef>() {
            public EmMtPollModeDef findValueByNumber(int number) {
              return EmMtPollModeDef.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(57);
    }

    private static final EmMtPollModeDef[] VALUES = values();

    public static EmMtPollModeDef valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtPollModeDef(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtPollModeDef)
  }

  /**
   * Protobuf enum {@code mt.EmMtPairTalkOperationType}
   */
  public enum EmMtPairTalkOperationType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMtPairTalkOperationTypeBegin = 0;</code>
     */
    emMtPairTalkOperationTypeBegin(0, 0),
    /**
     * <code>emMtPairTalkOperationTypeChairStart = 1;</code>
     *
     * <pre>
     * 主席开启对话模式
     * </pre>
     */
    emMtPairTalkOperationTypeChairStart(1, 1),
    /**
     * <code>emMtPairTalkOperationTypeChairStop = 2;</code>
     *
     * <pre>
     * 主席停止对话模式
     * </pre>
     */
    emMtPairTalkOperationTypeChairStop(2, 2),
    /**
     * <code>emMtPairTalkOperationTypeChairJoin = 3;</code>
     *
     * <pre>
     * 主席加入对话模式
     * </pre>
     */
    emMtPairTalkOperationTypeChairJoin(3, 3),
    /**
     * <code>emMtPairTalkOperationTypeChairQuit = 4;</code>
     *
     * <pre>
     * 主席退出对话模式
     * </pre>
     */
    emMtPairTalkOperationTypeChairQuit(4, 4),
    /**
     * <code>emMtPairTalkOperationTypeAudienceJoin = 5;</code>
     *
     * <pre>
     * 普通终端加入对话模式
     * </pre>
     */
    emMtPairTalkOperationTypeAudienceJoin(5, 5),
    /**
     * <code>emMtPairTalkOperationTypeAudienceQuit = 6;</code>
     *
     * <pre>
     * 普通终端退出对话模式	
     * </pre>
     */
    emMtPairTalkOperationTypeAudienceQuit(6, 6),
    ;

    /**
     * <code>emMtPairTalkOperationTypeBegin = 0;</code>
     */
    public static final int emMtPairTalkOperationTypeBegin_VALUE = 0;
    /**
     * <code>emMtPairTalkOperationTypeChairStart = 1;</code>
     *
     * <pre>
     * 主席开启对话模式
     * </pre>
     */
    public static final int emMtPairTalkOperationTypeChairStart_VALUE = 1;
    /**
     * <code>emMtPairTalkOperationTypeChairStop = 2;</code>
     *
     * <pre>
     * 主席停止对话模式
     * </pre>
     */
    public static final int emMtPairTalkOperationTypeChairStop_VALUE = 2;
    /**
     * <code>emMtPairTalkOperationTypeChairJoin = 3;</code>
     *
     * <pre>
     * 主席加入对话模式
     * </pre>
     */
    public static final int emMtPairTalkOperationTypeChairJoin_VALUE = 3;
    /**
     * <code>emMtPairTalkOperationTypeChairQuit = 4;</code>
     *
     * <pre>
     * 主席退出对话模式
     * </pre>
     */
    public static final int emMtPairTalkOperationTypeChairQuit_VALUE = 4;
    /**
     * <code>emMtPairTalkOperationTypeAudienceJoin = 5;</code>
     *
     * <pre>
     * 普通终端加入对话模式
     * </pre>
     */
    public static final int emMtPairTalkOperationTypeAudienceJoin_VALUE = 5;
    /**
     * <code>emMtPairTalkOperationTypeAudienceQuit = 6;</code>
     *
     * <pre>
     * 普通终端退出对话模式	
     * </pre>
     */
    public static final int emMtPairTalkOperationTypeAudienceQuit_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmMtPairTalkOperationType valueOf(int value) {
      switch (value) {
        case 0: return emMtPairTalkOperationTypeBegin;
        case 1: return emMtPairTalkOperationTypeChairStart;
        case 2: return emMtPairTalkOperationTypeChairStop;
        case 3: return emMtPairTalkOperationTypeChairJoin;
        case 4: return emMtPairTalkOperationTypeChairQuit;
        case 5: return emMtPairTalkOperationTypeAudienceJoin;
        case 6: return emMtPairTalkOperationTypeAudienceQuit;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtPairTalkOperationType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtPairTalkOperationType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtPairTalkOperationType>() {
            public EmMtPairTalkOperationType findValueByNumber(int number) {
              return EmMtPairTalkOperationType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(58);
    }

    private static final EmMtPairTalkOperationType[] VALUES = values();

    public static EmMtPairTalkOperationType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtPairTalkOperationType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtPairTalkOperationType)
  }

  /**
   * Protobuf enum {@code mt.EmMtCallMode}
   */
  public enum EmMtCallMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emJoin = 0;</code>
     */
    emJoin(0, 0),
    /**
     * <code>emCreate = 1;</code>
     */
    emCreate(1, 1),
    /**
     * <code>emInvite = 2;</code>
     */
    emInvite(2, 2),
    ;

    /**
     * <code>emJoin = 0;</code>
     */
    public static final int emJoin_VALUE = 0;
    /**
     * <code>emCreate = 1;</code>
     */
    public static final int emCreate_VALUE = 1;
    /**
     * <code>emInvite = 2;</code>
     */
    public static final int emInvite_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtCallMode valueOf(int value) {
      switch (value) {
        case 0: return emJoin;
        case 1: return emCreate;
        case 2: return emInvite;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtCallMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtCallMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtCallMode>() {
            public EmMtCallMode findValueByNumber(int number) {
              return EmMtCallMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(59);
    }

    private static final EmMtCallMode[] VALUES = values();

    public static EmMtCallMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtCallMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtCallMode)
  }

  /**
   * Protobuf enum {@code mt.EmMtConfMode}
   */
  public enum EmMtConfMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConfNone = 0;</code>
     */
    emConfNone(0, 0),
    /**
     * <code>emP2PConf = 1;</code>
     *
     * <pre>
     *点对点会议
     * </pre>
     */
    emP2PConf(1, 1),
    /**
     * <code>emMCCConf = 2;</code>
     *
     * <pre>
     *多点会议
     * </pre>
     */
    emMCCConf(2, 2),
    /**
     * <code>emFXOConf = 3;</code>
     *
     * <pre>
     *电话呼叫
     * </pre>
     */
    emFXOConf(3, 3),
    ;

    /**
     * <code>emConfNone = 0;</code>
     */
    public static final int emConfNone_VALUE = 0;
    /**
     * <code>emP2PConf = 1;</code>
     *
     * <pre>
     *点对点会议
     * </pre>
     */
    public static final int emP2PConf_VALUE = 1;
    /**
     * <code>emMCCConf = 2;</code>
     *
     * <pre>
     *多点会议
     * </pre>
     */
    public static final int emMCCConf_VALUE = 2;
    /**
     * <code>emFXOConf = 3;</code>
     *
     * <pre>
     *电话呼叫
     * </pre>
     */
    public static final int emFXOConf_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMtConfMode valueOf(int value) {
      switch (value) {
        case 0: return emConfNone;
        case 1: return emP2PConf;
        case 2: return emMCCConf;
        case 3: return emFXOConf;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtConfMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtConfMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtConfMode>() {
            public EmMtConfMode findValueByNumber(int number) {
              return EmMtConfMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(60);
    }

    private static final EmMtConfMode[] VALUES = values();

    public static EmMtConfMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtConfMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtConfMode)
  }

  /**
   * Protobuf enum {@code mt.EmMtLogChnnlType}
   *
   * <pre>
   *对应平台过来的CBB_EmLogChnnlType
   * </pre>
   */
  public enum EmMtLogChnnlType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMt_LOGCHL_VIDEO = 1;</code>
     *
     * <pre>
     *主视频逻辑通道
     * </pre>
     */
    emMt_LOGCHL_VIDEO(0, 1),
    /**
     * <code>emMt_LOGCHL_AUDIO = 2;</code>
     *
     * <pre>
     *音频逻辑通道
     * </pre>
     */
    emMt_LOGCHL_AUDIO(1, 2),
    /**
     * <code>emMt_LOGCHL_SECVIDEO = 3;</code>
     *
     * <pre>
     *第二视频逻辑通道
     * </pre>
     */
    emMt_LOGCHL_SECVIDEO(2, 3),
    /**
     * <code>emMt_LOGCHL_T120DATA = 4;</code>
     *
     * <pre>
     *T120数据逻辑通道
     * </pre>
     */
    emMt_LOGCHL_T120DATA(3, 4),
    /**
     * <code>emMt_LOGCHL_H224DATA = 5;</code>
     *
     * <pre>
     *H224数据逻辑通道
     * </pre>
     */
    emMt_LOGCHL_H224DATA(4, 5),
    /**
     * <code>emMt_LOGCHL_MMCUDATA = 6;</code>
     *
     * <pre>
     *级联数据逻辑通道
     * </pre>
     */
    emMt_LOGCHL_MMCUDATA(5, 6),
    /**
     * <code>emMt_LOGCHL_VIDEO_BOTH = 7;</code>
     *
     * <pre>
     *主视频+第二视频逻辑通道
     * </pre>
     */
    emMt_LOGCHL_VIDEO_BOTH(6, 7),
    ;

    /**
     * <code>emMt_LOGCHL_VIDEO = 1;</code>
     *
     * <pre>
     *主视频逻辑通道
     * </pre>
     */
    public static final int emMt_LOGCHL_VIDEO_VALUE = 1;
    /**
     * <code>emMt_LOGCHL_AUDIO = 2;</code>
     *
     * <pre>
     *音频逻辑通道
     * </pre>
     */
    public static final int emMt_LOGCHL_AUDIO_VALUE = 2;
    /**
     * <code>emMt_LOGCHL_SECVIDEO = 3;</code>
     *
     * <pre>
     *第二视频逻辑通道
     * </pre>
     */
    public static final int emMt_LOGCHL_SECVIDEO_VALUE = 3;
    /**
     * <code>emMt_LOGCHL_T120DATA = 4;</code>
     *
     * <pre>
     *T120数据逻辑通道
     * </pre>
     */
    public static final int emMt_LOGCHL_T120DATA_VALUE = 4;
    /**
     * <code>emMt_LOGCHL_H224DATA = 5;</code>
     *
     * <pre>
     *H224数据逻辑通道
     * </pre>
     */
    public static final int emMt_LOGCHL_H224DATA_VALUE = 5;
    /**
     * <code>emMt_LOGCHL_MMCUDATA = 6;</code>
     *
     * <pre>
     *级联数据逻辑通道
     * </pre>
     */
    public static final int emMt_LOGCHL_MMCUDATA_VALUE = 6;
    /**
     * <code>emMt_LOGCHL_VIDEO_BOTH = 7;</code>
     *
     * <pre>
     *主视频+第二视频逻辑通道
     * </pre>
     */
    public static final int emMt_LOGCHL_VIDEO_BOTH_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmMtLogChnnlType valueOf(int value) {
      switch (value) {
        case 1: return emMt_LOGCHL_VIDEO;
        case 2: return emMt_LOGCHL_AUDIO;
        case 3: return emMt_LOGCHL_SECVIDEO;
        case 4: return emMt_LOGCHL_T120DATA;
        case 5: return emMt_LOGCHL_H224DATA;
        case 6: return emMt_LOGCHL_MMCUDATA;
        case 7: return emMt_LOGCHL_VIDEO_BOTH;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtLogChnnlType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtLogChnnlType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtLogChnnlType>() {
            public EmMtLogChnnlType findValueByNumber(int number) {
              return EmMtLogChnnlType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(61);
    }

    private static final EmMtLogChnnlType[] VALUES = values();

    public static EmMtLogChnnlType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtLogChnnlType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtLogChnnlType)
  }

  /**
   * Protobuf enum {@code mt.EmMtMcu2MtNtfMsgType}
   *
   * <pre>
   *mcu通知终端的信息类型  
   * </pre>
   */
  public enum EmMtMcu2MtNtfMsgType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMt_NONE_NTF = 1;</code>
     */
    emMt_NONE_NTF(0, 1),
    /**
     * <code>emMt_BE_POLLED_NEXT_NTF = 2;</code>
     *
     * <pre>
     *普通业务控制逻辑相关通知:1-10
     * </pre>
     */
    emMt_BE_POLLED_NEXT_NTF(1, 2),
    /**
     * <code>emMt_NO_OPEN_DSCHNNL_NONSPEAKER = 11;</code>
     *
     * <pre>
     *打开双流通道失败相关通知:11-30
     * </pre>
     */
    emMt_NO_OPEN_DSCHNNL_NONSPEAKER(2, 11),
    /**
     * <code>emMt_NO_OPEN_DSCHNNLNONCAP = 12;</code>
     *
     * <pre>
     *打开双流通道 因 能力集限制 失败通知
     * </pre>
     */
    emMt_NO_OPEN_DSCHNNLNONCAP(3, 12),
    /**
     * <code>emMt_NO_OPEN_DSCHNNLBRLOW64 = 13;</code>
     *
     * <pre>
     *打开双流通道 因 通道码率小于64k 失败通知
     * </pre>
     */
    emMt_NO_OPEN_DSCHNNLBRLOW64(4, 13),
    /**
     * <code>emMt_NO_OPEN_DSCHNNLFECTYPE = 14;</code>
     *
     * <pre>
     *打开双流通道 因 FEC类型不匹配 失败通知
     * </pre>
     */
    emMt_NO_OPEN_DSCHNNLFECTYPE(5, 14),
    /**
     * <code>emMt_NO_OPEN_DSCHNNLNONMP = 15;</code>
     *
     * <pre>
     *打开双流通道 因 对应转发板不存在 失败通知
     * </pre>
     */
    emMt_NO_OPEN_DSCHNNLNONMP(6, 15),
    /**
     * <code>emMt_NO_OPEN_DSCHNNLENCRYPTMODE = 16;</code>
     *
     * <pre>
     *打开双流通道 因 加密模式不匹配 失败通知
     * </pre>
     */
    emMt_NO_OPEN_DSCHNNLENCRYPTMODE(7, 16),
    /**
     * <code>emMt_NO_OPEN_DSCHNNLOVERSATDCASTCHNNUM = 17;</code>
     *
     * <pre>
     *打开双流通道 因 超过了卫星分散会议的最大通道数 失败通知
     * </pre>
     */
    emMt_NO_OPEN_DSCHNNLOVERSATDCASTCHNNUM(8, 17),
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_NONCAP = 31;</code>
     *
     * <pre>
     *打开第一路视频流通道失败相关通知:31-50
     * </pre>
     */
    emMt_NO_OPEN_FSCHNNL_NONCAP(9, 31),
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_BR_LOW64 = 32;</code>
     *
     * <pre>
     *打开第一路视频通道 因 通道码率小于64k 失败通知
     * </pre>
     */
    emMt_NO_OPEN_FSCHNNL_BR_LOW64(10, 32),
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_ENCRPYT_MODE = 33;</code>
     *
     * <pre>
     *打开第一路视频通道 因 加密模式不匹配 失败通知
     * </pre>
     */
    emMt_NO_OPEN_FSCHNNL_ENCRPYT_MODE(11, 33),
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_FECTYPE = 34;</code>
     *
     * <pre>
     *打开第一路视频通道 因 FEC类型不匹配 失败通知
     * </pre>
     */
    emMt_NO_OPEN_FSCHNNL_FECTYPE(12, 34),
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_NONMP = 35;</code>
     *
     * <pre>
     *打开第一路视频通道 因 对应的转发板不存在 失败通知
     * </pre>
     */
    emMt_NO_OPEN_FSCHNNL_NONMP(13, 35),
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_BR_OVERFLOW = 36;</code>
     *
     * <pre>
     *打开第一路视频通道 因 码率过大 失败通知
     * </pre>
     */
    emMt_NO_OPEN_FSCHNNL_BR_OVERFLOW(14, 36),
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_BOTH_H263PLUS = 37;</code>
     *
     * <pre>
     *打开第一路视频通道 因 通道类型和动态载荷均为H263+ 失败通知
     * </pre>
     */
    emMt_NO_OPEN_FSCHNNL_BOTH_H263PLUS(15, 37),
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_FORMAT = 38;</code>
     *
     * <pre>
     *打开第一路视频通道 因 分辨率过大 失败通知
     * </pre>
     */
    emMt_NO_OPEN_FSCHNNL_FORMAT(16, 38),
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_FPS = 39;</code>
     *
     * <pre>
     *打开第一路视频通道 因 帧率过大 失败通知
     * </pre>
     */
    emMt_NO_OPEN_FSCHNNL_FPS(17, 39),
    /**
     * <code>emMt_CALL_FAILED_BR_LESS_THAN_CONF = 51;</code>
     *
     * <pre>
     *其他类型通知(待扩展):51+
     * </pre>
     */
    emMt_CALL_FAILED_BR_LESS_THAN_CONF(18, 51),
    /**
     * <code>emMt_CALL_FAILED_BR_LARGER_THAN_CONF = 52;</code>
     *
     * <pre>
     *呼叫码率 大于 会议码率，已自动调整
     * </pre>
     */
    emMt_CALL_FAILED_BR_LARGER_THAN_CONF(19, 52),
    /**
     * <code>emMt_NO_SUPPORT_OPR_FOR_NOAUTH = 53;</code>
     *
     * <pre>
     *不支持该操作，权限不足，请联系管理员
     * </pre>
     */
    emMt_NO_SUPPORT_OPR_FOR_NOAUTH(20, 53),
    /**
     * <code>emMt_NO_IN_MIXGRP_APPLY_INTERRUPT = 54;</code>
     *
     * <pre>
     *不在混音组中，发言前需申请插话
     * </pre>
     */
    emMt_NO_IN_MIXGRP_APPLY_INTERRUPT(21, 54),
    ;

    /**
     * <code>emMt_NONE_NTF = 1;</code>
     */
    public static final int emMt_NONE_NTF_VALUE = 1;
    /**
     * <code>emMt_BE_POLLED_NEXT_NTF = 2;</code>
     *
     * <pre>
     *普通业务控制逻辑相关通知:1-10
     * </pre>
     */
    public static final int emMt_BE_POLLED_NEXT_NTF_VALUE = 2;
    /**
     * <code>emMt_NO_OPEN_DSCHNNL_NONSPEAKER = 11;</code>
     *
     * <pre>
     *打开双流通道失败相关通知:11-30
     * </pre>
     */
    public static final int emMt_NO_OPEN_DSCHNNL_NONSPEAKER_VALUE = 11;
    /**
     * <code>emMt_NO_OPEN_DSCHNNLNONCAP = 12;</code>
     *
     * <pre>
     *打开双流通道 因 能力集限制 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_DSCHNNLNONCAP_VALUE = 12;
    /**
     * <code>emMt_NO_OPEN_DSCHNNLBRLOW64 = 13;</code>
     *
     * <pre>
     *打开双流通道 因 通道码率小于64k 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_DSCHNNLBRLOW64_VALUE = 13;
    /**
     * <code>emMt_NO_OPEN_DSCHNNLFECTYPE = 14;</code>
     *
     * <pre>
     *打开双流通道 因 FEC类型不匹配 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_DSCHNNLFECTYPE_VALUE = 14;
    /**
     * <code>emMt_NO_OPEN_DSCHNNLNONMP = 15;</code>
     *
     * <pre>
     *打开双流通道 因 对应转发板不存在 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_DSCHNNLNONMP_VALUE = 15;
    /**
     * <code>emMt_NO_OPEN_DSCHNNLENCRYPTMODE = 16;</code>
     *
     * <pre>
     *打开双流通道 因 加密模式不匹配 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_DSCHNNLENCRYPTMODE_VALUE = 16;
    /**
     * <code>emMt_NO_OPEN_DSCHNNLOVERSATDCASTCHNNUM = 17;</code>
     *
     * <pre>
     *打开双流通道 因 超过了卫星分散会议的最大通道数 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_DSCHNNLOVERSATDCASTCHNNUM_VALUE = 17;
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_NONCAP = 31;</code>
     *
     * <pre>
     *打开第一路视频流通道失败相关通知:31-50
     * </pre>
     */
    public static final int emMt_NO_OPEN_FSCHNNL_NONCAP_VALUE = 31;
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_BR_LOW64 = 32;</code>
     *
     * <pre>
     *打开第一路视频通道 因 通道码率小于64k 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_FSCHNNL_BR_LOW64_VALUE = 32;
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_ENCRPYT_MODE = 33;</code>
     *
     * <pre>
     *打开第一路视频通道 因 加密模式不匹配 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_FSCHNNL_ENCRPYT_MODE_VALUE = 33;
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_FECTYPE = 34;</code>
     *
     * <pre>
     *打开第一路视频通道 因 FEC类型不匹配 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_FSCHNNL_FECTYPE_VALUE = 34;
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_NONMP = 35;</code>
     *
     * <pre>
     *打开第一路视频通道 因 对应的转发板不存在 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_FSCHNNL_NONMP_VALUE = 35;
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_BR_OVERFLOW = 36;</code>
     *
     * <pre>
     *打开第一路视频通道 因 码率过大 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_FSCHNNL_BR_OVERFLOW_VALUE = 36;
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_BOTH_H263PLUS = 37;</code>
     *
     * <pre>
     *打开第一路视频通道 因 通道类型和动态载荷均为H263+ 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_FSCHNNL_BOTH_H263PLUS_VALUE = 37;
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_FORMAT = 38;</code>
     *
     * <pre>
     *打开第一路视频通道 因 分辨率过大 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_FSCHNNL_FORMAT_VALUE = 38;
    /**
     * <code>emMt_NO_OPEN_FSCHNNL_FPS = 39;</code>
     *
     * <pre>
     *打开第一路视频通道 因 帧率过大 失败通知
     * </pre>
     */
    public static final int emMt_NO_OPEN_FSCHNNL_FPS_VALUE = 39;
    /**
     * <code>emMt_CALL_FAILED_BR_LESS_THAN_CONF = 51;</code>
     *
     * <pre>
     *其他类型通知(待扩展):51+
     * </pre>
     */
    public static final int emMt_CALL_FAILED_BR_LESS_THAN_CONF_VALUE = 51;
    /**
     * <code>emMt_CALL_FAILED_BR_LARGER_THAN_CONF = 52;</code>
     *
     * <pre>
     *呼叫码率 大于 会议码率，已自动调整
     * </pre>
     */
    public static final int emMt_CALL_FAILED_BR_LARGER_THAN_CONF_VALUE = 52;
    /**
     * <code>emMt_NO_SUPPORT_OPR_FOR_NOAUTH = 53;</code>
     *
     * <pre>
     *不支持该操作，权限不足，请联系管理员
     * </pre>
     */
    public static final int emMt_NO_SUPPORT_OPR_FOR_NOAUTH_VALUE = 53;
    /**
     * <code>emMt_NO_IN_MIXGRP_APPLY_INTERRUPT = 54;</code>
     *
     * <pre>
     *不在混音组中，发言前需申请插话
     * </pre>
     */
    public static final int emMt_NO_IN_MIXGRP_APPLY_INTERRUPT_VALUE = 54;


    public final int getNumber() { return value; }

    public static EmMtMcu2MtNtfMsgType valueOf(int value) {
      switch (value) {
        case 1: return emMt_NONE_NTF;
        case 2: return emMt_BE_POLLED_NEXT_NTF;
        case 11: return emMt_NO_OPEN_DSCHNNL_NONSPEAKER;
        case 12: return emMt_NO_OPEN_DSCHNNLNONCAP;
        case 13: return emMt_NO_OPEN_DSCHNNLBRLOW64;
        case 14: return emMt_NO_OPEN_DSCHNNLFECTYPE;
        case 15: return emMt_NO_OPEN_DSCHNNLNONMP;
        case 16: return emMt_NO_OPEN_DSCHNNLENCRYPTMODE;
        case 17: return emMt_NO_OPEN_DSCHNNLOVERSATDCASTCHNNUM;
        case 31: return emMt_NO_OPEN_FSCHNNL_NONCAP;
        case 32: return emMt_NO_OPEN_FSCHNNL_BR_LOW64;
        case 33: return emMt_NO_OPEN_FSCHNNL_ENCRPYT_MODE;
        case 34: return emMt_NO_OPEN_FSCHNNL_FECTYPE;
        case 35: return emMt_NO_OPEN_FSCHNNL_NONMP;
        case 36: return emMt_NO_OPEN_FSCHNNL_BR_OVERFLOW;
        case 37: return emMt_NO_OPEN_FSCHNNL_BOTH_H263PLUS;
        case 38: return emMt_NO_OPEN_FSCHNNL_FORMAT;
        case 39: return emMt_NO_OPEN_FSCHNNL_FPS;
        case 51: return emMt_CALL_FAILED_BR_LESS_THAN_CONF;
        case 52: return emMt_CALL_FAILED_BR_LARGER_THAN_CONF;
        case 53: return emMt_NO_SUPPORT_OPR_FOR_NOAUTH;
        case 54: return emMt_NO_IN_MIXGRP_APPLY_INTERRUPT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtMcu2MtNtfMsgType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtMcu2MtNtfMsgType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtMcu2MtNtfMsgType>() {
            public EmMtMcu2MtNtfMsgType findValueByNumber(int number) {
              return EmMtMcu2MtNtfMsgType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(62);
    }

    private static final EmMtMcu2MtNtfMsgType[] VALUES = values();

    public static EmMtMcu2MtNtfMsgType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtMcu2MtNtfMsgType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtMcu2MtNtfMsgType)
  }

  /**
   * Protobuf enum {@code mt.EmGetListRspErr}
   *
   * <pre>
   *获取会议列表错误码
   *获取终端列表
   *获取列表，分包收数据，前三个枚举是通用的，
   * </pre>
   */
  public enum EmGetListRspErr
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emList_Finished = 0;</code>
     *
     * <pre>
     * 获取列表            成功并结束
     * </pre>
     */
    emList_Finished(0, 0),
    /**
     * <code>emList_Not_Finished = 1;</code>
     *
     * <pre>
     * 超过消息体大小，    余下分包传送
     * </pre>
     */
    emList_Not_Finished(1, 1),
    /**
     * <code>emList_UnCompleted = 2;</code>
     *
     * <pre>
     * 部分获取会议列表，  超时并结束
     * </pre>
     */
    emList_UnCompleted(2, 2),
    /**
     * <code>emList_SerDbErr = 3;</code>
     *
     * <pre>
     *&#47;//下面三个是收到平台来的错误码，仅用在获取会议列表
     * </pre>
     */
    emList_SerDbErr(3, 3),
    /**
     * <code>emList_Timeout = 4;</code>
     *
     * <pre>
     * 获取会议列表失败——服务器响应超时
     * </pre>
     */
    emList_Timeout(4, 4),
    /**
     * <code>emList_UnknownErr = 5;</code>
     *
     * <pre>
     * 获取会议列表失败（未知原因）
     * </pre>
     */
    emList_UnknownErr(5, 5),
    ;

    /**
     * <code>emList_Finished = 0;</code>
     *
     * <pre>
     * 获取列表            成功并结束
     * </pre>
     */
    public static final int emList_Finished_VALUE = 0;
    /**
     * <code>emList_Not_Finished = 1;</code>
     *
     * <pre>
     * 超过消息体大小，    余下分包传送
     * </pre>
     */
    public static final int emList_Not_Finished_VALUE = 1;
    /**
     * <code>emList_UnCompleted = 2;</code>
     *
     * <pre>
     * 部分获取会议列表，  超时并结束
     * </pre>
     */
    public static final int emList_UnCompleted_VALUE = 2;
    /**
     * <code>emList_SerDbErr = 3;</code>
     *
     * <pre>
     *&#47;//下面三个是收到平台来的错误码，仅用在获取会议列表
     * </pre>
     */
    public static final int emList_SerDbErr_VALUE = 3;
    /**
     * <code>emList_Timeout = 4;</code>
     *
     * <pre>
     * 获取会议列表失败——服务器响应超时
     * </pre>
     */
    public static final int emList_Timeout_VALUE = 4;
    /**
     * <code>emList_UnknownErr = 5;</code>
     *
     * <pre>
     * 获取会议列表失败（未知原因）
     * </pre>
     */
    public static final int emList_UnknownErr_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmGetListRspErr valueOf(int value) {
      switch (value) {
        case 0: return emList_Finished;
        case 1: return emList_Not_Finished;
        case 2: return emList_UnCompleted;
        case 3: return emList_SerDbErr;
        case 4: return emList_Timeout;
        case 5: return emList_UnknownErr;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmGetListRspErr>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmGetListRspErr>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmGetListRspErr>() {
            public EmGetListRspErr findValueByNumber(int number) {
              return EmGetListRspErr.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(63);
    }

    private static final EmGetListRspErr[] VALUES = values();

    public static EmGetListRspErr valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmGetListRspErr(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmGetListRspErr)
  }

  /**
   * Protobuf enum {@code mt.EmConfSpecial}
   */
  public enum EmConfSpecial
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNormalConf = 0;</code>
     *
     * <pre>
     *普通会议
     * </pre>
     */
    emNormalConf(0, 0),
    /**
     * <code>emSatelliteConf = 1;</code>
     *
     * <pre>
     *卫星会议
     * </pre>
     */
    emSatelliteConf(1, 1),
    ;

    /**
     * <code>emNormalConf = 0;</code>
     *
     * <pre>
     *普通会议
     * </pre>
     */
    public static final int emNormalConf_VALUE = 0;
    /**
     * <code>emSatelliteConf = 1;</code>
     *
     * <pre>
     *卫星会议
     * </pre>
     */
    public static final int emSatelliteConf_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmConfSpecial valueOf(int value) {
      switch (value) {
        case 0: return emNormalConf;
        case 1: return emSatelliteConf;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmConfSpecial>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmConfSpecial>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmConfSpecial>() {
            public EmConfSpecial findValueByNumber(int number) {
              return EmConfSpecial.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(64);
    }

    private static final EmConfSpecial[] VALUES = values();

    public static EmConfSpecial valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmConfSpecial(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmConfSpecial)
  }

  /**
   * Protobuf enum {@code mt.EmConfListType}
   */
  public enum EmConfListType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConfListType_Hold = 0;</code>
     *
     * <pre>
     *正在召开
     * </pre>
     */
    emConfListType_Hold(0, 0),
    /**
     * <code>emConfListType_Book = 1;</code>
     *
     * <pre>
     *预约
     * </pre>
     */
    emConfListType_Book(1, 1),
    /**
     * <code>emConfListType_Temp = 2;</code>
     *
     * <pre>
     *模板
     * </pre>
     */
    emConfListType_Temp(2, 2),
    /**
     * <code>emConfListType_End = 3;</code>
     */
    emConfListType_End(3, 3),
    ;

    /**
     * <code>emConfListType_Hold = 0;</code>
     *
     * <pre>
     *正在召开
     * </pre>
     */
    public static final int emConfListType_Hold_VALUE = 0;
    /**
     * <code>emConfListType_Book = 1;</code>
     *
     * <pre>
     *预约
     * </pre>
     */
    public static final int emConfListType_Book_VALUE = 1;
    /**
     * <code>emConfListType_Temp = 2;</code>
     *
     * <pre>
     *模板
     * </pre>
     */
    public static final int emConfListType_Temp_VALUE = 2;
    /**
     * <code>emConfListType_End = 3;</code>
     */
    public static final int emConfListType_End_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmConfListType valueOf(int value) {
      switch (value) {
        case 0: return emConfListType_Hold;
        case 1: return emConfListType_Book;
        case 2: return emConfListType_Temp;
        case 3: return emConfListType_End;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmConfListType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmConfListType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmConfListType>() {
            public EmConfListType findValueByNumber(int number) {
              return EmConfListType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(65);
    }

    private static final EmConfListType[] VALUES = values();

    public static EmConfListType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmConfListType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmConfListType)
  }

  /**
   * Protobuf enum {@code mt.EmMtClarity}
   *
   * <pre>
   *&#47;会议分辨率， 高清， 标清 
   * </pre>
   */
  public enum EmMtClarity
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EmMt_HD_MODE = 1;</code>
     *
     * <pre>
     *高清
     * </pre>
     */
    EmMt_HD_MODE(0, 1),
    /**
     * <code>EmMt_SD_MODE = 2;</code>
     *
     * <pre>
     *标清
     * </pre>
     */
    EmMt_SD_MODE(1, 2),
    /**
     * <code>EmMt_FLUENT_MODE = 3;</code>
     *
     * <pre>
     *流畅
     * </pre>
     */
    EmMt_FLUENT_MODE(2, 3),
    /**
     * <code>EmMt_UD_MODE = 4;</code>
     *
     * <pre>
     *自定义
     * </pre>
     */
    EmMt_UD_MODE(3, 4),
    /**
     * <code>EmMt_FHD_MODE = 5;</code>
     *
     * <pre>
     *全高清
     * </pre>
     */
    EmMt_FHD_MODE(4, 5),
    /**
     * <code>EmMt_UHD_MODE = 6;</code>
     *
     * <pre>
     *超高清
     * </pre>
     */
    EmMt_UHD_MODE(5, 6),
    ;

    /**
     * <code>EmMt_HD_MODE = 1;</code>
     *
     * <pre>
     *高清
     * </pre>
     */
    public static final int EmMt_HD_MODE_VALUE = 1;
    /**
     * <code>EmMt_SD_MODE = 2;</code>
     *
     * <pre>
     *标清
     * </pre>
     */
    public static final int EmMt_SD_MODE_VALUE = 2;
    /**
     * <code>EmMt_FLUENT_MODE = 3;</code>
     *
     * <pre>
     *流畅
     * </pre>
     */
    public static final int EmMt_FLUENT_MODE_VALUE = 3;
    /**
     * <code>EmMt_UD_MODE = 4;</code>
     *
     * <pre>
     *自定义
     * </pre>
     */
    public static final int EmMt_UD_MODE_VALUE = 4;
    /**
     * <code>EmMt_FHD_MODE = 5;</code>
     *
     * <pre>
     *全高清
     * </pre>
     */
    public static final int EmMt_FHD_MODE_VALUE = 5;
    /**
     * <code>EmMt_UHD_MODE = 6;</code>
     *
     * <pre>
     *超高清
     * </pre>
     */
    public static final int EmMt_UHD_MODE_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmMtClarity valueOf(int value) {
      switch (value) {
        case 1: return EmMt_HD_MODE;
        case 2: return EmMt_SD_MODE;
        case 3: return EmMt_FLUENT_MODE;
        case 4: return EmMt_UD_MODE;
        case 5: return EmMt_FHD_MODE;
        case 6: return EmMt_UHD_MODE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtClarity>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtClarity>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtClarity>() {
            public EmMtClarity findValueByNumber(int number) {
              return EmMtClarity.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(66);
    }

    private static final EmMtClarity[] VALUES = values();

    public static EmMtClarity valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtClarity(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtClarity)
  }

  /**
   * Protobuf enum {@code mt.EmMtType}
   *
   * <pre>
   *&#47;//多点会议中终端类型
   * </pre>
   */
  public enum EmMtType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EmMt_Type_Mt = 0;</code>
     *
     * <pre>
     *&#47;普通终端
     * </pre>
     */
    EmMt_Type_Mt(0, 0),
    /**
     * <code>EmMt_Type_PHONE = 1;</code>
     *
     * <pre>
     *&#47;电话终端
     * </pre>
     */
    EmMt_Type_PHONE(1, 1),
    /**
     * <code>EmMt_Type_SATD = 2;</code>
     *
     * <pre>
     *&#47;卫星终端
     * </pre>
     */
    EmMt_Type_SATD(2, 2),
    /**
     * <code>EmMt_Type_MMCU = 3;</code>
     *
     * <pre>
     *&#47;上级MCU (上级会议)
     * </pre>
     */
    EmMt_Type_MMCU(3, 3),
    /**
     * <code>EmMt_Type_SMCU = 4;</code>
     *
     * <pre>
     *&#47;下级MCU (下级会议)
     * </pre>
     */
    EmMt_Type_SMCU(4, 4),
    /**
     * <code>EmMt_Type_VRSREC = 5;</code>
     *
     * <pre>
     *&#47;vrs新录播设备
     * </pre>
     */
    EmMt_Type_VRSREC(5, 5),
    /**
     * <code>EmMt_Type_Other = 10;</code>
     *
     * <pre>
     *&#47;其他终端
     * </pre>
     */
    EmMt_Type_Other(6, 10),
    ;

    /**
     * <code>EmMt_Type_Mt = 0;</code>
     *
     * <pre>
     *&#47;普通终端
     * </pre>
     */
    public static final int EmMt_Type_Mt_VALUE = 0;
    /**
     * <code>EmMt_Type_PHONE = 1;</code>
     *
     * <pre>
     *&#47;电话终端
     * </pre>
     */
    public static final int EmMt_Type_PHONE_VALUE = 1;
    /**
     * <code>EmMt_Type_SATD = 2;</code>
     *
     * <pre>
     *&#47;卫星终端
     * </pre>
     */
    public static final int EmMt_Type_SATD_VALUE = 2;
    /**
     * <code>EmMt_Type_MMCU = 3;</code>
     *
     * <pre>
     *&#47;上级MCU (上级会议)
     * </pre>
     */
    public static final int EmMt_Type_MMCU_VALUE = 3;
    /**
     * <code>EmMt_Type_SMCU = 4;</code>
     *
     * <pre>
     *&#47;下级MCU (下级会议)
     * </pre>
     */
    public static final int EmMt_Type_SMCU_VALUE = 4;
    /**
     * <code>EmMt_Type_VRSREC = 5;</code>
     *
     * <pre>
     *&#47;vrs新录播设备
     * </pre>
     */
    public static final int EmMt_Type_VRSREC_VALUE = 5;
    /**
     * <code>EmMt_Type_Other = 10;</code>
     *
     * <pre>
     *&#47;其他终端
     * </pre>
     */
    public static final int EmMt_Type_Other_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmMtType valueOf(int value) {
      switch (value) {
        case 0: return EmMt_Type_Mt;
        case 1: return EmMt_Type_PHONE;
        case 2: return EmMt_Type_SATD;
        case 3: return EmMt_Type_MMCU;
        case 4: return EmMt_Type_SMCU;
        case 5: return EmMt_Type_VRSREC;
        case 10: return EmMt_Type_Other;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtType>() {
            public EmMtType findValueByNumber(int number) {
              return EmMtType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(67);
    }

    private static final EmMtType[] VALUES = values();

    public static EmMtType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtType)
  }

  /**
   * Protobuf enum {@code mt.EmMtAddrType}
   *
   * <pre>
   *&#47;//终端地址类型
   * </pre>
   */
  public enum EmMtAddrType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAddrIP = 0;</code>
     */
    emAddrIP(0, 0),
    /**
     * <code>emAddrE164 = 1;</code>
     */
    emAddrE164(1, 1),
    /**
     * <code>emAddrAlias = 2;</code>
     */
    emAddrAlias(2, 2),
    /**
     * <code>emDialNum = 3;</code>
     *
     * <pre>
     *&#47;/电话号码
     * </pre>
     */
    emDialNum(3, 3),
    /**
     * <code>emSipAddr = 4;</code>
     */
    emSipAddr(4, 4),
    /**
     * <code>emAddrMoid = 5;</code>
     */
    emAddrMoid(5, 5),
    /**
     * <code>emNoSysMailbox = 6;</code>
     *
     * <pre>
     *非系统邮箱
     * </pre>
     */
    emNoSysMailbox(6, 6),
    ;

    /**
     * <code>emAddrIP = 0;</code>
     */
    public static final int emAddrIP_VALUE = 0;
    /**
     * <code>emAddrE164 = 1;</code>
     */
    public static final int emAddrE164_VALUE = 1;
    /**
     * <code>emAddrAlias = 2;</code>
     */
    public static final int emAddrAlias_VALUE = 2;
    /**
     * <code>emDialNum = 3;</code>
     *
     * <pre>
     *&#47;/电话号码
     * </pre>
     */
    public static final int emDialNum_VALUE = 3;
    /**
     * <code>emSipAddr = 4;</code>
     */
    public static final int emSipAddr_VALUE = 4;
    /**
     * <code>emAddrMoid = 5;</code>
     */
    public static final int emAddrMoid_VALUE = 5;
    /**
     * <code>emNoSysMailbox = 6;</code>
     *
     * <pre>
     *非系统邮箱
     * </pre>
     */
    public static final int emNoSysMailbox_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmMtAddrType valueOf(int value) {
      switch (value) {
        case 0: return emAddrIP;
        case 1: return emAddrE164;
        case 2: return emAddrAlias;
        case 3: return emDialNum;
        case 4: return emSipAddr;
        case 5: return emAddrMoid;
        case 6: return emNoSysMailbox;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtAddrType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtAddrType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtAddrType>() {
            public EmMtAddrType findValueByNumber(int number) {
              return EmMtAddrType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(68);
    }

    private static final EmMtAddrType[] VALUES = values();

    public static EmMtAddrType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtAddrType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtAddrType)
  }

  /**
   * Protobuf enum {@code mt.EmMtModifyConfInfoType}
   */
  public enum EmMtModifyConfInfoType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>MT_MODIFY_BEGIN = 0;</code>
     */
    MT_MODIFY_BEGIN(0, 0),
    /**
     * <code>MT_MODIFY_CONF_NAMETYPE = 1;</code>
     *
     * <pre>
     * 修改会议名称
     * </pre>
     */
    MT_MODIFY_CONF_NAMETYPE(1, 1),
    /**
     * <code>MT_MODIFY_CONF_DURATIONTYPE = 2;</code>
     *
     * <pre>
     * 修改会议时长
     * </pre>
     */
    MT_MODIFY_CONF_DURATIONTYPE(2, 2),
    /**
     * <code>MT_MODIFY_CONF_PWDTYPE = 3;</code>
     *
     * <pre>
     * 修改会议密码
     * </pre>
     */
    MT_MODIFY_CONF_PWDTYPE(3, 3),
    /**
     * <code>MT_MODIFY_CONF_DUAL_MODETYPE = 4;</code>
     *
     * <pre>
     * 修改会议双流发起方式
     * </pre>
     */
    MT_MODIFY_CONF_DUAL_MODETYPE(4, 4),
    /**
     * <code>MT_MODIFY_CONF_SHOW_MEMBERALIAS = 5;</code>
     *
     * <pre>
     * 修改会议画面合成是否显示成员别名
     * </pre>
     */
    MT_MODIFY_CONF_SHOW_MEMBERALIAS(5, 5),
    /**
     * <code>MT_MODIFY_CONF_OPENMODE = 6;</code>
     *
     * <pre>
     * 修改会议的openmode(对应CBB_EmConfOpenModeDef)
     * </pre>
     */
    MT_MODIFY_CONF_OPENMODE(6, 6),
    /**
     * <code>MT_MODIFY_CONF_DUMB = 7;</code>
     *
     * <pre>
     * 修改会议全体哑音
     * </pre>
     */
    MT_MODIFY_CONF_DUMB(7, 7),
    /**
     * <code>MT_MODIFY_CONF_NoDisturb = 8;</code>
     *
     * <pre>
     * 修改会议是否封闭（对应终端免打扰）
     * </pre>
     */
    MT_MODIFY_CONF_NoDisturb(8, 8),
    ;

    /**
     * <code>MT_MODIFY_BEGIN = 0;</code>
     */
    public static final int MT_MODIFY_BEGIN_VALUE = 0;
    /**
     * <code>MT_MODIFY_CONF_NAMETYPE = 1;</code>
     *
     * <pre>
     * 修改会议名称
     * </pre>
     */
    public static final int MT_MODIFY_CONF_NAMETYPE_VALUE = 1;
    /**
     * <code>MT_MODIFY_CONF_DURATIONTYPE = 2;</code>
     *
     * <pre>
     * 修改会议时长
     * </pre>
     */
    public static final int MT_MODIFY_CONF_DURATIONTYPE_VALUE = 2;
    /**
     * <code>MT_MODIFY_CONF_PWDTYPE = 3;</code>
     *
     * <pre>
     * 修改会议密码
     * </pre>
     */
    public static final int MT_MODIFY_CONF_PWDTYPE_VALUE = 3;
    /**
     * <code>MT_MODIFY_CONF_DUAL_MODETYPE = 4;</code>
     *
     * <pre>
     * 修改会议双流发起方式
     * </pre>
     */
    public static final int MT_MODIFY_CONF_DUAL_MODETYPE_VALUE = 4;
    /**
     * <code>MT_MODIFY_CONF_SHOW_MEMBERALIAS = 5;</code>
     *
     * <pre>
     * 修改会议画面合成是否显示成员别名
     * </pre>
     */
    public static final int MT_MODIFY_CONF_SHOW_MEMBERALIAS_VALUE = 5;
    /**
     * <code>MT_MODIFY_CONF_OPENMODE = 6;</code>
     *
     * <pre>
     * 修改会议的openmode(对应CBB_EmConfOpenModeDef)
     * </pre>
     */
    public static final int MT_MODIFY_CONF_OPENMODE_VALUE = 6;
    /**
     * <code>MT_MODIFY_CONF_DUMB = 7;</code>
     *
     * <pre>
     * 修改会议全体哑音
     * </pre>
     */
    public static final int MT_MODIFY_CONF_DUMB_VALUE = 7;
    /**
     * <code>MT_MODIFY_CONF_NoDisturb = 8;</code>
     *
     * <pre>
     * 修改会议是否封闭（对应终端免打扰）
     * </pre>
     */
    public static final int MT_MODIFY_CONF_NoDisturb_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmMtModifyConfInfoType valueOf(int value) {
      switch (value) {
        case 0: return MT_MODIFY_BEGIN;
        case 1: return MT_MODIFY_CONF_NAMETYPE;
        case 2: return MT_MODIFY_CONF_DURATIONTYPE;
        case 3: return MT_MODIFY_CONF_PWDTYPE;
        case 4: return MT_MODIFY_CONF_DUAL_MODETYPE;
        case 5: return MT_MODIFY_CONF_SHOW_MEMBERALIAS;
        case 6: return MT_MODIFY_CONF_OPENMODE;
        case 7: return MT_MODIFY_CONF_DUMB;
        case 8: return MT_MODIFY_CONF_NoDisturb;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtModifyConfInfoType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtModifyConfInfoType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtModifyConfInfoType>() {
            public EmMtModifyConfInfoType findValueByNumber(int number) {
              return EmMtModifyConfInfoType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(69);
    }

    private static final EmMtModifyConfInfoType[] VALUES = values();

    public static EmMtModifyConfInfoType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtModifyConfInfoType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtModifyConfInfoType)
  }

  /**
   * Protobuf enum {@code mt.EmMtConfFailureReason}
   *
   * <pre>
   *会议发生错误时带的失败原因
   * </pre>
   */
  public enum EmMtConfFailureReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFAIL_REASON_DIFF_CONF_ENCRYPT_MODE = 1;</code>
     */
    emFAIL_REASON_DIFF_CONF_ENCRYPT_MODE(0, 1),
    /**
     * <code>emFAIL_REASON_MT_NOT_JOINED_CONF = 2;</code>
     */
    emFAIL_REASON_MT_NOT_JOINED_CONF(1, 2),
    /**
     * <code>emFAIL_REASON_CONF_IS_NOT_CPING = 3;</code>
     */
    emFAIL_REASON_CONF_IS_NOT_CPING(2, 3),
    /**
     * <code>emFAIL_REASON_MT_IS_NOT_CHAIR = 4;</code>
     */
    emFAIL_REASON_MT_IS_NOT_CHAIR(3, 4),
    /**
     * <code>emFAIL_REASON_CONF_IS_NOT_DIALOG_MODE = 5;</code>
     */
    emFAIL_REASON_CONF_IS_NOT_DIALOG_MODE(4, 5),
    /**
     * <code>emFAIL_REASON_NO_IDLE_CONF_RESOURCE = 6;</code>
     */
    emFAIL_REASON_NO_IDLE_CONF_RESOURCE(5, 6),
    /**
     * <code>emFAIL_REASON_CONF_RESOURCE_LACK = 7;</code>
     */
    emFAIL_REASON_CONF_RESOURCE_LACK(6, 7),
    /**
     * <code>emFAIL_REASON_MT_IN_DIALOG = 8;</code>
     */
    emFAIL_REASON_MT_IN_DIALOG(7, 8),
    /**
     * <code>emFAIL_REASON_SEL_MT_VID_OVER_CHNNL_NUM = 9;</code>
     *
     * <pre>
     *视频选看时，超过最大回传通道数
     * </pre>
     */
    emFAIL_REASON_SEL_MT_VID_OVER_CHNNL_NUM(8, 9),
    /**
     * <code>emFAIL_REASON_SEL_MT_AUD_OVER_CHNNL_NUM = 10;</code>
     *
     * <pre>
     *音频选看时，超过最大回传通道数
     * </pre>
     */
    emFAIL_REASON_SEL_MT_AUD_OVER_CHNNL_NUM(9, 10),
    /**
     * <code>emFAIL_REASON_SEL_MT_BOTH_OVER_CHNNL_NUM = 11;</code>
     *
     * <pre>
     *音视频选看时，超过最大回传通道数
     * </pre>
     */
    emFAIL_REASON_SEL_MT_BOTH_OVER_CHNNL_NUM(10, 11),
    /**
     * <code>emFAIL_REASON_CAN_NOT_JION_VMP_BY_OVER_CHNNL_NUM = 12;</code>
     *
     * <pre>
     *自动、对讲画面合成时，由于回传通道数的限制未能加入到画面合成中
     * </pre>
     */
    emFAIL_REASON_CAN_NOT_JION_VMP_BY_OVER_CHNNL_NUM(11, 12),
    /**
     * <code>emFAIL_REASON_CAN_NOT_JION_MIX_BY_OVER_CHNNL_NUM = 13;</code>
     *
     * <pre>
     *会议讨论时，由于回传通道数的限制未能加入到讨论组中
     * </pre>
     */
    emFAIL_REASON_CAN_NOT_JION_MIX_BY_OVER_CHNNL_NUM(12, 13),
    /**
     * <code>emFAIL_REASON_CHANGE_VMP_ASK_FALSE = 14;</code>
     *
     * <pre>
     *终端申请对话方失败
     * </pre>
     */
    emFAIL_REASON_CHANGE_VMP_ASK_FALSE(13, 14),
    /**
     * <code>emFAIL_REASON_CAN_NOT_JION_CTRY_VMP_BY_OVER_CHNNL_NUM = 15;</code>
     *
     * <pre>
     *会议模板定制画面合成时，由于回传通道数的限制未能加入到画面合成中
     * </pre>
     */
    emFAIL_REASON_CAN_NOT_JION_CTRY_VMP_BY_OVER_CHNNL_NUM(14, 15),
    ;

    /**
     * <code>emFAIL_REASON_DIFF_CONF_ENCRYPT_MODE = 1;</code>
     */
    public static final int emFAIL_REASON_DIFF_CONF_ENCRYPT_MODE_VALUE = 1;
    /**
     * <code>emFAIL_REASON_MT_NOT_JOINED_CONF = 2;</code>
     */
    public static final int emFAIL_REASON_MT_NOT_JOINED_CONF_VALUE = 2;
    /**
     * <code>emFAIL_REASON_CONF_IS_NOT_CPING = 3;</code>
     */
    public static final int emFAIL_REASON_CONF_IS_NOT_CPING_VALUE = 3;
    /**
     * <code>emFAIL_REASON_MT_IS_NOT_CHAIR = 4;</code>
     */
    public static final int emFAIL_REASON_MT_IS_NOT_CHAIR_VALUE = 4;
    /**
     * <code>emFAIL_REASON_CONF_IS_NOT_DIALOG_MODE = 5;</code>
     */
    public static final int emFAIL_REASON_CONF_IS_NOT_DIALOG_MODE_VALUE = 5;
    /**
     * <code>emFAIL_REASON_NO_IDLE_CONF_RESOURCE = 6;</code>
     */
    public static final int emFAIL_REASON_NO_IDLE_CONF_RESOURCE_VALUE = 6;
    /**
     * <code>emFAIL_REASON_CONF_RESOURCE_LACK = 7;</code>
     */
    public static final int emFAIL_REASON_CONF_RESOURCE_LACK_VALUE = 7;
    /**
     * <code>emFAIL_REASON_MT_IN_DIALOG = 8;</code>
     */
    public static final int emFAIL_REASON_MT_IN_DIALOG_VALUE = 8;
    /**
     * <code>emFAIL_REASON_SEL_MT_VID_OVER_CHNNL_NUM = 9;</code>
     *
     * <pre>
     *视频选看时，超过最大回传通道数
     * </pre>
     */
    public static final int emFAIL_REASON_SEL_MT_VID_OVER_CHNNL_NUM_VALUE = 9;
    /**
     * <code>emFAIL_REASON_SEL_MT_AUD_OVER_CHNNL_NUM = 10;</code>
     *
     * <pre>
     *音频选看时，超过最大回传通道数
     * </pre>
     */
    public static final int emFAIL_REASON_SEL_MT_AUD_OVER_CHNNL_NUM_VALUE = 10;
    /**
     * <code>emFAIL_REASON_SEL_MT_BOTH_OVER_CHNNL_NUM = 11;</code>
     *
     * <pre>
     *音视频选看时，超过最大回传通道数
     * </pre>
     */
    public static final int emFAIL_REASON_SEL_MT_BOTH_OVER_CHNNL_NUM_VALUE = 11;
    /**
     * <code>emFAIL_REASON_CAN_NOT_JION_VMP_BY_OVER_CHNNL_NUM = 12;</code>
     *
     * <pre>
     *自动、对讲画面合成时，由于回传通道数的限制未能加入到画面合成中
     * </pre>
     */
    public static final int emFAIL_REASON_CAN_NOT_JION_VMP_BY_OVER_CHNNL_NUM_VALUE = 12;
    /**
     * <code>emFAIL_REASON_CAN_NOT_JION_MIX_BY_OVER_CHNNL_NUM = 13;</code>
     *
     * <pre>
     *会议讨论时，由于回传通道数的限制未能加入到讨论组中
     * </pre>
     */
    public static final int emFAIL_REASON_CAN_NOT_JION_MIX_BY_OVER_CHNNL_NUM_VALUE = 13;
    /**
     * <code>emFAIL_REASON_CHANGE_VMP_ASK_FALSE = 14;</code>
     *
     * <pre>
     *终端申请对话方失败
     * </pre>
     */
    public static final int emFAIL_REASON_CHANGE_VMP_ASK_FALSE_VALUE = 14;
    /**
     * <code>emFAIL_REASON_CAN_NOT_JION_CTRY_VMP_BY_OVER_CHNNL_NUM = 15;</code>
     *
     * <pre>
     *会议模板定制画面合成时，由于回传通道数的限制未能加入到画面合成中
     * </pre>
     */
    public static final int emFAIL_REASON_CAN_NOT_JION_CTRY_VMP_BY_OVER_CHNNL_NUM_VALUE = 15;


    public final int getNumber() { return value; }

    public static EmMtConfFailureReason valueOf(int value) {
      switch (value) {
        case 1: return emFAIL_REASON_DIFF_CONF_ENCRYPT_MODE;
        case 2: return emFAIL_REASON_MT_NOT_JOINED_CONF;
        case 3: return emFAIL_REASON_CONF_IS_NOT_CPING;
        case 4: return emFAIL_REASON_MT_IS_NOT_CHAIR;
        case 5: return emFAIL_REASON_CONF_IS_NOT_DIALOG_MODE;
        case 6: return emFAIL_REASON_NO_IDLE_CONF_RESOURCE;
        case 7: return emFAIL_REASON_CONF_RESOURCE_LACK;
        case 8: return emFAIL_REASON_MT_IN_DIALOG;
        case 9: return emFAIL_REASON_SEL_MT_VID_OVER_CHNNL_NUM;
        case 10: return emFAIL_REASON_SEL_MT_AUD_OVER_CHNNL_NUM;
        case 11: return emFAIL_REASON_SEL_MT_BOTH_OVER_CHNNL_NUM;
        case 12: return emFAIL_REASON_CAN_NOT_JION_VMP_BY_OVER_CHNNL_NUM;
        case 13: return emFAIL_REASON_CAN_NOT_JION_MIX_BY_OVER_CHNNL_NUM;
        case 14: return emFAIL_REASON_CHANGE_VMP_ASK_FALSE;
        case 15: return emFAIL_REASON_CAN_NOT_JION_CTRY_VMP_BY_OVER_CHNNL_NUM;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtConfFailureReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtConfFailureReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtConfFailureReason>() {
            public EmMtConfFailureReason findValueByNumber(int number) {
              return EmMtConfFailureReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(70);
    }

    private static final EmMtConfFailureReason[] VALUES = values();

    public static EmMtConfFailureReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtConfFailureReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtConfFailureReason)
  }

  /**
   * Protobuf enum {@code mt.EmMtConfReleaseModeDef}
   */
  public enum EmMtConfReleaseModeDef
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCONF_RELEASEMODE_NONE = 0;</code>
     *
     * <pre>
     *不会自动结束
     * </pre>
     */
    emCONF_RELEASEMODE_NONE(0, 0),
    /**
     * <code>emCONF_RELEASEMODE_NOMT = 1;</code>
     *
     * <pre>
     *无终端时自动结束
     * </pre>
     */
    emCONF_RELEASEMODE_NOMT(1, 1),
    ;

    /**
     * <code>emCONF_RELEASEMODE_NONE = 0;</code>
     *
     * <pre>
     *不会自动结束
     * </pre>
     */
    public static final int emCONF_RELEASEMODE_NONE_VALUE = 0;
    /**
     * <code>emCONF_RELEASEMODE_NOMT = 1;</code>
     *
     * <pre>
     *无终端时自动结束
     * </pre>
     */
    public static final int emCONF_RELEASEMODE_NOMT_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmMtConfReleaseModeDef valueOf(int value) {
      switch (value) {
        case 0: return emCONF_RELEASEMODE_NONE;
        case 1: return emCONF_RELEASEMODE_NOMT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtConfReleaseModeDef>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtConfReleaseModeDef>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtConfReleaseModeDef>() {
            public EmMtConfReleaseModeDef findValueByNumber(int number) {
              return EmMtConfReleaseModeDef.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(71);
    }

    private static final EmMtConfReleaseModeDef[] VALUES = values();

    public static EmMtConfReleaseModeDef valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtConfReleaseModeDef(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtConfReleaseModeDef)
  }

  /**
   * Protobuf enum {@code mt.EmMtAliasType}
   */
  public enum EmMtAliasType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emBegin = 0;</code>
     */
    emBegin(0, 0),
    /**
     * <code>emE164 = 1;</code>
     *
     * <pre>
     *e164
     * </pre>
     */
    emE164(1, 1),
    /**
     * <code>emAlias = 2;</code>
     *
     * <pre>
     *别名
     * </pre>
     */
    emAlias(2, 2),
    /**
     * <code>emEmail = 3;</code>
     *
     * <pre>
     *email
     * </pre>
     */
    emEmail(3, 3),
    /**
     * <code>emEpID = 4;</code>
     *
     * <pre>
     *epid
     * </pre>
     */
    emEpID(4, 4),
    /**
     * <code>emGKID = 5;</code>
     *
     * <pre>
     *gkid	                  
     * </pre>
     */
    emGKID(5, 5),
    ;

    /**
     * <code>emBegin = 0;</code>
     */
    public static final int emBegin_VALUE = 0;
    /**
     * <code>emE164 = 1;</code>
     *
     * <pre>
     *e164
     * </pre>
     */
    public static final int emE164_VALUE = 1;
    /**
     * <code>emAlias = 2;</code>
     *
     * <pre>
     *别名
     * </pre>
     */
    public static final int emAlias_VALUE = 2;
    /**
     * <code>emEmail = 3;</code>
     *
     * <pre>
     *email
     * </pre>
     */
    public static final int emEmail_VALUE = 3;
    /**
     * <code>emEpID = 4;</code>
     *
     * <pre>
     *epid
     * </pre>
     */
    public static final int emEpID_VALUE = 4;
    /**
     * <code>emGKID = 5;</code>
     *
     * <pre>
     *gkid	                  
     * </pre>
     */
    public static final int emGKID_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmMtAliasType valueOf(int value) {
      switch (value) {
        case 0: return emBegin;
        case 1: return emE164;
        case 2: return emAlias;
        case 3: return emEmail;
        case 4: return emEpID;
        case 5: return emGKID;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtAliasType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtAliasType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtAliasType>() {
            public EmMtAliasType findValueByNumber(int number) {
              return EmMtAliasType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(72);
    }

    private static final EmMtAliasType[] VALUES = values();

    public static EmMtAliasType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtAliasType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtAliasType)
  }

  /**
   * Protobuf enum {@code mt.EmMtOpenMode}
   */
  public enum EmMtOpenMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMt_OPEN = 1;</code>
     *
     * <pre>
     *完全开放
     * </pre>
     */
    emMt_OPEN(0, 1),
    /**
     * <code>emMt_Hide = 2;</code>
     *
     * <pre>
     * 隐藏会议，仅受邀列表里的终端可见
     * </pre>
     */
    emMt_Hide(1, 2),
    ;

    /**
     * <code>emMt_OPEN = 1;</code>
     *
     * <pre>
     *完全开放
     * </pre>
     */
    public static final int emMt_OPEN_VALUE = 1;
    /**
     * <code>emMt_Hide = 2;</code>
     *
     * <pre>
     * 隐藏会议，仅受邀列表里的终端可见
     * </pre>
     */
    public static final int emMt_Hide_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtOpenMode valueOf(int value) {
      switch (value) {
        case 1: return emMt_OPEN;
        case 2: return emMt_Hide;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtOpenMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtOpenMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtOpenMode>() {
            public EmMtOpenMode findValueByNumber(int number) {
              return EmMtOpenMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(73);
    }

    private static final EmMtOpenMode[] VALUES = values();

    public static EmMtOpenMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtOpenMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtOpenMode)
  }

  /**
   * Protobuf enum {@code mt.EmMtVmpMode}
   */
  public enum EmMtVmpMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMt_VMP_MODE_NONE = 0;</code>
     *
     * <pre>
     *不进行画面合成
     * </pre>
     */
    emMt_VMP_MODE_NONE(0, 0),
    /**
     * <code>emMt_VMP_MODE_CTRL = 1;</code>
     *
     * <pre>
     *会控或主席选择成员合成
     * </pre>
     */
    emMt_VMP_MODE_CTRL(1, 1),
    /**
     * <code>emMt_VMP_MODE_AUTO = 2;</code>
     *
     * <pre>
     *动态分屏与设置成员
     * </pre>
     */
    emMt_VMP_MODE_AUTO(2, 2),
    ;

    /**
     * <code>emMt_VMP_MODE_NONE = 0;</code>
     *
     * <pre>
     *不进行画面合成
     * </pre>
     */
    public static final int emMt_VMP_MODE_NONE_VALUE = 0;
    /**
     * <code>emMt_VMP_MODE_CTRL = 1;</code>
     *
     * <pre>
     *会控或主席选择成员合成
     * </pre>
     */
    public static final int emMt_VMP_MODE_CTRL_VALUE = 1;
    /**
     * <code>emMt_VMP_MODE_AUTO = 2;</code>
     *
     * <pre>
     *动态分屏与设置成员
     * </pre>
     */
    public static final int emMt_VMP_MODE_AUTO_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtVmpMode valueOf(int value) {
      switch (value) {
        case 0: return emMt_VMP_MODE_NONE;
        case 1: return emMt_VMP_MODE_CTRL;
        case 2: return emMt_VMP_MODE_AUTO;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtVmpMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtVmpMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtVmpMode>() {
            public EmMtVmpMode findValueByNumber(int number) {
              return EmMtVmpMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(74);
    }

    private static final EmMtVmpMode[] VALUES = values();

    public static EmMtVmpMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtVmpMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtVmpMode)
  }

  /**
   * Protobuf enum {@code mt.EmMtMixType}
   *
   * <pre>
   *根据CBB_EmMixModeDef
   * </pre>
   */
  public enum EmMtMixType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMcuNoMix = 0;</code>
     *
     * <pre>
     *不混音
     * </pre>
     */
    emMcuNoMix(0, 0),
    /**
     * <code>emMcuWholeMix = 1;</code>
     *
     * <pre>
     *全体混音
     * </pre>
     */
    emMcuWholeMix(1, 1),
    /**
     * <code>emMcuPartMix = 2;</code>
     *
     * <pre>
     *定制混音
     * </pre>
     */
    emMcuPartMix(2, 2),
    /**
     * <code>emMcuVacMix = 3;</code>
     *
     * <pre>
     *VAC 
     * </pre>
     */
    emMcuVacMix(3, 3),
    /**
     * <code>emMcuVacWholeMix = 4;</code>
     *
     * <pre>
     *带Vac的全体混音
     * </pre>
     */
    emMcuVacWholeMix(4, 4),
    /**
     * <code>emMcuSmartMix = 5;</code>
     *
     * <pre>
     *智能混音
     * </pre>
     */
    emMcuSmartMix(5, 5),
    ;

    /**
     * <code>emMcuNoMix = 0;</code>
     *
     * <pre>
     *不混音
     * </pre>
     */
    public static final int emMcuNoMix_VALUE = 0;
    /**
     * <code>emMcuWholeMix = 1;</code>
     *
     * <pre>
     *全体混音
     * </pre>
     */
    public static final int emMcuWholeMix_VALUE = 1;
    /**
     * <code>emMcuPartMix = 2;</code>
     *
     * <pre>
     *定制混音
     * </pre>
     */
    public static final int emMcuPartMix_VALUE = 2;
    /**
     * <code>emMcuVacMix = 3;</code>
     *
     * <pre>
     *VAC 
     * </pre>
     */
    public static final int emMcuVacMix_VALUE = 3;
    /**
     * <code>emMcuVacWholeMix = 4;</code>
     *
     * <pre>
     *带Vac的全体混音
     * </pre>
     */
    public static final int emMcuVacWholeMix_VALUE = 4;
    /**
     * <code>emMcuSmartMix = 5;</code>
     *
     * <pre>
     *智能混音
     * </pre>
     */
    public static final int emMcuSmartMix_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmMtMixType valueOf(int value) {
      switch (value) {
        case 0: return emMcuNoMix;
        case 1: return emMcuWholeMix;
        case 2: return emMcuPartMix;
        case 3: return emMcuVacMix;
        case 4: return emMcuVacWholeMix;
        case 5: return emMcuSmartMix;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtMixType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtMixType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtMixType>() {
            public EmMtMixType findValueByNumber(int number) {
              return EmMtMixType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(75);
    }

    private static final EmMtMixType[] VALUES = values();

    public static EmMtMixType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtMixType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtMixType)
  }

  /**
   * Protobuf enum {@code mt.EmMtCallDisReason}
   *
   * <pre>
   *&#47;/呼叫挂断原因
   * </pre>
   */
  public enum EmMtCallDisReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emDisconnect_Busy = 0;</code>
     *
     * <pre>
     *对端忙
     * </pre>
     */
    emDisconnect_Busy(0, 0),
    /**
     * <code>emDisconnect_Normal = 1;</code>
     *
     * <pre>
     *正常挂断
     * </pre>
     */
    emDisconnect_Normal(1, 1),
    /**
     * <code>emDisconnect_Rejected = 2;</code>
     *
     * <pre>
     *对端拒绝
     * </pre>
     */
    emDisconnect_Rejected(2, 2),
    /**
     * <code>emDisconnect_Unreachable = 3;</code>
     *
     * <pre>
     *对端不可达
     * </pre>
     */
    emDisconnect_Unreachable(3, 3),
    /**
     * <code>emDisconnect_Local = 4;</code>
     *
     * <pre>
     *本地原因
     * </pre>
     */
    emDisconnect_Local(4, 4),
    /**
     * <code>emDisconnect_Unknown = 5;</code>
     *
     * <pre>
     *未知原因
     * </pre>
     */
    emDisconnect_Unknown(5, 5),
    /**
     * <code>emDisconnect_AdaptiveBusy = 7;</code>
     *
     * <pre>
     *emDisconnect_custom = 6;         //自定义原因, 这个不需要了，
     * </pre>
     */
    emDisconnect_AdaptiveBusy(6, 7),
    /**
     * <code>emDisconnect_Occupy = 8;</code>
     *
     * <pre>
     *其他终端或者mcu抢断
     * </pre>
     */
    emDisconnect_Occupy(7, 8),
    /**
     * <code>emDisconnect_Joinconftimeout = 20;</code>
     *
     * <pre>
     * 参加会议超时
     * </pre>
     */
    emDisconnect_Joinconftimeout(8, 20),
    /**
     * <code>emDisconnect_Createconftimeout = 21;</code>
     *
     * <pre>
     * 召集会议超时
     * </pre>
     */
    emDisconnect_Createconftimeout(9, 21),
    /**
     * <code>emDisconnect_Nomediaresource = 22;</code>
     *
     * <pre>
     * 没有媒体资源
     * </pre>
     */
    emDisconnect_Nomediaresource(10, 22),
    /**
     * <code>emDisconnect_Exceedmaxinconfmtnum = 23;</code>
     *
     * <pre>
     * 超过会议最大终端数（参加会议时）
     * </pre>
     */
    emDisconnect_Exceedmaxinconfmtnum(11, 23),
    /**
     * <code>emDisconnect_Exceedmaxconfnum = 24;</code>
     *
     * <pre>
     * 超过会议最大数（创建会议时）
     * </pre>
     */
    emDisconnect_Exceedmaxconfnum(12, 24),
    /**
     * <code>emDisconnect_EncrypeErr = 25;</code>
     *
     * <pre>
     * 与会议加密模式不符
     * </pre>
     */
    emDisconnect_EncrypeErr(13, 25),
    /**
     * <code>emDisconnect_P2Ptimeout = 26;</code>
     *
     * <pre>
     * 点对点呼叫超时
     * </pre>
     */
    emDisconnect_P2Ptimeout(14, 26),
    /**
     * <code>emDisconnect_MccDrop = 27;</code>
     *
     * <pre>
     * 会控挂断
     * </pre>
     */
    emDisconnect_MccDrop(15, 27),
    /**
     * <code>emDisconnect_ChairDrop = 28;</code>
     *
     * <pre>
     * 主席挂断
     * </pre>
     */
    emDisconnect_ChairDrop(16, 28),
    /**
     * <code>emDisconnect_MMcuDrop = 29;</code>
     *
     * <pre>
     * 上级会议挂断
     * </pre>
     */
    emDisconnect_MMcuDrop(17, 29),
    /**
     * <code>emDisconnect_ConfRelease = 30;</code>
     *
     * <pre>
     * 会议结束挂断
     * </pre>
     */
    emDisconnect_ConfRelease(18, 30),
    /**
     * <code>emDisconnect_PeerInConf = 31;</code>
     *
     * <pre>
     *正在会议中
     * </pre>
     */
    emDisconnect_PeerInConf(19, 31),
    /**
     * <code>emDisconnect_PeerNoDisturb = 32;</code>
     *
     * <pre>
     *免打扰
     * </pre>
     */
    emDisconnect_PeerNoDisturb(20, 32),
    /**
     * <code>emDisconnect_NotInPeerContact = 33;</code>
     *
     * <pre>
     *非好友
     * </pre>
     */
    emDisconnect_NotInPeerContact(21, 33),
    /**
     * <code>emDisconnect_PeerNoP2PPermission = 34;</code>
     *
     * <pre>
     *对端无点对点权限
     * </pre>
     */
    emDisconnect_PeerNoP2PPermission(22, 34),
    /**
     * <code>emDisconnect_PeerOnSleeping = 35;</code>
     *
     * <pre>
     *对端正在待机
     * </pre>
     */
    emDisconnect_PeerOnSleeping(23, 35),
    /**
     * <code>emDisconnect_ConfAutoRelease = 36;</code>
     *
     * <pre>
     *会议自动结束挂断
     * </pre>
     */
    emDisconnect_ConfAutoRelease(24, 36),
    /**
     * <code>emDisconnect_REASON_BUSYEXT = 37;</code>
     *
     * <pre>
     *终端忙,带终端目前所在会议的级别及会议名称
     * </pre>
     */
    emDisconnect_REASON_BUSYEXT(25, 37),
    /**
     * <code>emDisconnect_REASON_REMOTERECONNECT = 38;</code>
     *
     * <pre>
     *本端行政级别低，由远端自动发起重连
     * </pre>
     */
    emDisconnect_REASON_REMOTERECONNECT(26, 38),
    /**
     * <code>emDisConnect_CallNumExceed = 39;</code>
     *
     * <pre>
     *呼叫数超限
     * </pre>
     */
    emDisConnect_CallNumExceed(27, 39),
    /**
     * <code>emDisConnect_NotRegedToCallFailed = 40;</code>
     *
     * <pre>
     *本地没有注册成功导致呼叫别名或者e164号码有问题
     * </pre>
     */
    emDisConnect_NotRegedToCallFailed(28, 40),
    /**
     * <code>emDisConnect_LocalVodPlaying = 41;</code>
     *
     * <pre>
     *本地正在vod点播中
     * </pre>
     */
    emDisConnect_LocalVodPlaying(29, 41),
    /**
     * <code>emDisConnect_SecCrtNotFind = 42;</code>
     *
     * <pre>
     *&#47;//sec 注册失败reason
     * </pre>
     */
    emDisConnect_SecCrtNotFind(30, 42),
    /**
     * <code>emDisConnect_SecCrtVerifyFail = 43;</code>
     *
     * <pre>
     *&#47;证书验证失败
     * </pre>
     */
    emDisConnect_SecCrtVerifyFail(31, 43),
    /**
     * <code>emDisConnect_SecCrtExpired = 44;</code>
     *
     * <pre>
     *&#47;证书过期 有效期错误
     * </pre>
     */
    emDisConnect_SecCrtExpired(32, 44),
    /**
     * <code>emDisConnect_SecCrtFormatError = 45;</code>
     *
     * <pre>
     *&#47;证书格式错误
     * </pre>
     */
    emDisConnect_SecCrtFormatError(33, 45),
    /**
     * <code>emDisConnect_SecLoadCertFailed = 46;</code>
     *
     * <pre>
     *&#47;证书加载失败
     * </pre>
     */
    emDisConnect_SecLoadCertFailed(34, 46),
    /**
     * <code>emDisConnect_SecEncTypeError = 47;</code>
     *
     * <pre>
     *&#47;加密类型未协商成功
     * </pre>
     */
    emDisConnect_SecEncTypeError(35, 47),
    /**
     * <code>emDisConnect_AuthenticationErr = 48;</code>
     *
     * <pre>
     *&#47;强认证报错 一般是终端未强认证主呼强认证会议
     * </pre>
     */
    emDisConnect_AuthenticationErr(36, 48),
    /**
     * <code>emDisConnect_MtHasInConf = 49;</code>
     *
     * <pre>
     *&#47; 主席邀请终端入会，该终端已经在会议
     * </pre>
     */
    emDisConnect_MtHasInConf(37, 49),
    /**
     * <code>emDisConnect_MtEviction = 50;</code>
     *
     * <pre>
     *&#47; 强拆方式主动退会
     * </pre>
     */
    emDisConnect_MtEviction(38, 50),
    /**
     * <code>emDisConnect_SoftIntegrityTestErr = 51;</code>
     *
     * <pre>
     *&#47;软件完整性自测试失败
     * </pre>
     */
    emDisConnect_SoftIntegrityTestErr(39, 51),
    /**
     * <code>emDisConnect_GmTestErr = 52;</code>
     *
     * <pre>
     *&#47;国密算法自测试失败
     * </pre>
     */
    emDisConnect_GmTestErr(40, 52),
    /**
     * <code>emDisConnect_RandomNumTestErr = 53;</code>
     *
     * <pre>
     *&#47;随机数自测试失败
     * </pre>
     */
    emDisConnect_RandomNumTestErr(41, 53),
    /**
     * <code>emDisConnect_StrongAuthButIpCallErr = 54;</code>
     *
     * <pre>
     *&#47;强认证，不允许ip呼叫
     * </pre>
     */
    emDisConnect_StrongAuthButIpCallErr(42, 54),
    /**
     * <code>emDisConnect_ChannelNoAuth = 55;</code>
     *
     * <pre>
     *&#47;渠道产品未经授权
     * </pre>
     */
    emDisConnect_ChannelNoAuth(43, 55),
    /**
     * <code>emDisConnect_QtCallButNotGetPeerE164 = 56;</code>
     *
     * <pre>
     *&#47;量通呼叫，没有获取到对端的e164号码
     * </pre>
     */
    emDisConnect_QtCallButNotGetPeerE164(44, 56),
    /**
     * <code>emDisconnect_CancleInputPwd = 57;</code>
     *
     * <pre>
     *&#47;&lt; 取消输入会议密码
     * </pre>
     */
    emDisconnect_CancleInputPwd(45, 57),
    /**
     * <code>emDisconnect_End = 100;</code>
     *
     * <pre>
     *前面用于扩展
     * </pre>
     */
    emDisconnect_End(46, 100),
    ;

    /**
     * <code>emDisconnect_Busy = 0;</code>
     *
     * <pre>
     *对端忙
     * </pre>
     */
    public static final int emDisconnect_Busy_VALUE = 0;
    /**
     * <code>emDisconnect_Normal = 1;</code>
     *
     * <pre>
     *正常挂断
     * </pre>
     */
    public static final int emDisconnect_Normal_VALUE = 1;
    /**
     * <code>emDisconnect_Rejected = 2;</code>
     *
     * <pre>
     *对端拒绝
     * </pre>
     */
    public static final int emDisconnect_Rejected_VALUE = 2;
    /**
     * <code>emDisconnect_Unreachable = 3;</code>
     *
     * <pre>
     *对端不可达
     * </pre>
     */
    public static final int emDisconnect_Unreachable_VALUE = 3;
    /**
     * <code>emDisconnect_Local = 4;</code>
     *
     * <pre>
     *本地原因
     * </pre>
     */
    public static final int emDisconnect_Local_VALUE = 4;
    /**
     * <code>emDisconnect_Unknown = 5;</code>
     *
     * <pre>
     *未知原因
     * </pre>
     */
    public static final int emDisconnect_Unknown_VALUE = 5;
    /**
     * <code>emDisconnect_AdaptiveBusy = 7;</code>
     *
     * <pre>
     *emDisconnect_custom = 6;         //自定义原因, 这个不需要了，
     * </pre>
     */
    public static final int emDisconnect_AdaptiveBusy_VALUE = 7;
    /**
     * <code>emDisconnect_Occupy = 8;</code>
     *
     * <pre>
     *其他终端或者mcu抢断
     * </pre>
     */
    public static final int emDisconnect_Occupy_VALUE = 8;
    /**
     * <code>emDisconnect_Joinconftimeout = 20;</code>
     *
     * <pre>
     * 参加会议超时
     * </pre>
     */
    public static final int emDisconnect_Joinconftimeout_VALUE = 20;
    /**
     * <code>emDisconnect_Createconftimeout = 21;</code>
     *
     * <pre>
     * 召集会议超时
     * </pre>
     */
    public static final int emDisconnect_Createconftimeout_VALUE = 21;
    /**
     * <code>emDisconnect_Nomediaresource = 22;</code>
     *
     * <pre>
     * 没有媒体资源
     * </pre>
     */
    public static final int emDisconnect_Nomediaresource_VALUE = 22;
    /**
     * <code>emDisconnect_Exceedmaxinconfmtnum = 23;</code>
     *
     * <pre>
     * 超过会议最大终端数（参加会议时）
     * </pre>
     */
    public static final int emDisconnect_Exceedmaxinconfmtnum_VALUE = 23;
    /**
     * <code>emDisconnect_Exceedmaxconfnum = 24;</code>
     *
     * <pre>
     * 超过会议最大数（创建会议时）
     * </pre>
     */
    public static final int emDisconnect_Exceedmaxconfnum_VALUE = 24;
    /**
     * <code>emDisconnect_EncrypeErr = 25;</code>
     *
     * <pre>
     * 与会议加密模式不符
     * </pre>
     */
    public static final int emDisconnect_EncrypeErr_VALUE = 25;
    /**
     * <code>emDisconnect_P2Ptimeout = 26;</code>
     *
     * <pre>
     * 点对点呼叫超时
     * </pre>
     */
    public static final int emDisconnect_P2Ptimeout_VALUE = 26;
    /**
     * <code>emDisconnect_MccDrop = 27;</code>
     *
     * <pre>
     * 会控挂断
     * </pre>
     */
    public static final int emDisconnect_MccDrop_VALUE = 27;
    /**
     * <code>emDisconnect_ChairDrop = 28;</code>
     *
     * <pre>
     * 主席挂断
     * </pre>
     */
    public static final int emDisconnect_ChairDrop_VALUE = 28;
    /**
     * <code>emDisconnect_MMcuDrop = 29;</code>
     *
     * <pre>
     * 上级会议挂断
     * </pre>
     */
    public static final int emDisconnect_MMcuDrop_VALUE = 29;
    /**
     * <code>emDisconnect_ConfRelease = 30;</code>
     *
     * <pre>
     * 会议结束挂断
     * </pre>
     */
    public static final int emDisconnect_ConfRelease_VALUE = 30;
    /**
     * <code>emDisconnect_PeerInConf = 31;</code>
     *
     * <pre>
     *正在会议中
     * </pre>
     */
    public static final int emDisconnect_PeerInConf_VALUE = 31;
    /**
     * <code>emDisconnect_PeerNoDisturb = 32;</code>
     *
     * <pre>
     *免打扰
     * </pre>
     */
    public static final int emDisconnect_PeerNoDisturb_VALUE = 32;
    /**
     * <code>emDisconnect_NotInPeerContact = 33;</code>
     *
     * <pre>
     *非好友
     * </pre>
     */
    public static final int emDisconnect_NotInPeerContact_VALUE = 33;
    /**
     * <code>emDisconnect_PeerNoP2PPermission = 34;</code>
     *
     * <pre>
     *对端无点对点权限
     * </pre>
     */
    public static final int emDisconnect_PeerNoP2PPermission_VALUE = 34;
    /**
     * <code>emDisconnect_PeerOnSleeping = 35;</code>
     *
     * <pre>
     *对端正在待机
     * </pre>
     */
    public static final int emDisconnect_PeerOnSleeping_VALUE = 35;
    /**
     * <code>emDisconnect_ConfAutoRelease = 36;</code>
     *
     * <pre>
     *会议自动结束挂断
     * </pre>
     */
    public static final int emDisconnect_ConfAutoRelease_VALUE = 36;
    /**
     * <code>emDisconnect_REASON_BUSYEXT = 37;</code>
     *
     * <pre>
     *终端忙,带终端目前所在会议的级别及会议名称
     * </pre>
     */
    public static final int emDisconnect_REASON_BUSYEXT_VALUE = 37;
    /**
     * <code>emDisconnect_REASON_REMOTERECONNECT = 38;</code>
     *
     * <pre>
     *本端行政级别低，由远端自动发起重连
     * </pre>
     */
    public static final int emDisconnect_REASON_REMOTERECONNECT_VALUE = 38;
    /**
     * <code>emDisConnect_CallNumExceed = 39;</code>
     *
     * <pre>
     *呼叫数超限
     * </pre>
     */
    public static final int emDisConnect_CallNumExceed_VALUE = 39;
    /**
     * <code>emDisConnect_NotRegedToCallFailed = 40;</code>
     *
     * <pre>
     *本地没有注册成功导致呼叫别名或者e164号码有问题
     * </pre>
     */
    public static final int emDisConnect_NotRegedToCallFailed_VALUE = 40;
    /**
     * <code>emDisConnect_LocalVodPlaying = 41;</code>
     *
     * <pre>
     *本地正在vod点播中
     * </pre>
     */
    public static final int emDisConnect_LocalVodPlaying_VALUE = 41;
    /**
     * <code>emDisConnect_SecCrtNotFind = 42;</code>
     *
     * <pre>
     *&#47;//sec 注册失败reason
     * </pre>
     */
    public static final int emDisConnect_SecCrtNotFind_VALUE = 42;
    /**
     * <code>emDisConnect_SecCrtVerifyFail = 43;</code>
     *
     * <pre>
     *&#47;证书验证失败
     * </pre>
     */
    public static final int emDisConnect_SecCrtVerifyFail_VALUE = 43;
    /**
     * <code>emDisConnect_SecCrtExpired = 44;</code>
     *
     * <pre>
     *&#47;证书过期 有效期错误
     * </pre>
     */
    public static final int emDisConnect_SecCrtExpired_VALUE = 44;
    /**
     * <code>emDisConnect_SecCrtFormatError = 45;</code>
     *
     * <pre>
     *&#47;证书格式错误
     * </pre>
     */
    public static final int emDisConnect_SecCrtFormatError_VALUE = 45;
    /**
     * <code>emDisConnect_SecLoadCertFailed = 46;</code>
     *
     * <pre>
     *&#47;证书加载失败
     * </pre>
     */
    public static final int emDisConnect_SecLoadCertFailed_VALUE = 46;
    /**
     * <code>emDisConnect_SecEncTypeError = 47;</code>
     *
     * <pre>
     *&#47;加密类型未协商成功
     * </pre>
     */
    public static final int emDisConnect_SecEncTypeError_VALUE = 47;
    /**
     * <code>emDisConnect_AuthenticationErr = 48;</code>
     *
     * <pre>
     *&#47;强认证报错 一般是终端未强认证主呼强认证会议
     * </pre>
     */
    public static final int emDisConnect_AuthenticationErr_VALUE = 48;
    /**
     * <code>emDisConnect_MtHasInConf = 49;</code>
     *
     * <pre>
     *&#47; 主席邀请终端入会，该终端已经在会议
     * </pre>
     */
    public static final int emDisConnect_MtHasInConf_VALUE = 49;
    /**
     * <code>emDisConnect_MtEviction = 50;</code>
     *
     * <pre>
     *&#47; 强拆方式主动退会
     * </pre>
     */
    public static final int emDisConnect_MtEviction_VALUE = 50;
    /**
     * <code>emDisConnect_SoftIntegrityTestErr = 51;</code>
     *
     * <pre>
     *&#47;软件完整性自测试失败
     * </pre>
     */
    public static final int emDisConnect_SoftIntegrityTestErr_VALUE = 51;
    /**
     * <code>emDisConnect_GmTestErr = 52;</code>
     *
     * <pre>
     *&#47;国密算法自测试失败
     * </pre>
     */
    public static final int emDisConnect_GmTestErr_VALUE = 52;
    /**
     * <code>emDisConnect_RandomNumTestErr = 53;</code>
     *
     * <pre>
     *&#47;随机数自测试失败
     * </pre>
     */
    public static final int emDisConnect_RandomNumTestErr_VALUE = 53;
    /**
     * <code>emDisConnect_StrongAuthButIpCallErr = 54;</code>
     *
     * <pre>
     *&#47;强认证，不允许ip呼叫
     * </pre>
     */
    public static final int emDisConnect_StrongAuthButIpCallErr_VALUE = 54;
    /**
     * <code>emDisConnect_ChannelNoAuth = 55;</code>
     *
     * <pre>
     *&#47;渠道产品未经授权
     * </pre>
     */
    public static final int emDisConnect_ChannelNoAuth_VALUE = 55;
    /**
     * <code>emDisConnect_QtCallButNotGetPeerE164 = 56;</code>
     *
     * <pre>
     *&#47;量通呼叫，没有获取到对端的e164号码
     * </pre>
     */
    public static final int emDisConnect_QtCallButNotGetPeerE164_VALUE = 56;
    /**
     * <code>emDisconnect_CancleInputPwd = 57;</code>
     *
     * <pre>
     *&#47;&lt; 取消输入会议密码
     * </pre>
     */
    public static final int emDisconnect_CancleInputPwd_VALUE = 57;
    /**
     * <code>emDisconnect_End = 100;</code>
     *
     * <pre>
     *前面用于扩展
     * </pre>
     */
    public static final int emDisconnect_End_VALUE = 100;


    public final int getNumber() { return value; }

    public static EmMtCallDisReason valueOf(int value) {
      switch (value) {
        case 0: return emDisconnect_Busy;
        case 1: return emDisconnect_Normal;
        case 2: return emDisconnect_Rejected;
        case 3: return emDisconnect_Unreachable;
        case 4: return emDisconnect_Local;
        case 5: return emDisconnect_Unknown;
        case 7: return emDisconnect_AdaptiveBusy;
        case 8: return emDisconnect_Occupy;
        case 20: return emDisconnect_Joinconftimeout;
        case 21: return emDisconnect_Createconftimeout;
        case 22: return emDisconnect_Nomediaresource;
        case 23: return emDisconnect_Exceedmaxinconfmtnum;
        case 24: return emDisconnect_Exceedmaxconfnum;
        case 25: return emDisconnect_EncrypeErr;
        case 26: return emDisconnect_P2Ptimeout;
        case 27: return emDisconnect_MccDrop;
        case 28: return emDisconnect_ChairDrop;
        case 29: return emDisconnect_MMcuDrop;
        case 30: return emDisconnect_ConfRelease;
        case 31: return emDisconnect_PeerInConf;
        case 32: return emDisconnect_PeerNoDisturb;
        case 33: return emDisconnect_NotInPeerContact;
        case 34: return emDisconnect_PeerNoP2PPermission;
        case 35: return emDisconnect_PeerOnSleeping;
        case 36: return emDisconnect_ConfAutoRelease;
        case 37: return emDisconnect_REASON_BUSYEXT;
        case 38: return emDisconnect_REASON_REMOTERECONNECT;
        case 39: return emDisConnect_CallNumExceed;
        case 40: return emDisConnect_NotRegedToCallFailed;
        case 41: return emDisConnect_LocalVodPlaying;
        case 42: return emDisConnect_SecCrtNotFind;
        case 43: return emDisConnect_SecCrtVerifyFail;
        case 44: return emDisConnect_SecCrtExpired;
        case 45: return emDisConnect_SecCrtFormatError;
        case 46: return emDisConnect_SecLoadCertFailed;
        case 47: return emDisConnect_SecEncTypeError;
        case 48: return emDisConnect_AuthenticationErr;
        case 49: return emDisConnect_MtHasInConf;
        case 50: return emDisConnect_MtEviction;
        case 51: return emDisConnect_SoftIntegrityTestErr;
        case 52: return emDisConnect_GmTestErr;
        case 53: return emDisConnect_RandomNumTestErr;
        case 54: return emDisConnect_StrongAuthButIpCallErr;
        case 55: return emDisConnect_ChannelNoAuth;
        case 56: return emDisConnect_QtCallButNotGetPeerE164;
        case 57: return emDisconnect_CancleInputPwd;
        case 100: return emDisconnect_End;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtCallDisReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtCallDisReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtCallDisReason>() {
            public EmMtCallDisReason findValueByNumber(int number) {
              return EmMtCallDisReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(76);
    }

    private static final EmMtCallDisReason[] VALUES = values();

    public static EmMtCallDisReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtCallDisReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtCallDisReason)
  }

  /**
   * Protobuf enum {@code mt.EmUnRegFailedReason}
   */
  public enum EmUnRegFailedReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emURJRecived = 0;</code>
     *
     * <pre>
     *收到GK URJ
     * </pre>
     */
    emURJRecived(0, 0),
    /**
     * <code>emURQSendFailed = 1;</code>
     *
     * <pre>
     *发送URQ失败
     * </pre>
     */
    emURQSendFailed(1, 1),
    /**
     * <code>emURQCreateHRASFailed = 2;</code>
     *
     * <pre>
     *协议栈创建HRAS句柄失败
     * </pre>
     */
    emURQCreateHRASFailed(2, 2),
    ;

    /**
     * <code>emURJRecived = 0;</code>
     *
     * <pre>
     *收到GK URJ
     * </pre>
     */
    public static final int emURJRecived_VALUE = 0;
    /**
     * <code>emURQSendFailed = 1;</code>
     *
     * <pre>
     *发送URQ失败
     * </pre>
     */
    public static final int emURQSendFailed_VALUE = 1;
    /**
     * <code>emURQCreateHRASFailed = 2;</code>
     *
     * <pre>
     *协议栈创建HRAS句柄失败
     * </pre>
     */
    public static final int emURQCreateHRASFailed_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmUnRegFailedReason valueOf(int value) {
      switch (value) {
        case 0: return emURJRecived;
        case 1: return emURQSendFailed;
        case 2: return emURQCreateHRASFailed;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmUnRegFailedReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmUnRegFailedReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmUnRegFailedReason>() {
            public EmUnRegFailedReason findValueByNumber(int number) {
              return EmUnRegFailedReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(77);
    }

    private static final EmUnRegFailedReason[] VALUES = values();

    public static EmUnRegFailedReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmUnRegFailedReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmUnRegFailedReason)
  }

  /**
   * Protobuf enum {@code mt.EmRegFailedReason}
   */
  public enum EmRegFailedReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emGKFailedBegin = 0;</code>
     */
    emGKFailedBegin(0, 0),
    /**
     * <code>emGKUnReachable = 1;</code>
     *
     * <pre>
     *&#47;不可达
     * </pre>
     */
    emGKUnReachable(1, 1),
    /**
     * <code>emInvalidAliase = 2;</code>
     */
    emInvalidAliase(2, 2),
    /**
     * <code>emDupAlias = 3;</code>
     */
    emDupAlias(3, 3),
    /**
     * <code>emInvalidCallAddress = 4;</code>
     */
    emInvalidCallAddress(4, 4),
    /**
     * <code>emResourceUnavailable = 5;</code>
     *
     * <pre>
     *&#47;不可达
     * </pre>
     */
    emResourceUnavailable(5, 5),
    /**
     * <code>emRegNumberFull = 7;</code>
     *
     * <pre>
     *注册数量满，PCMT绑定GK失败消息提示
     * </pre>
     */
    emRegNumberFull(6, 7),
    /**
     * <code>emGKSecurityDenial = 8;</code>
     *
     * <pre>
     *GK注册权限失败
     * </pre>
     */
    emGKSecurityDenial(7, 8),
    /**
     * <code>emGKDismatch = 9;</code>
     *
     * <pre>
     *GK不是运营版本,服务器不匹配
     * </pre>
     */
    emGKDismatch(8, 9),
    /**
     * <code>emUnRegGKReq = 10;</code>
     *
     * <pre>
     *GK被抢登后，要求注销GK
     * </pre>
     */
    emUnRegGKReq(9, 10),
    /**
     * <code>emRRQCreateHRASFailed = 11;</code>
     *
     * <pre>
     *rrq创建句柄失败
     * </pre>
     */
    emRRQCreateHRASFailed(10, 11),
    /**
     * <code>emRRQSendFailed = 12;</code>
     *
     * <pre>
     *rrq发送失败
     * </pre>
     */
    emRRQSendFailed(11, 12),
    /**
     * <code>emSipFailedBegin = 50;</code>
     *
     * <pre>
     *sip注册失败原因开始
     * </pre>
     */
    emSipFailedBegin(12, 50),
    /**
     * <code>emSipLocalNormalUnreg = 51;</code>
     */
    emSipLocalNormalUnreg(13, 51),
    /**
     * <code>emSipInvalidUserNameAndPassword = 52;</code>
     */
    emSipInvalidUserNameAndPassword(14, 52),
    /**
     * <code>emSipRegistrarUnReachable = 53;</code>
     */
    emSipRegistrarUnReachable(15, 53),
    /**
     * <code>emSipInvalidAlias = 54;</code>
     */
    emSipInvalidAlias(16, 54),
    /**
     * <code>emSipUnknownReason = 55;</code>
     */
    emSipUnknownReason(17, 55),
    /**
     * <code>emSipRegisterFailed = 56;</code>
     */
    emSipRegisterFailed(18, 56),
    /**
     * <code>emSipRegisterNameDup = 57;</code>
     */
    emSipRegisterNameDup(19, 57),
    /**
     * <code>emSecCrtNotFind = 58;</code>
     *
     * <pre>
     *&#47;//sec 注册失败reason
     * </pre>
     */
    emSecCrtNotFind(20, 58),
    /**
     * <code>emSecCrtVerifyFail = 59;</code>
     *
     * <pre>
     *&#47;证书验证失败
     * </pre>
     */
    emSecCrtVerifyFail(21, 59),
    /**
     * <code>emSecCrtExpired = 60;</code>
     *
     * <pre>
     *&#47;证书过期 有效期错误
     * </pre>
     */
    emSecCrtExpired(22, 60),
    /**
     * <code>emSecCrtFormatError = 61;</code>
     *
     * <pre>
     *&#47;证书格式错误
     * </pre>
     */
    emSecCrtFormatError(23, 61),
    /**
     * <code>emSecLoadCertFailed = 62;</code>
     *
     * <pre>
     *&#47;证书加载失败
     * </pre>
     */
    emSecLoadCertFailed(24, 62),
    /**
     * <code>emUnRegSuc = 90;</code>
     *
     * <pre>
     *&#47;取消注册成功 
     * </pre>
     */
    emUnRegSuc(25, 90),
    ;

    /**
     * <code>emGKFailedBegin = 0;</code>
     */
    public static final int emGKFailedBegin_VALUE = 0;
    /**
     * <code>emGKUnReachable = 1;</code>
     *
     * <pre>
     *&#47;不可达
     * </pre>
     */
    public static final int emGKUnReachable_VALUE = 1;
    /**
     * <code>emInvalidAliase = 2;</code>
     */
    public static final int emInvalidAliase_VALUE = 2;
    /**
     * <code>emDupAlias = 3;</code>
     */
    public static final int emDupAlias_VALUE = 3;
    /**
     * <code>emInvalidCallAddress = 4;</code>
     */
    public static final int emInvalidCallAddress_VALUE = 4;
    /**
     * <code>emResourceUnavailable = 5;</code>
     *
     * <pre>
     *&#47;不可达
     * </pre>
     */
    public static final int emResourceUnavailable_VALUE = 5;
    /**
     * <code>emRegNumberFull = 7;</code>
     *
     * <pre>
     *注册数量满，PCMT绑定GK失败消息提示
     * </pre>
     */
    public static final int emRegNumberFull_VALUE = 7;
    /**
     * <code>emGKSecurityDenial = 8;</code>
     *
     * <pre>
     *GK注册权限失败
     * </pre>
     */
    public static final int emGKSecurityDenial_VALUE = 8;
    /**
     * <code>emGKDismatch = 9;</code>
     *
     * <pre>
     *GK不是运营版本,服务器不匹配
     * </pre>
     */
    public static final int emGKDismatch_VALUE = 9;
    /**
     * <code>emUnRegGKReq = 10;</code>
     *
     * <pre>
     *GK被抢登后，要求注销GK
     * </pre>
     */
    public static final int emUnRegGKReq_VALUE = 10;
    /**
     * <code>emRRQCreateHRASFailed = 11;</code>
     *
     * <pre>
     *rrq创建句柄失败
     * </pre>
     */
    public static final int emRRQCreateHRASFailed_VALUE = 11;
    /**
     * <code>emRRQSendFailed = 12;</code>
     *
     * <pre>
     *rrq发送失败
     * </pre>
     */
    public static final int emRRQSendFailed_VALUE = 12;
    /**
     * <code>emSipFailedBegin = 50;</code>
     *
     * <pre>
     *sip注册失败原因开始
     * </pre>
     */
    public static final int emSipFailedBegin_VALUE = 50;
    /**
     * <code>emSipLocalNormalUnreg = 51;</code>
     */
    public static final int emSipLocalNormalUnreg_VALUE = 51;
    /**
     * <code>emSipInvalidUserNameAndPassword = 52;</code>
     */
    public static final int emSipInvalidUserNameAndPassword_VALUE = 52;
    /**
     * <code>emSipRegistrarUnReachable = 53;</code>
     */
    public static final int emSipRegistrarUnReachable_VALUE = 53;
    /**
     * <code>emSipInvalidAlias = 54;</code>
     */
    public static final int emSipInvalidAlias_VALUE = 54;
    /**
     * <code>emSipUnknownReason = 55;</code>
     */
    public static final int emSipUnknownReason_VALUE = 55;
    /**
     * <code>emSipRegisterFailed = 56;</code>
     */
    public static final int emSipRegisterFailed_VALUE = 56;
    /**
     * <code>emSipRegisterNameDup = 57;</code>
     */
    public static final int emSipRegisterNameDup_VALUE = 57;
    /**
     * <code>emSecCrtNotFind = 58;</code>
     *
     * <pre>
     *&#47;//sec 注册失败reason
     * </pre>
     */
    public static final int emSecCrtNotFind_VALUE = 58;
    /**
     * <code>emSecCrtVerifyFail = 59;</code>
     *
     * <pre>
     *&#47;证书验证失败
     * </pre>
     */
    public static final int emSecCrtVerifyFail_VALUE = 59;
    /**
     * <code>emSecCrtExpired = 60;</code>
     *
     * <pre>
     *&#47;证书过期 有效期错误
     * </pre>
     */
    public static final int emSecCrtExpired_VALUE = 60;
    /**
     * <code>emSecCrtFormatError = 61;</code>
     *
     * <pre>
     *&#47;证书格式错误
     * </pre>
     */
    public static final int emSecCrtFormatError_VALUE = 61;
    /**
     * <code>emSecLoadCertFailed = 62;</code>
     *
     * <pre>
     *&#47;证书加载失败
     * </pre>
     */
    public static final int emSecLoadCertFailed_VALUE = 62;
    /**
     * <code>emUnRegSuc = 90;</code>
     *
     * <pre>
     *&#47;取消注册成功 
     * </pre>
     */
    public static final int emUnRegSuc_VALUE = 90;


    public final int getNumber() { return value; }

    public static EmRegFailedReason valueOf(int value) {
      switch (value) {
        case 0: return emGKFailedBegin;
        case 1: return emGKUnReachable;
        case 2: return emInvalidAliase;
        case 3: return emDupAlias;
        case 4: return emInvalidCallAddress;
        case 5: return emResourceUnavailable;
        case 7: return emRegNumberFull;
        case 8: return emGKSecurityDenial;
        case 9: return emGKDismatch;
        case 10: return emUnRegGKReq;
        case 11: return emRRQCreateHRASFailed;
        case 12: return emRRQSendFailed;
        case 50: return emSipFailedBegin;
        case 51: return emSipLocalNormalUnreg;
        case 52: return emSipInvalidUserNameAndPassword;
        case 53: return emSipRegistrarUnReachable;
        case 54: return emSipInvalidAlias;
        case 55: return emSipUnknownReason;
        case 56: return emSipRegisterFailed;
        case 57: return emSipRegisterNameDup;
        case 58: return emSecCrtNotFind;
        case 59: return emSecCrtVerifyFail;
        case 60: return emSecCrtExpired;
        case 61: return emSecCrtFormatError;
        case 62: return emSecLoadCertFailed;
        case 90: return emUnRegSuc;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRegFailedReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRegFailedReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRegFailedReason>() {
            public EmRegFailedReason findValueByNumber(int number) {
              return EmRegFailedReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(78);
    }

    private static final EmRegFailedReason[] VALUES = values();

    public static EmRegFailedReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRegFailedReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRegFailedReason)
  }

  /**
   * Protobuf enum {@code mt.EmEncryptArithmetic}
   *
   * <pre>
   *加密算法
   * </pre>
   */
  public enum EmEncryptArithmetic
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEncryptNone = 0;</code>
     */
    emEncryptNone(0, 0),
    /**
     * <code>emDES = 1;</code>
     */
    emDES(1, 1),
    /**
     * <code>emAES = 2;</code>
     */
    emAES(2, 2),
    /**
     * <code>emSM1 = 3;</code>
     */
    emSM1(3, 3),
    /**
     * <code>emSM4 = 4;</code>
     */
    emSM4(4, 4),
    /**
     * <code>emSM2 = 5;</code>
     */
    emSM2(5, 5),
    /**
     * <code>emSM3 = 6;</code>
     */
    emSM3(6, 6),
    /**
     * <code>emAuto = 10;</code>
     */
    emAuto(7, 10),
    ;

    /**
     * <code>emEncryptNone = 0;</code>
     */
    public static final int emEncryptNone_VALUE = 0;
    /**
     * <code>emDES = 1;</code>
     */
    public static final int emDES_VALUE = 1;
    /**
     * <code>emAES = 2;</code>
     */
    public static final int emAES_VALUE = 2;
    /**
     * <code>emSM1 = 3;</code>
     */
    public static final int emSM1_VALUE = 3;
    /**
     * <code>emSM4 = 4;</code>
     */
    public static final int emSM4_VALUE = 4;
    /**
     * <code>emSM2 = 5;</code>
     */
    public static final int emSM2_VALUE = 5;
    /**
     * <code>emSM3 = 6;</code>
     */
    public static final int emSM3_VALUE = 6;
    /**
     * <code>emAuto = 10;</code>
     */
    public static final int emAuto_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmEncryptArithmetic valueOf(int value) {
      switch (value) {
        case 0: return emEncryptNone;
        case 1: return emDES;
        case 2: return emAES;
        case 3: return emSM1;
        case 4: return emSM4;
        case 5: return emSM2;
        case 6: return emSM3;
        case 10: return emAuto;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEncryptArithmetic>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEncryptArithmetic>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEncryptArithmetic>() {
            public EmEncryptArithmetic findValueByNumber(int number) {
              return EmEncryptArithmetic.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(79);
    }

    private static final EmEncryptArithmetic[] VALUES = values();

    public static EmEncryptArithmetic valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEncryptArithmetic(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmEncryptArithmetic)
  }

  /**
   * Protobuf enum {@code mt.EmMtVmpStyle}
   *
   * <pre>
   *&#47;//画面合成风格 对应平台的CBB_EmVmpStyleDef
   * </pre>
   */
  public enum EmMtVmpStyle
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emInvalid_Style = 0;</code>
     *
     * <pre>
     *非法值
     * </pre>
     */
    emInvalid_Style(0, 0),
    /**
     * <code>emMt_VMP_STYLE_DYNAMIC = 1;</code>
     *
     * <pre>
     *动态分屏(仅自动合成时有效)
     * </pre>
     */
    emMt_VMP_STYLE_DYNAMIC(1, 1),
    /**
     * <code>emMt_VMP_STYLE_1 = 2;</code>
     *
     * <pre>
     *一画面全屏
     * </pre>
     */
    emMt_VMP_STYLE_1(2, 2),
    /**
     * <code>emMt_VMP_STYLE_2_1X2 = 3;</code>
     *
     * <pre>
     *两画面: 2等大，居中(1行2列)
     * </pre>
     */
    emMt_VMP_STYLE_2_1X2(3, 3),
    /**
     * <code>emMt_VMP_STYLE_2_B1_S1RD = 4;</code>
     *
     * <pre>
     *两画面: 1大1小，1大全屏，1小右下
     * </pre>
     */
    emMt_VMP_STYLE_2_B1_S1RD(4, 4),
    /**
     * <code>emMt_VMP_STYLE_3_1U_2D1X2 = 5;</code>
     *
     * <pre>
     *三画面: 等大，1上，2下(1行2列)
     * </pre>
     */
    emMt_VMP_STYLE_3_1U_2D1X2(5, 5),
    /**
     * <code>emMt_VMP_STYLE_3_B1L_S2R2X1 = 6;</code>
     *
     * <pre>
     *三画面: 1大2小，1大左，2小右(2行1列)
     * </pre>
     */
    emMt_VMP_STYLE_3_B1L_S2R2X1(6, 6),
    /**
     * <code>emMt_VMP_STYLE_3_1L_2R2X1 = 7;</code>
     *
     * <pre>
     *三画面: 等大，1左，2右(2行1列)
     * </pre>
     */
    emMt_VMP_STYLE_3_1L_2R2X1(7, 7),
    /**
     * <code>emMt_VMP_STYLE_3_B1_S2LD1X2 = 8;</code>
     *
     * <pre>
     *三画面: 1大2小，1大全屏，2小左下(1行2列)
     * </pre>
     */
    emMt_VMP_STYLE_3_B1_S2LD1X2(8, 8),
    /**
     * <code>emMt_VMP_STYLE_3_3X1 = 9;</code>
     *
     * <pre>
     *三画面: 等大，3行1列
     * </pre>
     */
    emMt_VMP_STYLE_3_3X1(9, 9),
    /**
     * <code>emMt_VMP_STYLE_4_2X2 = 10;</code>
     *
     * <pre>
     *四画面: 等大，2行2列
     * </pre>
     */
    emMt_VMP_STYLE_4_2X2(10, 10),
    /**
     * <code>emMt_VMP_STYLE_4_B1L_S3R3X1 = 11;</code>
     *
     * <pre>
     *四画面: 1大3小，1大左，3小右(3行1列)
     * </pre>
     */
    emMt_VMP_STYLE_4_B1L_S3R3X1(11, 11),
    /**
     * <code>emMt_VMP_STYLE_4_B1U_S3D1X3 = 12;</code>
     *
     * <pre>
     *四画面: 1大3小，1大上，3小下(1行3列)
     * </pre>
     */
    emMt_VMP_STYLE_4_B1U_S3D1X3(12, 12),
    /**
     * <code>emMt_VMP_STYLE_5_B1L_S4R4X1 = 13;</code>
     *
     * <pre>
     *五画面: 1大4小，1大左，4小右(4行1列)
     * </pre>
     */
    emMt_VMP_STYLE_5_B1L_S4R4X1(13, 13),
    /**
     * <code>emMt_VMP_STYLE_5_B1U_S4D1X4 = 14;</code>
     *
     * <pre>
     *五画面: 1大4小，1大上，4小下(1行4列)
     * </pre>
     */
    emMt_VMP_STYLE_5_B1U_S4D1X4(14, 14),
    /**
     * <code>emMt_VMP_STYLE_5_B2U1X2_S3D1X3 = 15;</code>
     *
     * <pre>
     *五画面: 2大3小，2大上(1行2列)，3小下(1行3列)
     * </pre>
     */
    emMt_VMP_STYLE_5_B2U1X2_S3D1X3(15, 15),
    /**
     * <code>emMt_VMP_STYLE_6_B1LU_S2RU2X1_S3D1X3 = 16;</code>
     *
     * <pre>
     *六画面: 1大5小，1大左上，2小右上(2行1列)，3小下(1行3列)
     * </pre>
     */
    emMt_VMP_STYLE_6_B1LU_S2RU2X1_S3D1X3(16, 16),
    /**
     * <code>emMt_VMP_STYLE_6_B2U1X2_S4D1X4 = 17;</code>
     *
     * <pre>
     *六画面: 2大4小，2大上(1行2列), 4小下(1行4列)
     * </pre>
     */
    emMt_VMP_STYLE_6_B2U1X2_S4D1X4(17, 17),
    /**
     * <code>emMt_VMP_STYLE_6_2X3 = 18;</code>
     *
     * <pre>
     *六画面: 等大，2行3列
     * </pre>
     */
    emMt_VMP_STYLE_6_2X3(18, 18),
    /**
     * <code>emMt_VMP_STYLE_6_B1U_S5D1X5 = 19;</code>
     *
     * <pre>
     *六画面: 1大5小，1大上，5小下(1行5列)
     * </pre>
     */
    emMt_VMP_STYLE_6_B1U_S5D1X5(19, 19),
    /**
     * <code>emMt_VMP_STYLE_7_B2U1X2_B1LD_S4RD2X2 = 20;</code>
     *
     * <pre>
     *七画面: 3大4小，2大上(1行2列)，1大左下，4小右下(2行2列)
     * </pre>
     */
    emMt_VMP_STYLE_7_B2U1X2_B1LD_S4RD2X2(20, 20),
    /**
     * <code>emMt_VMP_STYLE_7_S2LU2X1_B1MU_S2RU2X1_B2D1X2 = 21;</code>
     *
     * <pre>
     *七画面: 3大4小，2小左上(2行1列)，1大中上，2小右上(2行1列)，2大下(1行2列)
     * </pre>
     */
    emMt_VMP_STYLE_7_S2LU2X1_B1MU_S2RU2X1_B2D1X2(21, 21),
    /**
     * <code>emMt_VMP_STYLE_7_B1U_S6D1X6 = 22;</code>
     *
     * <pre>
     *七画面: 1大6小，1大上，6小下(1行6列)
     * </pre>
     */
    emMt_VMP_STYLE_7_B1U_S6D1X6(22, 22),
    /**
     * <code>emMt_VMP_STYLE_8_B1LU_S3RU3X1_S4D1X4 = 23;</code>
     *
     * <pre>
     *八画面: 1大7小，1大左上，3小右上(3行1列)，4小下(1行4列)
     * </pre>
     */
    emMt_VMP_STYLE_8_B1LU_S3RU3X1_S4D1X4(23, 23),
    /**
     * <code>emMt_VMP_STYLE_8_B4L2X2_S4R4X1 = 24;</code>
     *
     * <pre>
     *八画面: 4大4小，4大左(2行2列)，4小右(4行1列)
     * </pre>
     */
    emMt_VMP_STYLE_8_B4L2X2_S4R4X1(24, 24),
    /**
     * <code>emMt_VMP_STYLE_9_3X3 = 25;</code>
     *
     * <pre>
     *九画面: 等大，3行3列
     * </pre>
     */
    emMt_VMP_STYLE_9_3X3(25, 25),
    /**
     * <code>emMt_VMP_STYLE_9_S4U1X4_B1M_S4D1X4 = 26;</code>
     *
     * <pre>
     *九画面: 1大8小，4小上(1行4列)，1大中，4小下(1行4列)
     * </pre>
     */
    emMt_VMP_STYLE_9_S4U1X4_B1M_S4D1X4(26, 26),
    /**
     * <code>emMt_VMP_STYLE_10_B2L2X1_S8R4X2 = 27;</code>
     *
     * <pre>
     *十画面: 2大8小，2大左(2行1列)，8小右(4行2列)
     * </pre>
     */
    emMt_VMP_STYLE_10_B2L2X1_S8R4X2(27, 27),
    /**
     * <code>emMt_VMP_STYLE_10_B2U1X2_S8D2X4 = 28;</code>
     *
     * <pre>
     *十画面: 2大8小，2大上(1行2列)，8小下(2行4列)
     * </pre>
     */
    emMt_VMP_STYLE_10_B2U1X2_S8D2X4(28, 28),
    /**
     * <code>emMt_VMP_STYLE_10_S4U1X4_B2M1X2_S4D1X4 = 29;</code>
     *
     * <pre>
     *十画面: 2大8小，4小上(1行4列)，2大中(1行2列)，4小下(1行4列)
     * </pre>
     */
    emMt_VMP_STYLE_10_S4U1X4_B2M1X2_S4D1X4(29, 29),
    /**
     * <code>emMt_VMP_STYLE_10_S4L4X1_B2M2X1_S4R4X1 = 30;</code>
     *
     * <pre>
     *十画面: 2大8小，4小左(4行1列)，2大中(2行1列)，4小右(4行1列)
     * </pre>
     */
    emMt_VMP_STYLE_10_S4L4X1_B2M2X1_S4R4X1(30, 30),
    /**
     * <code>emMt_VMP_STYLE_11_S5U1X5_B1M_S5D1X5 = 31;</code>
     *
     * <pre>
     *十一画面: 1大10小，5小上(1行5列)，大1中，5小下(1行5列)
     * </pre>
     */
    emMt_VMP_STYLE_11_S5U1X5_B1M_S5D1X5(31, 31),
    /**
     * <code>emMt_VMP_STYLE_11_B1U_S10D2X5 = 32;</code>
     *
     * <pre>
     *十一画面: 1大10小，1大上，10小下(2行5列)
     * </pre>
     */
    emMt_VMP_STYLE_11_B1U_S10D2X5(32, 32),
    /**
     * <code>emMt_VMP_STYLE_12_B2U1X2_B1LD_S9RD3X3 = 33;</code>
     *
     * <pre>
     *十二画面: 3大9小，2大上(1行2列)，1大左下，9小右下(3行3列)
     * </pre>
     */
    emMt_VMP_STYLE_12_B2U1X2_B1LD_S9RD3X3(33, 33),
    /**
     * <code>emMt_VMP_STYLE_12_B1LU_S5RU4X1_S6D1X6 = 34;</code>
     *
     * <pre>
     *十二画面: 1大11小，大1左上，5小右上(4行1列)，5小下(1行5列)
     * </pre>
     */
    emMt_VMP_STYLE_12_B1LU_S5RU4X1_S6D1X6(34, 34),
    /**
     * <code>emMt_VMP_STYLE_13_B1LU_S4RU2X2_S8D2X4 = 35;</code>
     *
     * <pre>
     *十三画面: 1大12小，大1左上，4小右上(2行2列)，8小下(2行4列)
     * </pre>
     */
    emMt_VMP_STYLE_13_B1LU_S4RU2X2_S8D2X4(35, 35),
    /**
     * <code>emMt_VMP_STYLE_13_S4U1X4_S2LM2X1_B1MM_S2LM2X1_S4D1X4 = 36;</code>
     *
     * <pre>
     *十三画面: 1大12小，4小上(1行4列)，2小左中(2行1列)，1大中中，2小右中(2行1列), 4小下(1行4列)
     * </pre>
     */
    emMt_VMP_STYLE_13_S4U1X4_S2LM2X1_B1MM_S2LM2X1_S4D1X4(36, 36),
    /**
     * <code>emMt_VMP_STYLE_13_B4LU2X2_S4RU4X1_S5D1X5 = 37;</code>
     *
     * <pre>
     *十三画面: 4大9小，4大左上(2行2列)，4小右上(4行1列)，5小下(1行5列)
     * </pre>
     */
    emMt_VMP_STYLE_13_B4LU2X2_S4RU4X1_S5D1X5(37, 37),
    /**
     * <code>emMt_VMP_STYLE_14_B2LU1X2_S2RU2X1_S10D2X5 = 38;</code>
     *
     * <pre>
     *十四画面: 2大12小，2大左上(1行2列)，2小右上(2行1列)，10小下(2行5列)
     * </pre>
     */
    emMt_VMP_STYLE_14_B2LU1X2_S2RU2X1_S10D2X5(38, 38),
    /**
     * <code>emMt_VMP_STYLE_14_S5U1X5_B1LM_S2MM2X1_B1RM_S5D1X5 = 39;</code>
     *
     * <pre>
     *十四画面: 2大12小，5小上(1行5列)，1大左中，2小中中(2行1列)，1大右中，5小下(1行5列)
     * </pre>
     */
    emMt_VMP_STYLE_14_S5U1X5_B1LM_S2MM2X1_B1RM_S5D1X5(39, 39),
    /**
     * <code>emMt_VMP_STYLE_15_B3U1X3_S12D2X6 = 40;</code>
     *
     * <pre>
     *十五画面: 3大12小，3大上(1行3列)，12小下(2行6列)
     * </pre>
     */
    emMt_VMP_STYLE_15_B3U1X3_S12D2X6(40, 40),
    /**
     * <code>emMt_VMP_STYLE_15_S4U1X4_S3LM3X1_B1MM_S3RM3X1_S4D1X4 = 41;</code>
     *
     * <pre>
     *十五画面: 1大14小，4小上(1行4列)，3小左中(3行1列)，1大中中，3小右中(3行1列)，4小下(1行4列)
     * </pre>
     */
    emMt_VMP_STYLE_15_S4U1X4_S3LM3X1_B1MM_S3RM3X1_S4D1X4(41, 41),
    /**
     * <code>emMt_VMP_STYLE_16_4X4 = 42;</code>
     *
     * <pre>
     *十六画面: 16等分，4x4
     * </pre>
     */
    emMt_VMP_STYLE_16_4X4(42, 42),
    /**
     * <code>emMt_VMP_STYLE_16_B1LU_S7RU7X1_S8D1X8 = 43;</code>
     *
     * <pre>
     *十六画面: 1大15小，1大左上，7小右上(7行1列)，8小下(1行8列)
     * </pre>
     */
    emMt_VMP_STYLE_16_B1LU_S7RU7X1_S8D1X8(43, 43),
    /**
     * <code>emMt_VMP_STYLE_17_S5U1X5_S3LM3X1_B1MM_S3RM3X1_S5D1X5 = 44;</code>
     *
     * <pre>
     *十七画面: 1大16小，5小上(1行5列)，3小左中(3行1列)，1大中中，3小右中(3行1列)，5小下(1行5列)
     * </pre>
     */
    emMt_VMP_STYLE_17_S5U1X5_S3LM3X1_B1MM_S3RM3X1_S5D1X5(44, 44),
    /**
     * <code>emMt_VMP_STYLE_17_B1LU_S6RU3X2_S10D2X5 = 45;</code>
     *
     * <pre>
     *十七画面: 1大16小，1大左上，6小右上(3行2列)，10小下(2行5列)
     * </pre>
     */
    emMt_VMP_STYLE_17_B1LU_S6RU3X2_S10D2X5(45, 45),
    /**
     * <code>emMt_VMP_STYLE_17_B2U1X2_S15D3X5 = 46;</code>
     *
     * <pre>
     *十七画面: 2大15小，2大上(1行2列)，15小下(5列3行)
     * </pre>
     */
    emMt_VMP_STYLE_17_B2U1X2_S15D3X5(46, 46),
    /**
     * <code>emMt_VMP_STYLE_18_S6U1X6_B6M2X3_S6D1X6 = 47;</code>
     *
     * <pre>
     *十八画面: 6大12小，6小上(1行6列)，6大居中(2行3列)，6小下(1行6列)
     * </pre>
     */
    emMt_VMP_STYLE_18_S6U1X6_B6M2X3_S6D1X6(47, 47),
    /**
     * <code>emMt_VMP_STYLE_18_B6U2X3_S12D2X6 = 48;</code>
     *
     * <pre>
     *十八画面: 6大12小，6大上(2行3列)，12小下(2行6列)
     * </pre>
     */
    emMt_VMP_STYLE_18_B6U2X3_S12D2X6(48, 48),
    /**
     * <code>emMt_VMP_STYLE_18_S6L6X1_B6M3X2_S6R6X1 = 49;</code>
     *
     * <pre>
     *十八画面: 6大12小，6小左(6行1列)，6大中(3行2列)，6小右(6行1列)
     * </pre>
     */
    emMt_VMP_STYLE_18_S6L6X1_B6M3X2_S6R6X1(49, 49),
    /**
     * <code>emMt_VMP_STYLE_19_B2LU1X2_S2RU2X1_S15D3X5 = 50;</code>
     *
     * <pre>
     *十九画面: 2大17小，2大左上(1行2列)，2小右上(2行1列)，15小下(3行5列)
     * </pre>
     */
    emMt_VMP_STYLE_19_B2LU1X2_S2RU2X1_S15D3X5(50, 50),
    /**
     * <code>emMt_VMP_STYLE_19_B2LU2X1_S12RU4X3_S5D1X5 = 51;</code>
     *
     * <pre>
     *十九画面: 2大17小，2大左上(2行1列)，12小右上(4行3列)，5小下(1行5列)
     * </pre>
     */
    emMt_VMP_STYLE_19_B2LU2X1_S12RU4X3_S5D1X5(51, 51),
    /**
     * <code>emMt_VMP_STYLE_20_B2U1X2_S18D3X6 = 52;</code>
     *
     * <pre>
     *二十画面: 2大18小，2大上(1行2列)，18小下(3行6列)
     * </pre>
     */
    emMt_VMP_STYLE_20_B2U1X2_S18D3X6(52, 52),
    /**
     * <code>emMt_VMP_STYLE_20_S6U1X6_B2M1X2_S12D2X6 = 53;</code>
     *
     * <pre>
     *二十画面: 2大18小，6小上(1行6列)，2大中(1行2列)，12小下(2行6列)
     * </pre>
     */
    emMt_VMP_STYLE_20_S6U1X6_B2M1X2_S12D2X6(53, 53),
    /**
     * <code>emMt_VMP_STYLE_21_S6U1X6_S4LM4X1_B1MM_S4RM4X1_S6D1X6 = 54;</code>
     *
     * <pre>
     *二十一画面: 1大20小，6小上(1行6列)，4小左中(4行1列)，1大中中，4小右中(4行1列)，6小下(1行6列)
     * </pre>
     */
    emMt_VMP_STYLE_21_S6U1X6_S4LM4X1_B1MM_S4RM4X1_S6D1X6(54, 54),
    /**
     * <code>emMt_VMP_STYLE_21_B1LU_S8RU4X2_S12D2X6 = 55;</code>
     *
     * <pre>
     *二十一画面: 1大20小，1大左上，8小右上(4行2列)，12小下(2行6列)
     * </pre>
     */
    emMt_VMP_STYLE_21_B1LU_S8RU4X2_S12D2X6(55, 55),
    /**
     * <code>emMt_VMP_STYLE_22_B1LU_S6RU2X3_S15D3X5 = 56;</code>
     *
     * <pre>
     *二十二画面: 1大21小，1大左上，6小右上(2行3列)，15小下(3行5列)
     * </pre>
     */
    emMt_VMP_STYLE_22_B1LU_S6RU2X3_S15D3X5(56, 56),
    /**
     * <code>emMt_VMP_STYLE_23_4U1X4_15M3X5_4D1X4 = 57;</code>
     *
     * <pre>
     *二十三画面: 23同大，4上(1行4列)，15中(3行5列)，4下(1行4列)
     * </pre>
     */
    emMt_VMP_STYLE_23_4U1X4_15M3X5_4D1X4(57, 57),
    /**
     * <code>emMt_VMP_STYLE_23_B2U1X2_S4LM2X2_B1MM_S4RM2X2_S12D2X6 = 58;</code>
     *
     * <pre>
     *二十三画面: 3大20小，2大上(1行2列)，4小左中(2行2列)，1大中中，4小右中(2行2列)，12小下(2行6列)
     * </pre>
     */
    emMt_VMP_STYLE_23_B2U1X2_S4LM2X2_B1MM_S4RM2X2_S12D2X6(58, 58),
    /**
     * <code>emMt_VMP_STYLE_24_S6U1X6_S4LM4X1_B4MM2X2_S4RM4X1_S6D1X6 = 59;</code>
     *
     * <pre>
     *二十四画面: 4大20小，6小上(1行6列)，4小左中(4行1列)，4大中中(2行2列)，4小右中(4行1列)下(1行6列)
     * </pre>
     */
    emMt_VMP_STYLE_24_S6U1X6_S4LM4X1_B4MM2X2_S4RM4X1_S6D1X6(59, 59),
    /**
     * <code>emMt_VMP_STYLE_25_5X5 = 60;</code>
     *
     * <pre>
     *二十五画面: 等大，5行5列
     * </pre>
     */
    emMt_VMP_STYLE_25_5X5(60, 60),
    /**
     * <code>emMt_VMP_STYLE_25_S3LU3X1_B1MU_S3RU3X1_S18D3X6 = 61;</code>
     *
     * <pre>
     *二十五画面: 1大24小，3小左上(3行1列)，1大中上，3小右上(3行1列)，18小下(3行6列)  
     * </pre>
     */
    emMt_VMP_STYLE_25_S3LU3X1_B1MU_S3RU3X1_S18D3X6(61, 61),
    /**
     * <code>emMt_VMP_STYLE_2_B1_S1RU = 62;</code>
     *
     * <pre>
     *两画面: 1大1小，1大全屏，1小右上
     * </pre>
     */
    emMt_VMP_STYLE_2_B1_S1RU(62, 62),
    /**
     * <code>emMt_VMP_STYLE_2_B1_S1LD = 63;</code>
     *
     * <pre>
     * 两画面: 1大1小，1大全屏，1小左下
     * </pre>
     */
    emMt_VMP_STYLE_2_B1_S1LD(63, 63),
    /**
     * <code>emMt_VMP_STYLE_2_B1_S1L = 64;</code>
     *
     * <pre>
     * 两画面: 1大1小，1大全屏，1小左上
     * </pre>
     */
    emMt_VMP_STYLE_2_B1_S1L(64, 64),
    /**
     * <code>emMt_VMP_STYLE_20_5X4 = 100;</code>
     *
     * <pre>
     *二十画面，等分5*4， 兼容老的行业平台，5.0平台没有
     * </pre>
     */
    emMt_VMP_STYLE_20_5X4(65, 100),
    ;

    /**
     * <code>emInvalid_Style = 0;</code>
     *
     * <pre>
     *非法值
     * </pre>
     */
    public static final int emInvalid_Style_VALUE = 0;
    /**
     * <code>emMt_VMP_STYLE_DYNAMIC = 1;</code>
     *
     * <pre>
     *动态分屏(仅自动合成时有效)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_DYNAMIC_VALUE = 1;
    /**
     * <code>emMt_VMP_STYLE_1 = 2;</code>
     *
     * <pre>
     *一画面全屏
     * </pre>
     */
    public static final int emMt_VMP_STYLE_1_VALUE = 2;
    /**
     * <code>emMt_VMP_STYLE_2_1X2 = 3;</code>
     *
     * <pre>
     *两画面: 2等大，居中(1行2列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_2_1X2_VALUE = 3;
    /**
     * <code>emMt_VMP_STYLE_2_B1_S1RD = 4;</code>
     *
     * <pre>
     *两画面: 1大1小，1大全屏，1小右下
     * </pre>
     */
    public static final int emMt_VMP_STYLE_2_B1_S1RD_VALUE = 4;
    /**
     * <code>emMt_VMP_STYLE_3_1U_2D1X2 = 5;</code>
     *
     * <pre>
     *三画面: 等大，1上，2下(1行2列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_3_1U_2D1X2_VALUE = 5;
    /**
     * <code>emMt_VMP_STYLE_3_B1L_S2R2X1 = 6;</code>
     *
     * <pre>
     *三画面: 1大2小，1大左，2小右(2行1列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_3_B1L_S2R2X1_VALUE = 6;
    /**
     * <code>emMt_VMP_STYLE_3_1L_2R2X1 = 7;</code>
     *
     * <pre>
     *三画面: 等大，1左，2右(2行1列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_3_1L_2R2X1_VALUE = 7;
    /**
     * <code>emMt_VMP_STYLE_3_B1_S2LD1X2 = 8;</code>
     *
     * <pre>
     *三画面: 1大2小，1大全屏，2小左下(1行2列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_3_B1_S2LD1X2_VALUE = 8;
    /**
     * <code>emMt_VMP_STYLE_3_3X1 = 9;</code>
     *
     * <pre>
     *三画面: 等大，3行1列
     * </pre>
     */
    public static final int emMt_VMP_STYLE_3_3X1_VALUE = 9;
    /**
     * <code>emMt_VMP_STYLE_4_2X2 = 10;</code>
     *
     * <pre>
     *四画面: 等大，2行2列
     * </pre>
     */
    public static final int emMt_VMP_STYLE_4_2X2_VALUE = 10;
    /**
     * <code>emMt_VMP_STYLE_4_B1L_S3R3X1 = 11;</code>
     *
     * <pre>
     *四画面: 1大3小，1大左，3小右(3行1列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_4_B1L_S3R3X1_VALUE = 11;
    /**
     * <code>emMt_VMP_STYLE_4_B1U_S3D1X3 = 12;</code>
     *
     * <pre>
     *四画面: 1大3小，1大上，3小下(1行3列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_4_B1U_S3D1X3_VALUE = 12;
    /**
     * <code>emMt_VMP_STYLE_5_B1L_S4R4X1 = 13;</code>
     *
     * <pre>
     *五画面: 1大4小，1大左，4小右(4行1列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_5_B1L_S4R4X1_VALUE = 13;
    /**
     * <code>emMt_VMP_STYLE_5_B1U_S4D1X4 = 14;</code>
     *
     * <pre>
     *五画面: 1大4小，1大上，4小下(1行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_5_B1U_S4D1X4_VALUE = 14;
    /**
     * <code>emMt_VMP_STYLE_5_B2U1X2_S3D1X3 = 15;</code>
     *
     * <pre>
     *五画面: 2大3小，2大上(1行2列)，3小下(1行3列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_5_B2U1X2_S3D1X3_VALUE = 15;
    /**
     * <code>emMt_VMP_STYLE_6_B1LU_S2RU2X1_S3D1X3 = 16;</code>
     *
     * <pre>
     *六画面: 1大5小，1大左上，2小右上(2行1列)，3小下(1行3列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_6_B1LU_S2RU2X1_S3D1X3_VALUE = 16;
    /**
     * <code>emMt_VMP_STYLE_6_B2U1X2_S4D1X4 = 17;</code>
     *
     * <pre>
     *六画面: 2大4小，2大上(1行2列), 4小下(1行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_6_B2U1X2_S4D1X4_VALUE = 17;
    /**
     * <code>emMt_VMP_STYLE_6_2X3 = 18;</code>
     *
     * <pre>
     *六画面: 等大，2行3列
     * </pre>
     */
    public static final int emMt_VMP_STYLE_6_2X3_VALUE = 18;
    /**
     * <code>emMt_VMP_STYLE_6_B1U_S5D1X5 = 19;</code>
     *
     * <pre>
     *六画面: 1大5小，1大上，5小下(1行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_6_B1U_S5D1X5_VALUE = 19;
    /**
     * <code>emMt_VMP_STYLE_7_B2U1X2_B1LD_S4RD2X2 = 20;</code>
     *
     * <pre>
     *七画面: 3大4小，2大上(1行2列)，1大左下，4小右下(2行2列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_7_B2U1X2_B1LD_S4RD2X2_VALUE = 20;
    /**
     * <code>emMt_VMP_STYLE_7_S2LU2X1_B1MU_S2RU2X1_B2D1X2 = 21;</code>
     *
     * <pre>
     *七画面: 3大4小，2小左上(2行1列)，1大中上，2小右上(2行1列)，2大下(1行2列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_7_S2LU2X1_B1MU_S2RU2X1_B2D1X2_VALUE = 21;
    /**
     * <code>emMt_VMP_STYLE_7_B1U_S6D1X6 = 22;</code>
     *
     * <pre>
     *七画面: 1大6小，1大上，6小下(1行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_7_B1U_S6D1X6_VALUE = 22;
    /**
     * <code>emMt_VMP_STYLE_8_B1LU_S3RU3X1_S4D1X4 = 23;</code>
     *
     * <pre>
     *八画面: 1大7小，1大左上，3小右上(3行1列)，4小下(1行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_8_B1LU_S3RU3X1_S4D1X4_VALUE = 23;
    /**
     * <code>emMt_VMP_STYLE_8_B4L2X2_S4R4X1 = 24;</code>
     *
     * <pre>
     *八画面: 4大4小，4大左(2行2列)，4小右(4行1列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_8_B4L2X2_S4R4X1_VALUE = 24;
    /**
     * <code>emMt_VMP_STYLE_9_3X3 = 25;</code>
     *
     * <pre>
     *九画面: 等大，3行3列
     * </pre>
     */
    public static final int emMt_VMP_STYLE_9_3X3_VALUE = 25;
    /**
     * <code>emMt_VMP_STYLE_9_S4U1X4_B1M_S4D1X4 = 26;</code>
     *
     * <pre>
     *九画面: 1大8小，4小上(1行4列)，1大中，4小下(1行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_9_S4U1X4_B1M_S4D1X4_VALUE = 26;
    /**
     * <code>emMt_VMP_STYLE_10_B2L2X1_S8R4X2 = 27;</code>
     *
     * <pre>
     *十画面: 2大8小，2大左(2行1列)，8小右(4行2列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_10_B2L2X1_S8R4X2_VALUE = 27;
    /**
     * <code>emMt_VMP_STYLE_10_B2U1X2_S8D2X4 = 28;</code>
     *
     * <pre>
     *十画面: 2大8小，2大上(1行2列)，8小下(2行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_10_B2U1X2_S8D2X4_VALUE = 28;
    /**
     * <code>emMt_VMP_STYLE_10_S4U1X4_B2M1X2_S4D1X4 = 29;</code>
     *
     * <pre>
     *十画面: 2大8小，4小上(1行4列)，2大中(1行2列)，4小下(1行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_10_S4U1X4_B2M1X2_S4D1X4_VALUE = 29;
    /**
     * <code>emMt_VMP_STYLE_10_S4L4X1_B2M2X1_S4R4X1 = 30;</code>
     *
     * <pre>
     *十画面: 2大8小，4小左(4行1列)，2大中(2行1列)，4小右(4行1列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_10_S4L4X1_B2M2X1_S4R4X1_VALUE = 30;
    /**
     * <code>emMt_VMP_STYLE_11_S5U1X5_B1M_S5D1X5 = 31;</code>
     *
     * <pre>
     *十一画面: 1大10小，5小上(1行5列)，大1中，5小下(1行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_11_S5U1X5_B1M_S5D1X5_VALUE = 31;
    /**
     * <code>emMt_VMP_STYLE_11_B1U_S10D2X5 = 32;</code>
     *
     * <pre>
     *十一画面: 1大10小，1大上，10小下(2行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_11_B1U_S10D2X5_VALUE = 32;
    /**
     * <code>emMt_VMP_STYLE_12_B2U1X2_B1LD_S9RD3X3 = 33;</code>
     *
     * <pre>
     *十二画面: 3大9小，2大上(1行2列)，1大左下，9小右下(3行3列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_12_B2U1X2_B1LD_S9RD3X3_VALUE = 33;
    /**
     * <code>emMt_VMP_STYLE_12_B1LU_S5RU4X1_S6D1X6 = 34;</code>
     *
     * <pre>
     *十二画面: 1大11小，大1左上，5小右上(4行1列)，5小下(1行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_12_B1LU_S5RU4X1_S6D1X6_VALUE = 34;
    /**
     * <code>emMt_VMP_STYLE_13_B1LU_S4RU2X2_S8D2X4 = 35;</code>
     *
     * <pre>
     *十三画面: 1大12小，大1左上，4小右上(2行2列)，8小下(2行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_13_B1LU_S4RU2X2_S8D2X4_VALUE = 35;
    /**
     * <code>emMt_VMP_STYLE_13_S4U1X4_S2LM2X1_B1MM_S2LM2X1_S4D1X4 = 36;</code>
     *
     * <pre>
     *十三画面: 1大12小，4小上(1行4列)，2小左中(2行1列)，1大中中，2小右中(2行1列), 4小下(1行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_13_S4U1X4_S2LM2X1_B1MM_S2LM2X1_S4D1X4_VALUE = 36;
    /**
     * <code>emMt_VMP_STYLE_13_B4LU2X2_S4RU4X1_S5D1X5 = 37;</code>
     *
     * <pre>
     *十三画面: 4大9小，4大左上(2行2列)，4小右上(4行1列)，5小下(1行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_13_B4LU2X2_S4RU4X1_S5D1X5_VALUE = 37;
    /**
     * <code>emMt_VMP_STYLE_14_B2LU1X2_S2RU2X1_S10D2X5 = 38;</code>
     *
     * <pre>
     *十四画面: 2大12小，2大左上(1行2列)，2小右上(2行1列)，10小下(2行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_14_B2LU1X2_S2RU2X1_S10D2X5_VALUE = 38;
    /**
     * <code>emMt_VMP_STYLE_14_S5U1X5_B1LM_S2MM2X1_B1RM_S5D1X5 = 39;</code>
     *
     * <pre>
     *十四画面: 2大12小，5小上(1行5列)，1大左中，2小中中(2行1列)，1大右中，5小下(1行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_14_S5U1X5_B1LM_S2MM2X1_B1RM_S5D1X5_VALUE = 39;
    /**
     * <code>emMt_VMP_STYLE_15_B3U1X3_S12D2X6 = 40;</code>
     *
     * <pre>
     *十五画面: 3大12小，3大上(1行3列)，12小下(2行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_15_B3U1X3_S12D2X6_VALUE = 40;
    /**
     * <code>emMt_VMP_STYLE_15_S4U1X4_S3LM3X1_B1MM_S3RM3X1_S4D1X4 = 41;</code>
     *
     * <pre>
     *十五画面: 1大14小，4小上(1行4列)，3小左中(3行1列)，1大中中，3小右中(3行1列)，4小下(1行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_15_S4U1X4_S3LM3X1_B1MM_S3RM3X1_S4D1X4_VALUE = 41;
    /**
     * <code>emMt_VMP_STYLE_16_4X4 = 42;</code>
     *
     * <pre>
     *十六画面: 16等分，4x4
     * </pre>
     */
    public static final int emMt_VMP_STYLE_16_4X4_VALUE = 42;
    /**
     * <code>emMt_VMP_STYLE_16_B1LU_S7RU7X1_S8D1X8 = 43;</code>
     *
     * <pre>
     *十六画面: 1大15小，1大左上，7小右上(7行1列)，8小下(1行8列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_16_B1LU_S7RU7X1_S8D1X8_VALUE = 43;
    /**
     * <code>emMt_VMP_STYLE_17_S5U1X5_S3LM3X1_B1MM_S3RM3X1_S5D1X5 = 44;</code>
     *
     * <pre>
     *十七画面: 1大16小，5小上(1行5列)，3小左中(3行1列)，1大中中，3小右中(3行1列)，5小下(1行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_17_S5U1X5_S3LM3X1_B1MM_S3RM3X1_S5D1X5_VALUE = 44;
    /**
     * <code>emMt_VMP_STYLE_17_B1LU_S6RU3X2_S10D2X5 = 45;</code>
     *
     * <pre>
     *十七画面: 1大16小，1大左上，6小右上(3行2列)，10小下(2行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_17_B1LU_S6RU3X2_S10D2X5_VALUE = 45;
    /**
     * <code>emMt_VMP_STYLE_17_B2U1X2_S15D3X5 = 46;</code>
     *
     * <pre>
     *十七画面: 2大15小，2大上(1行2列)，15小下(5列3行)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_17_B2U1X2_S15D3X5_VALUE = 46;
    /**
     * <code>emMt_VMP_STYLE_18_S6U1X6_B6M2X3_S6D1X6 = 47;</code>
     *
     * <pre>
     *十八画面: 6大12小，6小上(1行6列)，6大居中(2行3列)，6小下(1行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_18_S6U1X6_B6M2X3_S6D1X6_VALUE = 47;
    /**
     * <code>emMt_VMP_STYLE_18_B6U2X3_S12D2X6 = 48;</code>
     *
     * <pre>
     *十八画面: 6大12小，6大上(2行3列)，12小下(2行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_18_B6U2X3_S12D2X6_VALUE = 48;
    /**
     * <code>emMt_VMP_STYLE_18_S6L6X1_B6M3X2_S6R6X1 = 49;</code>
     *
     * <pre>
     *十八画面: 6大12小，6小左(6行1列)，6大中(3行2列)，6小右(6行1列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_18_S6L6X1_B6M3X2_S6R6X1_VALUE = 49;
    /**
     * <code>emMt_VMP_STYLE_19_B2LU1X2_S2RU2X1_S15D3X5 = 50;</code>
     *
     * <pre>
     *十九画面: 2大17小，2大左上(1行2列)，2小右上(2行1列)，15小下(3行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_19_B2LU1X2_S2RU2X1_S15D3X5_VALUE = 50;
    /**
     * <code>emMt_VMP_STYLE_19_B2LU2X1_S12RU4X3_S5D1X5 = 51;</code>
     *
     * <pre>
     *十九画面: 2大17小，2大左上(2行1列)，12小右上(4行3列)，5小下(1行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_19_B2LU2X1_S12RU4X3_S5D1X5_VALUE = 51;
    /**
     * <code>emMt_VMP_STYLE_20_B2U1X2_S18D3X6 = 52;</code>
     *
     * <pre>
     *二十画面: 2大18小，2大上(1行2列)，18小下(3行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_20_B2U1X2_S18D3X6_VALUE = 52;
    /**
     * <code>emMt_VMP_STYLE_20_S6U1X6_B2M1X2_S12D2X6 = 53;</code>
     *
     * <pre>
     *二十画面: 2大18小，6小上(1行6列)，2大中(1行2列)，12小下(2行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_20_S6U1X6_B2M1X2_S12D2X6_VALUE = 53;
    /**
     * <code>emMt_VMP_STYLE_21_S6U1X6_S4LM4X1_B1MM_S4RM4X1_S6D1X6 = 54;</code>
     *
     * <pre>
     *二十一画面: 1大20小，6小上(1行6列)，4小左中(4行1列)，1大中中，4小右中(4行1列)，6小下(1行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_21_S6U1X6_S4LM4X1_B1MM_S4RM4X1_S6D1X6_VALUE = 54;
    /**
     * <code>emMt_VMP_STYLE_21_B1LU_S8RU4X2_S12D2X6 = 55;</code>
     *
     * <pre>
     *二十一画面: 1大20小，1大左上，8小右上(4行2列)，12小下(2行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_21_B1LU_S8RU4X2_S12D2X6_VALUE = 55;
    /**
     * <code>emMt_VMP_STYLE_22_B1LU_S6RU2X3_S15D3X5 = 56;</code>
     *
     * <pre>
     *二十二画面: 1大21小，1大左上，6小右上(2行3列)，15小下(3行5列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_22_B1LU_S6RU2X3_S15D3X5_VALUE = 56;
    /**
     * <code>emMt_VMP_STYLE_23_4U1X4_15M3X5_4D1X4 = 57;</code>
     *
     * <pre>
     *二十三画面: 23同大，4上(1行4列)，15中(3行5列)，4下(1行4列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_23_4U1X4_15M3X5_4D1X4_VALUE = 57;
    /**
     * <code>emMt_VMP_STYLE_23_B2U1X2_S4LM2X2_B1MM_S4RM2X2_S12D2X6 = 58;</code>
     *
     * <pre>
     *二十三画面: 3大20小，2大上(1行2列)，4小左中(2行2列)，1大中中，4小右中(2行2列)，12小下(2行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_23_B2U1X2_S4LM2X2_B1MM_S4RM2X2_S12D2X6_VALUE = 58;
    /**
     * <code>emMt_VMP_STYLE_24_S6U1X6_S4LM4X1_B4MM2X2_S4RM4X1_S6D1X6 = 59;</code>
     *
     * <pre>
     *二十四画面: 4大20小，6小上(1行6列)，4小左中(4行1列)，4大中中(2行2列)，4小右中(4行1列)下(1行6列)
     * </pre>
     */
    public static final int emMt_VMP_STYLE_24_S6U1X6_S4LM4X1_B4MM2X2_S4RM4X1_S6D1X6_VALUE = 59;
    /**
     * <code>emMt_VMP_STYLE_25_5X5 = 60;</code>
     *
     * <pre>
     *二十五画面: 等大，5行5列
     * </pre>
     */
    public static final int emMt_VMP_STYLE_25_5X5_VALUE = 60;
    /**
     * <code>emMt_VMP_STYLE_25_S3LU3X1_B1MU_S3RU3X1_S18D3X6 = 61;</code>
     *
     * <pre>
     *二十五画面: 1大24小，3小左上(3行1列)，1大中上，3小右上(3行1列)，18小下(3行6列)  
     * </pre>
     */
    public static final int emMt_VMP_STYLE_25_S3LU3X1_B1MU_S3RU3X1_S18D3X6_VALUE = 61;
    /**
     * <code>emMt_VMP_STYLE_2_B1_S1RU = 62;</code>
     *
     * <pre>
     *两画面: 1大1小，1大全屏，1小右上
     * </pre>
     */
    public static final int emMt_VMP_STYLE_2_B1_S1RU_VALUE = 62;
    /**
     * <code>emMt_VMP_STYLE_2_B1_S1LD = 63;</code>
     *
     * <pre>
     * 两画面: 1大1小，1大全屏，1小左下
     * </pre>
     */
    public static final int emMt_VMP_STYLE_2_B1_S1LD_VALUE = 63;
    /**
     * <code>emMt_VMP_STYLE_2_B1_S1L = 64;</code>
     *
     * <pre>
     * 两画面: 1大1小，1大全屏，1小左上
     * </pre>
     */
    public static final int emMt_VMP_STYLE_2_B1_S1L_VALUE = 64;
    /**
     * <code>emMt_VMP_STYLE_20_5X4 = 100;</code>
     *
     * <pre>
     *二十画面，等分5*4， 兼容老的行业平台，5.0平台没有
     * </pre>
     */
    public static final int emMt_VMP_STYLE_20_5X4_VALUE = 100;


    public final int getNumber() { return value; }

    public static EmMtVmpStyle valueOf(int value) {
      switch (value) {
        case 0: return emInvalid_Style;
        case 1: return emMt_VMP_STYLE_DYNAMIC;
        case 2: return emMt_VMP_STYLE_1;
        case 3: return emMt_VMP_STYLE_2_1X2;
        case 4: return emMt_VMP_STYLE_2_B1_S1RD;
        case 5: return emMt_VMP_STYLE_3_1U_2D1X2;
        case 6: return emMt_VMP_STYLE_3_B1L_S2R2X1;
        case 7: return emMt_VMP_STYLE_3_1L_2R2X1;
        case 8: return emMt_VMP_STYLE_3_B1_S2LD1X2;
        case 9: return emMt_VMP_STYLE_3_3X1;
        case 10: return emMt_VMP_STYLE_4_2X2;
        case 11: return emMt_VMP_STYLE_4_B1L_S3R3X1;
        case 12: return emMt_VMP_STYLE_4_B1U_S3D1X3;
        case 13: return emMt_VMP_STYLE_5_B1L_S4R4X1;
        case 14: return emMt_VMP_STYLE_5_B1U_S4D1X4;
        case 15: return emMt_VMP_STYLE_5_B2U1X2_S3D1X3;
        case 16: return emMt_VMP_STYLE_6_B1LU_S2RU2X1_S3D1X3;
        case 17: return emMt_VMP_STYLE_6_B2U1X2_S4D1X4;
        case 18: return emMt_VMP_STYLE_6_2X3;
        case 19: return emMt_VMP_STYLE_6_B1U_S5D1X5;
        case 20: return emMt_VMP_STYLE_7_B2U1X2_B1LD_S4RD2X2;
        case 21: return emMt_VMP_STYLE_7_S2LU2X1_B1MU_S2RU2X1_B2D1X2;
        case 22: return emMt_VMP_STYLE_7_B1U_S6D1X6;
        case 23: return emMt_VMP_STYLE_8_B1LU_S3RU3X1_S4D1X4;
        case 24: return emMt_VMP_STYLE_8_B4L2X2_S4R4X1;
        case 25: return emMt_VMP_STYLE_9_3X3;
        case 26: return emMt_VMP_STYLE_9_S4U1X4_B1M_S4D1X4;
        case 27: return emMt_VMP_STYLE_10_B2L2X1_S8R4X2;
        case 28: return emMt_VMP_STYLE_10_B2U1X2_S8D2X4;
        case 29: return emMt_VMP_STYLE_10_S4U1X4_B2M1X2_S4D1X4;
        case 30: return emMt_VMP_STYLE_10_S4L4X1_B2M2X1_S4R4X1;
        case 31: return emMt_VMP_STYLE_11_S5U1X5_B1M_S5D1X5;
        case 32: return emMt_VMP_STYLE_11_B1U_S10D2X5;
        case 33: return emMt_VMP_STYLE_12_B2U1X2_B1LD_S9RD3X3;
        case 34: return emMt_VMP_STYLE_12_B1LU_S5RU4X1_S6D1X6;
        case 35: return emMt_VMP_STYLE_13_B1LU_S4RU2X2_S8D2X4;
        case 36: return emMt_VMP_STYLE_13_S4U1X4_S2LM2X1_B1MM_S2LM2X1_S4D1X4;
        case 37: return emMt_VMP_STYLE_13_B4LU2X2_S4RU4X1_S5D1X5;
        case 38: return emMt_VMP_STYLE_14_B2LU1X2_S2RU2X1_S10D2X5;
        case 39: return emMt_VMP_STYLE_14_S5U1X5_B1LM_S2MM2X1_B1RM_S5D1X5;
        case 40: return emMt_VMP_STYLE_15_B3U1X3_S12D2X6;
        case 41: return emMt_VMP_STYLE_15_S4U1X4_S3LM3X1_B1MM_S3RM3X1_S4D1X4;
        case 42: return emMt_VMP_STYLE_16_4X4;
        case 43: return emMt_VMP_STYLE_16_B1LU_S7RU7X1_S8D1X8;
        case 44: return emMt_VMP_STYLE_17_S5U1X5_S3LM3X1_B1MM_S3RM3X1_S5D1X5;
        case 45: return emMt_VMP_STYLE_17_B1LU_S6RU3X2_S10D2X5;
        case 46: return emMt_VMP_STYLE_17_B2U1X2_S15D3X5;
        case 47: return emMt_VMP_STYLE_18_S6U1X6_B6M2X3_S6D1X6;
        case 48: return emMt_VMP_STYLE_18_B6U2X3_S12D2X6;
        case 49: return emMt_VMP_STYLE_18_S6L6X1_B6M3X2_S6R6X1;
        case 50: return emMt_VMP_STYLE_19_B2LU1X2_S2RU2X1_S15D3X5;
        case 51: return emMt_VMP_STYLE_19_B2LU2X1_S12RU4X3_S5D1X5;
        case 52: return emMt_VMP_STYLE_20_B2U1X2_S18D3X6;
        case 53: return emMt_VMP_STYLE_20_S6U1X6_B2M1X2_S12D2X6;
        case 54: return emMt_VMP_STYLE_21_S6U1X6_S4LM4X1_B1MM_S4RM4X1_S6D1X6;
        case 55: return emMt_VMP_STYLE_21_B1LU_S8RU4X2_S12D2X6;
        case 56: return emMt_VMP_STYLE_22_B1LU_S6RU2X3_S15D3X5;
        case 57: return emMt_VMP_STYLE_23_4U1X4_15M3X5_4D1X4;
        case 58: return emMt_VMP_STYLE_23_B2U1X2_S4LM2X2_B1MM_S4RM2X2_S12D2X6;
        case 59: return emMt_VMP_STYLE_24_S6U1X6_S4LM4X1_B4MM2X2_S4RM4X1_S6D1X6;
        case 60: return emMt_VMP_STYLE_25_5X5;
        case 61: return emMt_VMP_STYLE_25_S3LU3X1_B1MU_S3RU3X1_S18D3X6;
        case 62: return emMt_VMP_STYLE_2_B1_S1RU;
        case 63: return emMt_VMP_STYLE_2_B1_S1LD;
        case 64: return emMt_VMP_STYLE_2_B1_S1L;
        case 100: return emMt_VMP_STYLE_20_5X4;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtVmpStyle>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtVmpStyle>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtVmpStyle>() {
            public EmMtVmpStyle findValueByNumber(int number) {
              return EmMtVmpStyle.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(80);
    }

    private static final EmMtVmpStyle[] VALUES = values();

    public static EmMtVmpStyle valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtVmpStyle(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtVmpStyle)
  }

  /**
   * Protobuf enum {@code mt.EmMtMemberStatusDef}
   */
  public enum EmMtMemberStatusDef
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMT_STATUS_NULL = 0;</code>
     *
     * <pre>
     *没有指定状态
     * </pre>
     */
    emMT_STATUS_NULL(0, 0),
    /**
     * <code>emMT_STATUS_AUDIENCE = 1;</code>
     *
     * <pre>
     *观众  
     * </pre>
     */
    emMT_STATUS_AUDIENCE(1, 1),
    /**
     * <code>emMT_STATUS_CHAIRMAN = 2;</code>
     *
     * <pre>
     *主席
     * </pre>
     */
    emMT_STATUS_CHAIRMAN(2, 2),
    /**
     * <code>emMT_STATUS_SPEAKER = 3;</code>
     *
     * <pre>
     *发言人
     * </pre>
     */
    emMT_STATUS_SPEAKER(3, 3),
    ;

    /**
     * <code>emMT_STATUS_NULL = 0;</code>
     *
     * <pre>
     *没有指定状态
     * </pre>
     */
    public static final int emMT_STATUS_NULL_VALUE = 0;
    /**
     * <code>emMT_STATUS_AUDIENCE = 1;</code>
     *
     * <pre>
     *观众  
     * </pre>
     */
    public static final int emMT_STATUS_AUDIENCE_VALUE = 1;
    /**
     * <code>emMT_STATUS_CHAIRMAN = 2;</code>
     *
     * <pre>
     *主席
     * </pre>
     */
    public static final int emMT_STATUS_CHAIRMAN_VALUE = 2;
    /**
     * <code>emMT_STATUS_SPEAKER = 3;</code>
     *
     * <pre>
     *发言人
     * </pre>
     */
    public static final int emMT_STATUS_SPEAKER_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMtMemberStatusDef valueOf(int value) {
      switch (value) {
        case 0: return emMT_STATUS_NULL;
        case 1: return emMT_STATUS_AUDIENCE;
        case 2: return emMT_STATUS_CHAIRMAN;
        case 3: return emMT_STATUS_SPEAKER;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtMemberStatusDef>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtMemberStatusDef>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtMemberStatusDef>() {
            public EmMtMemberStatusDef findValueByNumber(int number) {
              return EmMtMemberStatusDef.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(81);
    }

    private static final EmMtMemberStatusDef[] VALUES = values();

    public static EmMtMemberStatusDef valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtMemberStatusDef(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtMemberStatusDef)
  }

  /**
   * Protobuf enum {@code mt.EmMtVMPMmbType}
   *
   * <pre>
   *画面合成成员类型定义
   * </pre>
   */
  public enum EmMtVMPMmbType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVmpMmbType_NULL = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    emVmpMmbType_NULL(0, 0),
    /**
     * <code>emVMPMmbMCSspec = 1;</code>
     *
     * <pre>
     *会控指定 
     * </pre>
     */
    emVMPMmbMCSspec(1, 1),
    /**
     * <code>emVMPMmbSpeaker = 2;</code>
     *
     * <pre>
     *发言人跟随
     * </pre>
     */
    emVMPMmbSpeaker(2, 2),
    /**
     * <code>emVMPMmbChairman = 3;</code>
     *
     * <pre>
     *主席跟随
     * </pre>
     */
    emVMPMmbChairman(3, 3),
    /**
     * <code>emVMPMmbPoll = 4;</code>
     *
     * <pre>
     *轮询视频跟随
     * </pre>
     */
    emVMPMmbPoll(4, 4),
    /**
     * <code>emVMPMmbVAC = 5;</code>
     *
     * <pre>
     *语音激励(会控不要用此类型)
     * </pre>
     */
    emVMPMmbVAC(5, 5),
    /**
     * <code>emVMPMmbCHLPOLL = 6;</code>
     *
     * <pre>
     *vmp单通道轮询
     * </pre>
     */
    emVMPMmbCHLPOLL(6, 6),
    /**
     * <code>emVMPMmbDSTREAM = 7;</code>
     *
     * <pre>
     *双流跟随
     * </pre>
     */
    emVMPMmbDSTREAM(7, 7),
    /**
     * <code>emVMPMmbVCSPEC = 8;</code>
     *
     * <pre>
     *会议业务指定
     * </pre>
     */
    emVMPMmbVCSPEC(8, 8),
    ;

    /**
     * <code>emVmpMmbType_NULL = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    public static final int emVmpMmbType_NULL_VALUE = 0;
    /**
     * <code>emVMPMmbMCSspec = 1;</code>
     *
     * <pre>
     *会控指定 
     * </pre>
     */
    public static final int emVMPMmbMCSspec_VALUE = 1;
    /**
     * <code>emVMPMmbSpeaker = 2;</code>
     *
     * <pre>
     *发言人跟随
     * </pre>
     */
    public static final int emVMPMmbSpeaker_VALUE = 2;
    /**
     * <code>emVMPMmbChairman = 3;</code>
     *
     * <pre>
     *主席跟随
     * </pre>
     */
    public static final int emVMPMmbChairman_VALUE = 3;
    /**
     * <code>emVMPMmbPoll = 4;</code>
     *
     * <pre>
     *轮询视频跟随
     * </pre>
     */
    public static final int emVMPMmbPoll_VALUE = 4;
    /**
     * <code>emVMPMmbVAC = 5;</code>
     *
     * <pre>
     *语音激励(会控不要用此类型)
     * </pre>
     */
    public static final int emVMPMmbVAC_VALUE = 5;
    /**
     * <code>emVMPMmbCHLPOLL = 6;</code>
     *
     * <pre>
     *vmp单通道轮询
     * </pre>
     */
    public static final int emVMPMmbCHLPOLL_VALUE = 6;
    /**
     * <code>emVMPMmbDSTREAM = 7;</code>
     *
     * <pre>
     *双流跟随
     * </pre>
     */
    public static final int emVMPMmbDSTREAM_VALUE = 7;
    /**
     * <code>emVMPMmbVCSPEC = 8;</code>
     *
     * <pre>
     *会议业务指定
     * </pre>
     */
    public static final int emVMPMmbVCSPEC_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmMtVMPMmbType valueOf(int value) {
      switch (value) {
        case 0: return emVmpMmbType_NULL;
        case 1: return emVMPMmbMCSspec;
        case 2: return emVMPMmbSpeaker;
        case 3: return emVMPMmbChairman;
        case 4: return emVMPMmbPoll;
        case 5: return emVMPMmbVAC;
        case 6: return emVMPMmbCHLPOLL;
        case 7: return emVMPMmbDSTREAM;
        case 8: return emVMPMmbVCSPEC;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtVMPMmbType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtVMPMmbType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtVMPMmbType>() {
            public EmMtVMPMmbType findValueByNumber(int number) {
              return EmMtVMPMmbType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(82);
    }

    private static final EmMtVMPMmbType[] VALUES = values();

    public static EmMtVMPMmbType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtVMPMmbType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtVMPMmbType)
  }

  /**
   * Protobuf enum {@code mt.EmAction}
   *
   * <pre>
   *操作
   * </pre>
   */
  public enum EmAction
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emActionBegin = 0;</code>
     *
     * <pre>
     *&#47;无效值
     * </pre>
     */
    emActionBegin(0, 0),
    /**
     * <code>emStart = 1;</code>
     */
    emStart(1, 1),
    /**
     * <code>emStop = 2;</code>
     */
    emStop(2, 2),
    /**
     * <code>emPause = 3;</code>
     */
    emPause(3, 3),
    /**
     * <code>emResume = 4;</code>
     */
    emResume(4, 4),
    ;

    /**
     * <code>emActionBegin = 0;</code>
     *
     * <pre>
     *&#47;无效值
     * </pre>
     */
    public static final int emActionBegin_VALUE = 0;
    /**
     * <code>emStart = 1;</code>
     */
    public static final int emStart_VALUE = 1;
    /**
     * <code>emStop = 2;</code>
     */
    public static final int emStop_VALUE = 2;
    /**
     * <code>emPause = 3;</code>
     */
    public static final int emPause_VALUE = 3;
    /**
     * <code>emResume = 4;</code>
     */
    public static final int emResume_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmAction valueOf(int value) {
      switch (value) {
        case 0: return emActionBegin;
        case 1: return emStart;
        case 2: return emStop;
        case 3: return emPause;
        case 4: return emResume;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAction>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAction>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAction>() {
            public EmAction findValueByNumber(int number) {
              return EmAction.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(83);
    }

    private static final EmAction[] VALUES = values();

    public static EmAction valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAction(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAction)
  }

  /**
   * Protobuf enum {@code mt.EmFileSys}
   *
   * <pre>
   * &lt;&lt; 文件系统类型 &gt;&gt;
   * </pre>
   */
  public enum EmFileSys
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRAWFS = 0;</code>
     *
     * <pre>
     *raw file system [ramdisk + rawblock + tffs]
     * </pre>
     */
    emRAWFS(0, 0),
    /**
     * <code>emTFFS = 1;</code>
     *
     * <pre>
     *tffs
     * </pre>
     */
    emTFFS(1, 1),
    ;

    /**
     * <code>emRAWFS = 0;</code>
     *
     * <pre>
     *raw file system [ramdisk + rawblock + tffs]
     * </pre>
     */
    public static final int emRAWFS_VALUE = 0;
    /**
     * <code>emTFFS = 1;</code>
     *
     * <pre>
     *tffs
     * </pre>
     */
    public static final int emTFFS_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmFileSys valueOf(int value) {
      switch (value) {
        case 0: return emRAWFS;
        case 1: return emTFFS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFileSys>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFileSys>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFileSys>() {
            public EmFileSys findValueByNumber(int number) {
              return EmFileSys.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(84);
    }

    private static final EmFileSys[] VALUES = values();

    public static EmFileSys valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFileSys(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFileSys)
  }

  /**
   * Protobuf enum {@code mt.EmQoS}
   */
  public enum EmQoS
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emDiffServ = 0;</code>
     *
     * <pre>
     *区分服务
     * </pre>
     */
    emDiffServ(0, 0),
    /**
     * <code>emIPPrecedence = 1;</code>
     *
     * <pre>
     *IP优先
     * </pre>
     */
    emIPPrecedence(1, 1),
    ;

    /**
     * <code>emDiffServ = 0;</code>
     *
     * <pre>
     *区分服务
     * </pre>
     */
    public static final int emDiffServ_VALUE = 0;
    /**
     * <code>emIPPrecedence = 1;</code>
     *
     * <pre>
     *IP优先
     * </pre>
     */
    public static final int emIPPrecedence_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmQoS valueOf(int value) {
      switch (value) {
        case 0: return emDiffServ;
        case 1: return emIPPrecedence;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmQoS>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmQoS>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmQoS>() {
            public EmQoS findValueByNumber(int number) {
              return EmQoS.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(85);
    }

    private static final EmQoS[] VALUES = values();

    public static EmQoS valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmQoS(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmQoS)
  }

  /**
   * Protobuf enum {@code mt.EmTOS}
   */
  public enum EmTOS
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emTOSNone = 0;</code>
     *
     * <pre>
     *不使用
     * </pre>
     */
    emTOSNone(0, 0),
    /**
     * <code>emTOSMinCost = 1;</code>
     *
     * <pre>
     *最小开销
     * </pre>
     */
    emTOSMinCost(1, 1),
    /**
     * <code>emTOSMaxReliable = 2;</code>
     *
     * <pre>
     *最高可靠性
     * </pre>
     */
    emTOSMaxReliable(2, 2),
    /**
     * <code>emTOSMaxThruput = 3;</code>
     *
     * <pre>
     *最大吞吐量
     * </pre>
     */
    emTOSMaxThruput(3, 3),
    /**
     * <code>emTOSMinDelay = 4;</code>
     *
     * <pre>
     *最小延迟
     * </pre>
     */
    emTOSMinDelay(4, 4),
    ;

    /**
     * <code>emTOSNone = 0;</code>
     *
     * <pre>
     *不使用
     * </pre>
     */
    public static final int emTOSNone_VALUE = 0;
    /**
     * <code>emTOSMinCost = 1;</code>
     *
     * <pre>
     *最小开销
     * </pre>
     */
    public static final int emTOSMinCost_VALUE = 1;
    /**
     * <code>emTOSMaxReliable = 2;</code>
     *
     * <pre>
     *最高可靠性
     * </pre>
     */
    public static final int emTOSMaxReliable_VALUE = 2;
    /**
     * <code>emTOSMaxThruput = 3;</code>
     *
     * <pre>
     *最大吞吐量
     * </pre>
     */
    public static final int emTOSMaxThruput_VALUE = 3;
    /**
     * <code>emTOSMinDelay = 4;</code>
     *
     * <pre>
     *最小延迟
     * </pre>
     */
    public static final int emTOSMinDelay_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmTOS valueOf(int value) {
      switch (value) {
        case 0: return emTOSNone;
        case 1: return emTOSMinCost;
        case 2: return emTOSMaxReliable;
        case 3: return emTOSMaxThruput;
        case 4: return emTOSMinDelay;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmTOS>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmTOS>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmTOS>() {
            public EmTOS findValueByNumber(int number) {
              return EmTOS.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(86);
    }

    private static final EmTOS[] VALUES = values();

    public static EmTOS valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmTOS(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmTOS)
  }

  /**
   * Protobuf enum {@code mt.EmCodecEvent}
   */
  public enum EmCodecEvent
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAudSpkMute = 0;</code>
     *
     * <pre>
     *系统扬声器静音
     * </pre>
     */
    emAudSpkMute(0, 0),
    /**
     * <code>emAudMicMute = 1;</code>
     *
     * <pre>
     *系统麦克风静音（或者未选中相应的设备）
     * </pre>
     */
    emAudMicMute(1, 1),
    /**
     * <code>emAudMicVolChange = 2;</code>
     *
     * <pre>
     *麦克风音量改变
     * </pre>
     */
    emAudMicVolChange(2, 2),
    /**
     * <code>emAudSpkVolChange = 3;</code>
     *
     * <pre>
     *扬声器音量改变
     * </pre>
     */
    emAudSpkVolChange(3, 3),
    /**
     * <code>emAudAecInvalid = 4;</code>
     *
     * <pre>
     *AEC失效且无法通过重置恢复
     * </pre>
     */
    emAudAecInvalid(4, 4),
    /**
     * <code>emVidChange = 6;</code>
     *
     * <pre>
     *视频保留事件
     * </pre>
     */
    emVidChange(5, 6),
    /**
     * <code>emNetLostPackLv1 = 7;</code>
     *
     * <pre>
     *级别1网络丢包
     * </pre>
     */
    emNetLostPackLv1(6, 7),
    /**
     * <code>emNetLostPackLv2 = 8;</code>
     *
     * <pre>
     *级别2网络丢包
     * </pre>
     */
    emNetLostPackLv2(7, 8),
    /**
     * <code>emNetLostPackLv3 = 9;</code>
     *
     * <pre>
     *级别3网络丢包
     * </pre>
     */
    emNetLostPackLv3(8, 9),
    /**
     * <code>emNoVidCapDev = 10;</code>
     *
     * <pre>
     *不存在图像采集设备
     * </pre>
     */
    emNoVidCapDev(9, 10),
    /**
     * <code>emNoAudCapDev = 11;</code>
     *
     * <pre>
     *不存在声音采集设备
     * </pre>
     */
    emNoAudCapDev(10, 11),
    /**
     * <code>emNoAudPlyDev = 12;</code>
     *
     * <pre>
     *不存在声音播放设备
     * </pre>
     */
    emNoAudPlyDev(11, 12),
    /**
     * <code>emOtherEvent = 13;</code>
     *
     * <pre>
     *保留事件
     * </pre>
     */
    emOtherEvent(12, 13),
    ;

    /**
     * <code>emAudSpkMute = 0;</code>
     *
     * <pre>
     *系统扬声器静音
     * </pre>
     */
    public static final int emAudSpkMute_VALUE = 0;
    /**
     * <code>emAudMicMute = 1;</code>
     *
     * <pre>
     *系统麦克风静音（或者未选中相应的设备）
     * </pre>
     */
    public static final int emAudMicMute_VALUE = 1;
    /**
     * <code>emAudMicVolChange = 2;</code>
     *
     * <pre>
     *麦克风音量改变
     * </pre>
     */
    public static final int emAudMicVolChange_VALUE = 2;
    /**
     * <code>emAudSpkVolChange = 3;</code>
     *
     * <pre>
     *扬声器音量改变
     * </pre>
     */
    public static final int emAudSpkVolChange_VALUE = 3;
    /**
     * <code>emAudAecInvalid = 4;</code>
     *
     * <pre>
     *AEC失效且无法通过重置恢复
     * </pre>
     */
    public static final int emAudAecInvalid_VALUE = 4;
    /**
     * <code>emVidChange = 6;</code>
     *
     * <pre>
     *视频保留事件
     * </pre>
     */
    public static final int emVidChange_VALUE = 6;
    /**
     * <code>emNetLostPackLv1 = 7;</code>
     *
     * <pre>
     *级别1网络丢包
     * </pre>
     */
    public static final int emNetLostPackLv1_VALUE = 7;
    /**
     * <code>emNetLostPackLv2 = 8;</code>
     *
     * <pre>
     *级别2网络丢包
     * </pre>
     */
    public static final int emNetLostPackLv2_VALUE = 8;
    /**
     * <code>emNetLostPackLv3 = 9;</code>
     *
     * <pre>
     *级别3网络丢包
     * </pre>
     */
    public static final int emNetLostPackLv3_VALUE = 9;
    /**
     * <code>emNoVidCapDev = 10;</code>
     *
     * <pre>
     *不存在图像采集设备
     * </pre>
     */
    public static final int emNoVidCapDev_VALUE = 10;
    /**
     * <code>emNoAudCapDev = 11;</code>
     *
     * <pre>
     *不存在声音采集设备
     * </pre>
     */
    public static final int emNoAudCapDev_VALUE = 11;
    /**
     * <code>emNoAudPlyDev = 12;</code>
     *
     * <pre>
     *不存在声音播放设备
     * </pre>
     */
    public static final int emNoAudPlyDev_VALUE = 12;
    /**
     * <code>emOtherEvent = 13;</code>
     *
     * <pre>
     *保留事件
     * </pre>
     */
    public static final int emOtherEvent_VALUE = 13;


    public final int getNumber() { return value; }

    public static EmCodecEvent valueOf(int value) {
      switch (value) {
        case 0: return emAudSpkMute;
        case 1: return emAudMicMute;
        case 2: return emAudMicVolChange;
        case 3: return emAudSpkVolChange;
        case 4: return emAudAecInvalid;
        case 6: return emVidChange;
        case 7: return emNetLostPackLv1;
        case 8: return emNetLostPackLv2;
        case 9: return emNetLostPackLv3;
        case 10: return emNoVidCapDev;
        case 11: return emNoAudCapDev;
        case 12: return emNoAudPlyDev;
        case 13: return emOtherEvent;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCodecEvent>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCodecEvent>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCodecEvent>() {
            public EmCodecEvent findValueByNumber(int number) {
              return EmCodecEvent.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(87);
    }

    private static final EmCodecEvent[] VALUES = values();

    public static EmCodecEvent valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCodecEvent(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCodecEvent)
  }

  /**
   * Protobuf enum {@code mt.EmMtcType}
   */
  public enum EmMtcType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUnkownT = 0;</code>
     *
     * <pre>
     *表示未知类型
     * </pre>
     */
    emUnkownT(0, 0),
    /**
     * <code>emMtcT = 1;</code>
     *
     * <pre>
     *mtc类型终端客户端
     * </pre>
     */
    emMtcT(1, 1),
    /**
     * <code>emPcdvT = 2;</code>
     *
     * <pre>
     *pc流类型终端客户端
     * </pre>
     */
    emPcdvT(2, 2),
    /**
     * <code>emNctT = 3;</code>
     *
     * <pre>
     *服务器配置类型终端客户端
     * </pre>
     */
    emNctT(3, 3),
    ;

    /**
     * <code>emUnkownT = 0;</code>
     *
     * <pre>
     *表示未知类型
     * </pre>
     */
    public static final int emUnkownT_VALUE = 0;
    /**
     * <code>emMtcT = 1;</code>
     *
     * <pre>
     *mtc类型终端客户端
     * </pre>
     */
    public static final int emMtcT_VALUE = 1;
    /**
     * <code>emPcdvT = 2;</code>
     *
     * <pre>
     *pc流类型终端客户端
     * </pre>
     */
    public static final int emPcdvT_VALUE = 2;
    /**
     * <code>emNctT = 3;</code>
     *
     * <pre>
     *服务器配置类型终端客户端
     * </pre>
     */
    public static final int emNctT_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMtcType valueOf(int value) {
      switch (value) {
        case 0: return emUnkownT;
        case 1: return emMtcT;
        case 2: return emPcdvT;
        case 3: return emNctT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtcType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtcType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtcType>() {
            public EmMtcType findValueByNumber(int number) {
              return EmMtcType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(88);
    }

    private static final EmMtcType[] VALUES = values();

    public static EmMtcType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtcType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtcType)
  }

  /**
   * Protobuf enum {@code mt.EmMtSleepState}
   */
  public enum EmMtSleepState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWakeup = 0;</code>
     *
     * <pre>
     *唤醒状态
     * </pre>
     */
    emWakeup(0, 0),
    /**
     * <code>emCountDown = 1;</code>
     *
     * <pre>
     *待机倒计时
     * </pre>
     */
    emCountDown(1, 1),
    /**
     * <code>emStandbyIng = 2;</code>
     *
     * <pre>
     *正在待机
     * </pre>
     */
    emStandbyIng(2, 2),
    /**
     * <code>emStandby = 3;</code>
     *
     * <pre>
     *已待机
     * </pre>
     */
    emStandby(3, 3),
    /**
     * <code>emWakeuping = 4;</code>
     *
     * <pre>
     *正在唤醒
     * </pre>
     */
    emWakeuping(4, 4),
    /**
     * <code>emStandbyProtect = 5;</code>
     *
     * <pre>
     *待机保护
     * </pre>
     */
    emStandbyProtect(5, 5),
    ;

    /**
     * <code>emWakeup = 0;</code>
     *
     * <pre>
     *唤醒状态
     * </pre>
     */
    public static final int emWakeup_VALUE = 0;
    /**
     * <code>emCountDown = 1;</code>
     *
     * <pre>
     *待机倒计时
     * </pre>
     */
    public static final int emCountDown_VALUE = 1;
    /**
     * <code>emStandbyIng = 2;</code>
     *
     * <pre>
     *正在待机
     * </pre>
     */
    public static final int emStandbyIng_VALUE = 2;
    /**
     * <code>emStandby = 3;</code>
     *
     * <pre>
     *已待机
     * </pre>
     */
    public static final int emStandby_VALUE = 3;
    /**
     * <code>emWakeuping = 4;</code>
     *
     * <pre>
     *正在唤醒
     * </pre>
     */
    public static final int emWakeuping_VALUE = 4;
    /**
     * <code>emStandbyProtect = 5;</code>
     *
     * <pre>
     *待机保护
     * </pre>
     */
    public static final int emStandbyProtect_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmMtSleepState valueOf(int value) {
      switch (value) {
        case 0: return emWakeup;
        case 1: return emCountDown;
        case 2: return emStandbyIng;
        case 3: return emStandby;
        case 4: return emWakeuping;
        case 5: return emStandbyProtect;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtSleepState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtSleepState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtSleepState>() {
            public EmMtSleepState findValueByNumber(int number) {
              return EmMtSleepState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(89);
    }

    private static final EmMtSleepState[] VALUES = values();

    public static EmMtSleepState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtSleepState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtSleepState)
  }

  /**
   * Protobuf enum {@code mt.EmMtPortType}
   */
  public enum EmMtPortType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPortInvalid = 0;</code>
     */
    emPortInvalid(0, 0),
    /**
     * <code>emPortTcpForH323 = 1;</code>
     */
    emPortTcpForH323(1, 1),
    /**
     * <code>emPortMP = 2;</code>
     *
     * <pre>
     *媒体端口 包括音视频编解码器端口
     * </pre>
     */
    emPortMP(2, 2),
    /**
     * <code>emPortAudioEncoder = 3;</code>
     *
     * <pre>
     * 音频编码器
     * </pre>
     */
    emPortAudioEncoder(3, 3),
    /**
     * <code>emPortAudioDecoder = 4;</code>
     *
     * <pre>
     * 音频解码器
     * </pre>
     */
    emPortAudioDecoder(4, 4),
    /**
     * <code>emPortVideoEncoder = 5;</code>
     *
     * <pre>
     * 视频编码器
     * </pre>
     */
    emPortVideoEncoder(5, 5),
    /**
     * <code>emPortVideoDecoder = 6;</code>
     *
     * <pre>
     * 视频解码器
     * </pre>
     */
    emPortVideoDecoder(6, 6),
    /**
     * <code>emPortFwdPcAssStream = 7;</code>
     *
     * <pre>
     * pc控制台辅流转发
     * </pre>
     */
    emPortFwdPcAssStream(7, 7),
    /**
     * <code>emPortFwdAudioLoop = 8;</code>
     *
     * <pre>
     * 音频自环
     * </pre>
     */
    emPortFwdAudioLoop(8, 8),
    /**
     * <code>emPortFwdVedioLoop = 9;</code>
     *
     * <pre>
     * 视频自环
     * </pre>
     */
    emPortFwdVedioLoop(9, 9),
    /**
     * <code>emMcNetBuf = 10;</code>
     *
     * <pre>
     * 内置mc中netbuf音视频——音频两对udp端口，主视频两对udp端口，辅视频两对udp端口
     * </pre>
     */
    emMcNetBuf(10, 10),
    /**
     * <code>emPortMcVmp = 11;</code>
     *
     * <pre>
     * 内置MC画面合成相关	——双流一对udp端口，合成生成结果端口一对udp端口，合成输入端口n对udp端口
     * </pre>
     */
    emPortMcVmp(11, 11),
    /**
     * <code>emPortMcMixer = 12;</code>
     *
     * <pre>
     * 内置MC混音器相关——混音生成结果端口一对udp端口，混音输入端口n对udp端口
     * </pre>
     */
    emPortMcMixer(12, 12),
    /**
     * <code>emPortInnerMcAudio = 13;</code>
     *
     * <pre>
     * 内置MC终端EP对应的本地音频端口——（n+1）*（一对音频接收端口和一对音频发送端口）
     * </pre>
     */
    emPortInnerMcAudio(13, 13),
    /**
     * <code>emPortInnerMcVedio = 14;</code>
     *
     * <pre>
     * 内置MC终端EP对应的本地视频端口——（n+1）*（一对主视频接收端口、一对主视频发送端口、一对辅视频接收端口、一对辅视频发送端口
     * </pre>
     */
    emPortInnerMcVedio(14, 14),
    /**
     * <code>emPortMc = 15;</code>
     *
     * <pre>
     * 内置mc中所有端口之和——emPortInnerMcAudio+emPortInnerMcVedio+emMcNetBuf+emPortMcVmp+emPortMcMixer
     * </pre>
     */
    emPortMc(15, 15),
    /**
     * <code>emPortInnerProxy = 16;</code>
     *
     * <pre>
     * 内置代理emMcNetBuf
     * </pre>
     */
    emPortInnerProxy(16, 16),
    ;

    /**
     * <code>emPortInvalid = 0;</code>
     */
    public static final int emPortInvalid_VALUE = 0;
    /**
     * <code>emPortTcpForH323 = 1;</code>
     */
    public static final int emPortTcpForH323_VALUE = 1;
    /**
     * <code>emPortMP = 2;</code>
     *
     * <pre>
     *媒体端口 包括音视频编解码器端口
     * </pre>
     */
    public static final int emPortMP_VALUE = 2;
    /**
     * <code>emPortAudioEncoder = 3;</code>
     *
     * <pre>
     * 音频编码器
     * </pre>
     */
    public static final int emPortAudioEncoder_VALUE = 3;
    /**
     * <code>emPortAudioDecoder = 4;</code>
     *
     * <pre>
     * 音频解码器
     * </pre>
     */
    public static final int emPortAudioDecoder_VALUE = 4;
    /**
     * <code>emPortVideoEncoder = 5;</code>
     *
     * <pre>
     * 视频编码器
     * </pre>
     */
    public static final int emPortVideoEncoder_VALUE = 5;
    /**
     * <code>emPortVideoDecoder = 6;</code>
     *
     * <pre>
     * 视频解码器
     * </pre>
     */
    public static final int emPortVideoDecoder_VALUE = 6;
    /**
     * <code>emPortFwdPcAssStream = 7;</code>
     *
     * <pre>
     * pc控制台辅流转发
     * </pre>
     */
    public static final int emPortFwdPcAssStream_VALUE = 7;
    /**
     * <code>emPortFwdAudioLoop = 8;</code>
     *
     * <pre>
     * 音频自环
     * </pre>
     */
    public static final int emPortFwdAudioLoop_VALUE = 8;
    /**
     * <code>emPortFwdVedioLoop = 9;</code>
     *
     * <pre>
     * 视频自环
     * </pre>
     */
    public static final int emPortFwdVedioLoop_VALUE = 9;
    /**
     * <code>emMcNetBuf = 10;</code>
     *
     * <pre>
     * 内置mc中netbuf音视频——音频两对udp端口，主视频两对udp端口，辅视频两对udp端口
     * </pre>
     */
    public static final int emMcNetBuf_VALUE = 10;
    /**
     * <code>emPortMcVmp = 11;</code>
     *
     * <pre>
     * 内置MC画面合成相关	——双流一对udp端口，合成生成结果端口一对udp端口，合成输入端口n对udp端口
     * </pre>
     */
    public static final int emPortMcVmp_VALUE = 11;
    /**
     * <code>emPortMcMixer = 12;</code>
     *
     * <pre>
     * 内置MC混音器相关——混音生成结果端口一对udp端口，混音输入端口n对udp端口
     * </pre>
     */
    public static final int emPortMcMixer_VALUE = 12;
    /**
     * <code>emPortInnerMcAudio = 13;</code>
     *
     * <pre>
     * 内置MC终端EP对应的本地音频端口——（n+1）*（一对音频接收端口和一对音频发送端口）
     * </pre>
     */
    public static final int emPortInnerMcAudio_VALUE = 13;
    /**
     * <code>emPortInnerMcVedio = 14;</code>
     *
     * <pre>
     * 内置MC终端EP对应的本地视频端口——（n+1）*（一对主视频接收端口、一对主视频发送端口、一对辅视频接收端口、一对辅视频发送端口
     * </pre>
     */
    public static final int emPortInnerMcVedio_VALUE = 14;
    /**
     * <code>emPortMc = 15;</code>
     *
     * <pre>
     * 内置mc中所有端口之和——emPortInnerMcAudio+emPortInnerMcVedio+emMcNetBuf+emPortMcVmp+emPortMcMixer
     * </pre>
     */
    public static final int emPortMc_VALUE = 15;
    /**
     * <code>emPortInnerProxy = 16;</code>
     *
     * <pre>
     * 内置代理emMcNetBuf
     * </pre>
     */
    public static final int emPortInnerProxy_VALUE = 16;


    public final int getNumber() { return value; }

    public static EmMtPortType valueOf(int value) {
      switch (value) {
        case 0: return emPortInvalid;
        case 1: return emPortTcpForH323;
        case 2: return emPortMP;
        case 3: return emPortAudioEncoder;
        case 4: return emPortAudioDecoder;
        case 5: return emPortVideoEncoder;
        case 6: return emPortVideoDecoder;
        case 7: return emPortFwdPcAssStream;
        case 8: return emPortFwdAudioLoop;
        case 9: return emPortFwdVedioLoop;
        case 10: return emMcNetBuf;
        case 11: return emPortMcVmp;
        case 12: return emPortMcMixer;
        case 13: return emPortInnerMcAudio;
        case 14: return emPortInnerMcVedio;
        case 15: return emPortMc;
        case 16: return emPortInnerProxy;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtPortType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtPortType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtPortType>() {
            public EmMtPortType findValueByNumber(int number) {
              return EmMtPortType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(90);
    }

    private static final EmMtPortType[] VALUES = values();

    public static EmMtPortType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtPortType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtPortType)
  }

  /**
   * Protobuf enum {@code mt.EmLabelType}
   *
   * <pre>
   *OSD台标类型
   * </pre>
   */
  public enum EmLabelType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emLabelAuto = 0;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    emLabelAuto(0, 0),
    /**
     * <code>emLabelUserDef = 1;</code>
     *
     * <pre>
     *自定义
     * </pre>
     */
    emLabelUserDef(1, 1),
    /**
     * <code>emLabelUserDefPic = 2;</code>
     *
     * <pre>
     *自定义图片
     * </pre>
     */
    emLabelUserDefPic(2, 2),
    /**
     * <code>emLabelOff = 3;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    emLabelOff(3, 3),
    ;

    /**
     * <code>emLabelAuto = 0;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    public static final int emLabelAuto_VALUE = 0;
    /**
     * <code>emLabelUserDef = 1;</code>
     *
     * <pre>
     *自定义
     * </pre>
     */
    public static final int emLabelUserDef_VALUE = 1;
    /**
     * <code>emLabelUserDefPic = 2;</code>
     *
     * <pre>
     *自定义图片
     * </pre>
     */
    public static final int emLabelUserDefPic_VALUE = 2;
    /**
     * <code>emLabelOff = 3;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    public static final int emLabelOff_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmLabelType valueOf(int value) {
      switch (value) {
        case 0: return emLabelAuto;
        case 1: return emLabelUserDef;
        case 2: return emLabelUserDefPic;
        case 3: return emLabelOff;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmLabelType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmLabelType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmLabelType>() {
            public EmLabelType findValueByNumber(int number) {
              return EmLabelType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(91);
    }

    private static final EmLabelType[] VALUES = values();

    public static EmLabelType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmLabelType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmLabelType)
  }

  /**
   * Protobuf enum {@code mt.EmLabelPosType}
   *
   * <pre>
   *OSD台标位置
   * </pre>
   */
  public enum EmLabelPosType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emTopLeft = 0;</code>
     */
    emTopLeft(0, 0),
    /**
     * <code>emTopRight = 1;</code>
     */
    emTopRight(1, 1),
    /**
     * <code>emBottomLeft = 2;</code>
     */
    emBottomLeft(2, 2),
    /**
     * <code>emBottomRight = 3;</code>
     */
    emBottomRight(3, 3),
    /**
     * <code>emCustom = 4;</code>
     */
    emCustom(4, 4),
    ;

    /**
     * <code>emTopLeft = 0;</code>
     */
    public static final int emTopLeft_VALUE = 0;
    /**
     * <code>emTopRight = 1;</code>
     */
    public static final int emTopRight_VALUE = 1;
    /**
     * <code>emBottomLeft = 2;</code>
     */
    public static final int emBottomLeft_VALUE = 2;
    /**
     * <code>emBottomRight = 3;</code>
     */
    public static final int emBottomRight_VALUE = 3;
    /**
     * <code>emCustom = 4;</code>
     */
    public static final int emCustom_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmLabelPosType valueOf(int value) {
      switch (value) {
        case 0: return emTopLeft;
        case 1: return emTopRight;
        case 2: return emBottomLeft;
        case 3: return emBottomRight;
        case 4: return emCustom;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmLabelPosType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmLabelPosType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmLabelPosType>() {
            public EmLabelPosType findValueByNumber(int number) {
              return EmLabelPosType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(92);
    }

    private static final EmLabelPosType[] VALUES = values();

    public static EmLabelPosType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmLabelPosType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmLabelPosType)
  }

  /**
   * Protobuf enum {@code mt.EmDualVideoShowMode}
   *
   * <pre>
   *双流显示模式
   * </pre>
   */
  public enum EmDualVideoShowMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emDualVideoOnSigleScreen = 1;</code>
     *
     * <pre>
     *单屏双显
     * </pre>
     */
    emDualVideoOnSigleScreen(0, 1),
    /**
     * <code>emEachVideoOwnScreen = 2;</code>
     *
     * <pre>
     *双屏双显
     * </pre>
     */
    emEachVideoOwnScreen(1, 2),
    /**
     * <code>emTripleVideoOnSingleScn = 3;</code>
     *
     * <pre>
     *单屏三显
     * </pre>
     */
    emTripleVideoOnSingleScn(2, 3),
    /**
     * <code>emThreeVideoOnThreeScreen = 4;</code>
     *
     * <pre>
     *三屏三显
     * </pre>
     */
    emThreeVideoOnThreeScreen(3, 4),
    ;

    /**
     * <code>emDualVideoOnSigleScreen = 1;</code>
     *
     * <pre>
     *单屏双显
     * </pre>
     */
    public static final int emDualVideoOnSigleScreen_VALUE = 1;
    /**
     * <code>emEachVideoOwnScreen = 2;</code>
     *
     * <pre>
     *双屏双显
     * </pre>
     */
    public static final int emEachVideoOwnScreen_VALUE = 2;
    /**
     * <code>emTripleVideoOnSingleScn = 3;</code>
     *
     * <pre>
     *单屏三显
     * </pre>
     */
    public static final int emTripleVideoOnSingleScn_VALUE = 3;
    /**
     * <code>emThreeVideoOnThreeScreen = 4;</code>
     *
     * <pre>
     *三屏三显
     * </pre>
     */
    public static final int emThreeVideoOnThreeScreen_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmDualVideoShowMode valueOf(int value) {
      switch (value) {
        case 1: return emDualVideoOnSigleScreen;
        case 2: return emEachVideoOwnScreen;
        case 3: return emTripleVideoOnSingleScn;
        case 4: return emThreeVideoOnThreeScreen;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDualVideoShowMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDualVideoShowMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDualVideoShowMode>() {
            public EmDualVideoShowMode findValueByNumber(int number) {
              return EmDualVideoShowMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(93);
    }

    private static final EmDualVideoShowMode[] VALUES = values();

    public static EmDualVideoShowMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDualVideoShowMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDualVideoShowMode)
  }

  /**
   * Protobuf enum {@code mt.EmPiPMode}
   *
   * <pre>
   *画中画显示模式
   * </pre>
   */
  public enum EmPiPMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPipInvalid = 0;</code>
     *
     * <pre>
     *无效的画中画
     * </pre>
     */
    emPipInvalid(0, 0),
    /**
     * <code>emPiPClose = 1;</code>
     *
     * <pre>
     *画中画关闭
     * </pre>
     */
    emPiPClose(1, 1),
    /**
     * <code>emPIPLeftRight = 2;</code>
     *
     * <pre>
     *两画面，左右对等
     * </pre>
     */
    emPIPLeftRight(2, 2),
    /**
     * <code>emPiPRightBottom = 3;</code>
     *
     * <pre>
     *画中画小画面显示在右下角
     * </pre>
     */
    emPiPRightBottom(3, 3),
    /**
     * <code>emPiPLeftBottom = 4;</code>
     *
     * <pre>
     *画中画小画面显示在左下角
     * </pre>
     */
    emPiPLeftBottom(4, 4),
    /**
     * <code>emPiPLeftTop = 5;</code>
     *
     * <pre>
     *画中画小画面显示在左上角
     * </pre>
     */
    emPiPLeftTop(5, 5),
    /**
     * <code>emPiPRightTop = 6;</code>
     *
     * <pre>
     *画中画小画面显示在右上角
     * </pre>
     */
    emPiPRightTop(6, 6),
    /**
     * <code>emPiPTwoSmallLeftInOneBig = 7;</code>
     *
     * <pre>
     *一大两小，大画面包含两个小画面(小画面靠左)	
     * </pre>
     */
    emPiPTwoSmallLeftInOneBig(7, 7),
    /**
     * <code>emPiPTwoSmallRightInOneBig = 8;</code>
     *
     * <pre>
     *一大两小，大画面包含两个小画面(小画面靠右)	
     * </pre>
     */
    emPiPTwoSmallRightInOneBig(8, 8),
    /**
     * <code>emPiPOneBigAndTwoSmall = 9;</code>
     *
     * <pre>
     *一大两小，大画面右侧画外有两个小画面	
     * </pre>
     */
    emPiPOneBigAndTwoSmall(9, 9),
    /**
     * <code>emPiPThree = 10;</code>
     *
     * <pre>
     *三画面,品字形
     * </pre>
     */
    emPiPThree(10, 10),
    ;

    /**
     * <code>emPipInvalid = 0;</code>
     *
     * <pre>
     *无效的画中画
     * </pre>
     */
    public static final int emPipInvalid_VALUE = 0;
    /**
     * <code>emPiPClose = 1;</code>
     *
     * <pre>
     *画中画关闭
     * </pre>
     */
    public static final int emPiPClose_VALUE = 1;
    /**
     * <code>emPIPLeftRight = 2;</code>
     *
     * <pre>
     *两画面，左右对等
     * </pre>
     */
    public static final int emPIPLeftRight_VALUE = 2;
    /**
     * <code>emPiPRightBottom = 3;</code>
     *
     * <pre>
     *画中画小画面显示在右下角
     * </pre>
     */
    public static final int emPiPRightBottom_VALUE = 3;
    /**
     * <code>emPiPLeftBottom = 4;</code>
     *
     * <pre>
     *画中画小画面显示在左下角
     * </pre>
     */
    public static final int emPiPLeftBottom_VALUE = 4;
    /**
     * <code>emPiPLeftTop = 5;</code>
     *
     * <pre>
     *画中画小画面显示在左上角
     * </pre>
     */
    public static final int emPiPLeftTop_VALUE = 5;
    /**
     * <code>emPiPRightTop = 6;</code>
     *
     * <pre>
     *画中画小画面显示在右上角
     * </pre>
     */
    public static final int emPiPRightTop_VALUE = 6;
    /**
     * <code>emPiPTwoSmallLeftInOneBig = 7;</code>
     *
     * <pre>
     *一大两小，大画面包含两个小画面(小画面靠左)	
     * </pre>
     */
    public static final int emPiPTwoSmallLeftInOneBig_VALUE = 7;
    /**
     * <code>emPiPTwoSmallRightInOneBig = 8;</code>
     *
     * <pre>
     *一大两小，大画面包含两个小画面(小画面靠右)	
     * </pre>
     */
    public static final int emPiPTwoSmallRightInOneBig_VALUE = 8;
    /**
     * <code>emPiPOneBigAndTwoSmall = 9;</code>
     *
     * <pre>
     *一大两小，大画面右侧画外有两个小画面	
     * </pre>
     */
    public static final int emPiPOneBigAndTwoSmall_VALUE = 9;
    /**
     * <code>emPiPThree = 10;</code>
     *
     * <pre>
     *三画面,品字形
     * </pre>
     */
    public static final int emPiPThree_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmPiPMode valueOf(int value) {
      switch (value) {
        case 0: return emPipInvalid;
        case 1: return emPiPClose;
        case 2: return emPIPLeftRight;
        case 3: return emPiPRightBottom;
        case 4: return emPiPLeftBottom;
        case 5: return emPiPLeftTop;
        case 6: return emPiPRightTop;
        case 7: return emPiPTwoSmallLeftInOneBig;
        case 8: return emPiPTwoSmallRightInOneBig;
        case 9: return emPiPOneBigAndTwoSmall;
        case 10: return emPiPThree;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPiPMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPiPMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPiPMode>() {
            public EmPiPMode findValueByNumber(int number) {
              return EmPiPMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(94);
    }

    private static final EmPiPMode[] VALUES = values();

    public static EmPiPMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPiPMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPiPMode)
  }

  /**
   * Protobuf enum {@code mt.EmDisplayDeviceType}
   *
   * <pre>
   *显示设别类型
   * </pre>
   */
  public enum EmDisplayDeviceType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCRT = 1;</code>
     */
    emCRT(0, 1),
    /**
     * <code>emLCD = 2;</code>
     */
    emLCD(1, 2),
    ;

    /**
     * <code>emCRT = 1;</code>
     */
    public static final int emCRT_VALUE = 1;
    /**
     * <code>emLCD = 2;</code>
     */
    public static final int emLCD_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmDisplayDeviceType valueOf(int value) {
      switch (value) {
        case 1: return emCRT;
        case 2: return emLCD;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDisplayDeviceType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDisplayDeviceType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDisplayDeviceType>() {
            public EmDisplayDeviceType findValueByNumber(int number) {
              return EmDisplayDeviceType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(95);
    }

    private static final EmDisplayDeviceType[] VALUES = values();

    public static EmDisplayDeviceType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDisplayDeviceType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDisplayDeviceType)
  }

  /**
   * Protobuf enum {@code mt.EmOsdScreenMode}
   *
   * <pre>
   *OSD界面模式
   * </pre>
   */
  public enum EmOsdScreenMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSimple = 1;</code>
     *
     * <pre>
     *简单模式
     * </pre>
     */
    emSimple(0, 1),
    /**
     * <code>emNormal = 2;</code>
     *
     * <pre>
     *普通模式
     * </pre>
     */
    emNormal(1, 2),
    /**
     * <code>emAdvanced = 3;</code>
     *
     * <pre>
     *高级模式
     * </pre>
     */
    emAdvanced(2, 3),
    ;

    /**
     * <code>emSimple = 1;</code>
     *
     * <pre>
     *简单模式
     * </pre>
     */
    public static final int emSimple_VALUE = 1;
    /**
     * <code>emNormal = 2;</code>
     *
     * <pre>
     *普通模式
     * </pre>
     */
    public static final int emNormal_VALUE = 2;
    /**
     * <code>emAdvanced = 3;</code>
     *
     * <pre>
     *高级模式
     * </pre>
     */
    public static final int emAdvanced_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmOsdScreenMode valueOf(int value) {
      switch (value) {
        case 1: return emSimple;
        case 2: return emNormal;
        case 3: return emAdvanced;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmOsdScreenMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmOsdScreenMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmOsdScreenMode>() {
            public EmOsdScreenMode findValueByNumber(int number) {
              return EmOsdScreenMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(96);
    }

    private static final EmOsdScreenMode[] VALUES = values();

    public static EmOsdScreenMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmOsdScreenMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmOsdScreenMode)
  }

  /**
   * Protobuf enum {@code mt.EmMtRing}
   */
  public enum EmMtRing
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRingNone = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    emRingNone(0, 0),
    /**
     * <code>emRing1 = 1;</code>
     *
     * <pre>
     *ring1.pcm
     * </pre>
     */
    emRing1(1, 1),
    /**
     * <code>emRing2 = 2;</code>
     *
     * <pre>
     *ring2.pcm
     * </pre>
     */
    emRing2(2, 2),
    /**
     * <code>emRing3 = 3;</code>
     *
     * <pre>
     *ring3.pcm
     * </pre>
     */
    emRing3(3, 3),
    /**
     * <code>emRing4 = 4;</code>
     *
     * <pre>
     *ring4.pcm
     * </pre>
     */
    emRing4(4, 4),
    /**
     * <code>emRing5 = 5;</code>
     *
     * <pre>
     *ring5.pcm
     * </pre>
     */
    emRing5(5, 5),
    /**
     * <code>emRing6 = 6;</code>
     *
     * <pre>
     *ring6.pcm
     * </pre>
     */
    emRing6(6, 6),
    /**
     * <code>emRing7 = 7;</code>
     *
     * <pre>
     *ring7.pcm
     * </pre>
     */
    emRing7(7, 7),
    /**
     * <code>emRing8 = 8;</code>
     *
     * <pre>
     *ring8.pcm
     * </pre>
     */
    emRing8(8, 8),
    /**
     * <code>emRing9 = 9;</code>
     *
     * <pre>
     *ring9.pcm
     * </pre>
     */
    emRing9(9, 9),
    /**
     * <code>emRing10 = 10;</code>
     *
     * <pre>
     *ring10.pcm
     * </pre>
     */
    emRing10(10, 10),
    ;

    /**
     * <code>emRingNone = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    public static final int emRingNone_VALUE = 0;
    /**
     * <code>emRing1 = 1;</code>
     *
     * <pre>
     *ring1.pcm
     * </pre>
     */
    public static final int emRing1_VALUE = 1;
    /**
     * <code>emRing2 = 2;</code>
     *
     * <pre>
     *ring2.pcm
     * </pre>
     */
    public static final int emRing2_VALUE = 2;
    /**
     * <code>emRing3 = 3;</code>
     *
     * <pre>
     *ring3.pcm
     * </pre>
     */
    public static final int emRing3_VALUE = 3;
    /**
     * <code>emRing4 = 4;</code>
     *
     * <pre>
     *ring4.pcm
     * </pre>
     */
    public static final int emRing4_VALUE = 4;
    /**
     * <code>emRing5 = 5;</code>
     *
     * <pre>
     *ring5.pcm
     * </pre>
     */
    public static final int emRing5_VALUE = 5;
    /**
     * <code>emRing6 = 6;</code>
     *
     * <pre>
     *ring6.pcm
     * </pre>
     */
    public static final int emRing6_VALUE = 6;
    /**
     * <code>emRing7 = 7;</code>
     *
     * <pre>
     *ring7.pcm
     * </pre>
     */
    public static final int emRing7_VALUE = 7;
    /**
     * <code>emRing8 = 8;</code>
     *
     * <pre>
     *ring8.pcm
     * </pre>
     */
    public static final int emRing8_VALUE = 8;
    /**
     * <code>emRing9 = 9;</code>
     *
     * <pre>
     *ring9.pcm
     * </pre>
     */
    public static final int emRing9_VALUE = 9;
    /**
     * <code>emRing10 = 10;</code>
     *
     * <pre>
     *ring10.pcm
     * </pre>
     */
    public static final int emRing10_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmMtRing valueOf(int value) {
      switch (value) {
        case 0: return emRingNone;
        case 1: return emRing1;
        case 2: return emRing2;
        case 3: return emRing3;
        case 4: return emRing4;
        case 5: return emRing5;
        case 6: return emRing6;
        case 7: return emRing7;
        case 8: return emRing8;
        case 9: return emRing9;
        case 10: return emRing10;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtRing>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtRing>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtRing>() {
            public EmMtRing findValueByNumber(int number) {
              return EmMtRing.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(97);
    }

    private static final EmMtRing[] VALUES = values();

    public static EmMtRing valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtRing(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtRing)
  }

  /**
   * Protobuf enum {@code mt.EmMtPathType}
   *
   * <pre>
   ** 数据路径类型 
   * </pre>
   */
  public enum EmMtPathType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPathTypeBgn = 1;</code>
     */
    emPathTypeBgn(0, 1),
    /**
     * <code>emMtPathConfig = 2;</code>
     *
     * <pre>
     *终端配置
     * </pre>
     */
    emMtPathConfig(1, 2),
    /**
     * <code>emMtPathLog = 3;</code>
     *
     * <pre>
     *终端日志
     * </pre>
     */
    emMtPathLog(2, 3),
    /**
     * <code>emMtDataLog = 4;</code>
     *
     * <pre>
     *终端数据
     * </pre>
     */
    emMtDataLog(3, 4),
    /**
     * <code>emMtPathSec = 5;</code>
     *
     * <pre>
     *商密库用到的目录
     * </pre>
     */
    emMtPathSec(4, 5),
    /**
     * <code>emMtPathSecMT = 6;</code>
     *
     * <pre>
     *商密库用到的标准设备证书目录
     * </pre>
     */
    emMtPathSecMT(5, 6),
    /**
     * <code>emMtPathSecEnc = 7;</code>
     *
     * <pre>
     *商密库用到的加密设备证书目录
     * </pre>
     */
    emMtPathSecEnc(6, 7),
    /**
     * <code>emMtPathSecSign = 8;</code>
     *
     * <pre>
     *商密库用到的签名设备目录
     * </pre>
     */
    emMtPathSecSign(7, 8),
    /**
     * <code>emPathTypeEnd = 255;</code>
     */
    emPathTypeEnd(8, 255),
    ;

    /**
     * <code>emPathTypeBgn = 1;</code>
     */
    public static final int emPathTypeBgn_VALUE = 1;
    /**
     * <code>emMtPathConfig = 2;</code>
     *
     * <pre>
     *终端配置
     * </pre>
     */
    public static final int emMtPathConfig_VALUE = 2;
    /**
     * <code>emMtPathLog = 3;</code>
     *
     * <pre>
     *终端日志
     * </pre>
     */
    public static final int emMtPathLog_VALUE = 3;
    /**
     * <code>emMtDataLog = 4;</code>
     *
     * <pre>
     *终端数据
     * </pre>
     */
    public static final int emMtDataLog_VALUE = 4;
    /**
     * <code>emMtPathSec = 5;</code>
     *
     * <pre>
     *商密库用到的目录
     * </pre>
     */
    public static final int emMtPathSec_VALUE = 5;
    /**
     * <code>emMtPathSecMT = 6;</code>
     *
     * <pre>
     *商密库用到的标准设备证书目录
     * </pre>
     */
    public static final int emMtPathSecMT_VALUE = 6;
    /**
     * <code>emMtPathSecEnc = 7;</code>
     *
     * <pre>
     *商密库用到的加密设备证书目录
     * </pre>
     */
    public static final int emMtPathSecEnc_VALUE = 7;
    /**
     * <code>emMtPathSecSign = 8;</code>
     *
     * <pre>
     *商密库用到的签名设备目录
     * </pre>
     */
    public static final int emMtPathSecSign_VALUE = 8;
    /**
     * <code>emPathTypeEnd = 255;</code>
     */
    public static final int emPathTypeEnd_VALUE = 255;


    public final int getNumber() { return value; }

    public static EmMtPathType valueOf(int value) {
      switch (value) {
        case 1: return emPathTypeBgn;
        case 2: return emMtPathConfig;
        case 3: return emMtPathLog;
        case 4: return emMtDataLog;
        case 5: return emMtPathSec;
        case 6: return emMtPathSecMT;
        case 7: return emMtPathSecEnc;
        case 8: return emMtPathSecSign;
        case 255: return emPathTypeEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtPathType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtPathType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtPathType>() {
            public EmMtPathType findValueByNumber(int number) {
              return EmMtPathType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(98);
    }

    private static final EmMtPathType[] VALUES = values();

    public static EmMtPathType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtPathType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtPathType)
  }

  /**
   * Protobuf enum {@code mt.EmMtOnlineState}
   */
  public enum EmMtOnlineState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>em_state_invalid = 0;</code>
     *
     * <pre>
     * 无状态
     * </pre>
     */
    em_state_invalid(0, 0),
    /**
     * <code>em_state_offline = 1;</code>
     *
     * <pre>
     * 离线
     * </pre>
     */
    em_state_offline(1, 1),
    /**
     * <code>em_state_leave = 2;</code>
     *
     * <pre>
     * 暂时离开
     * </pre>
     */
    em_state_leave(2, 2),
    /**
     * <code>em_state_online = 3;</code>
     *
     * <pre>
     * (正常)在线
     * </pre>
     */
    em_state_online(3, 3),
    /**
     * <code>em_state_no_disturb = 4;</code>
     *
     * <pre>
     * 免打扰
     * </pre>
     */
    em_state_no_disturb(4, 4),
    /**
     * <code>em_state_conference = 5;</code>
     *
     * <pre>
     * 会议中
     * </pre>
     */
    em_state_conference(5, 5),
    /**
     * <code>em_state_hidden = 6;</code>
     *
     * <pre>
     * 隐身
     * </pre>
     */
    em_state_hidden(6, 6),
    /**
     * <code>em_state_logining = 7;</code>
     *
     * <pre>
     * 登陆中
     * </pre>
     */
    em_state_logining(7, 7),
    /**
     * <code>em_state_end = 8;</code>
     */
    em_state_end(8, 8),
    ;

    /**
     * <code>em_state_invalid = 0;</code>
     *
     * <pre>
     * 无状态
     * </pre>
     */
    public static final int em_state_invalid_VALUE = 0;
    /**
     * <code>em_state_offline = 1;</code>
     *
     * <pre>
     * 离线
     * </pre>
     */
    public static final int em_state_offline_VALUE = 1;
    /**
     * <code>em_state_leave = 2;</code>
     *
     * <pre>
     * 暂时离开
     * </pre>
     */
    public static final int em_state_leave_VALUE = 2;
    /**
     * <code>em_state_online = 3;</code>
     *
     * <pre>
     * (正常)在线
     * </pre>
     */
    public static final int em_state_online_VALUE = 3;
    /**
     * <code>em_state_no_disturb = 4;</code>
     *
     * <pre>
     * 免打扰
     * </pre>
     */
    public static final int em_state_no_disturb_VALUE = 4;
    /**
     * <code>em_state_conference = 5;</code>
     *
     * <pre>
     * 会议中
     * </pre>
     */
    public static final int em_state_conference_VALUE = 5;
    /**
     * <code>em_state_hidden = 6;</code>
     *
     * <pre>
     * 隐身
     * </pre>
     */
    public static final int em_state_hidden_VALUE = 6;
    /**
     * <code>em_state_logining = 7;</code>
     *
     * <pre>
     * 登陆中
     * </pre>
     */
    public static final int em_state_logining_VALUE = 7;
    /**
     * <code>em_state_end = 8;</code>
     */
    public static final int em_state_end_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmMtOnlineState valueOf(int value) {
      switch (value) {
        case 0: return em_state_invalid;
        case 1: return em_state_offline;
        case 2: return em_state_leave;
        case 3: return em_state_online;
        case 4: return em_state_no_disturb;
        case 5: return em_state_conference;
        case 6: return em_state_hidden;
        case 7: return em_state_logining;
        case 8: return em_state_end;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtOnlineState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtOnlineState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtOnlineState>() {
            public EmMtOnlineState findValueByNumber(int number) {
              return EmMtOnlineState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(99);
    }

    private static final EmMtOnlineState[] VALUES = values();

    public static EmMtOnlineState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtOnlineState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtOnlineState)
  }

  /**
   * Protobuf enum {@code mt.EmMtImTerminalType}
   */
  public enum EmMtImTerminalType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>im_mt_type_unknown = 0;</code>
     *
     * <pre>
     * 未知
     * </pre>
     */
    im_mt_type_unknown(0, 0),
    /**
     * <code>im_mt_type_true_link = 1;</code>
     *
     * <pre>
     * 致邻
     * </pre>
     */
    im_mt_type_true_link(1, 1),
    /**
     * <code>im_mt_type_true_touch_phone = 2;</code>
     *
     * <pre>
     * 手机-android
     * </pre>
     */
    im_mt_type_true_touch_phone(2, 2),
    /**
     * <code>im_mt_type_true_touch_pad = 3;</code>
     *
     * <pre>
     * 平板-ios
     * </pre>
     */
    im_mt_type_true_touch_pad(3, 3),
    /**
     * <code>im_mt_type_true_sens = 4;</code>
     *
     * <pre>
     * 硬终端
     * </pre>
     */
    im_mt_type_true_sens(4, 4),
    /**
     * <code>im_mt_type_true_touch_phone_ios = 5;</code>
     *
     * <pre>
     * 手机-ios
     * </pre>
     */
    im_mt_type_true_touch_phone_ios(5, 5),
    /**
     * <code>im_mt_type_true_touch_pad_android = 6;</code>
     *
     * <pre>
     * 平板-android
     * </pre>
     */
    im_mt_type_true_touch_pad_android(6, 6),
    /**
     * <code>im_mt_type_web = 7;</code>
     */
    im_mt_type_web(7, 7),
    /**
     * <code>im_mt_type_true_link_tv = 8;</code>
     *
     * <pre>
     * TV盒子
     * </pre>
     */
    im_mt_type_true_link_tv(8, 8),
    /**
     * <code>im_mt_type_end = 9;</code>
     */
    im_mt_type_end(9, 9),
    ;

    /**
     * <code>im_mt_type_unknown = 0;</code>
     *
     * <pre>
     * 未知
     * </pre>
     */
    public static final int im_mt_type_unknown_VALUE = 0;
    /**
     * <code>im_mt_type_true_link = 1;</code>
     *
     * <pre>
     * 致邻
     * </pre>
     */
    public static final int im_mt_type_true_link_VALUE = 1;
    /**
     * <code>im_mt_type_true_touch_phone = 2;</code>
     *
     * <pre>
     * 手机-android
     * </pre>
     */
    public static final int im_mt_type_true_touch_phone_VALUE = 2;
    /**
     * <code>im_mt_type_true_touch_pad = 3;</code>
     *
     * <pre>
     * 平板-ios
     * </pre>
     */
    public static final int im_mt_type_true_touch_pad_VALUE = 3;
    /**
     * <code>im_mt_type_true_sens = 4;</code>
     *
     * <pre>
     * 硬终端
     * </pre>
     */
    public static final int im_mt_type_true_sens_VALUE = 4;
    /**
     * <code>im_mt_type_true_touch_phone_ios = 5;</code>
     *
     * <pre>
     * 手机-ios
     * </pre>
     */
    public static final int im_mt_type_true_touch_phone_ios_VALUE = 5;
    /**
     * <code>im_mt_type_true_touch_pad_android = 6;</code>
     *
     * <pre>
     * 平板-android
     * </pre>
     */
    public static final int im_mt_type_true_touch_pad_android_VALUE = 6;
    /**
     * <code>im_mt_type_web = 7;</code>
     */
    public static final int im_mt_type_web_VALUE = 7;
    /**
     * <code>im_mt_type_true_link_tv = 8;</code>
     *
     * <pre>
     * TV盒子
     * </pre>
     */
    public static final int im_mt_type_true_link_tv_VALUE = 8;
    /**
     * <code>im_mt_type_end = 9;</code>
     */
    public static final int im_mt_type_end_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmMtImTerminalType valueOf(int value) {
      switch (value) {
        case 0: return im_mt_type_unknown;
        case 1: return im_mt_type_true_link;
        case 2: return im_mt_type_true_touch_phone;
        case 3: return im_mt_type_true_touch_pad;
        case 4: return im_mt_type_true_sens;
        case 5: return im_mt_type_true_touch_phone_ios;
        case 6: return im_mt_type_true_touch_pad_android;
        case 7: return im_mt_type_web;
        case 8: return im_mt_type_true_link_tv;
        case 9: return im_mt_type_end;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtImTerminalType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtImTerminalType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtImTerminalType>() {
            public EmMtImTerminalType findValueByNumber(int number) {
              return EmMtImTerminalType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(100);
    }

    private static final EmMtImTerminalType[] VALUES = values();

    public static EmMtImTerminalType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtImTerminalType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtImTerminalType)
  }

  /**
   * Protobuf enum {@code mt.EmMtFile}
   */
  public enum EmMtFile
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMtFileBegin = 0;</code>
     *
     * <pre>
     *终端文件类型开始
     * </pre>
     */
    emMtFileBegin(0, 0),
    /**
     * <code>emMtConfigFile = 1;</code>
     *
     * <pre>
     *配置文件
     * </pre>
     */
    emMtConfigFile(1, 1),
    /**
     * <code>emMtDebugConfigFile = 2;</code>
     *
     * <pre>
     *调试配置文件	
     * </pre>
     */
    emMtDebugConfigFile(2, 2),
    /**
     * <code>emMtStaticPicFile = 3;</code>
     *
     * <pre>
     *终端静态图片文件
     * </pre>
     */
    emMtStaticPicFile(3, 3),
    /**
     * <code>emMtUpgradeStateFile = 4;</code>
     *
     * <pre>
     *终端升级状态信息保存文件（实现断点续传）
     * </pre>
     */
    emMtUpgradeStateFile(4, 4),
    /**
     * <code>emMtMcLicenseFile = 5;</code>
     *
     * <pre>
     *内置mc的license文件
     * </pre>
     */
    emMtMcLicenseFile(5, 5),
    /**
     * <code>emMtKdvlogCfgFile = 6;</code>
     *
     * <pre>
     *kdvlog模块需要的配置文件
     * </pre>
     */
    emMtKdvlogCfgFile(6, 6),
    /**
     * <code>emMtCorruptConfigFile = 7;</code>
     *
     * <pre>
     *已损坏的配置文件
     * </pre>
     */
    emMtCorruptConfigFile(7, 7),
    /**
     * <code>emMtExceptionFile = 8;</code>
     *
     * <pre>
     *终端崩溃异常文件
     * </pre>
     */
    emMtExceptionFile(8, 8),
    /**
     * <code>emMtLogFile = 9;</code>
     *
     * <pre>
     *终端日志文件路径
     * </pre>
     */
    emMtLogFile(9, 9),
    /**
     * <code>emMtLocalCARASCertFile = 10;</code>
     *
     * <pre>
     *终端打包时存放的CA证书文件(RAS)
     * </pre>
     */
    emMtLocalCARASCertFile(10, 10),
    /**
     * <code>emMtLocalCASM2CertFile = 11;</code>
     *
     * <pre>
     *终端打包时存放的CA证书文件(SM2)
     * </pre>
     */
    emMtLocalCASM2CertFile(11, 11),
    /**
     * <code>emMtSecCACertFile = 12;</code>
     *
     * <pre>
     *商密库用到的Ca证书文件
     * </pre>
     */
    emMtSecCACertFile(12, 12),
    /**
     * <code>emMtSecDeviceCertFile = 13;</code>
     *
     * <pre>
     *商密库用到的设备证书文件
     * </pre>
     */
    emMtSecDeviceCertFile(13, 13),
    /**
     * <code>emMtSecPrivkeyFile = 14;</code>
     *
     * <pre>
     *商密库用到的设备证书对应私钥文件
     * </pre>
     */
    emMtSecPrivkeyFile(14, 14),
    /**
     * <code>emMtSecSignCertFile = 15;</code>
     *
     * <pre>
     *GMTLS使用签名证书文件
     * </pre>
     */
    emMtSecSignCertFile(15, 15),
    /**
     * <code>emMtSecSignPrivKeyFile = 16;</code>
     *
     * <pre>
     *GMTLS使用签名私钥文件
     * </pre>
     */
    emMtSecSignPrivKeyFile(16, 16),
    /**
     * <code>emMtSecEncCertFile = 17;</code>
     *
     * <pre>
     *GMTLS使用加密证书文件
     * </pre>
     */
    emMtSecEncCertFile(17, 17),
    /**
     * <code>emMtSecEncPrivKeyFile = 18;</code>
     *
     * <pre>
     *GMTLS使用加密私钥文件	
     * </pre>
     */
    emMtSecEncPrivKeyFile(18, 18),
    /**
     * <code>emMtAgentTerLicenseFile = 19;</code>
     *
     * <pre>
     *渠道终端license证书文件
     * </pre>
     */
    emMtAgentTerLicenseFile(19, 19),
    /**
     * <code>emMtFileEnd = 255;</code>
     *
     * <pre>
     *终端文件类型结束
     * </pre>
     */
    emMtFileEnd(20, 255),
    ;

    /**
     * <code>emMtFileBegin = 0;</code>
     *
     * <pre>
     *终端文件类型开始
     * </pre>
     */
    public static final int emMtFileBegin_VALUE = 0;
    /**
     * <code>emMtConfigFile = 1;</code>
     *
     * <pre>
     *配置文件
     * </pre>
     */
    public static final int emMtConfigFile_VALUE = 1;
    /**
     * <code>emMtDebugConfigFile = 2;</code>
     *
     * <pre>
     *调试配置文件	
     * </pre>
     */
    public static final int emMtDebugConfigFile_VALUE = 2;
    /**
     * <code>emMtStaticPicFile = 3;</code>
     *
     * <pre>
     *终端静态图片文件
     * </pre>
     */
    public static final int emMtStaticPicFile_VALUE = 3;
    /**
     * <code>emMtUpgradeStateFile = 4;</code>
     *
     * <pre>
     *终端升级状态信息保存文件（实现断点续传）
     * </pre>
     */
    public static final int emMtUpgradeStateFile_VALUE = 4;
    /**
     * <code>emMtMcLicenseFile = 5;</code>
     *
     * <pre>
     *内置mc的license文件
     * </pre>
     */
    public static final int emMtMcLicenseFile_VALUE = 5;
    /**
     * <code>emMtKdvlogCfgFile = 6;</code>
     *
     * <pre>
     *kdvlog模块需要的配置文件
     * </pre>
     */
    public static final int emMtKdvlogCfgFile_VALUE = 6;
    /**
     * <code>emMtCorruptConfigFile = 7;</code>
     *
     * <pre>
     *已损坏的配置文件
     * </pre>
     */
    public static final int emMtCorruptConfigFile_VALUE = 7;
    /**
     * <code>emMtExceptionFile = 8;</code>
     *
     * <pre>
     *终端崩溃异常文件
     * </pre>
     */
    public static final int emMtExceptionFile_VALUE = 8;
    /**
     * <code>emMtLogFile = 9;</code>
     *
     * <pre>
     *终端日志文件路径
     * </pre>
     */
    public static final int emMtLogFile_VALUE = 9;
    /**
     * <code>emMtLocalCARASCertFile = 10;</code>
     *
     * <pre>
     *终端打包时存放的CA证书文件(RAS)
     * </pre>
     */
    public static final int emMtLocalCARASCertFile_VALUE = 10;
    /**
     * <code>emMtLocalCASM2CertFile = 11;</code>
     *
     * <pre>
     *终端打包时存放的CA证书文件(SM2)
     * </pre>
     */
    public static final int emMtLocalCASM2CertFile_VALUE = 11;
    /**
     * <code>emMtSecCACertFile = 12;</code>
     *
     * <pre>
     *商密库用到的Ca证书文件
     * </pre>
     */
    public static final int emMtSecCACertFile_VALUE = 12;
    /**
     * <code>emMtSecDeviceCertFile = 13;</code>
     *
     * <pre>
     *商密库用到的设备证书文件
     * </pre>
     */
    public static final int emMtSecDeviceCertFile_VALUE = 13;
    /**
     * <code>emMtSecPrivkeyFile = 14;</code>
     *
     * <pre>
     *商密库用到的设备证书对应私钥文件
     * </pre>
     */
    public static final int emMtSecPrivkeyFile_VALUE = 14;
    /**
     * <code>emMtSecSignCertFile = 15;</code>
     *
     * <pre>
     *GMTLS使用签名证书文件
     * </pre>
     */
    public static final int emMtSecSignCertFile_VALUE = 15;
    /**
     * <code>emMtSecSignPrivKeyFile = 16;</code>
     *
     * <pre>
     *GMTLS使用签名私钥文件
     * </pre>
     */
    public static final int emMtSecSignPrivKeyFile_VALUE = 16;
    /**
     * <code>emMtSecEncCertFile = 17;</code>
     *
     * <pre>
     *GMTLS使用加密证书文件
     * </pre>
     */
    public static final int emMtSecEncCertFile_VALUE = 17;
    /**
     * <code>emMtSecEncPrivKeyFile = 18;</code>
     *
     * <pre>
     *GMTLS使用加密私钥文件	
     * </pre>
     */
    public static final int emMtSecEncPrivKeyFile_VALUE = 18;
    /**
     * <code>emMtAgentTerLicenseFile = 19;</code>
     *
     * <pre>
     *渠道终端license证书文件
     * </pre>
     */
    public static final int emMtAgentTerLicenseFile_VALUE = 19;
    /**
     * <code>emMtFileEnd = 255;</code>
     *
     * <pre>
     *终端文件类型结束
     * </pre>
     */
    public static final int emMtFileEnd_VALUE = 255;


    public final int getNumber() { return value; }

    public static EmMtFile valueOf(int value) {
      switch (value) {
        case 0: return emMtFileBegin;
        case 1: return emMtConfigFile;
        case 2: return emMtDebugConfigFile;
        case 3: return emMtStaticPicFile;
        case 4: return emMtUpgradeStateFile;
        case 5: return emMtMcLicenseFile;
        case 6: return emMtKdvlogCfgFile;
        case 7: return emMtCorruptConfigFile;
        case 8: return emMtExceptionFile;
        case 9: return emMtLogFile;
        case 10: return emMtLocalCARASCertFile;
        case 11: return emMtLocalCASM2CertFile;
        case 12: return emMtSecCACertFile;
        case 13: return emMtSecDeviceCertFile;
        case 14: return emMtSecPrivkeyFile;
        case 15: return emMtSecSignCertFile;
        case 16: return emMtSecSignPrivKeyFile;
        case 17: return emMtSecEncCertFile;
        case 18: return emMtSecEncPrivKeyFile;
        case 19: return emMtAgentTerLicenseFile;
        case 255: return emMtFileEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtFile>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtFile>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtFile>() {
            public EmMtFile findValueByNumber(int number) {
              return EmMtFile.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(101);
    }

    private static final EmMtFile[] VALUES = values();

    public static EmMtFile valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtFile(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtFile)
  }

  /**
   * Protobuf enum {@code mt.EImDeclineReason}
   */
  public enum EImDeclineReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>im_decline_reason_unknown = 1;</code>
     *
     * <pre>
     * 未知原因
     * </pre>
     */
    im_decline_reason_unknown(0, 1),
    /**
     * <code>im_decline_reason_max_persistent_room_count = 2;</code>
     *
     * <pre>
     * 达到固定群最大数
     * </pre>
     */
    im_decline_reason_max_persistent_room_count(1, 2),
    /**
     * <code>im_decline_reason_max_temporary_room_count = 3;</code>
     *
     * <pre>
     * 达到临时群最大数
     * </pre>
     */
    im_decline_reason_max_temporary_room_count(2, 3),
    /**
     * <code>im_decline_reason_from_weibo = 4;</code>
     *
     * <pre>
     * 仅微博在线时的拒绝
     * </pre>
     */
    im_decline_reason_from_weibo(3, 4),
    ;

    /**
     * <code>im_decline_reason_unknown = 1;</code>
     *
     * <pre>
     * 未知原因
     * </pre>
     */
    public static final int im_decline_reason_unknown_VALUE = 1;
    /**
     * <code>im_decline_reason_max_persistent_room_count = 2;</code>
     *
     * <pre>
     * 达到固定群最大数
     * </pre>
     */
    public static final int im_decline_reason_max_persistent_room_count_VALUE = 2;
    /**
     * <code>im_decline_reason_max_temporary_room_count = 3;</code>
     *
     * <pre>
     * 达到临时群最大数
     * </pre>
     */
    public static final int im_decline_reason_max_temporary_room_count_VALUE = 3;
    /**
     * <code>im_decline_reason_from_weibo = 4;</code>
     *
     * <pre>
     * 仅微博在线时的拒绝
     * </pre>
     */
    public static final int im_decline_reason_from_weibo_VALUE = 4;


    public final int getNumber() { return value; }

    public static EImDeclineReason valueOf(int value) {
      switch (value) {
        case 1: return im_decline_reason_unknown;
        case 2: return im_decline_reason_max_persistent_room_count;
        case 3: return im_decline_reason_max_temporary_room_count;
        case 4: return im_decline_reason_from_weibo;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EImDeclineReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EImDeclineReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EImDeclineReason>() {
            public EImDeclineReason findValueByNumber(int number) {
              return EImDeclineReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(102);
    }

    private static final EImDeclineReason[] VALUES = values();

    public static EImDeclineReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EImDeclineReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EImDeclineReason)
  }

  /**
   * Protobuf enum {@code mt.EImCharState}
   */
  public enum EImCharState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>im_char_state_active = 0;</code>
     */
    im_char_state_active(0, 0),
    /**
     * <code>im_char_state_composing = 1;</code>
     *
     * <pre>
     * 正在输入
     * </pre>
     */
    im_char_state_composing(1, 1),
    /**
     * <code>im_char_state_paused = 2;</code>
     *
     * <pre>
     * 停止输入
     * </pre>
     */
    im_char_state_paused(2, 2),
    ;

    /**
     * <code>im_char_state_active = 0;</code>
     */
    public static final int im_char_state_active_VALUE = 0;
    /**
     * <code>im_char_state_composing = 1;</code>
     *
     * <pre>
     * 正在输入
     * </pre>
     */
    public static final int im_char_state_composing_VALUE = 1;
    /**
     * <code>im_char_state_paused = 2;</code>
     *
     * <pre>
     * 停止输入
     * </pre>
     */
    public static final int im_char_state_paused_VALUE = 2;


    public final int getNumber() { return value; }

    public static EImCharState valueOf(int value) {
      switch (value) {
        case 0: return im_char_state_active;
        case 1: return im_char_state_composing;
        case 2: return im_char_state_paused;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EImCharState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EImCharState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EImCharState>() {
            public EImCharState findValueByNumber(int number) {
              return EImCharState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(103);
    }

    private static final EImCharState[] VALUES = values();

    public static EImCharState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EImCharState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EImCharState)
  }

  /**
   * Protobuf enum {@code mt.EmMtMemberType}
   */
  public enum EmMtMemberType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>em_member_invalid = 0;</code>
     */
    em_member_invalid(0, 0),
    /**
     * <code>em_member_im_id = 1;</code>
     *
     * <pre>
     * XMPP JID
     * </pre>
     */
    em_member_im_id(1, 1),
    /**
     * <code>em_member_telephone = 2;</code>
     *
     * <pre>
     * 电话类型	
     * </pre>
     */
    em_member_telephone(2, 2),
    /**
     * <code>em_member_fxo = 3;</code>
     *
     * <pre>
     * FXO电话类型	
     * </pre>
     */
    em_member_fxo(3, 3),
    /**
     * <code>em_member_jid = 4;</code>
     */
    em_member_jid(4, 4),
    ;

    /**
     * <code>em_member_invalid = 0;</code>
     */
    public static final int em_member_invalid_VALUE = 0;
    /**
     * <code>em_member_im_id = 1;</code>
     *
     * <pre>
     * XMPP JID
     * </pre>
     */
    public static final int em_member_im_id_VALUE = 1;
    /**
     * <code>em_member_telephone = 2;</code>
     *
     * <pre>
     * 电话类型	
     * </pre>
     */
    public static final int em_member_telephone_VALUE = 2;
    /**
     * <code>em_member_fxo = 3;</code>
     *
     * <pre>
     * FXO电话类型	
     * </pre>
     */
    public static final int em_member_fxo_VALUE = 3;
    /**
     * <code>em_member_jid = 4;</code>
     */
    public static final int em_member_jid_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmMtMemberType valueOf(int value) {
      switch (value) {
        case 0: return em_member_invalid;
        case 1: return em_member_im_id;
        case 2: return em_member_telephone;
        case 3: return em_member_fxo;
        case 4: return em_member_jid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtMemberType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtMemberType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtMemberType>() {
            public EmMtMemberType findValueByNumber(int number) {
              return EmMtMemberType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(104);
    }

    private static final EmMtMemberType[] VALUES = values();

    public static EmMtMemberType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtMemberType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtMemberType)
  }

  /**
   * Protobuf enum {@code mt.EmMtMultiChatType}
   */
  public enum EmMtMultiChatType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>em_multichat_invalid = 0;</code>
     *
     * <pre>
     *非法类型
     * </pre>
     */
    em_multichat_invalid(0, 0),
    /**
     * <code>em_multichat_normal = 1;</code>
     *
     * <pre>
     *普通类型
     * </pre>
     */
    em_multichat_normal(1, 1),
    /**
     * <code>em_multichat_conf = 2;</code>
     *
     * <pre>
     *会议类型
     * </pre>
     */
    em_multichat_conf(2, 2),
    /**
     * <code>em_multichat_end = 3;</code>
     */
    em_multichat_end(3, 3),
    ;

    /**
     * <code>em_multichat_invalid = 0;</code>
     *
     * <pre>
     *非法类型
     * </pre>
     */
    public static final int em_multichat_invalid_VALUE = 0;
    /**
     * <code>em_multichat_normal = 1;</code>
     *
     * <pre>
     *普通类型
     * </pre>
     */
    public static final int em_multichat_normal_VALUE = 1;
    /**
     * <code>em_multichat_conf = 2;</code>
     *
     * <pre>
     *会议类型
     * </pre>
     */
    public static final int em_multichat_conf_VALUE = 2;
    /**
     * <code>em_multichat_end = 3;</code>
     */
    public static final int em_multichat_end_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMtMultiChatType valueOf(int value) {
      switch (value) {
        case 0: return em_multichat_invalid;
        case 1: return em_multichat_normal;
        case 2: return em_multichat_conf;
        case 3: return em_multichat_end;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtMultiChatType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtMultiChatType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtMultiChatType>() {
            public EmMtMultiChatType findValueByNumber(int number) {
              return EmMtMultiChatType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(105);
    }

    private static final EmMtMultiChatType[] VALUES = values();

    public static EmMtMultiChatType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtMultiChatType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtMultiChatType)
  }

  /**
   * Protobuf enum {@code mt.EmRestMeetingNotifyType}
   */
  public enum EmRestMeetingNotifyType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRestMeetingNotifyTypeUnknown = 0;</code>
     */
    emRestMeetingNotifyTypeUnknown(0, 0),
    /**
     * <code>emCreateMeeting = 102;</code>
     */
    emCreateMeeting(1, 102),
    /**
     * <code>emUpdateMeeting = 103;</code>
     */
    emUpdateMeeting(2, 103),
    /**
     * <code>emDeleteMeeting = 104;</code>
     */
    emDeleteMeeting(3, 104),
    /**
     * <code>emCreateRegular = 105;</code>
     */
    emCreateRegular(4, 105),
    /**
     * <code>emUpdateRegular = 106;</code>
     */
    emUpdateRegular(5, 106),
    /**
     * <code>emDeleteRegular = 107;</code>
     */
    emDeleteRegular(6, 107),
    /**
     * <code>emUpdateMeetingCancelPerson = 108;</code>
     */
    emUpdateMeetingCancelPerson(7, 108),
    /**
     * <code>emAheadOfMeeting = 109;</code>
     */
    emAheadOfMeeting(8, 109),
    /**
     * <code>emCancelRoom = 110;</code>
     */
    emCancelRoom(9, 110),
    /**
     * <code>emDeadLineChanged = 111;</code>
     */
    emDeadLineChanged(10, 111),
    /**
     * <code>emUserFeedbacked = 112;</code>
     */
    emUserFeedbacked(11, 112),
    /**
     * <code>emForbiddenRoom = 113;</code>
     */
    emForbiddenRoom(12, 113),
    /**
     * <code>emDeleteRoom = 114;</code>
     */
    emDeleteRoom(13, 114),
    /**
     * <code>emStartTimeAchieve = 115;</code>
     */
    emStartTimeAchieve(14, 115),
    /**
     * <code>emNormalStart = 116;</code>
     */
    emNormalStart(15, 116),
    /**
     * <code>emStartMeetingRemind = 117;</code>
     */
    emStartMeetingRemind(16, 117),
    /**
     * <code>emStartBeforeMeeting = 118;</code>
     */
    emStartBeforeMeeting(17, 118),
    /**
     * <code>emParticipant_Meeting_Remind = 119;</code>
     */
    emParticipant_Meeting_Remind(18, 119),
    /**
     * <code>emLive_URL = 120;</code>
     */
    emLive_URL(19, 120),
    ;

    /**
     * <code>emRestMeetingNotifyTypeUnknown = 0;</code>
     */
    public static final int emRestMeetingNotifyTypeUnknown_VALUE = 0;
    /**
     * <code>emCreateMeeting = 102;</code>
     */
    public static final int emCreateMeeting_VALUE = 102;
    /**
     * <code>emUpdateMeeting = 103;</code>
     */
    public static final int emUpdateMeeting_VALUE = 103;
    /**
     * <code>emDeleteMeeting = 104;</code>
     */
    public static final int emDeleteMeeting_VALUE = 104;
    /**
     * <code>emCreateRegular = 105;</code>
     */
    public static final int emCreateRegular_VALUE = 105;
    /**
     * <code>emUpdateRegular = 106;</code>
     */
    public static final int emUpdateRegular_VALUE = 106;
    /**
     * <code>emDeleteRegular = 107;</code>
     */
    public static final int emDeleteRegular_VALUE = 107;
    /**
     * <code>emUpdateMeetingCancelPerson = 108;</code>
     */
    public static final int emUpdateMeetingCancelPerson_VALUE = 108;
    /**
     * <code>emAheadOfMeeting = 109;</code>
     */
    public static final int emAheadOfMeeting_VALUE = 109;
    /**
     * <code>emCancelRoom = 110;</code>
     */
    public static final int emCancelRoom_VALUE = 110;
    /**
     * <code>emDeadLineChanged = 111;</code>
     */
    public static final int emDeadLineChanged_VALUE = 111;
    /**
     * <code>emUserFeedbacked = 112;</code>
     */
    public static final int emUserFeedbacked_VALUE = 112;
    /**
     * <code>emForbiddenRoom = 113;</code>
     */
    public static final int emForbiddenRoom_VALUE = 113;
    /**
     * <code>emDeleteRoom = 114;</code>
     */
    public static final int emDeleteRoom_VALUE = 114;
    /**
     * <code>emStartTimeAchieve = 115;</code>
     */
    public static final int emStartTimeAchieve_VALUE = 115;
    /**
     * <code>emNormalStart = 116;</code>
     */
    public static final int emNormalStart_VALUE = 116;
    /**
     * <code>emStartMeetingRemind = 117;</code>
     */
    public static final int emStartMeetingRemind_VALUE = 117;
    /**
     * <code>emStartBeforeMeeting = 118;</code>
     */
    public static final int emStartBeforeMeeting_VALUE = 118;
    /**
     * <code>emParticipant_Meeting_Remind = 119;</code>
     */
    public static final int emParticipant_Meeting_Remind_VALUE = 119;
    /**
     * <code>emLive_URL = 120;</code>
     */
    public static final int emLive_URL_VALUE = 120;


    public final int getNumber() { return value; }

    public static EmRestMeetingNotifyType valueOf(int value) {
      switch (value) {
        case 0: return emRestMeetingNotifyTypeUnknown;
        case 102: return emCreateMeeting;
        case 103: return emUpdateMeeting;
        case 104: return emDeleteMeeting;
        case 105: return emCreateRegular;
        case 106: return emUpdateRegular;
        case 107: return emDeleteRegular;
        case 108: return emUpdateMeetingCancelPerson;
        case 109: return emAheadOfMeeting;
        case 110: return emCancelRoom;
        case 111: return emDeadLineChanged;
        case 112: return emUserFeedbacked;
        case 113: return emForbiddenRoom;
        case 114: return emDeleteRoom;
        case 115: return emStartTimeAchieve;
        case 116: return emNormalStart;
        case 117: return emStartMeetingRemind;
        case 118: return emStartBeforeMeeting;
        case 119: return emParticipant_Meeting_Remind;
        case 120: return emLive_URL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRestMeetingNotifyType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRestMeetingNotifyType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRestMeetingNotifyType>() {
            public EmRestMeetingNotifyType findValueByNumber(int number) {
              return EmRestMeetingNotifyType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(106);
    }

    private static final EmRestMeetingNotifyType[] VALUES = values();

    public static EmRestMeetingNotifyType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRestMeetingNotifyType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRestMeetingNotifyType)
  }

  /**
   * Protobuf enum {@code mt.EmMtOperateUserInfo}
   */
  public enum EmMtOperateUserInfo
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emOperateUserAdd = 1;</code>
     *
     * <pre>
     * 增加好友
     * </pre>
     */
    emOperateUserAdd(0, 1),
    /**
     * <code>emOperateUserDelete = 2;</code>
     *
     * <pre>
     * 删除好友
     * </pre>
     */
    emOperateUserDelete(1, 2),
    /**
     * <code>emOperateUserModify = 3;</code>
     */
    emOperateUserModify(2, 3),
    /**
     * <code>emOperateUserSearch = 4;</code>
     */
    emOperateUserSearch(3, 4),
    ;

    /**
     * <code>emOperateUserAdd = 1;</code>
     *
     * <pre>
     * 增加好友
     * </pre>
     */
    public static final int emOperateUserAdd_VALUE = 1;
    /**
     * <code>emOperateUserDelete = 2;</code>
     *
     * <pre>
     * 删除好友
     * </pre>
     */
    public static final int emOperateUserDelete_VALUE = 2;
    /**
     * <code>emOperateUserModify = 3;</code>
     */
    public static final int emOperateUserModify_VALUE = 3;
    /**
     * <code>emOperateUserSearch = 4;</code>
     */
    public static final int emOperateUserSearch_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmMtOperateUserInfo valueOf(int value) {
      switch (value) {
        case 1: return emOperateUserAdd;
        case 2: return emOperateUserDelete;
        case 3: return emOperateUserModify;
        case 4: return emOperateUserSearch;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtOperateUserInfo>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtOperateUserInfo>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtOperateUserInfo>() {
            public EmMtOperateUserInfo findValueByNumber(int number) {
              return EmMtOperateUserInfo.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(107);
    }

    private static final EmMtOperateUserInfo[] VALUES = values();

    public static EmMtOperateUserInfo valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtOperateUserInfo(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtOperateUserInfo)
  }

  /**
   * Protobuf enum {@code mt.EmH323SrvType}
   *
   * <pre>
   *H323服务类型
   * </pre>
   */
  public enum EmH323SrvType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emH323SrvH323None = 1;</code>
     *
     * <pre>
     *无
     * </pre>
     */
    emH323SrvH323None(0, 1),
    /**
     * <code>emH323SrvH323Pxy = 2;</code>
     *
     * <pre>
     *h323代理
     * </pre>
     */
    emH323SrvH323Pxy(1, 2),
    /**
     * <code>emH323SrvH323H460 = 3;</code>
     *
     * <pre>
     *h460代理
     * </pre>
     */
    emH323SrvH323H460(2, 3),
    /**
     * <code>emH323SrvH323Gk = 4;</code>
     *
     * <pre>
     *注册gk
     * </pre>
     */
    emH323SrvH323Gk(3, 4),
    ;

    /**
     * <code>emH323SrvH323None = 1;</code>
     *
     * <pre>
     *无
     * </pre>
     */
    public static final int emH323SrvH323None_VALUE = 1;
    /**
     * <code>emH323SrvH323Pxy = 2;</code>
     *
     * <pre>
     *h323代理
     * </pre>
     */
    public static final int emH323SrvH323Pxy_VALUE = 2;
    /**
     * <code>emH323SrvH323H460 = 3;</code>
     *
     * <pre>
     *h460代理
     * </pre>
     */
    public static final int emH323SrvH323H460_VALUE = 3;
    /**
     * <code>emH323SrvH323Gk = 4;</code>
     *
     * <pre>
     *注册gk
     * </pre>
     */
    public static final int emH323SrvH323Gk_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmH323SrvType valueOf(int value) {
      switch (value) {
        case 1: return emH323SrvH323None;
        case 2: return emH323SrvH323Pxy;
        case 3: return emH323SrvH323H460;
        case 4: return emH323SrvH323Gk;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmH323SrvType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmH323SrvType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmH323SrvType>() {
            public EmH323SrvType findValueByNumber(int number) {
              return EmH323SrvType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(108);
    }

    private static final EmH323SrvType[] VALUES = values();

    public static EmH323SrvType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmH323SrvType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmH323SrvType)
  }

  /**
   * Protobuf enum {@code mt.EmSipSrvType}
   *
   * <pre>
   *SIP服务类型
   * </pre>
   */
  public enum EmSipSrvType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSipSrvServer = 1;</code>
     *
     * <pre>
     *注册sip服务器
     * </pre>
     */
    emSipSrvServer(0, 1),
    /**
     * <code>emSipSrvPxy = 2;</code>
     *
     * <pre>
     *注册sip代理
     * </pre>
     */
    emSipSrvPxy(1, 2),
    ;

    /**
     * <code>emSipSrvServer = 1;</code>
     *
     * <pre>
     *注册sip服务器
     * </pre>
     */
    public static final int emSipSrvServer_VALUE = 1;
    /**
     * <code>emSipSrvPxy = 2;</code>
     *
     * <pre>
     *注册sip代理
     * </pre>
     */
    public static final int emSipSrvPxy_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmSipSrvType valueOf(int value) {
      switch (value) {
        case 1: return emSipSrvServer;
        case 2: return emSipSrvPxy;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSipSrvType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSipSrvType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSipSrvType>() {
            public EmSipSrvType findValueByNumber(int number) {
              return EmSipSrvType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(109);
    }

    private static final EmSipSrvType[] VALUES = values();

    public static EmSipSrvType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSipSrvType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSipSrvType)
  }

  /**
   * Protobuf enum {@code mt.APIType}
   */
  public enum APIType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUnknownAPI = 0;</code>
     */
    emUnknownAPI(0, 0),
    /**
     * <code>emPlatformAPI = 1;</code>
     */
    emPlatformAPI(1, 1),
    /**
     * <code>emWeiboAPI = 2;</code>
     */
    emWeiboAPI(2, 2),
    /**
     * <code>emMeetingAPI = 3;</code>
     */
    emMeetingAPI(3, 3),
    /**
     * <code>emAppAPI = 4;</code>
     */
    emAppAPI(4, 4),
    ;

    /**
     * <code>emUnknownAPI = 0;</code>
     */
    public static final int emUnknownAPI_VALUE = 0;
    /**
     * <code>emPlatformAPI = 1;</code>
     */
    public static final int emPlatformAPI_VALUE = 1;
    /**
     * <code>emWeiboAPI = 2;</code>
     */
    public static final int emWeiboAPI_VALUE = 2;
    /**
     * <code>emMeetingAPI = 3;</code>
     */
    public static final int emMeetingAPI_VALUE = 3;
    /**
     * <code>emAppAPI = 4;</code>
     */
    public static final int emAppAPI_VALUE = 4;


    public final int getNumber() { return value; }

    public static APIType valueOf(int value) {
      switch (value) {
        case 0: return emUnknownAPI;
        case 1: return emPlatformAPI;
        case 2: return emWeiboAPI;
        case 3: return emMeetingAPI;
        case 4: return emAppAPI;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<APIType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<APIType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<APIType>() {
            public APIType findValueByNumber(int number) {
              return APIType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(110);
    }

    private static final APIType[] VALUES = values();

    public static APIType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private APIType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.APIType)
  }

  /**
   * Protobuf enum {@code mt.EmChatType}
   *
   * <pre>
   * 消息类型
   * </pre>
   */
  public enum EmChatType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emChatNormal = 0;</code>
     *
     * <pre>
     * 普通消息类型
     * </pre>
     */
    emChatNormal(0, 0),
    /**
     * <code>emChatAuto = 1;</code>
     *
     * <pre>
     * 自动回复的消息
     * </pre>
     */
    emChatAuto(1, 1),
    ;

    /**
     * <code>emChatNormal = 0;</code>
     *
     * <pre>
     * 普通消息类型
     * </pre>
     */
    public static final int emChatNormal_VALUE = 0;
    /**
     * <code>emChatAuto = 1;</code>
     *
     * <pre>
     * 自动回复的消息
     * </pre>
     */
    public static final int emChatAuto_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmChatType valueOf(int value) {
      switch (value) {
        case 0: return emChatNormal;
        case 1: return emChatAuto;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmChatType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmChatType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmChatType>() {
            public EmChatType findValueByNumber(int number) {
              return EmChatType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(111);
    }

    private static final EmChatType[] VALUES = values();

    public static EmChatType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmChatType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmChatType)
  }

  /**
   * Protobuf enum {@code mt.EmRtspStatus}
   */
  public enum EmRtspStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRtspInit = 1;</code>
     */
    emRtspInit(0, 1),
    /**
     * <code>emRtspPreReady = 2;</code>
     */
    emRtspPreReady(1, 2),
    /**
     * <code>emRtspReady = 3;</code>
     */
    emRtspReady(2, 3),
    /**
     * <code>emRtspPlaying = 4;</code>
     */
    emRtspPlaying(3, 4),
    /**
     * <code>emRtspPause = 5;</code>
     */
    emRtspPause(4, 5),
    /**
     * <code>emRtspResume = 6;</code>
     */
    emRtspResume(5, 6),
    /**
     * <code>emRtspAdjustSpeed = 7;</code>
     */
    emRtspAdjustSpeed(6, 7),
    /**
     * <code>emRtspAdjustProcess = 8;</code>
     */
    emRtspAdjustProcess(7, 8),
    ;

    /**
     * <code>emRtspInit = 1;</code>
     */
    public static final int emRtspInit_VALUE = 1;
    /**
     * <code>emRtspPreReady = 2;</code>
     */
    public static final int emRtspPreReady_VALUE = 2;
    /**
     * <code>emRtspReady = 3;</code>
     */
    public static final int emRtspReady_VALUE = 3;
    /**
     * <code>emRtspPlaying = 4;</code>
     */
    public static final int emRtspPlaying_VALUE = 4;
    /**
     * <code>emRtspPause = 5;</code>
     */
    public static final int emRtspPause_VALUE = 5;
    /**
     * <code>emRtspResume = 6;</code>
     */
    public static final int emRtspResume_VALUE = 6;
    /**
     * <code>emRtspAdjustSpeed = 7;</code>
     */
    public static final int emRtspAdjustSpeed_VALUE = 7;
    /**
     * <code>emRtspAdjustProcess = 8;</code>
     */
    public static final int emRtspAdjustProcess_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmRtspStatus valueOf(int value) {
      switch (value) {
        case 1: return emRtspInit;
        case 2: return emRtspPreReady;
        case 3: return emRtspReady;
        case 4: return emRtspPlaying;
        case 5: return emRtspPause;
        case 6: return emRtspResume;
        case 7: return emRtspAdjustSpeed;
        case 8: return emRtspAdjustProcess;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRtspStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRtspStatus>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRtspStatus>() {
            public EmRtspStatus findValueByNumber(int number) {
              return EmRtspStatus.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(112);
    }

    private static final EmRtspStatus[] VALUES = values();

    public static EmRtspStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRtspStatus(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRtspStatus)
  }

  /**
   * Protobuf enum {@code mt.EmServerAddrType}
   */
  public enum EmServerAddrType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSrvAddrTypeDefault = 0;</code>
     *
     * <pre>
     *默认不可修改
     * </pre>
     */
    emSrvAddrTypeDefault(0, 0),
    /**
     * <code>emSrvAddrTypeCustom = 1;</code>
     *
     * <pre>
     *用户自定义 可编辑
     * </pre>
     */
    emSrvAddrTypeCustom(1, 1),
    ;

    /**
     * <code>emSrvAddrTypeDefault = 0;</code>
     *
     * <pre>
     *默认不可修改
     * </pre>
     */
    public static final int emSrvAddrTypeDefault_VALUE = 0;
    /**
     * <code>emSrvAddrTypeCustom = 1;</code>
     *
     * <pre>
     *用户自定义 可编辑
     * </pre>
     */
    public static final int emSrvAddrTypeCustom_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmServerAddrType valueOf(int value) {
      switch (value) {
        case 0: return emSrvAddrTypeDefault;
        case 1: return emSrvAddrTypeCustom;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmServerAddrType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmServerAddrType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmServerAddrType>() {
            public EmServerAddrType findValueByNumber(int number) {
              return EmServerAddrType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(113);
    }

    private static final EmServerAddrType[] VALUES = values();

    public static EmServerAddrType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmServerAddrType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmServerAddrType)
  }

  /**
   * Protobuf enum {@code mt.EmVMeetingVideoModel}
   *
   * <pre>
   * 会议清晰度
   * </pre>
   */
  public enum EmVMeetingVideoModel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMeeting_vmeeting_video_model_fluent = 1;</code>
     */
    emMeeting_vmeeting_video_model_fluent(0, 1),
    /**
     * <code>emMeeting_vmeeting_video_model_normal_quality = 2;</code>
     */
    emMeeting_vmeeting_video_model_normal_quality(1, 2),
    /**
     * <code>emMeeting_vmeeting_video_model_high_quality = 3;</code>
     */
    emMeeting_vmeeting_video_model_high_quality(2, 3),
    /**
     * <code>emMeeting_vmeeting_video_model_full_high_quality = 4;</code>
     */
    emMeeting_vmeeting_video_model_full_high_quality(3, 4),
    ;

    /**
     * <code>emMeeting_vmeeting_video_model_fluent = 1;</code>
     */
    public static final int emMeeting_vmeeting_video_model_fluent_VALUE = 1;
    /**
     * <code>emMeeting_vmeeting_video_model_normal_quality = 2;</code>
     */
    public static final int emMeeting_vmeeting_video_model_normal_quality_VALUE = 2;
    /**
     * <code>emMeeting_vmeeting_video_model_high_quality = 3;</code>
     */
    public static final int emMeeting_vmeeting_video_model_high_quality_VALUE = 3;
    /**
     * <code>emMeeting_vmeeting_video_model_full_high_quality = 4;</code>
     */
    public static final int emMeeting_vmeeting_video_model_full_high_quality_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmVMeetingVideoModel valueOf(int value) {
      switch (value) {
        case 1: return emMeeting_vmeeting_video_model_fluent;
        case 2: return emMeeting_vmeeting_video_model_normal_quality;
        case 3: return emMeeting_vmeeting_video_model_high_quality;
        case 4: return emMeeting_vmeeting_video_model_full_high_quality;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVMeetingVideoModel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVMeetingVideoModel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVMeetingVideoModel>() {
            public EmVMeetingVideoModel findValueByNumber(int number) {
              return EmVMeetingVideoModel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(114);
    }

    private static final EmVMeetingVideoModel[] VALUES = values();

    public static EmVMeetingVideoModel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVMeetingVideoModel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVMeetingVideoModel)
  }

  /**
   * Protobuf enum {@code mt.EmDesktopShareLimit}
   *
   * <pre>
   * 桌面共享权限
   * </pre>
   */
  public enum EmDesktopShareLimit
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMeeting_desktop_share_limit_speaker = 0;</code>
     */
    emMeeting_desktop_share_limit_speaker(0, 0),
    /**
     * <code>emMeeting_desktop_share_limit_all = 1;</code>
     */
    emMeeting_desktop_share_limit_all(1, 1),
    ;

    /**
     * <code>emMeeting_desktop_share_limit_speaker = 0;</code>
     */
    public static final int emMeeting_desktop_share_limit_speaker_VALUE = 0;
    /**
     * <code>emMeeting_desktop_share_limit_all = 1;</code>
     */
    public static final int emMeeting_desktop_share_limit_all_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmDesktopShareLimit valueOf(int value) {
      switch (value) {
        case 0: return emMeeting_desktop_share_limit_speaker;
        case 1: return emMeeting_desktop_share_limit_all;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDesktopShareLimit>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDesktopShareLimit>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDesktopShareLimit>() {
            public EmDesktopShareLimit findValueByNumber(int number) {
              return EmDesktopShareLimit.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(115);
    }

    private static final EmDesktopShareLimit[] VALUES = values();

    public static EmDesktopShareLimit valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDesktopShareLimit(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDesktopShareLimit)
  }

  /**
   * Protobuf enum {@code mt.EmVMeetingMode}
   *
   * <pre>
   * 会议模式
   * </pre>
   */
  public enum EmVMeetingMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMeeting_vmeeting_mode_discuss = 0;</code>
     */
    emMeeting_vmeeting_mode_discuss(0, 0),
    /**
     * <code>emMeeting_vmeeting_mode_training = 1;</code>
     */
    emMeeting_vmeeting_mode_training(1, 1),
    ;

    /**
     * <code>emMeeting_vmeeting_mode_discuss = 0;</code>
     */
    public static final int emMeeting_vmeeting_mode_discuss_VALUE = 0;
    /**
     * <code>emMeeting_vmeeting_mode_training = 1;</code>
     */
    public static final int emMeeting_vmeeting_mode_training_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmVMeetingMode valueOf(int value) {
      switch (value) {
        case 0: return emMeeting_vmeeting_mode_discuss;
        case 1: return emMeeting_vmeeting_mode_training;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVMeetingMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVMeetingMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVMeetingMode>() {
            public EmVMeetingMode findValueByNumber(int number) {
              return EmVMeetingMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(116);
    }

    private static final EmVMeetingMode[] VALUES = values();

    public static EmVMeetingMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVMeetingMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVMeetingMode)
  }

  /**
   * Protobuf enum {@code mt.EmCallDuration}
   *
   * <pre>
   * 呼叫时长（会议API使用）
   * </pre>
   */
  public enum EmCallDuration
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMeeting_call_duration_very_short = 0;</code>
     */
    emMeeting_call_duration_very_short(0, 0),
    /**
     * <code>emMeeting_call_duration_short = 1;</code>
     */
    emMeeting_call_duration_short(1, 1),
    /**
     * <code>emMeeting_call_duration_normal = 2;</code>
     */
    emMeeting_call_duration_normal(2, 2),
    /**
     * <code>emMeeting_call_duration_long = 3;</code>
     */
    emMeeting_call_duration_long(3, 3),
    /**
     * <code>emMeeting_call_duration_very_long = 4;</code>
     */
    emMeeting_call_duration_very_long(4, 4),
    ;

    /**
     * <code>emMeeting_call_duration_very_short = 0;</code>
     */
    public static final int emMeeting_call_duration_very_short_VALUE = 0;
    /**
     * <code>emMeeting_call_duration_short = 1;</code>
     */
    public static final int emMeeting_call_duration_short_VALUE = 1;
    /**
     * <code>emMeeting_call_duration_normal = 2;</code>
     */
    public static final int emMeeting_call_duration_normal_VALUE = 2;
    /**
     * <code>emMeeting_call_duration_long = 3;</code>
     */
    public static final int emMeeting_call_duration_long_VALUE = 3;
    /**
     * <code>emMeeting_call_duration_very_long = 4;</code>
     */
    public static final int emMeeting_call_duration_very_long_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmCallDuration valueOf(int value) {
      switch (value) {
        case 0: return emMeeting_call_duration_very_short;
        case 1: return emMeeting_call_duration_short;
        case 2: return emMeeting_call_duration_normal;
        case 3: return emMeeting_call_duration_long;
        case 4: return emMeeting_call_duration_very_long;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCallDuration>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCallDuration>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCallDuration>() {
            public EmCallDuration findValueByNumber(int number) {
              return EmCallDuration.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(117);
    }

    private static final EmCallDuration[] VALUES = values();

    public static EmCallDuration valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCallDuration(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCallDuration)
  }

  /**
   * Protobuf enum {@code mt.EmNetType}
   *
   * <pre>
   * 丢包重传时所选择的网络类型
   * </pre>
   */
  public enum EmNetType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emInternet = 0;</code>
     */
    emInternet(0, 0),
    /**
     * <code>emSpecial = 1;</code>
     */
    emSpecial(1, 1),
    /**
     * <code>emVPN = 2;</code>
     */
    emVPN(2, 2),
    ;

    /**
     * <code>emInternet = 0;</code>
     */
    public static final int emInternet_VALUE = 0;
    /**
     * <code>emSpecial = 1;</code>
     */
    public static final int emSpecial_VALUE = 1;
    /**
     * <code>emVPN = 2;</code>
     */
    public static final int emVPN_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmNetType valueOf(int value) {
      switch (value) {
        case 0: return emInternet;
        case 1: return emSpecial;
        case 2: return emVPN;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNetType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNetType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNetType>() {
            public EmNetType findValueByNumber(int number) {
              return EmNetType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(118);
    }

    private static final EmNetType[] VALUES = values();

    public static EmNetType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNetType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmNetType)
  }

  /**
   * Protobuf enum {@code mt.EmUpgradeVerLevel}
   *
   * <pre>
   *升级包版本等级
   * </pre>
   */
  public enum EmUpgradeVerLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUpgradeLevelForced = 0;</code>
     *
     * <pre>
     *强制
     * </pre>
     */
    emUpgradeLevelForced(0, 0),
    /**
     * <code>emUpgradeLevelSuggested = 1;</code>
     *
     * <pre>
     *建议
     * </pre>
     */
    emUpgradeLevelSuggested(1, 1),
    /**
     * <code>emUpgradeLevelNormal = 2;</code>
     *
     * <pre>
     *普通
     * </pre>
     */
    emUpgradeLevelNormal(2, 2),
    ;

    /**
     * <code>emUpgradeLevelForced = 0;</code>
     *
     * <pre>
     *强制
     * </pre>
     */
    public static final int emUpgradeLevelForced_VALUE = 0;
    /**
     * <code>emUpgradeLevelSuggested = 1;</code>
     *
     * <pre>
     *建议
     * </pre>
     */
    public static final int emUpgradeLevelSuggested_VALUE = 1;
    /**
     * <code>emUpgradeLevelNormal = 2;</code>
     *
     * <pre>
     *普通
     * </pre>
     */
    public static final int emUpgradeLevelNormal_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmUpgradeVerLevel valueOf(int value) {
      switch (value) {
        case 0: return emUpgradeLevelForced;
        case 1: return emUpgradeLevelSuggested;
        case 2: return emUpgradeLevelNormal;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeVerLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeVerLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmUpgradeVerLevel>() {
            public EmUpgradeVerLevel findValueByNumber(int number) {
              return EmUpgradeVerLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(119);
    }

    private static final EmUpgradeVerLevel[] VALUES = values();

    public static EmUpgradeVerLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmUpgradeVerLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmUpgradeVerLevel)
  }

  /**
   * Protobuf enum {@code mt.EmUpgradeReleaseAttr}
   *
   * <pre>
   *版本发布属性
   * </pre>
   */
  public enum EmUpgradeReleaseAttr
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUpgradeAttr = 0;</code>
     */
    emUpgradeAttr(0, 0),
    /**
     * <code>emUpgradeAttrCommon = 1;</code>
     *
     * <pre>
     *普通版本
     * </pre>
     */
    emUpgradeAttrCommon(1, 1),
    /**
     * <code>emUpgradeAttrRecommend = 2;</code>
     *
     * <pre>
     *推荐版本
     * </pre>
     */
    emUpgradeAttrRecommend(2, 2),
    /**
     * <code>emUpgradeAttrGray = 4;</code>
     *
     * <pre>
     *灰度版本
     * </pre>
     */
    emUpgradeAttrGray(3, 4),
    ;

    /**
     * <code>emUpgradeAttr = 0;</code>
     */
    public static final int emUpgradeAttr_VALUE = 0;
    /**
     * <code>emUpgradeAttrCommon = 1;</code>
     *
     * <pre>
     *普通版本
     * </pre>
     */
    public static final int emUpgradeAttrCommon_VALUE = 1;
    /**
     * <code>emUpgradeAttrRecommend = 2;</code>
     *
     * <pre>
     *推荐版本
     * </pre>
     */
    public static final int emUpgradeAttrRecommend_VALUE = 2;
    /**
     * <code>emUpgradeAttrGray = 4;</code>
     *
     * <pre>
     *灰度版本
     * </pre>
     */
    public static final int emUpgradeAttrGray_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmUpgradeReleaseAttr valueOf(int value) {
      switch (value) {
        case 0: return emUpgradeAttr;
        case 1: return emUpgradeAttrCommon;
        case 2: return emUpgradeAttrRecommend;
        case 4: return emUpgradeAttrGray;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeReleaseAttr>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeReleaseAttr>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmUpgradeReleaseAttr>() {
            public EmUpgradeReleaseAttr findValueByNumber(int number) {
              return EmUpgradeReleaseAttr.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(120);
    }

    private static final EmUpgradeReleaseAttr[] VALUES = values();

    public static EmUpgradeReleaseAttr valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmUpgradeReleaseAttr(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmUpgradeReleaseAttr)
  }

  /**
   * Protobuf enum {@code mt.EmMtPortrait}
   */
  public enum EmMtPortrait
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>mtportrait32 = 0;</code>
     *
     * <pre>
     * 32位头像
     * </pre>
     */
    mtportrait32(0, 0),
    /**
     * <code>mtportrait40 = 1;</code>
     *
     * <pre>
     * 40位头像
     * </pre>
     */
    mtportrait40(1, 1),
    /**
     * <code>mtportrait64 = 2;</code>
     *
     * <pre>
     * 64位头像
     * </pre>
     */
    mtportrait64(2, 2),
    /**
     * <code>mtportrait128 = 3;</code>
     *
     * <pre>
     * 128位头像
     * </pre>
     */
    mtportrait128(3, 3),
    /**
     * <code>mtportrait256 = 4;</code>
     *
     * <pre>
     * 256位头像
     * </pre>
     */
    mtportrait256(4, 4),
    ;

    /**
     * <code>mtportrait32 = 0;</code>
     *
     * <pre>
     * 32位头像
     * </pre>
     */
    public static final int mtportrait32_VALUE = 0;
    /**
     * <code>mtportrait40 = 1;</code>
     *
     * <pre>
     * 40位头像
     * </pre>
     */
    public static final int mtportrait40_VALUE = 1;
    /**
     * <code>mtportrait64 = 2;</code>
     *
     * <pre>
     * 64位头像
     * </pre>
     */
    public static final int mtportrait64_VALUE = 2;
    /**
     * <code>mtportrait128 = 3;</code>
     *
     * <pre>
     * 128位头像
     * </pre>
     */
    public static final int mtportrait128_VALUE = 3;
    /**
     * <code>mtportrait256 = 4;</code>
     *
     * <pre>
     * 256位头像
     * </pre>
     */
    public static final int mtportrait256_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmMtPortrait valueOf(int value) {
      switch (value) {
        case 0: return mtportrait32;
        case 1: return mtportrait40;
        case 2: return mtportrait64;
        case 3: return mtportrait128;
        case 4: return mtportrait256;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtPortrait>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtPortrait>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtPortrait>() {
            public EmMtPortrait findValueByNumber(int number) {
              return EmMtPortrait.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(121);
    }

    private static final EmMtPortrait[] VALUES = values();

    public static EmMtPortrait valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtPortrait(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtPortrait)
  }

  /**
   * Protobuf enum {@code mt.EmMCMode}
   *
   * <pre>
   *内置mc的模式
   * </pre>
   */
  public enum EmMCMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMcSpeech = 0;</code>
     *
     * <pre>
     *发言人模式
     * </pre>
     */
    emMcSpeech(0, 0),
    /**
     * <code>emMcDiscuss = 1;</code>
     *
     * <pre>
     *讨论模式
     * </pre>
     */
    emMcDiscuss(1, 1),
    /**
     * <code>emMcInvalid = 2;</code>
     *
     * <pre>
     *无效内置mc模式
     * </pre>
     */
    emMcInvalid(2, 2),
    ;

    /**
     * <code>emMcSpeech = 0;</code>
     *
     * <pre>
     *发言人模式
     * </pre>
     */
    public static final int emMcSpeech_VALUE = 0;
    /**
     * <code>emMcDiscuss = 1;</code>
     *
     * <pre>
     *讨论模式
     * </pre>
     */
    public static final int emMcDiscuss_VALUE = 1;
    /**
     * <code>emMcInvalid = 2;</code>
     *
     * <pre>
     *无效内置mc模式
     * </pre>
     */
    public static final int emMcInvalid_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMCMode valueOf(int value) {
      switch (value) {
        case 0: return emMcSpeech;
        case 1: return emMcDiscuss;
        case 2: return emMcInvalid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMCMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMCMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMCMode>() {
            public EmMCMode findValueByNumber(int number) {
              return EmMCMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(122);
    }

    private static final EmMCMode[] VALUES = values();

    public static EmMCMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMCMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMCMode)
  }

  /**
   * Protobuf enum {@code mt.EmServerType}
   *
   * <pre>
   *服务器类型
   * </pre>
   */
  public enum EmServerType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAPS = 0;</code>
     *
     * <pre>
     *接入
     * </pre>
     */
    emAPS(0, 0),
    /**
     * <code>emXNU = 1;</code>
     *
     * <pre>
     *短消息
     * </pre>
     */
    emXNU(1, 1),
    /**
     * <code>emSUS = 2;</code>
     *
     * <pre>
     *升级
     * </pre>
     */
    emSUS(2, 2),
    /**
     * <code>emNMS = 3;</code>
     *
     * <pre>
     *网管
     * </pre>
     */
    emNMS(3, 3),
    /**
     * <code>emNTS = 4;</code>
     *
     * <pre>
     *测速
     * </pre>
     */
    emNTS(4, 4),
    /**
     * <code>emSIP = 5;</code>
     *
     * <pre>
     *SIP呼叫
     * </pre>
     */
    emSIP(5, 5),
    /**
     * <code>emNonH323 = 6;</code>
     *
     * <pre>
     *非标H323
     * </pre>
     */
    emNonH323(6, 6),
    /**
     * <code>emStdH323 = 7;</code>
     *
     * <pre>
     *标准H323
     * </pre>
     */
    emStdH323(7, 7),
    /**
     * <code>emNTP = 8;</code>
     *
     * <pre>
     *NTP
     * </pre>
     */
    emNTP(8, 8),
    /**
     * <code>emVOD = 9;</code>
     *
     * <pre>
     *VOD
     * </pre>
     */
    emVOD(9, 9),
    /**
     * <code>emMoMeeting = 10;</code>
     *
     * <pre>
     *会管
     * </pre>
     */
    emMoMeeting(10, 10),
    /**
     * <code>emMoPlatform = 11;</code>
     *
     * <pre>
     *平台
     * </pre>
     */
    emMoPlatform(11, 11),
    /**
     * <code>emVRS = 12;</code>
     *
     * <pre>
     *会议录播
     * </pre>
     */
    emVRS(12, 12),
    /**
     * <code>emDCS = 13;</code>
     *
     * <pre>
     *数据会议
     * </pre>
     */
    emDCS(13, 13),
    /**
     * <code>emNS = 14;</code>
     *
     * <pre>
     *推送服务器
     * </pre>
     */
    emNS(14, 14),
    /**
     * <code>emKIS = 15;</code>
     *
     * <pre>
     *KIS服务器
     * </pre>
     */
    emKIS(15, 15),
    /**
     * <code>emServerTypeEnd = 16;</code>
     */
    emServerTypeEnd(16, 16),
    ;

    /**
     * <code>emAPS = 0;</code>
     *
     * <pre>
     *接入
     * </pre>
     */
    public static final int emAPS_VALUE = 0;
    /**
     * <code>emXNU = 1;</code>
     *
     * <pre>
     *短消息
     * </pre>
     */
    public static final int emXNU_VALUE = 1;
    /**
     * <code>emSUS = 2;</code>
     *
     * <pre>
     *升级
     * </pre>
     */
    public static final int emSUS_VALUE = 2;
    /**
     * <code>emNMS = 3;</code>
     *
     * <pre>
     *网管
     * </pre>
     */
    public static final int emNMS_VALUE = 3;
    /**
     * <code>emNTS = 4;</code>
     *
     * <pre>
     *测速
     * </pre>
     */
    public static final int emNTS_VALUE = 4;
    /**
     * <code>emSIP = 5;</code>
     *
     * <pre>
     *SIP呼叫
     * </pre>
     */
    public static final int emSIP_VALUE = 5;
    /**
     * <code>emNonH323 = 6;</code>
     *
     * <pre>
     *非标H323
     * </pre>
     */
    public static final int emNonH323_VALUE = 6;
    /**
     * <code>emStdH323 = 7;</code>
     *
     * <pre>
     *标准H323
     * </pre>
     */
    public static final int emStdH323_VALUE = 7;
    /**
     * <code>emNTP = 8;</code>
     *
     * <pre>
     *NTP
     * </pre>
     */
    public static final int emNTP_VALUE = 8;
    /**
     * <code>emVOD = 9;</code>
     *
     * <pre>
     *VOD
     * </pre>
     */
    public static final int emVOD_VALUE = 9;
    /**
     * <code>emMoMeeting = 10;</code>
     *
     * <pre>
     *会管
     * </pre>
     */
    public static final int emMoMeeting_VALUE = 10;
    /**
     * <code>emMoPlatform = 11;</code>
     *
     * <pre>
     *平台
     * </pre>
     */
    public static final int emMoPlatform_VALUE = 11;
    /**
     * <code>emVRS = 12;</code>
     *
     * <pre>
     *会议录播
     * </pre>
     */
    public static final int emVRS_VALUE = 12;
    /**
     * <code>emDCS = 13;</code>
     *
     * <pre>
     *数据会议
     * </pre>
     */
    public static final int emDCS_VALUE = 13;
    /**
     * <code>emNS = 14;</code>
     *
     * <pre>
     *推送服务器
     * </pre>
     */
    public static final int emNS_VALUE = 14;
    /**
     * <code>emKIS = 15;</code>
     *
     * <pre>
     *KIS服务器
     * </pre>
     */
    public static final int emKIS_VALUE = 15;
    /**
     * <code>emServerTypeEnd = 16;</code>
     */
    public static final int emServerTypeEnd_VALUE = 16;


    public final int getNumber() { return value; }

    public static EmServerType valueOf(int value) {
      switch (value) {
        case 0: return emAPS;
        case 1: return emXNU;
        case 2: return emSUS;
        case 3: return emNMS;
        case 4: return emNTS;
        case 5: return emSIP;
        case 6: return emNonH323;
        case 7: return emStdH323;
        case 8: return emNTP;
        case 9: return emVOD;
        case 10: return emMoMeeting;
        case 11: return emMoPlatform;
        case 12: return emVRS;
        case 13: return emDCS;
        case 14: return emNS;
        case 15: return emKIS;
        case 16: return emServerTypeEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmServerType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmServerType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmServerType>() {
            public EmServerType findValueByNumber(int number) {
              return EmServerType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(123);
    }

    private static final EmServerType[] VALUES = values();

    public static EmServerType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmServerType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmServerType)
  }

  /**
   * Protobuf enum {@code mt.EmServerState}
   *
   * <pre>
   *服务器连接状态
   * </pre>
   */
  public enum EmServerState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emIdle = 0;</code>
     *
     * <pre>
     *空闲
     * </pre>
     */
    emIdle(0, 0),
    /**
     * <code>emDnsQuerying = 1;</code>
     *
     * <pre>
     *正在解析IP
     * </pre>
     */
    emDnsQuerying(1, 1),
    /**
     * <code>emLogging_In = 2;</code>
     *
     * <pre>
     *正在登录
     * </pre>
     */
    emLogging_In(2, 2),
    /**
     * <code>emLogin_Succ = 3;</code>
     *
     * <pre>
     *登录成功
     * </pre>
     */
    emLogin_Succ(3, 3),
    /**
     * <code>emLogging_Out = 4;</code>
     *
     * <pre>
     *正在登出
     * </pre>
     */
    emLogging_Out(4, 4),
    /**
     * <code>emDisconnected = 5;</code>
     *
     * <pre>
     *断链（适用于保持心跳的服务器）
     * </pre>
     */
    emDisconnected(5, 5),
    /**
     * <code>emLogin_Err = 6;</code>
     *
     * <pre>
     *登录失败
     * </pre>
     */
    emLogin_Err(6, 6),
    ;

    /**
     * <code>emIdle = 0;</code>
     *
     * <pre>
     *空闲
     * </pre>
     */
    public static final int emIdle_VALUE = 0;
    /**
     * <code>emDnsQuerying = 1;</code>
     *
     * <pre>
     *正在解析IP
     * </pre>
     */
    public static final int emDnsQuerying_VALUE = 1;
    /**
     * <code>emLogging_In = 2;</code>
     *
     * <pre>
     *正在登录
     * </pre>
     */
    public static final int emLogging_In_VALUE = 2;
    /**
     * <code>emLogin_Succ = 3;</code>
     *
     * <pre>
     *登录成功
     * </pre>
     */
    public static final int emLogin_Succ_VALUE = 3;
    /**
     * <code>emLogging_Out = 4;</code>
     *
     * <pre>
     *正在登出
     * </pre>
     */
    public static final int emLogging_Out_VALUE = 4;
    /**
     * <code>emDisconnected = 5;</code>
     *
     * <pre>
     *断链（适用于保持心跳的服务器）
     * </pre>
     */
    public static final int emDisconnected_VALUE = 5;
    /**
     * <code>emLogin_Err = 6;</code>
     *
     * <pre>
     *登录失败
     * </pre>
     */
    public static final int emLogin_Err_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmServerState valueOf(int value) {
      switch (value) {
        case 0: return emIdle;
        case 1: return emDnsQuerying;
        case 2: return emLogging_In;
        case 3: return emLogin_Succ;
        case 4: return emLogging_Out;
        case 5: return emDisconnected;
        case 6: return emLogin_Err;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmServerState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmServerState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmServerState>() {
            public EmServerState findValueByNumber(int number) {
              return EmServerState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(124);
    }

    private static final EmServerState[] VALUES = values();

    public static EmServerState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmServerState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmServerState)
  }

  /**
   * Protobuf enum {@code mt.EmMtCallRecordType}
   *
   * <pre>
   * 呼入，呼出，还是未接，全部
   * </pre>
   */
  public enum EmMtCallRecordType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCallIn = 0;</code>
     *
     * <pre>
     *&#47;&lt; 呼入
     * </pre>
     */
    emCallIn(0, 0),
    /**
     * <code>emCallOut = 1;</code>
     *
     * <pre>
     *&#47;&lt; 呼出
     * </pre>
     */
    emCallOut(1, 1),
    /**
     * <code>emMissed = 2;</code>
     *
     * <pre>
     *&#47;&lt; 未接
     * </pre>
     */
    emMissed(2, 2),
    /**
     * <code>emAll = 3;</code>
     *
     * <pre>
     *&#47;&lt; 全部
     * </pre>
     */
    emAll(3, 3),
    ;

    /**
     * <code>emCallIn = 0;</code>
     *
     * <pre>
     *&#47;&lt; 呼入
     * </pre>
     */
    public static final int emCallIn_VALUE = 0;
    /**
     * <code>emCallOut = 1;</code>
     *
     * <pre>
     *&#47;&lt; 呼出
     * </pre>
     */
    public static final int emCallOut_VALUE = 1;
    /**
     * <code>emMissed = 2;</code>
     *
     * <pre>
     *&#47;&lt; 未接
     * </pre>
     */
    public static final int emMissed_VALUE = 2;
    /**
     * <code>emAll = 3;</code>
     *
     * <pre>
     *&#47;&lt; 全部
     * </pre>
     */
    public static final int emAll_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMtCallRecordType valueOf(int value) {
      switch (value) {
        case 0: return emCallIn;
        case 1: return emCallOut;
        case 2: return emMissed;
        case 3: return emAll;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtCallRecordType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtCallRecordType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtCallRecordType>() {
            public EmMtCallRecordType findValueByNumber(int number) {
              return EmMtCallRecordType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(125);
    }

    private static final EmMtCallRecordType[] VALUES = values();

    public static EmMtCallRecordType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtCallRecordType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtCallRecordType)
  }

  /**
   * Protobuf enum {@code mt.EmMtCallType}
   *
   * <pre>
   * 呼叫类型（视频，还是音频）
   * </pre>
   */
  public enum EmMtCallType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVideo = 0;</code>
     *
     * <pre>
     *&#47;&lt; 视频呼叫
     * </pre>
     */
    emVideo(0, 0),
    /**
     * <code>emAudio = 1;</code>
     *
     * <pre>
     *&#47;&lt; 音频呼叫
     * </pre>
     */
    emAudio(1, 1),
    /**
     * <code>emPhone = 2;</code>
     *
     * <pre>
     *&#47;&lt; 电话呼叫
     * </pre>
     */
    emPhone(2, 2),
    ;

    /**
     * <code>emVideo = 0;</code>
     *
     * <pre>
     *&#47;&lt; 视频呼叫
     * </pre>
     */
    public static final int emVideo_VALUE = 0;
    /**
     * <code>emAudio = 1;</code>
     *
     * <pre>
     *&#47;&lt; 音频呼叫
     * </pre>
     */
    public static final int emAudio_VALUE = 1;
    /**
     * <code>emPhone = 2;</code>
     *
     * <pre>
     *&#47;&lt; 电话呼叫
     * </pre>
     */
    public static final int emPhone_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtCallType valueOf(int value) {
      switch (value) {
        case 0: return emVideo;
        case 1: return emAudio;
        case 2: return emPhone;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtCallType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtCallType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtCallType>() {
            public EmMtCallType findValueByNumber(int number) {
              return EmMtCallType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(126);
    }

    private static final EmMtCallType[] VALUES = values();

    public static EmMtCallType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtCallType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtCallType)
  }

  /**
   * Protobuf enum {@code mt.EmMtRecordErr}
   */
  public enum EmMtRecordErr
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRecord_Ok = 0;</code>
     */
    emRecord_Ok(0, 0),
    /**
     * <code>emRecord_Err_Index = 1;</code>
     *
     * <pre>
     *&#47;&lt; 获取时提供的索引值错误
     * </pre>
     */
    emRecord_Err_Index(1, 1),
    /**
     * <code>emRecord_Err_No_Marching_Records = 2;</code>
     *
     * <pre>
     *&#47;&lt; 没有符合条件的记录
     * </pre>
     */
    emRecord_Err_No_Marching_Records(2, 2),
    /**
     * <code>emRecord_Err_No_Marching_Type = 3;</code>
     *
     * <pre>
     *&#47;&lt; 没有符合的匹配类型
     * </pre>
     */
    emRecord_Err_No_Marching_Type(3, 3),
    /**
     * <code>emRecord_Err_CallRecordType = 4;</code>
     *
     * <pre>
     *&#47;&lt; 呼叫记录类型异常（不在呼入，呼出，未接里）
     * </pre>
     */
    emRecord_Err_CallRecordType(4, 4),
    /**
     * <code>emRecord_Err_CallType = 5;</code>
     *
     * <pre>
     *&#47;&lt; 呼叫类型异常（不在视频呼叫，音频呼叫里）
     * </pre>
     */
    emRecord_Err_CallType(5, 5),
    /**
     * <code>emRecord_Err_Describe = 6;</code>
     *
     * <pre>
     *&#47;&lt; 条目描述为空
     * </pre>
     */
    emRecord_Err_Describe(6, 6),
    /**
     * <code>emRecord_Err_AddrType = 7;</code>
     *
     * <pre>
     *&#47;&lt; 不是有效呼叫（不是E164，也不是IP，也不是电话等等）
     * </pre>
     */
    emRecord_Err_AddrType(7, 7),
    /**
     * <code>emRecord_Err_Addr = 8;</code>
     *
     * <pre>
     *&#47;&lt; 本身呼叫内容异常（内容为空）
     * </pre>
     */
    emRecord_Err_Addr(8, 8),
    /**
     * <code>emRecord_Err_Rate = 9;</code>
     *
     * <pre>
     *&#47;&lt; 呼叫码率为0
     * </pre>
     */
    emRecord_Err_Rate(9, 9),
    /**
     * <code>emRecord_Err_PackageNum = 10;</code>
     *
     * <pre>
     *&#47;&lt; 分包数量异常
     * </pre>
     */
    emRecord_Err_PackageNum(10, 10),
    /**
     * <code>emRecord_Err_Over_MaxLocalRecordNum = 11;</code>
     *
     * <pre>
     *&#47;&lt; 超过最大联系人数量
     * </pre>
     */
    emRecord_Err_Over_MaxLocalRecordNum(11, 11),
    /**
     * <code>emRoster_Err_GroupName_NULL = 100;</code>
     *
     * <pre>
     *&#47;&lt; 组名为空
     * </pre>
     */
    emRoster_Err_GroupName_NULL(12, 100),
    /**
     * <code>emRoster_Err_GroupSn = 101;</code>
     *
     * <pre>
     *&#47;&lt; 组SN号异常
     * </pre>
     */
    emRoster_Err_GroupSn(13, 101),
    /**
     * <code>emRoster_Err_ParentGroupSn = 102;</code>
     *
     * <pre>
     *&#47;&lt; 父组SN号异常
     * </pre>
     */
    emRoster_Err_ParentGroupSn(14, 102),
    /**
     * <code>emRoster_Err_RosterSn = 103;</code>
     *
     * <pre>
     *&#47;&lt; 联系人SN号异常
     * </pre>
     */
    emRoster_Err_RosterSn(15, 103),
    /**
     * <code>emRoster_Err_RosterName = 104;</code>
     *
     * <pre>
     *&#47;&lt; 联系人名称异常
     * </pre>
     */
    emRoster_Err_RosterName(16, 104),
    ;

    /**
     * <code>emRecord_Ok = 0;</code>
     */
    public static final int emRecord_Ok_VALUE = 0;
    /**
     * <code>emRecord_Err_Index = 1;</code>
     *
     * <pre>
     *&#47;&lt; 获取时提供的索引值错误
     * </pre>
     */
    public static final int emRecord_Err_Index_VALUE = 1;
    /**
     * <code>emRecord_Err_No_Marching_Records = 2;</code>
     *
     * <pre>
     *&#47;&lt; 没有符合条件的记录
     * </pre>
     */
    public static final int emRecord_Err_No_Marching_Records_VALUE = 2;
    /**
     * <code>emRecord_Err_No_Marching_Type = 3;</code>
     *
     * <pre>
     *&#47;&lt; 没有符合的匹配类型
     * </pre>
     */
    public static final int emRecord_Err_No_Marching_Type_VALUE = 3;
    /**
     * <code>emRecord_Err_CallRecordType = 4;</code>
     *
     * <pre>
     *&#47;&lt; 呼叫记录类型异常（不在呼入，呼出，未接里）
     * </pre>
     */
    public static final int emRecord_Err_CallRecordType_VALUE = 4;
    /**
     * <code>emRecord_Err_CallType = 5;</code>
     *
     * <pre>
     *&#47;&lt; 呼叫类型异常（不在视频呼叫，音频呼叫里）
     * </pre>
     */
    public static final int emRecord_Err_CallType_VALUE = 5;
    /**
     * <code>emRecord_Err_Describe = 6;</code>
     *
     * <pre>
     *&#47;&lt; 条目描述为空
     * </pre>
     */
    public static final int emRecord_Err_Describe_VALUE = 6;
    /**
     * <code>emRecord_Err_AddrType = 7;</code>
     *
     * <pre>
     *&#47;&lt; 不是有效呼叫（不是E164，也不是IP，也不是电话等等）
     * </pre>
     */
    public static final int emRecord_Err_AddrType_VALUE = 7;
    /**
     * <code>emRecord_Err_Addr = 8;</code>
     *
     * <pre>
     *&#47;&lt; 本身呼叫内容异常（内容为空）
     * </pre>
     */
    public static final int emRecord_Err_Addr_VALUE = 8;
    /**
     * <code>emRecord_Err_Rate = 9;</code>
     *
     * <pre>
     *&#47;&lt; 呼叫码率为0
     * </pre>
     */
    public static final int emRecord_Err_Rate_VALUE = 9;
    /**
     * <code>emRecord_Err_PackageNum = 10;</code>
     *
     * <pre>
     *&#47;&lt; 分包数量异常
     * </pre>
     */
    public static final int emRecord_Err_PackageNum_VALUE = 10;
    /**
     * <code>emRecord_Err_Over_MaxLocalRecordNum = 11;</code>
     *
     * <pre>
     *&#47;&lt; 超过最大联系人数量
     * </pre>
     */
    public static final int emRecord_Err_Over_MaxLocalRecordNum_VALUE = 11;
    /**
     * <code>emRoster_Err_GroupName_NULL = 100;</code>
     *
     * <pre>
     *&#47;&lt; 组名为空
     * </pre>
     */
    public static final int emRoster_Err_GroupName_NULL_VALUE = 100;
    /**
     * <code>emRoster_Err_GroupSn = 101;</code>
     *
     * <pre>
     *&#47;&lt; 组SN号异常
     * </pre>
     */
    public static final int emRoster_Err_GroupSn_VALUE = 101;
    /**
     * <code>emRoster_Err_ParentGroupSn = 102;</code>
     *
     * <pre>
     *&#47;&lt; 父组SN号异常
     * </pre>
     */
    public static final int emRoster_Err_ParentGroupSn_VALUE = 102;
    /**
     * <code>emRoster_Err_RosterSn = 103;</code>
     *
     * <pre>
     *&#47;&lt; 联系人SN号异常
     * </pre>
     */
    public static final int emRoster_Err_RosterSn_VALUE = 103;
    /**
     * <code>emRoster_Err_RosterName = 104;</code>
     *
     * <pre>
     *&#47;&lt; 联系人名称异常
     * </pre>
     */
    public static final int emRoster_Err_RosterName_VALUE = 104;


    public final int getNumber() { return value; }

    public static EmMtRecordErr valueOf(int value) {
      switch (value) {
        case 0: return emRecord_Ok;
        case 1: return emRecord_Err_Index;
        case 2: return emRecord_Err_No_Marching_Records;
        case 3: return emRecord_Err_No_Marching_Type;
        case 4: return emRecord_Err_CallRecordType;
        case 5: return emRecord_Err_CallType;
        case 6: return emRecord_Err_Describe;
        case 7: return emRecord_Err_AddrType;
        case 8: return emRecord_Err_Addr;
        case 9: return emRecord_Err_Rate;
        case 10: return emRecord_Err_PackageNum;
        case 11: return emRecord_Err_Over_MaxLocalRecordNum;
        case 100: return emRoster_Err_GroupName_NULL;
        case 101: return emRoster_Err_GroupSn;
        case 102: return emRoster_Err_ParentGroupSn;
        case 103: return emRoster_Err_RosterSn;
        case 104: return emRoster_Err_RosterName;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtRecordErr>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtRecordErr>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtRecordErr>() {
            public EmMtRecordErr findValueByNumber(int number) {
              return EmMtRecordErr.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(127);
    }

    private static final EmMtRecordErr[] VALUES = values();

    public static EmMtRecordErr valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtRecordErr(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtRecordErr)
  }

  /**
   * Protobuf enum {@code mt.EmMtRecordSearchType}
   */
  public enum EmMtRecordSearchType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCallRecordType = 0;</code>
     *
     * <pre>
     *&#47;&lt; 根据是呼入，呼出，还是未接
     * </pre>
     */
    emCallRecordType(0, 0),
    /**
     * <code>emCallType = 1;</code>
     *
     * <pre>
     *&#47;&lt; 根据是视频，还是音频呼叫
     * </pre>
     */
    emCallType(1, 1),
    /**
     * <code>emDescribe = 2;</code>
     *
     * <pre>
     *&#47;&lt; 按条目名称
     * </pre>
     */
    emDescribe(2, 2),
    ;

    /**
     * <code>emCallRecordType = 0;</code>
     *
     * <pre>
     *&#47;&lt; 根据是呼入，呼出，还是未接
     * </pre>
     */
    public static final int emCallRecordType_VALUE = 0;
    /**
     * <code>emCallType = 1;</code>
     *
     * <pre>
     *&#47;&lt; 根据是视频，还是音频呼叫
     * </pre>
     */
    public static final int emCallType_VALUE = 1;
    /**
     * <code>emDescribe = 2;</code>
     *
     * <pre>
     *&#47;&lt; 按条目名称
     * </pre>
     */
    public static final int emDescribe_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtRecordSearchType valueOf(int value) {
      switch (value) {
        case 0: return emCallRecordType;
        case 1: return emCallType;
        case 2: return emDescribe;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtRecordSearchType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtRecordSearchType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtRecordSearchType>() {
            public EmMtRecordSearchType findValueByNumber(int number) {
              return EmMtRecordSearchType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(128);
    }

    private static final EmMtRecordSearchType[] VALUES = values();

    public static EmMtRecordSearchType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtRecordSearchType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtRecordSearchType)
  }

  /**
   * Protobuf enum {@code mt.EmMtAudPrecedenceLevel}
   */
  public enum EmMtAudPrecedenceLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAudPrecedenceLow = 0;</code>
     *
     * <pre>
     *&#47;/&lt; 低
     * </pre>
     */
    emAudPrecedenceLow(0, 0),
    /**
     * <code>emAudPrecedenceMiddle = 1;</code>
     *
     * <pre>
     *&#47;/&lt; 中
     * </pre>
     */
    emAudPrecedenceMiddle(1, 1),
    /**
     * <code>emAudPrecedenceHigh = 2;</code>
     *
     * <pre>
     *&#47;/&lt; 高
     * </pre>
     */
    emAudPrecedenceHigh(2, 2),
    ;

    /**
     * <code>emAudPrecedenceLow = 0;</code>
     *
     * <pre>
     *&#47;/&lt; 低
     * </pre>
     */
    public static final int emAudPrecedenceLow_VALUE = 0;
    /**
     * <code>emAudPrecedenceMiddle = 1;</code>
     *
     * <pre>
     *&#47;/&lt; 中
     * </pre>
     */
    public static final int emAudPrecedenceMiddle_VALUE = 1;
    /**
     * <code>emAudPrecedenceHigh = 2;</code>
     *
     * <pre>
     *&#47;/&lt; 高
     * </pre>
     */
    public static final int emAudPrecedenceHigh_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtAudPrecedenceLevel valueOf(int value) {
      switch (value) {
        case 0: return emAudPrecedenceLow;
        case 1: return emAudPrecedenceMiddle;
        case 2: return emAudPrecedenceHigh;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtAudPrecedenceLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtAudPrecedenceLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtAudPrecedenceLevel>() {
            public EmMtAudPrecedenceLevel findValueByNumber(int number) {
              return EmMtAudPrecedenceLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(129);
    }

    private static final EmMtAudPrecedenceLevel[] VALUES = values();

    public static EmMtAudPrecedenceLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtAudPrecedenceLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtAudPrecedenceLevel)
  }

  /**
   * Protobuf enum {@code mt.EmAlarmLevel}
   *
   * <pre>
   *告警等级
   * </pre>
   */
  public enum EmAlarmLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAlarmNormal = 0;</code>
     *
     * <pre>
     *设备正常
     * </pre>
     */
    emAlarmNormal(0, 0),
    /**
     * <code>emAlarmGeneral = 1;</code>
     *
     * <pre>
     *普通告警
     * </pre>
     */
    emAlarmGeneral(1, 1),
    /**
     * <code>emAlarmImportant = 2;</code>
     *
     * <pre>
     *重要告警
     * </pre>
     */
    emAlarmImportant(2, 2),
    /**
     * <code>emAlarmCritical = 3;</code>
     *
     * <pre>
     *严重告警
     * </pre>
     */
    emAlarmCritical(3, 3),
    /**
     * <code>emAlarmUnknown = 4;</code>
     *
     * <pre>
     *未知告警
     * </pre>
     */
    emAlarmUnknown(4, 4),
    ;

    /**
     * <code>emAlarmNormal = 0;</code>
     *
     * <pre>
     *设备正常
     * </pre>
     */
    public static final int emAlarmNormal_VALUE = 0;
    /**
     * <code>emAlarmGeneral = 1;</code>
     *
     * <pre>
     *普通告警
     * </pre>
     */
    public static final int emAlarmGeneral_VALUE = 1;
    /**
     * <code>emAlarmImportant = 2;</code>
     *
     * <pre>
     *重要告警
     * </pre>
     */
    public static final int emAlarmImportant_VALUE = 2;
    /**
     * <code>emAlarmCritical = 3;</code>
     *
     * <pre>
     *严重告警
     * </pre>
     */
    public static final int emAlarmCritical_VALUE = 3;
    /**
     * <code>emAlarmUnknown = 4;</code>
     *
     * <pre>
     *未知告警
     * </pre>
     */
    public static final int emAlarmUnknown_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmAlarmLevel valueOf(int value) {
      switch (value) {
        case 0: return emAlarmNormal;
        case 1: return emAlarmGeneral;
        case 2: return emAlarmImportant;
        case 3: return emAlarmCritical;
        case 4: return emAlarmUnknown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAlarmLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAlarmLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAlarmLevel>() {
            public EmAlarmLevel findValueByNumber(int number) {
              return EmAlarmLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(130);
    }

    private static final EmAlarmLevel[] VALUES = values();

    public static EmAlarmLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAlarmLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAlarmLevel)
  }

  /**
   * Protobuf enum {@code mt.EmAlarmState}
   *
   * <pre>
   *告警状态
   * </pre>
   */
  public enum EmAlarmState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emStateAlarm = 0;</code>
     *
     * <pre>
     *表示各种有问题的告警状态
     * </pre>
     */
    emStateAlarm(0, 0),
    /**
     * <code>emStateNormal = 1;</code>
     *
     * <pre>
     *表示各种正常的状态
     * </pre>
     */
    emStateNormal(1, 1),
    ;

    /**
     * <code>emStateAlarm = 0;</code>
     *
     * <pre>
     *表示各种有问题的告警状态
     * </pre>
     */
    public static final int emStateAlarm_VALUE = 0;
    /**
     * <code>emStateNormal = 1;</code>
     *
     * <pre>
     *表示各种正常的状态
     * </pre>
     */
    public static final int emStateNormal_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmAlarmState valueOf(int value) {
      switch (value) {
        case 0: return emStateAlarm;
        case 1: return emStateNormal;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAlarmState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAlarmState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAlarmState>() {
            public EmAlarmState findValueByNumber(int number) {
              return EmAlarmState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(131);
    }

    private static final EmAlarmState[] VALUES = values();

    public static EmAlarmState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAlarmState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAlarmState)
  }

  /**
   * Protobuf enum {@code mt.EmAlarmCode}
   *
   * <pre>
   *告警码
   * </pre>
   */
  public enum EmAlarmCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAlarmFileSysErr = 1010;</code>
     *
     * <pre>
     *文件系统出错
     * </pre>
     */
    emAlarmFileSysErr(0, 1010),
    /**
     * <code>emAlarmSysBusy = 1011;</code>
     *
     * <pre>
     *系统任务忙
     * </pre>
     */
    emAlarmSysBusy(1, 1011),
    /**
     * <code>emAlarmFanErr = 1016;</code>
     *
     * <pre>
     *设备风扇异常
     * </pre>
     */
    emAlarmFanErr(2, 1016),
    /**
     * <code>emAlarmTempHigh = 1017;</code>
     *
     * <pre>
     *设备温度过高
     * </pre>
     */
    emAlarmTempHigh(3, 1017),
    /**
     * <code>emAlarmVoltageHigh = 1018;</code>
     *
     * <pre>
     *设备电压过高
     * </pre>
     */
    emAlarmVoltageHigh(4, 1018),
    ;

    /**
     * <code>emAlarmFileSysErr = 1010;</code>
     *
     * <pre>
     *文件系统出错
     * </pre>
     */
    public static final int emAlarmFileSysErr_VALUE = 1010;
    /**
     * <code>emAlarmSysBusy = 1011;</code>
     *
     * <pre>
     *系统任务忙
     * </pre>
     */
    public static final int emAlarmSysBusy_VALUE = 1011;
    /**
     * <code>emAlarmFanErr = 1016;</code>
     *
     * <pre>
     *设备风扇异常
     * </pre>
     */
    public static final int emAlarmFanErr_VALUE = 1016;
    /**
     * <code>emAlarmTempHigh = 1017;</code>
     *
     * <pre>
     *设备温度过高
     * </pre>
     */
    public static final int emAlarmTempHigh_VALUE = 1017;
    /**
     * <code>emAlarmVoltageHigh = 1018;</code>
     *
     * <pre>
     *设备电压过高
     * </pre>
     */
    public static final int emAlarmVoltageHigh_VALUE = 1018;


    public final int getNumber() { return value; }

    public static EmAlarmCode valueOf(int value) {
      switch (value) {
        case 1010: return emAlarmFileSysErr;
        case 1011: return emAlarmSysBusy;
        case 1016: return emAlarmFanErr;
        case 1017: return emAlarmTempHigh;
        case 1018: return emAlarmVoltageHigh;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAlarmCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAlarmCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAlarmCode>() {
            public EmAlarmCode findValueByNumber(int number) {
              return EmAlarmCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(132);
    }

    private static final EmAlarmCode[] VALUES = values();

    public static EmAlarmCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAlarmCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAlarmCode)
  }

  /**
   * Protobuf enum {@code mt.EmDLProtocol}
   *
   * <pre>
   *E1链路检测类型
   * </pre>
   */
  public enum EmDLProtocol
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPPP = 0;</code>
     */
    emPPP(0, 0),
    /**
     * <code>emHDLC = 1;</code>
     */
    emHDLC(1, 1),
    /**
     * <code>emPPPOE = 2;</code>
     */
    emPPPOE(2, 2),
    /**
     * <code>emMP = 3;</code>
     */
    emMP(3, 3),
    ;

    /**
     * <code>emPPP = 0;</code>
     */
    public static final int emPPP_VALUE = 0;
    /**
     * <code>emHDLC = 1;</code>
     */
    public static final int emHDLC_VALUE = 1;
    /**
     * <code>emPPPOE = 2;</code>
     */
    public static final int emPPPOE_VALUE = 2;
    /**
     * <code>emMP = 3;</code>
     */
    public static final int emMP_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmDLProtocol valueOf(int value) {
      switch (value) {
        case 0: return emPPP;
        case 1: return emHDLC;
        case 2: return emPPPOE;
        case 3: return emMP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDLProtocol>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDLProtocol>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDLProtocol>() {
            public EmDLProtocol findValueByNumber(int number) {
              return EmDLProtocol.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(133);
    }

    private static final EmDLProtocol[] VALUES = values();

    public static EmDLProtocol valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDLProtocol(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDLProtocol)
  }

  /**
   * Protobuf enum {@code mt.EmAuthenticationType}
   *
   * <pre>
   *E1验证类型
   * </pre>
   */
  public enum EmAuthenticationType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emE1AuthTypeNone = 0;</code>
     */
    emE1AuthTypeNone(0, 0),
    /**
     * <code>emE1AuthTypePAP = 1;</code>
     */
    emE1AuthTypePAP(1, 1),
    /**
     * <code>emE1AuthTypeCHAP = 2;</code>
     */
    emE1AuthTypeCHAP(2, 2),
    ;

    /**
     * <code>emE1AuthTypeNone = 0;</code>
     */
    public static final int emE1AuthTypeNone_VALUE = 0;
    /**
     * <code>emE1AuthTypePAP = 1;</code>
     */
    public static final int emE1AuthTypePAP_VALUE = 1;
    /**
     * <code>emE1AuthTypeCHAP = 2;</code>
     */
    public static final int emE1AuthTypeCHAP_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmAuthenticationType valueOf(int value) {
      switch (value) {
        case 0: return emE1AuthTypeNone;
        case 1: return emE1AuthTypePAP;
        case 2: return emE1AuthTypeCHAP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAuthenticationType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAuthenticationType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAuthenticationType>() {
            public EmAuthenticationType findValueByNumber(int number) {
              return EmAuthenticationType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(134);
    }

    private static final EmAuthenticationType[] VALUES = values();

    public static EmAuthenticationType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAuthenticationType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAuthenticationType)
  }

  /**
   * Protobuf enum {@code mt.EmApsLoginErrcode}
   */
  public enum EmApsLoginErrcode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emApsLoginOk = 0;</code>
     *
     * <pre>
     *成功
     * </pre>
     */
    emApsLoginOk(0, 0),
    /**
     * <code>emApsLoginErrUnknown = 1;</code>
     *
     * <pre>
     *未知错误
     * </pre>
     */
    emApsLoginErrUnknown(1, 1),
    ;

    /**
     * <code>emApsLoginOk = 0;</code>
     *
     * <pre>
     *成功
     * </pre>
     */
    public static final int emApsLoginOk_VALUE = 0;
    /**
     * <code>emApsLoginErrUnknown = 1;</code>
     *
     * <pre>
     *未知错误
     * </pre>
     */
    public static final int emApsLoginErrUnknown_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmApsLoginErrcode valueOf(int value) {
      switch (value) {
        case 0: return emApsLoginOk;
        case 1: return emApsLoginErrUnknown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmApsLoginErrcode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmApsLoginErrcode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmApsLoginErrcode>() {
            public EmApsLoginErrcode findValueByNumber(int number) {
              return EmApsLoginErrcode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(135);
    }

    private static final EmApsLoginErrcode[] VALUES = values();

    public static EmApsLoginErrcode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmApsLoginErrcode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmApsLoginErrcode)
  }

  /**
   * Protobuf enum {@code mt.EmPortType}
   */
  public enum EmPortType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConfChanPort = 0;</code>
     *
     * <pre>
     *会议通道的端口
     * </pre>
     */
    emConfChanPort(0, 0),
    /**
     * <code>emImPort = 1;</code>
     */
    emImPort(1, 1),
    /**
     * <code>emVodPort = 2;</code>
     */
    emVodPort(2, 2),
    /**
     * <code>emMcPort = 3;</code>
     */
    emMcPort(3, 3),
    /**
     * <code>emH323CallingPort = 4;</code>
     */
    emH323CallingPort(4, 4),
    /**
     * <code>emH323TcpBasePort = 5;</code>
     */
    emH323TcpBasePort(5, 5),
    /**
     * <code>emH323TcpEndPort = 6;</code>
     */
    emH323TcpEndPort(6, 6),
    /**
     * <code>emH323pxyBasePort = 7;</code>
     */
    emH323pxyBasePort(7, 7),
    /**
     * <code>emH323pxyEndPort = 8;</code>
     */
    emH323pxyEndPort(8, 8),
    /**
     * <code>emSipBfcpPort = 9;</code>
     */
    emSipBfcpPort(9, 9),
    /**
     * <code>emMTCPort = 10;</code>
     */
    emMTCPort(10, 10),
    /**
     * <code>emGKPort = 11;</code>
     */
    emGKPort(11, 11),
    /**
     * <code>emSipCallingPort = 12;</code>
     */
    emSipCallingPort(12, 12),
    ;

    /**
     * <code>emConfChanPort = 0;</code>
     *
     * <pre>
     *会议通道的端口
     * </pre>
     */
    public static final int emConfChanPort_VALUE = 0;
    /**
     * <code>emImPort = 1;</code>
     */
    public static final int emImPort_VALUE = 1;
    /**
     * <code>emVodPort = 2;</code>
     */
    public static final int emVodPort_VALUE = 2;
    /**
     * <code>emMcPort = 3;</code>
     */
    public static final int emMcPort_VALUE = 3;
    /**
     * <code>emH323CallingPort = 4;</code>
     */
    public static final int emH323CallingPort_VALUE = 4;
    /**
     * <code>emH323TcpBasePort = 5;</code>
     */
    public static final int emH323TcpBasePort_VALUE = 5;
    /**
     * <code>emH323TcpEndPort = 6;</code>
     */
    public static final int emH323TcpEndPort_VALUE = 6;
    /**
     * <code>emH323pxyBasePort = 7;</code>
     */
    public static final int emH323pxyBasePort_VALUE = 7;
    /**
     * <code>emH323pxyEndPort = 8;</code>
     */
    public static final int emH323pxyEndPort_VALUE = 8;
    /**
     * <code>emSipBfcpPort = 9;</code>
     */
    public static final int emSipBfcpPort_VALUE = 9;
    /**
     * <code>emMTCPort = 10;</code>
     */
    public static final int emMTCPort_VALUE = 10;
    /**
     * <code>emGKPort = 11;</code>
     */
    public static final int emGKPort_VALUE = 11;
    /**
     * <code>emSipCallingPort = 12;</code>
     */
    public static final int emSipCallingPort_VALUE = 12;


    public final int getNumber() { return value; }

    public static EmPortType valueOf(int value) {
      switch (value) {
        case 0: return emConfChanPort;
        case 1: return emImPort;
        case 2: return emVodPort;
        case 3: return emMcPort;
        case 4: return emH323CallingPort;
        case 5: return emH323TcpBasePort;
        case 6: return emH323TcpEndPort;
        case 7: return emH323pxyBasePort;
        case 8: return emH323pxyEndPort;
        case 9: return emSipBfcpPort;
        case 10: return emMTCPort;
        case 11: return emGKPort;
        case 12: return emSipCallingPort;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPortType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPortType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPortType>() {
            public EmPortType findValueByNumber(int number) {
              return EmPortType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(136);
    }

    private static final EmPortType[] VALUES = values();

    public static EmPortType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPortType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPortType)
  }

  /**
   * Protobuf enum {@code mt.EmVideoType}
   *
   * <pre>
   *硬终端产品的枚举 start
   *视频类型
   * </pre>
   */
  public enum EmVideoType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>em1stPriomVideo = 0;</code>
     *
     * <pre>
     *第一路主视频
     * </pre>
     */
    em1stPriomVideo(0, 0),
    /**
     * <code>em2ndPriomVideo = 1;</code>
     *
     * <pre>
     *第二路主视频
     * </pre>
     */
    em2ndPriomVideo(1, 1),
    /**
     * <code>em3rdPriomVideo = 2;</code>
     *
     * <pre>
     *第三路主视频
     * </pre>
     */
    em3rdPriomVideo(2, 2),
    /**
     * <code>emSecondVideo = 10;</code>
     *
     * <pre>
     *第二路视频
     * </pre>
     */
    emSecondVideo(3, 10),
    ;

    /**
     * <code>em1stPriomVideo = 0;</code>
     *
     * <pre>
     *第一路主视频
     * </pre>
     */
    public static final int em1stPriomVideo_VALUE = 0;
    /**
     * <code>em2ndPriomVideo = 1;</code>
     *
     * <pre>
     *第二路主视频
     * </pre>
     */
    public static final int em2ndPriomVideo_VALUE = 1;
    /**
     * <code>em3rdPriomVideo = 2;</code>
     *
     * <pre>
     *第三路主视频
     * </pre>
     */
    public static final int em3rdPriomVideo_VALUE = 2;
    /**
     * <code>emSecondVideo = 10;</code>
     *
     * <pre>
     *第二路视频
     * </pre>
     */
    public static final int emSecondVideo_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmVideoType valueOf(int value) {
      switch (value) {
        case 0: return em1stPriomVideo;
        case 1: return em2ndPriomVideo;
        case 2: return em3rdPriomVideo;
        case 10: return emSecondVideo;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVideoType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVideoType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVideoType>() {
            public EmVideoType findValueByNumber(int number) {
              return EmVideoType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(137);
    }

    private static final EmVideoType[] VALUES = values();

    public static EmVideoType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVideoType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVideoType)
  }

  /**
   * Protobuf enum {@code mt.EmVideoOutPutMode}
   *
   * <pre>
   *视频输出制式
   * </pre>
   */
  public enum EmVideoOutPutMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVOM_HD_ORIGIN = 0;</code>
     */
    emVOM_HD_ORIGIN(0, 0),
    /**
     * <code>emVOM_HD_1080p_24 = 1;</code>
     */
    emVOM_HD_1080p_24(1, 1),
    /**
     * <code>emVOM_HD_1080p_25 = 2;</code>
     */
    emVOM_HD_1080p_25(2, 2),
    /**
     * <code>emVOM_HD_1080p_30 = 3;</code>
     */
    emVOM_HD_1080p_30(3, 3),
    /**
     * <code>emVOM_HD_1080p_50 = 4;</code>
     */
    emVOM_HD_1080p_50(4, 4),
    /**
     * <code>emVOM_HD_1080p_60hz = 5;</code>
     */
    emVOM_HD_1080p_60hz(5, 5),
    /**
     * <code>emVOM_HD_1080p_60fps = 6;</code>
     */
    emVOM_HD_1080p_60fps(6, 6),
    /**
     * <code>emVOM_HD_1080i_50 = 7;</code>
     */
    emVOM_HD_1080i_50(7, 7),
    /**
     * <code>emVOM_HD_1080i_60 = 8;</code>
     */
    emVOM_HD_1080i_60(8, 8),
    /**
     * <code>emVOM_HD_720p_50 = 9;</code>
     */
    emVOM_HD_720p_50(9, 9),
    /**
     * <code>emVOM_HD_720p_60hz = 10;</code>
     */
    emVOM_HD_720p_60hz(10, 10),
    /**
     * <code>emVOM_HD_720p_60fps = 11;</code>
     */
    emVOM_HD_720p_60fps(11, 11),
    /**
     * <code>emVOM_HD_576i_50 = 12;</code>
     */
    emVOM_HD_576i_50(12, 12),
    /**
     * <code>emVOM_HD_1080p_29 = 13;</code>
     */
    emVOM_HD_1080p_29(13, 13),
    /**
     * <code>emVOM_HD_1080p_59 = 14;</code>
     */
    emVOM_HD_1080p_59(14, 14),
    /**
     * <code>emVOM_HD_576p = 15;</code>
     */
    emVOM_HD_576p(15, 15),
    /**
     * <code>emVOM_HD_1080p_29_97 = 16;</code>
     */
    emVOM_HD_1080p_29_97(16, 16),
    /**
     * <code>emVOM_HD_1080p_59_94 = 17;</code>
     */
    emVOM_HD_1080p_59_94(17, 17),
    /**
     * <code>emVOM_HD_VGA_60 = 18;</code>
     */
    emVOM_HD_VGA_60(18, 18),
    /**
     * <code>emVOM_HD_VGA_75 = 19;</code>
     */
    emVOM_HD_VGA_75(19, 19),
    /**
     * <code>emVOM_HD_SVGA_60 = 20;</code>
     */
    emVOM_HD_SVGA_60(20, 20),
    /**
     * <code>emVOM_HD_SVGA_75 = 21;</code>
     */
    emVOM_HD_SVGA_75(21, 21),
    /**
     * <code>emVOM_HD_XGA_60 = 22;</code>
     */
    emVOM_HD_XGA_60(22, 22),
    /**
     * <code>emVOM_HD_XGA_75 = 23;</code>
     */
    emVOM_HD_XGA_75(23, 23),
    /**
     * <code>emVOM_HD_SXGA_60 = 24;</code>
     */
    emVOM_HD_SXGA_60(24, 24),
    /**
     * <code>emVOM_HD_WXGA1280x768_60 = 25;</code>
     */
    emVOM_HD_WXGA1280x768_60(25, 25),
    /**
     * <code>emVOM_HD_WXGA1280x768_75 = 26;</code>
     */
    emVOM_HD_WXGA1280x768_75(26, 26),
    /**
     * <code>emVOM_HD_WXGA1280x800_60 = 27;</code>
     */
    emVOM_HD_WXGA1280x800_60(27, 27),
    /**
     * <code>emVOM_HD_WXGA1280x800_75 = 28;</code>
     */
    emVOM_HD_WXGA1280x800_75(28, 28),
    /**
     * <code>emVOM_HD_WXGA1366x768_60 = 29;</code>
     */
    emVOM_HD_WXGA1366x768_60(29, 29),
    /**
     * <code>emVOM_HD_UXGA1600x1200_60 = 30;</code>
     */
    emVOM_HD_UXGA1600x1200_60(30, 30),
    /**
     * <code>emVOM_HD_WSXGA1440x900_60 = 31;</code>
     */
    emVOM_HD_WSXGA1440x900_60(31, 31),
    /**
     * <code>emVOM_HD_SXGAPLUS1680x1050_60 = 32;</code>
     */
    emVOM_HD_SXGAPLUS1680x1050_60(32, 32),
    /**
     * <code>emVOM_HD_4k3860x2160_30 = 33;</code>
     */
    emVOM_HD_4k3860x2160_30(33, 33),
    /**
     * <code>emVOM_HD_4k3860x2160_60 = 34;</code>
     */
    emVOM_HD_4k3860x2160_60(34, 34),
    ;

    /**
     * <code>emVOM_HD_ORIGIN = 0;</code>
     */
    public static final int emVOM_HD_ORIGIN_VALUE = 0;
    /**
     * <code>emVOM_HD_1080p_24 = 1;</code>
     */
    public static final int emVOM_HD_1080p_24_VALUE = 1;
    /**
     * <code>emVOM_HD_1080p_25 = 2;</code>
     */
    public static final int emVOM_HD_1080p_25_VALUE = 2;
    /**
     * <code>emVOM_HD_1080p_30 = 3;</code>
     */
    public static final int emVOM_HD_1080p_30_VALUE = 3;
    /**
     * <code>emVOM_HD_1080p_50 = 4;</code>
     */
    public static final int emVOM_HD_1080p_50_VALUE = 4;
    /**
     * <code>emVOM_HD_1080p_60hz = 5;</code>
     */
    public static final int emVOM_HD_1080p_60hz_VALUE = 5;
    /**
     * <code>emVOM_HD_1080p_60fps = 6;</code>
     */
    public static final int emVOM_HD_1080p_60fps_VALUE = 6;
    /**
     * <code>emVOM_HD_1080i_50 = 7;</code>
     */
    public static final int emVOM_HD_1080i_50_VALUE = 7;
    /**
     * <code>emVOM_HD_1080i_60 = 8;</code>
     */
    public static final int emVOM_HD_1080i_60_VALUE = 8;
    /**
     * <code>emVOM_HD_720p_50 = 9;</code>
     */
    public static final int emVOM_HD_720p_50_VALUE = 9;
    /**
     * <code>emVOM_HD_720p_60hz = 10;</code>
     */
    public static final int emVOM_HD_720p_60hz_VALUE = 10;
    /**
     * <code>emVOM_HD_720p_60fps = 11;</code>
     */
    public static final int emVOM_HD_720p_60fps_VALUE = 11;
    /**
     * <code>emVOM_HD_576i_50 = 12;</code>
     */
    public static final int emVOM_HD_576i_50_VALUE = 12;
    /**
     * <code>emVOM_HD_1080p_29 = 13;</code>
     */
    public static final int emVOM_HD_1080p_29_VALUE = 13;
    /**
     * <code>emVOM_HD_1080p_59 = 14;</code>
     */
    public static final int emVOM_HD_1080p_59_VALUE = 14;
    /**
     * <code>emVOM_HD_576p = 15;</code>
     */
    public static final int emVOM_HD_576p_VALUE = 15;
    /**
     * <code>emVOM_HD_1080p_29_97 = 16;</code>
     */
    public static final int emVOM_HD_1080p_29_97_VALUE = 16;
    /**
     * <code>emVOM_HD_1080p_59_94 = 17;</code>
     */
    public static final int emVOM_HD_1080p_59_94_VALUE = 17;
    /**
     * <code>emVOM_HD_VGA_60 = 18;</code>
     */
    public static final int emVOM_HD_VGA_60_VALUE = 18;
    /**
     * <code>emVOM_HD_VGA_75 = 19;</code>
     */
    public static final int emVOM_HD_VGA_75_VALUE = 19;
    /**
     * <code>emVOM_HD_SVGA_60 = 20;</code>
     */
    public static final int emVOM_HD_SVGA_60_VALUE = 20;
    /**
     * <code>emVOM_HD_SVGA_75 = 21;</code>
     */
    public static final int emVOM_HD_SVGA_75_VALUE = 21;
    /**
     * <code>emVOM_HD_XGA_60 = 22;</code>
     */
    public static final int emVOM_HD_XGA_60_VALUE = 22;
    /**
     * <code>emVOM_HD_XGA_75 = 23;</code>
     */
    public static final int emVOM_HD_XGA_75_VALUE = 23;
    /**
     * <code>emVOM_HD_SXGA_60 = 24;</code>
     */
    public static final int emVOM_HD_SXGA_60_VALUE = 24;
    /**
     * <code>emVOM_HD_WXGA1280x768_60 = 25;</code>
     */
    public static final int emVOM_HD_WXGA1280x768_60_VALUE = 25;
    /**
     * <code>emVOM_HD_WXGA1280x768_75 = 26;</code>
     */
    public static final int emVOM_HD_WXGA1280x768_75_VALUE = 26;
    /**
     * <code>emVOM_HD_WXGA1280x800_60 = 27;</code>
     */
    public static final int emVOM_HD_WXGA1280x800_60_VALUE = 27;
    /**
     * <code>emVOM_HD_WXGA1280x800_75 = 28;</code>
     */
    public static final int emVOM_HD_WXGA1280x800_75_VALUE = 28;
    /**
     * <code>emVOM_HD_WXGA1366x768_60 = 29;</code>
     */
    public static final int emVOM_HD_WXGA1366x768_60_VALUE = 29;
    /**
     * <code>emVOM_HD_UXGA1600x1200_60 = 30;</code>
     */
    public static final int emVOM_HD_UXGA1600x1200_60_VALUE = 30;
    /**
     * <code>emVOM_HD_WSXGA1440x900_60 = 31;</code>
     */
    public static final int emVOM_HD_WSXGA1440x900_60_VALUE = 31;
    /**
     * <code>emVOM_HD_SXGAPLUS1680x1050_60 = 32;</code>
     */
    public static final int emVOM_HD_SXGAPLUS1680x1050_60_VALUE = 32;
    /**
     * <code>emVOM_HD_4k3860x2160_30 = 33;</code>
     */
    public static final int emVOM_HD_4k3860x2160_30_VALUE = 33;
    /**
     * <code>emVOM_HD_4k3860x2160_60 = 34;</code>
     */
    public static final int emVOM_HD_4k3860x2160_60_VALUE = 34;


    public final int getNumber() { return value; }

    public static EmVideoOutPutMode valueOf(int value) {
      switch (value) {
        case 0: return emVOM_HD_ORIGIN;
        case 1: return emVOM_HD_1080p_24;
        case 2: return emVOM_HD_1080p_25;
        case 3: return emVOM_HD_1080p_30;
        case 4: return emVOM_HD_1080p_50;
        case 5: return emVOM_HD_1080p_60hz;
        case 6: return emVOM_HD_1080p_60fps;
        case 7: return emVOM_HD_1080i_50;
        case 8: return emVOM_HD_1080i_60;
        case 9: return emVOM_HD_720p_50;
        case 10: return emVOM_HD_720p_60hz;
        case 11: return emVOM_HD_720p_60fps;
        case 12: return emVOM_HD_576i_50;
        case 13: return emVOM_HD_1080p_29;
        case 14: return emVOM_HD_1080p_59;
        case 15: return emVOM_HD_576p;
        case 16: return emVOM_HD_1080p_29_97;
        case 17: return emVOM_HD_1080p_59_94;
        case 18: return emVOM_HD_VGA_60;
        case 19: return emVOM_HD_VGA_75;
        case 20: return emVOM_HD_SVGA_60;
        case 21: return emVOM_HD_SVGA_75;
        case 22: return emVOM_HD_XGA_60;
        case 23: return emVOM_HD_XGA_75;
        case 24: return emVOM_HD_SXGA_60;
        case 25: return emVOM_HD_WXGA1280x768_60;
        case 26: return emVOM_HD_WXGA1280x768_75;
        case 27: return emVOM_HD_WXGA1280x800_60;
        case 28: return emVOM_HD_WXGA1280x800_75;
        case 29: return emVOM_HD_WXGA1366x768_60;
        case 30: return emVOM_HD_UXGA1600x1200_60;
        case 31: return emVOM_HD_WSXGA1440x900_60;
        case 32: return emVOM_HD_SXGAPLUS1680x1050_60;
        case 33: return emVOM_HD_4k3860x2160_30;
        case 34: return emVOM_HD_4k3860x2160_60;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVideoOutPutMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVideoOutPutMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVideoOutPutMode>() {
            public EmVideoOutPutMode findValueByNumber(int number) {
              return EmVideoOutPutMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(138);
    }

    private static final EmVideoOutPutMode[] VALUES = values();

    public static EmVideoOutPutMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVideoOutPutMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVideoOutPutMode)
  }

  /**
   * Protobuf enum {@code mt.EmTextAlign}
   *
   * <pre>
   *横幅
   * </pre>
   */
  public enum EmTextAlign
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAlignLeft = 0;</code>
     *
     * <pre>
     *居左
     * </pre>
     */
    emAlignLeft(0, 0),
    /**
     * <code>emAlignCenter = 1;</code>
     *
     * <pre>
     *居中
     * </pre>
     */
    emAlignCenter(1, 1),
    /**
     * <code>emAlignRight = 2;</code>
     *
     * <pre>
     *居右
     * </pre>
     */
    emAlignRight(2, 2),
    ;

    /**
     * <code>emAlignLeft = 0;</code>
     *
     * <pre>
     *居左
     * </pre>
     */
    public static final int emAlignLeft_VALUE = 0;
    /**
     * <code>emAlignCenter = 1;</code>
     *
     * <pre>
     *居中
     * </pre>
     */
    public static final int emAlignCenter_VALUE = 1;
    /**
     * <code>emAlignRight = 2;</code>
     *
     * <pre>
     *居右
     * </pre>
     */
    public static final int emAlignRight_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmTextAlign valueOf(int value) {
      switch (value) {
        case 0: return emAlignLeft;
        case 1: return emAlignCenter;
        case 2: return emAlignRight;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmTextAlign>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmTextAlign>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmTextAlign>() {
            public EmTextAlign findValueByNumber(int number) {
              return EmTextAlign.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(139);
    }

    private static final EmTextAlign[] VALUES = values();

    public static EmTextAlign valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmTextAlign(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmTextAlign)
  }

  /**
   * Protobuf enum {@code mt.EmRollMode}
   *
   * <pre>
   *横幅
   * </pre>
   */
  public enum EmRollMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emStatic = 0;</code>
     */
    emStatic(0, 0),
    /**
     * <code>emRight2Left = 1;</code>
     */
    emRight2Left(1, 1),
    /**
     * <code>emDown2Up = 2;</code>
     */
    emDown2Up(2, 2),
    /**
     * <code>emScollPage = 3;</code>
     */
    emScollPage(3, 3),
    ;

    /**
     * <code>emStatic = 0;</code>
     */
    public static final int emStatic_VALUE = 0;
    /**
     * <code>emRight2Left = 1;</code>
     */
    public static final int emRight2Left_VALUE = 1;
    /**
     * <code>emDown2Up = 2;</code>
     */
    public static final int emDown2Up_VALUE = 2;
    /**
     * <code>emScollPage = 3;</code>
     */
    public static final int emScollPage_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmRollMode valueOf(int value) {
      switch (value) {
        case 0: return emStatic;
        case 1: return emRight2Left;
        case 2: return emDown2Up;
        case 3: return emScollPage;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRollMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRollMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRollMode>() {
            public EmRollMode findValueByNumber(int number) {
              return EmRollMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(140);
    }

    private static final EmRollMode[] VALUES = values();

    public static EmRollMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRollMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRollMode)
  }

  /**
   * Protobuf enum {@code mt.EmRollSpeed}
   *
   * <pre>
   *横幅
   * </pre>
   */
  public enum EmRollSpeed
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRollSlower = 0;</code>
     */
    emRollSlower(0, 0),
    /**
     * <code>emRollSlow = 1;</code>
     */
    emRollSlow(1, 1),
    /**
     * <code>emRollNormal = 2;</code>
     */
    emRollNormal(2, 2),
    /**
     * <code>emRollFast = 3;</code>
     */
    emRollFast(3, 3),
    /**
     * <code>emRollFaster = 4;</code>
     */
    emRollFaster(4, 4),
    ;

    /**
     * <code>emRollSlower = 0;</code>
     */
    public static final int emRollSlower_VALUE = 0;
    /**
     * <code>emRollSlow = 1;</code>
     */
    public static final int emRollSlow_VALUE = 1;
    /**
     * <code>emRollNormal = 2;</code>
     */
    public static final int emRollNormal_VALUE = 2;
    /**
     * <code>emRollFast = 3;</code>
     */
    public static final int emRollFast_VALUE = 3;
    /**
     * <code>emRollFaster = 4;</code>
     */
    public static final int emRollFaster_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmRollSpeed valueOf(int value) {
      switch (value) {
        case 0: return emRollSlower;
        case 1: return emRollSlow;
        case 2: return emRollNormal;
        case 3: return emRollFast;
        case 4: return emRollFaster;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRollSpeed>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRollSpeed>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRollSpeed>() {
            public EmRollSpeed findValueByNumber(int number) {
              return EmRollSpeed.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(141);
    }

    private static final EmRollSpeed[] VALUES = values();

    public static EmRollSpeed valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRollSpeed(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRollSpeed)
  }

  /**
   * Protobuf enum {@code mt.EmHDAudPortIn}
   *
   * <pre>
   *音频输入接口
   * </pre>
   */
  public enum EmHDAudPortIn
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emHDAudInBegin = 0;</code>
     *
     * <pre>
     * X500                  X700-4K|X500-4K       X500-1080P|X300       SKY300
     * </pre>
     */
    emHDAudInBegin(0, 0),
    /**
     * <code>emHDAudInDMic1 = 1;</code>
     *
     * <pre>
     * 有线MIC 1             有线MIC_2             有线MIC_1             有线MIC_2
     * </pre>
     */
    emHDAudInDMic1(1, 1),
    /**
     * <code>emHDAudInDMic2 = 2;</code>
     *
     * <pre>
     * 有线MIC 2             有线MIC_3             ...
     * </pre>
     */
    emHDAudInDMic2(2, 2),
    /**
     * <code>emHDAudInXLR = 3;</code>
     *
     * <pre>
     * 卡侬MIC_1             卡侬MIC_1             卡侬MIC_2             卡侬MIC_1
     * </pre>
     */
    emHDAudInXLR(3, 3),
    /**
     * <code>emHDAudInWMic1 = 4;</code>
     *
     * <pre>
     * 无线MIC_1             无线MIC_1             无线MIC_1
     * </pre>
     */
    emHDAudInWMic1(4, 4),
    /**
     * <code>emHDAudInWMic2 = 5;</code>
     *
     * <pre>
     * 无线MIC_2             无线MIC_2             ...
     * </pre>
     */
    emHDAudInWMic2(5, 5),
    /**
     * <code>emHDAudInWMic3 = 6;</code>
     *
     * <pre>
     * 无线MIC_3             无线MIC_3             ...
     * </pre>
     */
    emHDAudInWMic3(6, 6),
    /**
     * <code>emHDAudInRCA = 7;</code>
     *
     * <pre>
     * LINE_4                LINE_5                LINE_4
     * </pre>
     */
    emHDAudInRCA(7, 7),
    /**
     * <code>emHDAudInTRS3_5 = 8;</code>
     *
     * <pre>
     * AUX_3                 AUX_3                 AUX_3                 AUX_3
     * </pre>
     */
    emHDAudInTRS3_5(8, 8),
    /**
     * <code>emHDAudInHDMI1 = 9;</code>
     *
     * <pre>
     * HDMI_4                HDMI_6                HDMI_3|HDMI_3         HDMI_2
     * </pre>
     */
    emHDAudInHDMI1(9, 9),
    /**
     * <code>emHDAudInHDMI2 = 10;</code>
     *
     * <pre>
     * ...                   HDMI_1|...            ...
     * </pre>
     */
    emHDAudInHDMI2(10, 10),
    /**
     * <code>emHDAudInHDMI3 = 11;</code>
     *
     * <pre>
     * ...                   HDMI_2|...            ...
     * </pre>
     */
    emHDAudInHDMI3(11, 11),
    /**
     * <code>emHDAudInDHDMI = 12;</code>
     *
     * <pre>
     * DVI/YPbPr/VGA/HDMI_3  DVI/HDMI/VGA/YPbPr_5  DVI/HDMI/VGA/YPbPr_1
     * </pre>
     */
    emHDAudInDHDMI(12, 12),
    /**
     * <code>emHDAudInSDI1 = 13;</code>
     *
     * <pre>
     * SDI1                  SDI_3                 SDI_2|...
     * </pre>
     */
    emHDAudInSDI1(13, 13),
    /**
     * <code>emHDAudInSDI2 = 14;</code>
     *
     * <pre>
     * SDI2                  SDI_4                 ...
     * </pre>
     */
    emHDAudInSDI2(14, 14),
    /**
     * <code>emHDAudInHDBaseT1 = 15;</code>
     *
     * <pre>
     * HDBaseT_1             HDBaseT_1             HDBaseT_1
     * </pre>
     */
    emHDAudInHDBaseT1(15, 15),
    /**
     * <code>emHDAudInHDBaseT2 = 16;</code>
     *
     * <pre>
     * HDBaseT_2             HDBaseT_2             HDBaseT_2|...
     * </pre>
     */
    emHDAudInHDBaseT2(16, 16),
    /**
     * <code>emHDAudInDsiMic1 = 17;</code>
     *
     * <pre>
     * ...                   ...                   ...                  DSIMIC_1
     * </pre>
     */
    emHDAudInDsiMic1(17, 17),
    /**
     * <code>emHDAudInDsiMic2 = 18;</code>
     *
     * <pre>
     * ...                   ...                   ...                  DSIMIC_2
     * </pre>
     */
    emHDAudInDsiMic2(18, 18),
    ;

    /**
     * <code>emHDAudInBegin = 0;</code>
     *
     * <pre>
     * X500                  X700-4K|X500-4K       X500-1080P|X300       SKY300
     * </pre>
     */
    public static final int emHDAudInBegin_VALUE = 0;
    /**
     * <code>emHDAudInDMic1 = 1;</code>
     *
     * <pre>
     * 有线MIC 1             有线MIC_2             有线MIC_1             有线MIC_2
     * </pre>
     */
    public static final int emHDAudInDMic1_VALUE = 1;
    /**
     * <code>emHDAudInDMic2 = 2;</code>
     *
     * <pre>
     * 有线MIC 2             有线MIC_3             ...
     * </pre>
     */
    public static final int emHDAudInDMic2_VALUE = 2;
    /**
     * <code>emHDAudInXLR = 3;</code>
     *
     * <pre>
     * 卡侬MIC_1             卡侬MIC_1             卡侬MIC_2             卡侬MIC_1
     * </pre>
     */
    public static final int emHDAudInXLR_VALUE = 3;
    /**
     * <code>emHDAudInWMic1 = 4;</code>
     *
     * <pre>
     * 无线MIC_1             无线MIC_1             无线MIC_1
     * </pre>
     */
    public static final int emHDAudInWMic1_VALUE = 4;
    /**
     * <code>emHDAudInWMic2 = 5;</code>
     *
     * <pre>
     * 无线MIC_2             无线MIC_2             ...
     * </pre>
     */
    public static final int emHDAudInWMic2_VALUE = 5;
    /**
     * <code>emHDAudInWMic3 = 6;</code>
     *
     * <pre>
     * 无线MIC_3             无线MIC_3             ...
     * </pre>
     */
    public static final int emHDAudInWMic3_VALUE = 6;
    /**
     * <code>emHDAudInRCA = 7;</code>
     *
     * <pre>
     * LINE_4                LINE_5                LINE_4
     * </pre>
     */
    public static final int emHDAudInRCA_VALUE = 7;
    /**
     * <code>emHDAudInTRS3_5 = 8;</code>
     *
     * <pre>
     * AUX_3                 AUX_3                 AUX_3                 AUX_3
     * </pre>
     */
    public static final int emHDAudInTRS3_5_VALUE = 8;
    /**
     * <code>emHDAudInHDMI1 = 9;</code>
     *
     * <pre>
     * HDMI_4                HDMI_6                HDMI_3|HDMI_3         HDMI_2
     * </pre>
     */
    public static final int emHDAudInHDMI1_VALUE = 9;
    /**
     * <code>emHDAudInHDMI2 = 10;</code>
     *
     * <pre>
     * ...                   HDMI_1|...            ...
     * </pre>
     */
    public static final int emHDAudInHDMI2_VALUE = 10;
    /**
     * <code>emHDAudInHDMI3 = 11;</code>
     *
     * <pre>
     * ...                   HDMI_2|...            ...
     * </pre>
     */
    public static final int emHDAudInHDMI3_VALUE = 11;
    /**
     * <code>emHDAudInDHDMI = 12;</code>
     *
     * <pre>
     * DVI/YPbPr/VGA/HDMI_3  DVI/HDMI/VGA/YPbPr_5  DVI/HDMI/VGA/YPbPr_1
     * </pre>
     */
    public static final int emHDAudInDHDMI_VALUE = 12;
    /**
     * <code>emHDAudInSDI1 = 13;</code>
     *
     * <pre>
     * SDI1                  SDI_3                 SDI_2|...
     * </pre>
     */
    public static final int emHDAudInSDI1_VALUE = 13;
    /**
     * <code>emHDAudInSDI2 = 14;</code>
     *
     * <pre>
     * SDI2                  SDI_4                 ...
     * </pre>
     */
    public static final int emHDAudInSDI2_VALUE = 14;
    /**
     * <code>emHDAudInHDBaseT1 = 15;</code>
     *
     * <pre>
     * HDBaseT_1             HDBaseT_1             HDBaseT_1
     * </pre>
     */
    public static final int emHDAudInHDBaseT1_VALUE = 15;
    /**
     * <code>emHDAudInHDBaseT2 = 16;</code>
     *
     * <pre>
     * HDBaseT_2             HDBaseT_2             HDBaseT_2|...
     * </pre>
     */
    public static final int emHDAudInHDBaseT2_VALUE = 16;
    /**
     * <code>emHDAudInDsiMic1 = 17;</code>
     *
     * <pre>
     * ...                   ...                   ...                  DSIMIC_1
     * </pre>
     */
    public static final int emHDAudInDsiMic1_VALUE = 17;
    /**
     * <code>emHDAudInDsiMic2 = 18;</code>
     *
     * <pre>
     * ...                   ...                   ...                  DSIMIC_2
     * </pre>
     */
    public static final int emHDAudInDsiMic2_VALUE = 18;


    public final int getNumber() { return value; }

    public static EmHDAudPortIn valueOf(int value) {
      switch (value) {
        case 0: return emHDAudInBegin;
        case 1: return emHDAudInDMic1;
        case 2: return emHDAudInDMic2;
        case 3: return emHDAudInXLR;
        case 4: return emHDAudInWMic1;
        case 5: return emHDAudInWMic2;
        case 6: return emHDAudInWMic3;
        case 7: return emHDAudInRCA;
        case 8: return emHDAudInTRS3_5;
        case 9: return emHDAudInHDMI1;
        case 10: return emHDAudInHDMI2;
        case 11: return emHDAudInHDMI3;
        case 12: return emHDAudInDHDMI;
        case 13: return emHDAudInSDI1;
        case 14: return emHDAudInSDI2;
        case 15: return emHDAudInHDBaseT1;
        case 16: return emHDAudInHDBaseT2;
        case 17: return emHDAudInDsiMic1;
        case 18: return emHDAudInDsiMic2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDAudPortIn>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDAudPortIn>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDAudPortIn>() {
            public EmHDAudPortIn findValueByNumber(int number) {
              return EmHDAudPortIn.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(142);
    }

    private static final EmHDAudPortIn[] VALUES = values();

    public static EmHDAudPortIn valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDAudPortIn(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDAudPortIn)
  }

  /**
   * Protobuf enum {@code mt.EmHDAudPortOut}
   *
   * <pre>
   *音频输出接口
   * </pre>
   */
  public enum EmHDAudPortOut
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emHDAudOutBegin = 0;</code>
     *
     * <pre>
     * X500                    X700-4K|X500-4K       X500-1080P|X300       SKY300
     * </pre>
     */
    emHDAudOutBegin(0, 0),
    /**
     * <code>emHDAudOutRCA = 1;</code>
     *
     * <pre>
     * LINE 3                  LINE 3                LINE_2
     * </pre>
     */
    emHDAudOutRCA(1, 1),
    /**
     * <code>emHDAudOutTRS6_5 = 2;</code>
     *
     * <pre>
     * TRS 1                   TRS 1                 TRS_3
     * </pre>
     */
    emHDAudOutTRS6_5(2, 2),
    /**
     * <code>emHDAudOutTRS3_5 = 3;</code>
     *
     * <pre>
     * AUX 2                   AUX 2                 AUX_1                 AUX_1
     * </pre>
     */
    emHDAudOutTRS3_5(3, 3),
    /**
     * <code>emHDAudOutDHDMI1 = 4;</code>
     *
     * <pre>
     * DVI/YPbPr/VGA/HDMI1_1   DVI/HDMI/VGA/YPbPr_3  DVI/HDMI/VGA/YPbPr_1
     * </pre>
     */
    emHDAudOutDHDMI1(4, 4),
    /**
     * <code>emHDAudOutDHDMI2 = 5;</code>
     *
     * <pre>
     * ...                     ...                   ...
     * </pre>
     */
    emHDAudOutDHDMI2(5, 5),
    /**
     * <code>emHDAudOutHDMI = 6;</code>
     *
     * <pre>
     * HDMI_3                  HDMI_4                HDMI_2                HDMI_2
     * </pre>
     */
    emHDAudOutHDMI(6, 6),
    /**
     * <code>emHDAudOutSDI = 7;</code>
     *
     * <pre>
     * SDI                     SDI 5                 SDI_1|...
     * </pre>
     */
    emHDAudOutSDI(7, 7),
    /**
     * <code>emHDAudOutHDMI1 = 8;</code>
     *
     * <pre>
     * ...                     HDMI_1|...            HDMI_1_1|...          HDMI_3
     * </pre>
     */
    emHDAudOutHDMI1(8, 8),
    /**
     * <code>emHDAudOutHDMI2 = 9;</code>
     *
     * <pre>
     * ...                     HDMI_2|...            HDMI_1_2|HDMI_1
     * </pre>
     */
    emHDAudOutHDMI2(9, 9),
    ;

    /**
     * <code>emHDAudOutBegin = 0;</code>
     *
     * <pre>
     * X500                    X700-4K|X500-4K       X500-1080P|X300       SKY300
     * </pre>
     */
    public static final int emHDAudOutBegin_VALUE = 0;
    /**
     * <code>emHDAudOutRCA = 1;</code>
     *
     * <pre>
     * LINE 3                  LINE 3                LINE_2
     * </pre>
     */
    public static final int emHDAudOutRCA_VALUE = 1;
    /**
     * <code>emHDAudOutTRS6_5 = 2;</code>
     *
     * <pre>
     * TRS 1                   TRS 1                 TRS_3
     * </pre>
     */
    public static final int emHDAudOutTRS6_5_VALUE = 2;
    /**
     * <code>emHDAudOutTRS3_5 = 3;</code>
     *
     * <pre>
     * AUX 2                   AUX 2                 AUX_1                 AUX_1
     * </pre>
     */
    public static final int emHDAudOutTRS3_5_VALUE = 3;
    /**
     * <code>emHDAudOutDHDMI1 = 4;</code>
     *
     * <pre>
     * DVI/YPbPr/VGA/HDMI1_1   DVI/HDMI/VGA/YPbPr_3  DVI/HDMI/VGA/YPbPr_1
     * </pre>
     */
    public static final int emHDAudOutDHDMI1_VALUE = 4;
    /**
     * <code>emHDAudOutDHDMI2 = 5;</code>
     *
     * <pre>
     * ...                     ...                   ...
     * </pre>
     */
    public static final int emHDAudOutDHDMI2_VALUE = 5;
    /**
     * <code>emHDAudOutHDMI = 6;</code>
     *
     * <pre>
     * HDMI_3                  HDMI_4                HDMI_2                HDMI_2
     * </pre>
     */
    public static final int emHDAudOutHDMI_VALUE = 6;
    /**
     * <code>emHDAudOutSDI = 7;</code>
     *
     * <pre>
     * SDI                     SDI 5                 SDI_1|...
     * </pre>
     */
    public static final int emHDAudOutSDI_VALUE = 7;
    /**
     * <code>emHDAudOutHDMI1 = 8;</code>
     *
     * <pre>
     * ...                     HDMI_1|...            HDMI_1_1|...          HDMI_3
     * </pre>
     */
    public static final int emHDAudOutHDMI1_VALUE = 8;
    /**
     * <code>emHDAudOutHDMI2 = 9;</code>
     *
     * <pre>
     * ...                     HDMI_2|...            HDMI_1_2|HDMI_1
     * </pre>
     */
    public static final int emHDAudOutHDMI2_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmHDAudPortOut valueOf(int value) {
      switch (value) {
        case 0: return emHDAudOutBegin;
        case 1: return emHDAudOutRCA;
        case 2: return emHDAudOutTRS6_5;
        case 3: return emHDAudOutTRS3_5;
        case 4: return emHDAudOutDHDMI1;
        case 5: return emHDAudOutDHDMI2;
        case 6: return emHDAudOutHDMI;
        case 7: return emHDAudOutSDI;
        case 8: return emHDAudOutHDMI1;
        case 9: return emHDAudOutHDMI2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDAudPortOut>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDAudPortOut>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDAudPortOut>() {
            public EmHDAudPortOut findValueByNumber(int number) {
              return EmHDAudPortOut.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(143);
    }

    private static final EmHDAudPortOut[] VALUES = values();

    public static EmHDAudPortOut valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDAudPortOut(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDAudPortOut)
  }

  /**
   * Protobuf enum {@code mt.EmHDMultiVideoSwitch}
   *
   * <pre>
   *多流多视开关
   * </pre>
   */
  public enum EmHDMultiVideoSwitch
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emHDMultiVideoStop = 0;</code>
     *
     * <pre>
     *关闭多流或者多视
     * </pre>
     */
    emHDMultiVideoStop(0, 0),
    /**
     * <code>emHDMultiView = 1;</code>
     *
     * <pre>
     *多视
     * </pre>
     */
    emHDMultiView(1, 1),
    /**
     * <code>emHDMultiStream = 2;</code>
     *
     * <pre>
     *多流
     * </pre>
     */
    emHDMultiStream(2, 2),
    ;

    /**
     * <code>emHDMultiVideoStop = 0;</code>
     *
     * <pre>
     *关闭多流或者多视
     * </pre>
     */
    public static final int emHDMultiVideoStop_VALUE = 0;
    /**
     * <code>emHDMultiView = 1;</code>
     *
     * <pre>
     *多视
     * </pre>
     */
    public static final int emHDMultiView_VALUE = 1;
    /**
     * <code>emHDMultiStream = 2;</code>
     *
     * <pre>
     *多流
     * </pre>
     */
    public static final int emHDMultiStream_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmHDMultiVideoSwitch valueOf(int value) {
      switch (value) {
        case 0: return emHDMultiVideoStop;
        case 1: return emHDMultiView;
        case 2: return emHDMultiStream;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDMultiVideoSwitch>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDMultiVideoSwitch>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDMultiVideoSwitch>() {
            public EmHDMultiVideoSwitch findValueByNumber(int number) {
              return EmHDMultiVideoSwitch.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(144);
    }

    private static final EmHDMultiVideoSwitch[] VALUES = values();

    public static EmHDMultiVideoSwitch valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDMultiVideoSwitch(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDMultiVideoSwitch)
  }

  /**
   * Protobuf enum {@code mt.EmHDMultiViewMP}
   *
   * <pre>
   *多视画面风格
   * </pre>
   */
  public enum EmHDMultiViewMP
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMVMP_LeftRight_One = 0;</code>
     *
     * <pre>
     *两画面,左右对等
     * </pre>
     */
    emMVMP_LeftRight_One(0, 0),
    /**
     * <code>emMVMP_BigSmall_RightDown = 1;</code>
     *
     * <pre>
     *一大一小，小画面右下
     * </pre>
     */
    emMVMP_BigSmall_RightDown(1, 1),
    /**
     * <code>emMVMP_BigSmall_LeftDown = 2;</code>
     *
     * <pre>
     *一大一小，小画面左下
     * </pre>
     */
    emMVMP_BigSmall_LeftDown(2, 2),
    /**
     * <code>emMVMP_BigSmall_LeftUp = 3;</code>
     *
     * <pre>
     *一大一小，小画面左上
     * </pre>
     */
    emMVMP_BigSmall_LeftUp(3, 3),
    /**
     * <code>emMVMP_BigSmall_RightUp = 4;</code>
     *
     * <pre>
     *一大一小，小画面右上	
     * </pre>
     */
    emMVMP_BigSmall_RightUp(4, 4),
    /**
     * <code>emMVMP_3View_1Big2Small = 5;</code>
     *
     * <pre>
     *三视，1大2小，1左，2右(2行1列)
     * </pre>
     */
    emMVMP_3View_1Big2Small(5, 5),
    /**
     * <code>emMVMP_3View_1Top2Bottom = 6;</code>
     *
     * <pre>
     *三视，品字形，1上，2下(1行2列)
     * </pre>
     */
    emMVMP_3View_1Top2Bottom(6, 6),
    /**
     * <code>emMVMP_SingleView_Close = 7;</code>
     *
     * <pre>
     *单画面，即关闭多视
     * </pre>
     */
    emMVMP_SingleView_Close(7, 7),
    ;

    /**
     * <code>emMVMP_LeftRight_One = 0;</code>
     *
     * <pre>
     *两画面,左右对等
     * </pre>
     */
    public static final int emMVMP_LeftRight_One_VALUE = 0;
    /**
     * <code>emMVMP_BigSmall_RightDown = 1;</code>
     *
     * <pre>
     *一大一小，小画面右下
     * </pre>
     */
    public static final int emMVMP_BigSmall_RightDown_VALUE = 1;
    /**
     * <code>emMVMP_BigSmall_LeftDown = 2;</code>
     *
     * <pre>
     *一大一小，小画面左下
     * </pre>
     */
    public static final int emMVMP_BigSmall_LeftDown_VALUE = 2;
    /**
     * <code>emMVMP_BigSmall_LeftUp = 3;</code>
     *
     * <pre>
     *一大一小，小画面左上
     * </pre>
     */
    public static final int emMVMP_BigSmall_LeftUp_VALUE = 3;
    /**
     * <code>emMVMP_BigSmall_RightUp = 4;</code>
     *
     * <pre>
     *一大一小，小画面右上	
     * </pre>
     */
    public static final int emMVMP_BigSmall_RightUp_VALUE = 4;
    /**
     * <code>emMVMP_3View_1Big2Small = 5;</code>
     *
     * <pre>
     *三视，1大2小，1左，2右(2行1列)
     * </pre>
     */
    public static final int emMVMP_3View_1Big2Small_VALUE = 5;
    /**
     * <code>emMVMP_3View_1Top2Bottom = 6;</code>
     *
     * <pre>
     *三视，品字形，1上，2下(1行2列)
     * </pre>
     */
    public static final int emMVMP_3View_1Top2Bottom_VALUE = 6;
    /**
     * <code>emMVMP_SingleView_Close = 7;</code>
     *
     * <pre>
     *单画面，即关闭多视
     * </pre>
     */
    public static final int emMVMP_SingleView_Close_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmHDMultiViewMP valueOf(int value) {
      switch (value) {
        case 0: return emMVMP_LeftRight_One;
        case 1: return emMVMP_BigSmall_RightDown;
        case 2: return emMVMP_BigSmall_LeftDown;
        case 3: return emMVMP_BigSmall_LeftUp;
        case 4: return emMVMP_BigSmall_RightUp;
        case 5: return emMVMP_3View_1Big2Small;
        case 6: return emMVMP_3View_1Top2Bottom;
        case 7: return emMVMP_SingleView_Close;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDMultiViewMP>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDMultiViewMP>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDMultiViewMP>() {
            public EmHDMultiViewMP findValueByNumber(int number) {
              return EmHDMultiViewMP.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(145);
    }

    private static final EmHDMultiViewMP[] VALUES = values();

    public static EmHDMultiViewMP valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDMultiViewMP(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDMultiViewMP)
  }

  /**
   * Protobuf enum {@code mt.EmHDVideoPortMode}
   *
   * <pre>
   *视频接口模式
   * </pre>
   */
  public enum EmHDVideoPortMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVPM_Invalid = 0;</code>
     *
     * <pre>
     *用于表示无效视频模式
     * </pre>
     */
    emVPM_Invalid(0, 0),
    /**
     * <code>emVPM_Auto = 1;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    emVPM_Auto(1, 1),
    /**
     * <code>emVPM_HDMI = 2;</code>
     */
    emVPM_HDMI(2, 2),
    /**
     * <code>emVPM_DVI = 3;</code>
     */
    emVPM_DVI(3, 3),
    /**
     * <code>emVPM_YPBPR = 4;</code>
     */
    emVPM_YPBPR(4, 4),
    /**
     * <code>emVPM_VGA = 5;</code>
     */
    emVPM_VGA(5, 5),
    ;

    /**
     * <code>emVPM_Invalid = 0;</code>
     *
     * <pre>
     *用于表示无效视频模式
     * </pre>
     */
    public static final int emVPM_Invalid_VALUE = 0;
    /**
     * <code>emVPM_Auto = 1;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    public static final int emVPM_Auto_VALUE = 1;
    /**
     * <code>emVPM_HDMI = 2;</code>
     */
    public static final int emVPM_HDMI_VALUE = 2;
    /**
     * <code>emVPM_DVI = 3;</code>
     */
    public static final int emVPM_DVI_VALUE = 3;
    /**
     * <code>emVPM_YPBPR = 4;</code>
     */
    public static final int emVPM_YPBPR_VALUE = 4;
    /**
     * <code>emVPM_VGA = 5;</code>
     */
    public static final int emVPM_VGA_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmHDVideoPortMode valueOf(int value) {
      switch (value) {
        case 0: return emVPM_Invalid;
        case 1: return emVPM_Auto;
        case 2: return emVPM_HDMI;
        case 3: return emVPM_DVI;
        case 4: return emVPM_YPBPR;
        case 5: return emVPM_VGA;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDVideoPortMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDVideoPortMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDVideoPortMode>() {
            public EmHDVideoPortMode findValueByNumber(int number) {
              return EmHDVideoPortMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(146);
    }

    private static final EmHDVideoPortMode[] VALUES = values();

    public static EmHDVideoPortMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDVideoPortMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDVideoPortMode)
  }

  /**
   * Protobuf enum {@code mt.EmHDVideoOutPortType}
   *
   * <pre>
   *视频输出接口定义
   * </pre>
   */
  public enum EmHDVideoOutPortType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVOT_Invalid = 0;</code>
     *
     * <pre>
     *无效    X500                   X700-4K|X500-4K        X500-1080P|X300       SKY300
     * </pre>
     */
    emVOT_Invalid(0, 0),
    /**
     * <code>emVOT_DVI1 = 1;</code>
     *
     * <pre>
     *dvi1    DVI/YPbPr/VGA/HDMI_1   DVI/HDMI/VGA/YPbPr_3   DVI/HDMI/VGA/YPbPr_1
     * </pre>
     */
    emVOT_DVI1(1, 1),
    /**
     * <code>emVOT_DVI2 = 2;</code>
     *
     * <pre>
     *dvi2
     * </pre>
     */
    emVOT_DVI2(2, 2),
    /**
     * <code>emVOT_DVI3 = 3;</code>
     *
     * <pre>
     *dvi3
     * </pre>
     */
    emVOT_DVI3(3, 3),
    /**
     * <code>emVOT_DVI4 = 4;</code>
     *
     * <pre>
     *dvi4
     * </pre>
     */
    emVOT_DVI4(4, 4),
    /**
     * <code>emVOT_HDMI1 = 5;</code>
     *
     * <pre>
     *hdmi1   HDMI_3                 HDMI_4                 HDMI_2                HDMI_2
     * </pre>
     */
    emVOT_HDMI1(5, 5),
    /**
     * <code>emVOT_HDMI2 = 6;</code>
     *
     * <pre>
     *hdmi2                          HDMI_1|...             HDMI_1_1|...          HDMI_3
     * </pre>
     */
    emVOT_HDMI2(6, 6),
    /**
     * <code>emVOT_HDMI3 = 7;</code>
     *
     * <pre>
     *hdmi3                          HDMI_2|...             HDMI_1_2|HDMI_1
     * </pre>
     */
    emVOT_HDMI3(7, 7),
    /**
     * <code>emVOT_HDMI4 = 8;</code>
     *
     * <pre>
     *hdmi4
     * </pre>
     */
    emVOT_HDMI4(8, 8),
    /**
     * <code>emVOT_YPbPr1 = 9;</code>
     *
     * <pre>
     *YPbPr1
     * </pre>
     */
    emVOT_YPbPr1(9, 9),
    /**
     * <code>emVOT_YPbPr2 = 10;</code>
     *
     * <pre>
     *YPbPr2
     * </pre>
     */
    emVOT_YPbPr2(10, 10),
    /**
     * <code>emVOT_YPbPr3 = 11;</code>
     *
     * <pre>
     *YPbPr3
     * </pre>
     */
    emVOT_YPbPr3(11, 11),
    /**
     * <code>emVOT_YPbPr4 = 12;</code>
     *
     * <pre>
     *YPbPr4
     * </pre>
     */
    emVOT_YPbPr4(12, 12),
    /**
     * <code>emVOT_VGA1 = 13;</code>
     *
     * <pre>
     *vga1   VGA/YPbPr_2            VGA/YPbPr_4            VGA/YPbPr_2          VGA/YPbPr_1
     * </pre>
     */
    emVOT_VGA1(13, 13),
    /**
     * <code>emVOT_VGA2 = 14;</code>
     *
     * <pre>
     *vga2   VGA/YPbPr_3
     * </pre>
     */
    emVOT_VGA2(14, 14),
    /**
     * <code>emVOT_VGA3 = 15;</code>
     *
     * <pre>
     *vga3
     * </pre>
     */
    emVOT_VGA3(15, 15),
    /**
     * <code>emVOT_VGA4 = 16;</code>
     *
     * <pre>
     *vga4
     * </pre>
     */
    emVOT_VGA4(16, 16),
    /**
     * <code>emVOT_SDI1 = 17;</code>
     *
     * <pre>
     *sdi1   SDI_2                  SDI_5                  SDI_1|...
     * </pre>
     */
    emVOT_SDI1(17, 17),
    /**
     * <code>emVOT_SDI2 = 18;</code>
     *
     * <pre>
     *sdi2
     * </pre>
     */
    emVOT_SDI2(18, 18),
    /**
     * <code>emVOT_SDI3 = 19;</code>
     *
     * <pre>
     *sdi3
     * </pre>
     */
    emVOT_SDI3(19, 19),
    /**
     * <code>emVOT_SDI4 = 20;</code>
     *
     * <pre>
     *sdi4
     * </pre>
     */
    emVOT_SDI4(20, 20),
    /**
     * <code>emVOT_C1 = 21;</code>
     *
     * <pre>
     *cvbs1  CVBS_4
     * </pre>
     */
    emVOT_C1(21, 21),
    /**
     * <code>emVOT_C2 = 22;</code>
     *
     * <pre>
     *cvbs2
     * </pre>
     */
    emVOT_C2(22, 22),
    /**
     * <code>emVOT_C3 = 23;</code>
     *
     * <pre>
     *cvbs3
     * </pre>
     */
    emVOT_C3(23, 23),
    ;

    /**
     * <code>emVOT_Invalid = 0;</code>
     *
     * <pre>
     *无效    X500                   X700-4K|X500-4K        X500-1080P|X300       SKY300
     * </pre>
     */
    public static final int emVOT_Invalid_VALUE = 0;
    /**
     * <code>emVOT_DVI1 = 1;</code>
     *
     * <pre>
     *dvi1    DVI/YPbPr/VGA/HDMI_1   DVI/HDMI/VGA/YPbPr_3   DVI/HDMI/VGA/YPbPr_1
     * </pre>
     */
    public static final int emVOT_DVI1_VALUE = 1;
    /**
     * <code>emVOT_DVI2 = 2;</code>
     *
     * <pre>
     *dvi2
     * </pre>
     */
    public static final int emVOT_DVI2_VALUE = 2;
    /**
     * <code>emVOT_DVI3 = 3;</code>
     *
     * <pre>
     *dvi3
     * </pre>
     */
    public static final int emVOT_DVI3_VALUE = 3;
    /**
     * <code>emVOT_DVI4 = 4;</code>
     *
     * <pre>
     *dvi4
     * </pre>
     */
    public static final int emVOT_DVI4_VALUE = 4;
    /**
     * <code>emVOT_HDMI1 = 5;</code>
     *
     * <pre>
     *hdmi1   HDMI_3                 HDMI_4                 HDMI_2                HDMI_2
     * </pre>
     */
    public static final int emVOT_HDMI1_VALUE = 5;
    /**
     * <code>emVOT_HDMI2 = 6;</code>
     *
     * <pre>
     *hdmi2                          HDMI_1|...             HDMI_1_1|...          HDMI_3
     * </pre>
     */
    public static final int emVOT_HDMI2_VALUE = 6;
    /**
     * <code>emVOT_HDMI3 = 7;</code>
     *
     * <pre>
     *hdmi3                          HDMI_2|...             HDMI_1_2|HDMI_1
     * </pre>
     */
    public static final int emVOT_HDMI3_VALUE = 7;
    /**
     * <code>emVOT_HDMI4 = 8;</code>
     *
     * <pre>
     *hdmi4
     * </pre>
     */
    public static final int emVOT_HDMI4_VALUE = 8;
    /**
     * <code>emVOT_YPbPr1 = 9;</code>
     *
     * <pre>
     *YPbPr1
     * </pre>
     */
    public static final int emVOT_YPbPr1_VALUE = 9;
    /**
     * <code>emVOT_YPbPr2 = 10;</code>
     *
     * <pre>
     *YPbPr2
     * </pre>
     */
    public static final int emVOT_YPbPr2_VALUE = 10;
    /**
     * <code>emVOT_YPbPr3 = 11;</code>
     *
     * <pre>
     *YPbPr3
     * </pre>
     */
    public static final int emVOT_YPbPr3_VALUE = 11;
    /**
     * <code>emVOT_YPbPr4 = 12;</code>
     *
     * <pre>
     *YPbPr4
     * </pre>
     */
    public static final int emVOT_YPbPr4_VALUE = 12;
    /**
     * <code>emVOT_VGA1 = 13;</code>
     *
     * <pre>
     *vga1   VGA/YPbPr_2            VGA/YPbPr_4            VGA/YPbPr_2          VGA/YPbPr_1
     * </pre>
     */
    public static final int emVOT_VGA1_VALUE = 13;
    /**
     * <code>emVOT_VGA2 = 14;</code>
     *
     * <pre>
     *vga2   VGA/YPbPr_3
     * </pre>
     */
    public static final int emVOT_VGA2_VALUE = 14;
    /**
     * <code>emVOT_VGA3 = 15;</code>
     *
     * <pre>
     *vga3
     * </pre>
     */
    public static final int emVOT_VGA3_VALUE = 15;
    /**
     * <code>emVOT_VGA4 = 16;</code>
     *
     * <pre>
     *vga4
     * </pre>
     */
    public static final int emVOT_VGA4_VALUE = 16;
    /**
     * <code>emVOT_SDI1 = 17;</code>
     *
     * <pre>
     *sdi1   SDI_2                  SDI_5                  SDI_1|...
     * </pre>
     */
    public static final int emVOT_SDI1_VALUE = 17;
    /**
     * <code>emVOT_SDI2 = 18;</code>
     *
     * <pre>
     *sdi2
     * </pre>
     */
    public static final int emVOT_SDI2_VALUE = 18;
    /**
     * <code>emVOT_SDI3 = 19;</code>
     *
     * <pre>
     *sdi3
     * </pre>
     */
    public static final int emVOT_SDI3_VALUE = 19;
    /**
     * <code>emVOT_SDI4 = 20;</code>
     *
     * <pre>
     *sdi4
     * </pre>
     */
    public static final int emVOT_SDI4_VALUE = 20;
    /**
     * <code>emVOT_C1 = 21;</code>
     *
     * <pre>
     *cvbs1  CVBS_4
     * </pre>
     */
    public static final int emVOT_C1_VALUE = 21;
    /**
     * <code>emVOT_C2 = 22;</code>
     *
     * <pre>
     *cvbs2
     * </pre>
     */
    public static final int emVOT_C2_VALUE = 22;
    /**
     * <code>emVOT_C3 = 23;</code>
     *
     * <pre>
     *cvbs3
     * </pre>
     */
    public static final int emVOT_C3_VALUE = 23;


    public final int getNumber() { return value; }

    public static EmHDVideoOutPortType valueOf(int value) {
      switch (value) {
        case 0: return emVOT_Invalid;
        case 1: return emVOT_DVI1;
        case 2: return emVOT_DVI2;
        case 3: return emVOT_DVI3;
        case 4: return emVOT_DVI4;
        case 5: return emVOT_HDMI1;
        case 6: return emVOT_HDMI2;
        case 7: return emVOT_HDMI3;
        case 8: return emVOT_HDMI4;
        case 9: return emVOT_YPbPr1;
        case 10: return emVOT_YPbPr2;
        case 11: return emVOT_YPbPr3;
        case 12: return emVOT_YPbPr4;
        case 13: return emVOT_VGA1;
        case 14: return emVOT_VGA2;
        case 15: return emVOT_VGA3;
        case 16: return emVOT_VGA4;
        case 17: return emVOT_SDI1;
        case 18: return emVOT_SDI2;
        case 19: return emVOT_SDI3;
        case 20: return emVOT_SDI4;
        case 21: return emVOT_C1;
        case 22: return emVOT_C2;
        case 23: return emVOT_C3;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDVideoOutPortType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDVideoOutPortType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDVideoOutPortType>() {
            public EmHDVideoOutPortType findValueByNumber(int number) {
              return EmHDVideoOutPortType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(147);
    }

    private static final EmHDVideoOutPortType[] VALUES = values();

    public static EmHDVideoOutPortType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDVideoOutPortType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDVideoOutPortType)
  }

  /**
   * Protobuf enum {@code mt.EmHDVideoSourceType}
   *
   * <pre>
   *视频输出口的输入源定义
   * </pre>
   */
  public enum EmHDVideoSourceType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVS_Invalid = 0;</code>
     *
     * <pre>
     *无效视频源
     * </pre>
     */
    emVS_Invalid(0, 0),
    /**
     * <code>emVS_1stDec = 1;</code>
     *
     * <pre>
     *第1路解码
     * </pre>
     */
    emVS_1stDec(1, 1),
    /**
     * <code>emVS_2ndDec = 2;</code>
     *
     * <pre>
     *第2路解码
     * </pre>
     */
    emVS_2ndDec(2, 2),
    /**
     * <code>emVS_3rdDec = 3;</code>
     *
     * <pre>
     *第3路解码
     * </pre>
     */
    emVS_3rdDec(3, 3),
    /**
     * <code>emVS_4thDec = 4;</code>
     *
     * <pre>
     *第4路解码
     * </pre>
     */
    emVS_4thDec(4, 4),
    /**
     * <code>emVS_5thDec = 5;</code>
     *
     * <pre>
     *第5路解码
     * </pre>
     */
    emVS_5thDec(5, 5),
    /**
     * <code>emVS_6thDec = 6;</code>
     *
     * <pre>
     *第6路解码
     * </pre>
     */
    emVS_6thDec(6, 6),
    /**
     * <code>emVS_7thDec = 7;</code>
     *
     * <pre>
     *第7路解码
     * </pre>
     */
    emVS_7thDec(7, 7),
    /**
     * <code>emVS_8thDec = 8;</code>
     *
     * <pre>
     *第8路解码
     * </pre>
     */
    emVS_8thDec(8, 8),
    /**
     * <code>emVS_9thDec = 9;</code>
     *
     * <pre>
     *第9路解码
     * </pre>
     */
    emVS_9thDec(9, 9),
    /**
     * <code>emVS_10thDec = 10;</code>
     *
     * <pre>
     *第10路解码
     * </pre>
     */
    emVS_10thDec(10, 10),
    /**
     * <code>emVS_MtVidInnerCamera = 11;</code>
     *
     * <pre>
     *内置摄像头
     * </pre>
     */
    emVS_MtVidInnerCamera(11, 11),
    /**
     * <code>emVS_MtVidDVI1 = 12;</code>
     */
    emVS_MtVidDVI1(12, 12),
    /**
     * <code>emVS_MtVidDVI2 = 13;</code>
     */
    emVS_MtVidDVI2(13, 13),
    /**
     * <code>emVS_MtVidDVI3 = 14;</code>
     */
    emVS_MtVidDVI3(14, 14),
    /**
     * <code>emVS_MtVidDVI4 = 15;</code>
     */
    emVS_MtVidDVI4(15, 15),
    /**
     * <code>emVS_MtVidHDMI1 = 16;</code>
     */
    emVS_MtVidHDMI1(16, 16),
    /**
     * <code>emVS_MtVidHDMI2 = 17;</code>
     */
    emVS_MtVidHDMI2(17, 17),
    /**
     * <code>emVS_MtVidHDMI3 = 18;</code>
     */
    emVS_MtVidHDMI3(18, 18),
    /**
     * <code>emVS_MtVidHDMI4 = 19;</code>
     */
    emVS_MtVidHDMI4(19, 19),
    /**
     * <code>emVS_MtVidYPbPr1 = 20;</code>
     */
    emVS_MtVidYPbPr1(20, 20),
    /**
     * <code>emVS_MtVidYPbPr2 = 21;</code>
     */
    emVS_MtVidYPbPr2(21, 21),
    /**
     * <code>emVS_MtVidYPbPr3 = 22;</code>
     */
    emVS_MtVidYPbPr3(22, 22),
    /**
     * <code>emVS_MtVidYPbPr4 = 23;</code>
     */
    emVS_MtVidYPbPr4(23, 23),
    /**
     * <code>emVS_MtVidVGA1 = 24;</code>
     */
    emVS_MtVidVGA1(24, 24),
    /**
     * <code>emVS_MtVidVGA2 = 25;</code>
     */
    emVS_MtVidVGA2(25, 25),
    /**
     * <code>emVS_MtVidVGA3 = 26;</code>
     */
    emVS_MtVidVGA3(26, 26),
    /**
     * <code>emVS_MtVidVGA4 = 27;</code>
     */
    emVS_MtVidVGA4(27, 27),
    /**
     * <code>emVS_MtVidC1 = 28;</code>
     */
    emVS_MtVidC1(28, 28),
    /**
     * <code>emVS_MtVidC2 = 29;</code>
     */
    emVS_MtVidC2(29, 29),
    /**
     * <code>emVS_MtVidC3 = 30;</code>
     */
    emVS_MtVidC3(30, 30),
    /**
     * <code>emVS_MtVidS1 = 31;</code>
     */
    emVS_MtVidS1(31, 31),
    /**
     * <code>emVS_MtVidS2 = 32;</code>
     */
    emVS_MtVidS2(32, 32),
    /**
     * <code>emVS_MtVidS3 = 33;</code>
     */
    emVS_MtVidS3(33, 33),
    /**
     * <code>emVS_MtVidHDBaseT1 = 34;</code>
     */
    emVS_MtVidHDBaseT1(34, 34),
    /**
     * <code>emVS_MtVidHDBaseT2 = 35;</code>
     */
    emVS_MtVidHDBaseT2(35, 35),
    /**
     * <code>emVS_MtVidHDBaseT3 = 36;</code>
     */
    emVS_MtVidHDBaseT3(36, 36),
    /**
     * <code>emVS_MtVidHDBaseT4 = 37;</code>
     */
    emVS_MtVidHDBaseT4(37, 37),
    /**
     * <code>emVS_MtVidSDI1 = 38;</code>
     */
    emVS_MtVidSDI1(38, 38),
    /**
     * <code>emVS_MtVidSDI2 = 39;</code>
     */
    emVS_MtVidSDI2(39, 39),
    /**
     * <code>emVS_MtVidSDI3 = 40;</code>
     */
    emVS_MtVidSDI3(40, 40),
    /**
     * <code>emVS_MtVidSDI4 = 41;</code>
     */
    emVS_MtVidSDI4(41, 41),
    ;

    /**
     * <code>emVS_Invalid = 0;</code>
     *
     * <pre>
     *无效视频源
     * </pre>
     */
    public static final int emVS_Invalid_VALUE = 0;
    /**
     * <code>emVS_1stDec = 1;</code>
     *
     * <pre>
     *第1路解码
     * </pre>
     */
    public static final int emVS_1stDec_VALUE = 1;
    /**
     * <code>emVS_2ndDec = 2;</code>
     *
     * <pre>
     *第2路解码
     * </pre>
     */
    public static final int emVS_2ndDec_VALUE = 2;
    /**
     * <code>emVS_3rdDec = 3;</code>
     *
     * <pre>
     *第3路解码
     * </pre>
     */
    public static final int emVS_3rdDec_VALUE = 3;
    /**
     * <code>emVS_4thDec = 4;</code>
     *
     * <pre>
     *第4路解码
     * </pre>
     */
    public static final int emVS_4thDec_VALUE = 4;
    /**
     * <code>emVS_5thDec = 5;</code>
     *
     * <pre>
     *第5路解码
     * </pre>
     */
    public static final int emVS_5thDec_VALUE = 5;
    /**
     * <code>emVS_6thDec = 6;</code>
     *
     * <pre>
     *第6路解码
     * </pre>
     */
    public static final int emVS_6thDec_VALUE = 6;
    /**
     * <code>emVS_7thDec = 7;</code>
     *
     * <pre>
     *第7路解码
     * </pre>
     */
    public static final int emVS_7thDec_VALUE = 7;
    /**
     * <code>emVS_8thDec = 8;</code>
     *
     * <pre>
     *第8路解码
     * </pre>
     */
    public static final int emVS_8thDec_VALUE = 8;
    /**
     * <code>emVS_9thDec = 9;</code>
     *
     * <pre>
     *第9路解码
     * </pre>
     */
    public static final int emVS_9thDec_VALUE = 9;
    /**
     * <code>emVS_10thDec = 10;</code>
     *
     * <pre>
     *第10路解码
     * </pre>
     */
    public static final int emVS_10thDec_VALUE = 10;
    /**
     * <code>emVS_MtVidInnerCamera = 11;</code>
     *
     * <pre>
     *内置摄像头
     * </pre>
     */
    public static final int emVS_MtVidInnerCamera_VALUE = 11;
    /**
     * <code>emVS_MtVidDVI1 = 12;</code>
     */
    public static final int emVS_MtVidDVI1_VALUE = 12;
    /**
     * <code>emVS_MtVidDVI2 = 13;</code>
     */
    public static final int emVS_MtVidDVI2_VALUE = 13;
    /**
     * <code>emVS_MtVidDVI3 = 14;</code>
     */
    public static final int emVS_MtVidDVI3_VALUE = 14;
    /**
     * <code>emVS_MtVidDVI4 = 15;</code>
     */
    public static final int emVS_MtVidDVI4_VALUE = 15;
    /**
     * <code>emVS_MtVidHDMI1 = 16;</code>
     */
    public static final int emVS_MtVidHDMI1_VALUE = 16;
    /**
     * <code>emVS_MtVidHDMI2 = 17;</code>
     */
    public static final int emVS_MtVidHDMI2_VALUE = 17;
    /**
     * <code>emVS_MtVidHDMI3 = 18;</code>
     */
    public static final int emVS_MtVidHDMI3_VALUE = 18;
    /**
     * <code>emVS_MtVidHDMI4 = 19;</code>
     */
    public static final int emVS_MtVidHDMI4_VALUE = 19;
    /**
     * <code>emVS_MtVidYPbPr1 = 20;</code>
     */
    public static final int emVS_MtVidYPbPr1_VALUE = 20;
    /**
     * <code>emVS_MtVidYPbPr2 = 21;</code>
     */
    public static final int emVS_MtVidYPbPr2_VALUE = 21;
    /**
     * <code>emVS_MtVidYPbPr3 = 22;</code>
     */
    public static final int emVS_MtVidYPbPr3_VALUE = 22;
    /**
     * <code>emVS_MtVidYPbPr4 = 23;</code>
     */
    public static final int emVS_MtVidYPbPr4_VALUE = 23;
    /**
     * <code>emVS_MtVidVGA1 = 24;</code>
     */
    public static final int emVS_MtVidVGA1_VALUE = 24;
    /**
     * <code>emVS_MtVidVGA2 = 25;</code>
     */
    public static final int emVS_MtVidVGA2_VALUE = 25;
    /**
     * <code>emVS_MtVidVGA3 = 26;</code>
     */
    public static final int emVS_MtVidVGA3_VALUE = 26;
    /**
     * <code>emVS_MtVidVGA4 = 27;</code>
     */
    public static final int emVS_MtVidVGA4_VALUE = 27;
    /**
     * <code>emVS_MtVidC1 = 28;</code>
     */
    public static final int emVS_MtVidC1_VALUE = 28;
    /**
     * <code>emVS_MtVidC2 = 29;</code>
     */
    public static final int emVS_MtVidC2_VALUE = 29;
    /**
     * <code>emVS_MtVidC3 = 30;</code>
     */
    public static final int emVS_MtVidC3_VALUE = 30;
    /**
     * <code>emVS_MtVidS1 = 31;</code>
     */
    public static final int emVS_MtVidS1_VALUE = 31;
    /**
     * <code>emVS_MtVidS2 = 32;</code>
     */
    public static final int emVS_MtVidS2_VALUE = 32;
    /**
     * <code>emVS_MtVidS3 = 33;</code>
     */
    public static final int emVS_MtVidS3_VALUE = 33;
    /**
     * <code>emVS_MtVidHDBaseT1 = 34;</code>
     */
    public static final int emVS_MtVidHDBaseT1_VALUE = 34;
    /**
     * <code>emVS_MtVidHDBaseT2 = 35;</code>
     */
    public static final int emVS_MtVidHDBaseT2_VALUE = 35;
    /**
     * <code>emVS_MtVidHDBaseT3 = 36;</code>
     */
    public static final int emVS_MtVidHDBaseT3_VALUE = 36;
    /**
     * <code>emVS_MtVidHDBaseT4 = 37;</code>
     */
    public static final int emVS_MtVidHDBaseT4_VALUE = 37;
    /**
     * <code>emVS_MtVidSDI1 = 38;</code>
     */
    public static final int emVS_MtVidSDI1_VALUE = 38;
    /**
     * <code>emVS_MtVidSDI2 = 39;</code>
     */
    public static final int emVS_MtVidSDI2_VALUE = 39;
    /**
     * <code>emVS_MtVidSDI3 = 40;</code>
     */
    public static final int emVS_MtVidSDI3_VALUE = 40;
    /**
     * <code>emVS_MtVidSDI4 = 41;</code>
     */
    public static final int emVS_MtVidSDI4_VALUE = 41;


    public final int getNumber() { return value; }

    public static EmHDVideoSourceType valueOf(int value) {
      switch (value) {
        case 0: return emVS_Invalid;
        case 1: return emVS_1stDec;
        case 2: return emVS_2ndDec;
        case 3: return emVS_3rdDec;
        case 4: return emVS_4thDec;
        case 5: return emVS_5thDec;
        case 6: return emVS_6thDec;
        case 7: return emVS_7thDec;
        case 8: return emVS_8thDec;
        case 9: return emVS_9thDec;
        case 10: return emVS_10thDec;
        case 11: return emVS_MtVidInnerCamera;
        case 12: return emVS_MtVidDVI1;
        case 13: return emVS_MtVidDVI2;
        case 14: return emVS_MtVidDVI3;
        case 15: return emVS_MtVidDVI4;
        case 16: return emVS_MtVidHDMI1;
        case 17: return emVS_MtVidHDMI2;
        case 18: return emVS_MtVidHDMI3;
        case 19: return emVS_MtVidHDMI4;
        case 20: return emVS_MtVidYPbPr1;
        case 21: return emVS_MtVidYPbPr2;
        case 22: return emVS_MtVidYPbPr3;
        case 23: return emVS_MtVidYPbPr4;
        case 24: return emVS_MtVidVGA1;
        case 25: return emVS_MtVidVGA2;
        case 26: return emVS_MtVidVGA3;
        case 27: return emVS_MtVidVGA4;
        case 28: return emVS_MtVidC1;
        case 29: return emVS_MtVidC2;
        case 30: return emVS_MtVidC3;
        case 31: return emVS_MtVidS1;
        case 32: return emVS_MtVidS2;
        case 33: return emVS_MtVidS3;
        case 34: return emVS_MtVidHDBaseT1;
        case 35: return emVS_MtVidHDBaseT2;
        case 36: return emVS_MtVidHDBaseT3;
        case 37: return emVS_MtVidHDBaseT4;
        case 38: return emVS_MtVidSDI1;
        case 39: return emVS_MtVidSDI2;
        case 40: return emVS_MtVidSDI3;
        case 41: return emVS_MtVidSDI4;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDVideoSourceType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDVideoSourceType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDVideoSourceType>() {
            public EmHDVideoSourceType findValueByNumber(int number) {
              return EmHDVideoSourceType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(148);
    }

    private static final EmHDVideoSourceType[] VALUES = values();

    public static EmHDVideoSourceType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDVideoSourceType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDVideoSourceType)
  }

  /**
   * Protobuf enum {@code mt.EmHDLastDisplay}
   *
   * <pre>
   *无图像显示输出配置
   * </pre>
   */
  public enum EmHDLastDisplay
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emLD_LastFrame = 0;</code>
     *
     * <pre>
     *最后一帧
     * </pre>
     */
    emLD_LastFrame(0, 0),
    /**
     * <code>emLD_BlueScreen = 1;</code>
     *
     * <pre>
     *蓝屏
     * </pre>
     */
    emLD_BlueScreen(1, 1),
    /**
     * <code>emLD_StaticBMP = 2;</code>
     *
     * <pre>
     *静态图片 
     * </pre>
     */
    emLD_StaticBMP(2, 2),
    /**
     * <code>emLD_CustomBMP = 3;</code>
     *
     * <pre>
     *用户自定义图片 
     * </pre>
     */
    emLD_CustomBMP(3, 3),
    ;

    /**
     * <code>emLD_LastFrame = 0;</code>
     *
     * <pre>
     *最后一帧
     * </pre>
     */
    public static final int emLD_LastFrame_VALUE = 0;
    /**
     * <code>emLD_BlueScreen = 1;</code>
     *
     * <pre>
     *蓝屏
     * </pre>
     */
    public static final int emLD_BlueScreen_VALUE = 1;
    /**
     * <code>emLD_StaticBMP = 2;</code>
     *
     * <pre>
     *静态图片 
     * </pre>
     */
    public static final int emLD_StaticBMP_VALUE = 2;
    /**
     * <code>emLD_CustomBMP = 3;</code>
     *
     * <pre>
     *用户自定义图片 
     * </pre>
     */
    public static final int emLD_CustomBMP_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmHDLastDisplay valueOf(int value) {
      switch (value) {
        case 0: return emLD_LastFrame;
        case 1: return emLD_BlueScreen;
        case 2: return emLD_StaticBMP;
        case 3: return emLD_CustomBMP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDLastDisplay>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDLastDisplay>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDLastDisplay>() {
            public EmHDLastDisplay findValueByNumber(int number) {
              return EmHDLastDisplay.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(149);
    }

    private static final EmHDLastDisplay[] VALUES = values();

    public static EmHDLastDisplay valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDLastDisplay(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDLastDisplay)
  }

  /**
   * Protobuf enum {@code mt.EmHDImageNoise}
   *
   * <pre>
   *图像降噪
   * </pre>
   */
  public enum EmHDImageNoise
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emImageNoise_Disable = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    emImageNoise_Disable(0, 0),
    /**
     * <code>emImageNoise_Low = 1;</code>
     *
     * <pre>
     *微弱
     * </pre>
     */
    emImageNoise_Low(1, 1),
    /**
     * <code>emImageNoise_Med = 2;</code>
     *
     * <pre>
     *弱
     * </pre>
     */
    emImageNoise_Med(2, 2),
    /**
     * <code>emImageNoise_High = 3;</code>
     *
     * <pre>
     *强
     * </pre>
     */
    emImageNoise_High(3, 3),
    /**
     * <code>emImageNoise_UltraHigh = 4;</code>
     *
     * <pre>
     *超强
     * </pre>
     */
    emImageNoise_UltraHigh(4, 4),
    ;

    /**
     * <code>emImageNoise_Disable = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    public static final int emImageNoise_Disable_VALUE = 0;
    /**
     * <code>emImageNoise_Low = 1;</code>
     *
     * <pre>
     *微弱
     * </pre>
     */
    public static final int emImageNoise_Low_VALUE = 1;
    /**
     * <code>emImageNoise_Med = 2;</code>
     *
     * <pre>
     *弱
     * </pre>
     */
    public static final int emImageNoise_Med_VALUE = 2;
    /**
     * <code>emImageNoise_High = 3;</code>
     *
     * <pre>
     *强
     * </pre>
     */
    public static final int emImageNoise_High_VALUE = 3;
    /**
     * <code>emImageNoise_UltraHigh = 4;</code>
     *
     * <pre>
     *超强
     * </pre>
     */
    public static final int emImageNoise_UltraHigh_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmHDImageNoise valueOf(int value) {
      switch (value) {
        case 0: return emImageNoise_Disable;
        case 1: return emImageNoise_Low;
        case 2: return emImageNoise_Med;
        case 3: return emImageNoise_High;
        case 4: return emImageNoise_UltraHigh;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDImageNoise>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDImageNoise>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDImageNoise>() {
            public EmHDImageNoise findValueByNumber(int number) {
              return EmHDImageNoise.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(150);
    }

    private static final EmHDImageNoise[] VALUES = values();

    public static EmHDImageNoise valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDImageNoise(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDImageNoise)
  }

  /**
   * Protobuf enum {@code mt.EmHDImageDeformationTensile}
   *
   * <pre>
   *变形拉伸
   * </pre>
   */
  public enum EmHDImageDeformationTensile
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emImageDT_Transverse = 0;</code>
     *
     * <pre>
     *左右
     * </pre>
     */
    emImageDT_Transverse(0, 0),
    /**
     * <code>emImageDT_Longitudinal = 1;</code>
     *
     * <pre>
     *上下
     * </pre>
     */
    emImageDT_Longitudinal(1, 1),
    ;

    /**
     * <code>emImageDT_Transverse = 0;</code>
     *
     * <pre>
     *左右
     * </pre>
     */
    public static final int emImageDT_Transverse_VALUE = 0;
    /**
     * <code>emImageDT_Longitudinal = 1;</code>
     *
     * <pre>
     *上下
     * </pre>
     */
    public static final int emImageDT_Longitudinal_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmHDImageDeformationTensile valueOf(int value) {
      switch (value) {
        case 0: return emImageDT_Transverse;
        case 1: return emImageDT_Longitudinal;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDImageDeformationTensile>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDImageDeformationTensile>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDImageDeformationTensile>() {
            public EmHDImageDeformationTensile findValueByNumber(int number) {
              return EmHDImageDeformationTensile.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(151);
    }

    private static final EmHDImageDeformationTensile[] VALUES = values();

    public static EmHDImageDeformationTensile valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDImageDeformationTensile(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDImageDeformationTensile)
  }

  /**
   * Protobuf enum {@code mt.EmEthnetWorkMode}
   *
   * <pre>
   ** 以太网工作模式 
   * </pre>
   */
  public enum EmEthnetWorkMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEthModeAuto = 0;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    emEthModeAuto(0, 0),
    /**
     * <code>emEthMode10MFull = 1;</code>
     *
     * <pre>
     *10M全双工
     * </pre>
     */
    emEthMode10MFull(1, 1),
    /**
     * <code>emEthMode10MHalf = 2;</code>
     *
     * <pre>
     *10M半双工
     * </pre>
     */
    emEthMode10MHalf(2, 2),
    /**
     * <code>emEthMode100MFull = 3;</code>
     *
     * <pre>
     *100M全双工
     * </pre>
     */
    emEthMode100MFull(3, 3),
    /**
     * <code>emEthMode100MHalf = 4;</code>
     *
     * <pre>
     *100M半双工
     * </pre>
     */
    emEthMode100MHalf(4, 4),
    /**
     * <code>emEthMode1000MFull = 5;</code>
     *
     * <pre>
     *1000M全双工
     * </pre>
     */
    emEthMode1000MFull(5, 5),
    /**
     * <code>emEthMode1000MHalf = 6;</code>
     *
     * <pre>
     *1000M半双工	
     * </pre>
     */
    emEthMode1000MHalf(6, 6),
    ;

    /**
     * <code>emEthModeAuto = 0;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    public static final int emEthModeAuto_VALUE = 0;
    /**
     * <code>emEthMode10MFull = 1;</code>
     *
     * <pre>
     *10M全双工
     * </pre>
     */
    public static final int emEthMode10MFull_VALUE = 1;
    /**
     * <code>emEthMode10MHalf = 2;</code>
     *
     * <pre>
     *10M半双工
     * </pre>
     */
    public static final int emEthMode10MHalf_VALUE = 2;
    /**
     * <code>emEthMode100MFull = 3;</code>
     *
     * <pre>
     *100M全双工
     * </pre>
     */
    public static final int emEthMode100MFull_VALUE = 3;
    /**
     * <code>emEthMode100MHalf = 4;</code>
     *
     * <pre>
     *100M半双工
     * </pre>
     */
    public static final int emEthMode100MHalf_VALUE = 4;
    /**
     * <code>emEthMode1000MFull = 5;</code>
     *
     * <pre>
     *1000M全双工
     * </pre>
     */
    public static final int emEthMode1000MFull_VALUE = 5;
    /**
     * <code>emEthMode1000MHalf = 6;</code>
     *
     * <pre>
     *1000M半双工	
     * </pre>
     */
    public static final int emEthMode1000MHalf_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmEthnetWorkMode valueOf(int value) {
      switch (value) {
        case 0: return emEthModeAuto;
        case 1: return emEthMode10MFull;
        case 2: return emEthMode10MHalf;
        case 3: return emEthMode100MFull;
        case 4: return emEthMode100MHalf;
        case 5: return emEthMode1000MFull;
        case 6: return emEthMode1000MHalf;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEthnetWorkMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEthnetWorkMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEthnetWorkMode>() {
            public EmEthnetWorkMode findValueByNumber(int number) {
              return EmEthnetWorkMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(152);
    }

    private static final EmEthnetWorkMode[] VALUES = values();

    public static EmEthnetWorkMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEthnetWorkMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmEthnetWorkMode)
  }

  /**
   * Protobuf enum {@code mt.EmEthInterfaceMode}
   *
   * <pre>
   ** 以太网多网口模式 
   * </pre>
   */
  public enum EmEthInterfaceMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEthInterfaceModeBackup = 0;</code>
     *
     * <pre>
     *备份
     * </pre>
     */
    emEthInterfaceModeBackup(0, 0),
    /**
     * <code>emEthInterfaceModeMulti = 1;</code>
     *
     * <pre>
     *多网口
     * </pre>
     */
    emEthInterfaceModeMulti(1, 1),
    /**
     * <code>emEthInterfaceModeSingle = 2;</code>
     *
     * <pre>
     *单网口
     * </pre>
     */
    emEthInterfaceModeSingle(2, 2),
    ;

    /**
     * <code>emEthInterfaceModeBackup = 0;</code>
     *
     * <pre>
     *备份
     * </pre>
     */
    public static final int emEthInterfaceModeBackup_VALUE = 0;
    /**
     * <code>emEthInterfaceModeMulti = 1;</code>
     *
     * <pre>
     *多网口
     * </pre>
     */
    public static final int emEthInterfaceModeMulti_VALUE = 1;
    /**
     * <code>emEthInterfaceModeSingle = 2;</code>
     *
     * <pre>
     *单网口
     * </pre>
     */
    public static final int emEthInterfaceModeSingle_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmEthInterfaceMode valueOf(int value) {
      switch (value) {
        case 0: return emEthInterfaceModeBackup;
        case 1: return emEthInterfaceModeMulti;
        case 2: return emEthInterfaceModeSingle;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEthInterfaceMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEthInterfaceMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEthInterfaceMode>() {
            public EmEthInterfaceMode findValueByNumber(int number) {
              return EmEthInterfaceMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(153);
    }

    private static final EmEthInterfaceMode[] VALUES = values();

    public static EmEthInterfaceMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEthInterfaceMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmEthInterfaceMode)
  }

  /**
   * Protobuf enum {@code mt.EmEthStartupResult}
   *
   * <pre>
   ** 以太网启动状况 
   * </pre>
   */
  public enum EmEthStartupResult
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEthStartupSuccess = 0;</code>
     *
     * <pre>
     *启动成功
     * </pre>
     */
    emEthStartupSuccess(0, 0),
    /**
     * <code>emEthStartupFail = 1;</code>
     *
     * <pre>
     *启动失败
     * </pre>
     */
    emEthStartupFail(1, 1),
    ;

    /**
     * <code>emEthStartupSuccess = 0;</code>
     *
     * <pre>
     *启动成功
     * </pre>
     */
    public static final int emEthStartupSuccess_VALUE = 0;
    /**
     * <code>emEthStartupFail = 1;</code>
     *
     * <pre>
     *启动失败
     * </pre>
     */
    public static final int emEthStartupFail_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmEthStartupResult valueOf(int value) {
      switch (value) {
        case 0: return emEthStartupSuccess;
        case 1: return emEthStartupFail;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEthStartupResult>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEthStartupResult>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEthStartupResult>() {
            public EmEthStartupResult findValueByNumber(int number) {
              return EmEthStartupResult.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(154);
    }

    private static final EmEthStartupResult[] VALUES = values();

    public static EmEthStartupResult valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEthStartupResult(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmEthStartupResult)
  }

  /**
   * Protobuf enum {@code mt.EmPPPoELinkState}
   *
   * <pre>
   ** PPPoE连接状态 
   * </pre>
   */
  public enum EmPPPoELinkState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPPPoELinkStateIdle = 0;</code>
     *
     * <pre>
     *未连接
     * </pre>
     */
    emPPPoELinkStateIdle(0, 0),
    /**
     * <code>emPPPoELinkStateConnecting = 1;</code>
     *
     * <pre>
     *连接中
     * </pre>
     */
    emPPPoELinkStateConnecting(1, 1),
    /**
     * <code>emPPPoELinkStateDisConnecting = 2;</code>
     *
     * <pre>
     *断开中
     * </pre>
     */
    emPPPoELinkStateDisConnecting(2, 2),
    /**
     * <code>emPPPoELinkStateConnected = 3;</code>
     *
     * <pre>
     *已连接	
     * </pre>
     */
    emPPPoELinkStateConnected(3, 3),
    ;

    /**
     * <code>emPPPoELinkStateIdle = 0;</code>
     *
     * <pre>
     *未连接
     * </pre>
     */
    public static final int emPPPoELinkStateIdle_VALUE = 0;
    /**
     * <code>emPPPoELinkStateConnecting = 1;</code>
     *
     * <pre>
     *连接中
     * </pre>
     */
    public static final int emPPPoELinkStateConnecting_VALUE = 1;
    /**
     * <code>emPPPoELinkStateDisConnecting = 2;</code>
     *
     * <pre>
     *断开中
     * </pre>
     */
    public static final int emPPPoELinkStateDisConnecting_VALUE = 2;
    /**
     * <code>emPPPoELinkStateConnected = 3;</code>
     *
     * <pre>
     *已连接	
     * </pre>
     */
    public static final int emPPPoELinkStateConnected_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmPPPoELinkState valueOf(int value) {
      switch (value) {
        case 0: return emPPPoELinkStateIdle;
        case 1: return emPPPoELinkStateConnecting;
        case 2: return emPPPoELinkStateDisConnecting;
        case 3: return emPPPoELinkStateConnected;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPPPoELinkState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPPPoELinkState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPPPoELinkState>() {
            public EmPPPoELinkState findValueByNumber(int number) {
              return EmPPPoELinkState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(155);
    }

    private static final EmPPPoELinkState[] VALUES = values();

    public static EmPPPoELinkState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPPPoELinkState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPPPoELinkState)
  }

  /**
   * Protobuf enum {@code mt.EmPPPoELinkErrReason}
   *
   * <pre>
   ** PPPoE连接失败原因 
   * </pre>
   */
  public enum EmPPPoELinkErrReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPPPoELinkErrReason_None = 0;</code>
     *
     * <pre>
     *连接成功
     * </pre>
     */
    emPPPoELinkErrReason_None(0, 0),
    /**
     * <code>emPPPoELinkErrReason_UsrOrPwdError = 1;</code>
     *
     * <pre>
     *用户名或密码错误
     * </pre>
     */
    emPPPoELinkErrReason_UsrOrPwdError(1, 1),
    /**
     * <code>emPPPoELinkErrReason_Timeout = 2;</code>
     *
     * <pre>
     *拨号超时
     * </pre>
     */
    emPPPoELinkErrReason_Timeout(2, 2),
    /**
     * <code>emPPPoELinkErrReason_Linkdown = 3;</code>
     *
     * <pre>
     *断链
     * </pre>
     */
    emPPPoELinkErrReason_Linkdown(3, 3),
    /**
     * <code>emPPPoELinkErrReason_NoISPServer = 4;</code>
     *
     * <pre>
     *找不到ISP服务商
     * </pre>
     */
    emPPPoELinkErrReason_NoISPServer(4, 4),
    /**
     * <code>emPPPoELinkErrReason_Unknown = 5;</code>
     *
     * <pre>
     *其他未知原因
     * </pre>
     */
    emPPPoELinkErrReason_Unknown(5, 5),
    ;

    /**
     * <code>emPPPoELinkErrReason_None = 0;</code>
     *
     * <pre>
     *连接成功
     * </pre>
     */
    public static final int emPPPoELinkErrReason_None_VALUE = 0;
    /**
     * <code>emPPPoELinkErrReason_UsrOrPwdError = 1;</code>
     *
     * <pre>
     *用户名或密码错误
     * </pre>
     */
    public static final int emPPPoELinkErrReason_UsrOrPwdError_VALUE = 1;
    /**
     * <code>emPPPoELinkErrReason_Timeout = 2;</code>
     *
     * <pre>
     *拨号超时
     * </pre>
     */
    public static final int emPPPoELinkErrReason_Timeout_VALUE = 2;
    /**
     * <code>emPPPoELinkErrReason_Linkdown = 3;</code>
     *
     * <pre>
     *断链
     * </pre>
     */
    public static final int emPPPoELinkErrReason_Linkdown_VALUE = 3;
    /**
     * <code>emPPPoELinkErrReason_NoISPServer = 4;</code>
     *
     * <pre>
     *找不到ISP服务商
     * </pre>
     */
    public static final int emPPPoELinkErrReason_NoISPServer_VALUE = 4;
    /**
     * <code>emPPPoELinkErrReason_Unknown = 5;</code>
     *
     * <pre>
     *其他未知原因
     * </pre>
     */
    public static final int emPPPoELinkErrReason_Unknown_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmPPPoELinkErrReason valueOf(int value) {
      switch (value) {
        case 0: return emPPPoELinkErrReason_None;
        case 1: return emPPPoELinkErrReason_UsrOrPwdError;
        case 2: return emPPPoELinkErrReason_Timeout;
        case 3: return emPPPoELinkErrReason_Linkdown;
        case 4: return emPPPoELinkErrReason_NoISPServer;
        case 5: return emPPPoELinkErrReason_Unknown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPPPoELinkErrReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPPPoELinkErrReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPPPoELinkErrReason>() {
            public EmPPPoELinkErrReason findValueByNumber(int number) {
              return EmPPPoELinkErrReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(156);
    }

    private static final EmPPPoELinkErrReason[] VALUES = values();

    public static EmPPPoELinkErrReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPPPoELinkErrReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPPPoELinkErrReason)
  }

  /**
   * Protobuf enum {@code mt.EmWifiWorkMode}
   *
   * <pre>
   ** WIFI工作模式 
   * </pre>
   */
  public enum EmWifiWorkMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWifiWorkModeClose = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    emWifiWorkModeClose(0, 0),
    /**
     * <code>emWifiWorkModeWifiClient = 1;</code>
     *
     * <pre>
     *Wifi客户端接入
     * </pre>
     */
    emWifiWorkModeWifiClient(1, 1),
    /**
     * <code>emWifiWorkModeWifiAp = 2;</code>
     *
     * <pre>
     *Wifi-AP服务          
     * </pre>
     */
    emWifiWorkModeWifiAp(2, 2),
    ;

    /**
     * <code>emWifiWorkModeClose = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    public static final int emWifiWorkModeClose_VALUE = 0;
    /**
     * <code>emWifiWorkModeWifiClient = 1;</code>
     *
     * <pre>
     *Wifi客户端接入
     * </pre>
     */
    public static final int emWifiWorkModeWifiClient_VALUE = 1;
    /**
     * <code>emWifiWorkModeWifiAp = 2;</code>
     *
     * <pre>
     *Wifi-AP服务          
     * </pre>
     */
    public static final int emWifiWorkModeWifiAp_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmWifiWorkMode valueOf(int value) {
      switch (value) {
        case 0: return emWifiWorkModeClose;
        case 1: return emWifiWorkModeWifiClient;
        case 2: return emWifiWorkModeWifiAp;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWifiWorkMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWifiWorkMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWifiWorkMode>() {
            public EmWifiWorkMode findValueByNumber(int number) {
              return EmWifiWorkMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(157);
    }

    private static final EmWifiWorkMode[] VALUES = values();

    public static EmWifiWorkMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWifiWorkMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWifiWorkMode)
  }

  /**
   * Protobuf enum {@code mt.EmWifiKeyType}
   *
   * <pre>
   ** WIFI加密模式 
   * </pre>
   */
  public enum EmWifiKeyType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWifiKeyTypeNone = 0;</code>
     *
     * <pre>
     *未加密
     * </pre>
     */
    emWifiKeyTypeNone(0, 0),
    /**
     * <code>emWifiKeyTypeWPA = 1;</code>
     *
     * <pre>
     *WPA-PSK
     * </pre>
     */
    emWifiKeyTypeWPA(1, 1),
    /**
     * <code>emWifiKeyTypeWPA2 = 2;</code>
     *
     * <pre>
     *WPA2-PSK
     * </pre>
     */
    emWifiKeyTypeWPA2(2, 2),
    /**
     * <code>emWifiKeyTypeWPAWPA2 = 3;</code>
     *
     * <pre>
     *WPA-PSK or WPA2-PSK
     * </pre>
     */
    emWifiKeyTypeWPAWPA2(3, 3),
    /**
     * <code>emWifiKeyTypeWEP = 4;</code>
     *
     * <pre>
     *WEP
     * </pre>
     */
    emWifiKeyTypeWEP(4, 4),
    ;

    /**
     * <code>emWifiKeyTypeNone = 0;</code>
     *
     * <pre>
     *未加密
     * </pre>
     */
    public static final int emWifiKeyTypeNone_VALUE = 0;
    /**
     * <code>emWifiKeyTypeWPA = 1;</code>
     *
     * <pre>
     *WPA-PSK
     * </pre>
     */
    public static final int emWifiKeyTypeWPA_VALUE = 1;
    /**
     * <code>emWifiKeyTypeWPA2 = 2;</code>
     *
     * <pre>
     *WPA2-PSK
     * </pre>
     */
    public static final int emWifiKeyTypeWPA2_VALUE = 2;
    /**
     * <code>emWifiKeyTypeWPAWPA2 = 3;</code>
     *
     * <pre>
     *WPA-PSK or WPA2-PSK
     * </pre>
     */
    public static final int emWifiKeyTypeWPAWPA2_VALUE = 3;
    /**
     * <code>emWifiKeyTypeWEP = 4;</code>
     *
     * <pre>
     *WEP
     * </pre>
     */
    public static final int emWifiKeyTypeWEP_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmWifiKeyType valueOf(int value) {
      switch (value) {
        case 0: return emWifiKeyTypeNone;
        case 1: return emWifiKeyTypeWPA;
        case 2: return emWifiKeyTypeWPA2;
        case 3: return emWifiKeyTypeWPAWPA2;
        case 4: return emWifiKeyTypeWEP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWifiKeyType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWifiKeyType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWifiKeyType>() {
            public EmWifiKeyType findValueByNumber(int number) {
              return EmWifiKeyType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(158);
    }

    private static final EmWifiKeyType[] VALUES = values();

    public static EmWifiKeyType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWifiKeyType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWifiKeyType)
  }

  /**
   * Protobuf enum {@code mt.EmWifiSignalLevel}
   *
   * <pre>
   ** WIFI信号强度(4级) 
   * </pre>
   */
  public enum EmWifiSignalLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWifiSignalLevelNone = 0;</code>
     *
     * <pre>
     *无信号 0格信号
     * </pre>
     */
    emWifiSignalLevelNone(0, 0),
    /**
     * <code>emWifiSignalLevelLess = 1;</code>
     *
     * <pre>
     *弱     1格信号
     * </pre>
     */
    emWifiSignalLevelLess(1, 1),
    /**
     * <code>emWifiSignalLevelLow = 2;</code>
     *
     * <pre>
     *低     2格信号
     * </pre>
     */
    emWifiSignalLevelLow(2, 2),
    /**
     * <code>emWifiSignalLevelMid = 3;</code>
     *
     * <pre>
     *中     3格信号
     * </pre>
     */
    emWifiSignalLevelMid(3, 3),
    /**
     * <code>emWifiSignalLevelHigh = 4;</code>
     *
     * <pre>
     *高     4格信号
     * </pre>
     */
    emWifiSignalLevelHigh(4, 4),
    ;

    /**
     * <code>emWifiSignalLevelNone = 0;</code>
     *
     * <pre>
     *无信号 0格信号
     * </pre>
     */
    public static final int emWifiSignalLevelNone_VALUE = 0;
    /**
     * <code>emWifiSignalLevelLess = 1;</code>
     *
     * <pre>
     *弱     1格信号
     * </pre>
     */
    public static final int emWifiSignalLevelLess_VALUE = 1;
    /**
     * <code>emWifiSignalLevelLow = 2;</code>
     *
     * <pre>
     *低     2格信号
     * </pre>
     */
    public static final int emWifiSignalLevelLow_VALUE = 2;
    /**
     * <code>emWifiSignalLevelMid = 3;</code>
     *
     * <pre>
     *中     3格信号
     * </pre>
     */
    public static final int emWifiSignalLevelMid_VALUE = 3;
    /**
     * <code>emWifiSignalLevelHigh = 4;</code>
     *
     * <pre>
     *高     4格信号
     * </pre>
     */
    public static final int emWifiSignalLevelHigh_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmWifiSignalLevel valueOf(int value) {
      switch (value) {
        case 0: return emWifiSignalLevelNone;
        case 1: return emWifiSignalLevelLess;
        case 2: return emWifiSignalLevelLow;
        case 3: return emWifiSignalLevelMid;
        case 4: return emWifiSignalLevelHigh;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWifiSignalLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWifiSignalLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWifiSignalLevel>() {
            public EmWifiSignalLevel findValueByNumber(int number) {
              return EmWifiSignalLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(159);
    }

    private static final EmWifiSignalLevel[] VALUES = values();

    public static EmWifiSignalLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWifiSignalLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWifiSignalLevel)
  }

  /**
   * Protobuf enum {@code mt.EmWifiLinkState}
   *
   * <pre>
   ** WIFI连接状态 
   * </pre>
   */
  public enum EmWifiLinkState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWifiLinkStateIdle = 0;</code>
     *
     * <pre>
     *空闲中
     * </pre>
     */
    emWifiLinkStateIdle(0, 0),
    /**
     * <code>emWifiLinkStateAuthentication = 1;</code>
     *
     * <pre>
     *认证中
     * </pre>
     */
    emWifiLinkStateAuthentication(1, 1),
    /**
     * <code>emWifiLinkStateBlocked = 2;</code>
     *
     * <pre>
     *阻塞	
     * </pre>
     */
    emWifiLinkStateBlocked(2, 2),
    /**
     * <code>emWifiLinkStateConnected = 3;</code>
     *
     * <pre>
     *已连接	
     * </pre>
     */
    emWifiLinkStateConnected(3, 3),
    /**
     * <code>emWifiLinkStateConnecting = 4;</code>
     *
     * <pre>
     *连接中
     * </pre>
     */
    emWifiLinkStateConnecting(4, 4),
    /**
     * <code>emWifiLinkStateDisConnected = 5;</code>
     *
     * <pre>
     *已断开
     * </pre>
     */
    emWifiLinkStateDisConnected(5, 5),
    /**
     * <code>emWifiLinkStateDisConnecting = 6;</code>
     *
     * <pre>
     *断开中
     * </pre>
     */
    emWifiLinkStateDisConnecting(6, 6),
    /**
     * <code>emWifiLinkStateFailed = 7;</code>
     *
     * <pre>
     *失败
     * </pre>
     */
    emWifiLinkStateFailed(7, 7),
    /**
     * <code>emWifiLinkStateObtainingIpAddr = 8;</code>
     *
     * <pre>
     *获取IP中
     * </pre>
     */
    emWifiLinkStateObtainingIpAddr(8, 8),
    /**
     * <code>emWifiLinkStateScanning = 9;</code>
     *
     * <pre>
     *扫描中
     * </pre>
     */
    emWifiLinkStateScanning(9, 9),
    /**
     * <code>emWifiLinkStateSuspended = 10;</code>
     *
     * <pre>
     *挂起暂停中
     * </pre>
     */
    emWifiLinkStateSuspended(10, 10),
    /**
     * <code>emWifiLinkStateVerifyingPoorLink = 11;</code>
     *
     * <pre>
     * </pre>
     */
    emWifiLinkStateVerifyingPoorLink(11, 11),
    ;

    /**
     * <code>emWifiLinkStateIdle = 0;</code>
     *
     * <pre>
     *空闲中
     * </pre>
     */
    public static final int emWifiLinkStateIdle_VALUE = 0;
    /**
     * <code>emWifiLinkStateAuthentication = 1;</code>
     *
     * <pre>
     *认证中
     * </pre>
     */
    public static final int emWifiLinkStateAuthentication_VALUE = 1;
    /**
     * <code>emWifiLinkStateBlocked = 2;</code>
     *
     * <pre>
     *阻塞	
     * </pre>
     */
    public static final int emWifiLinkStateBlocked_VALUE = 2;
    /**
     * <code>emWifiLinkStateConnected = 3;</code>
     *
     * <pre>
     *已连接	
     * </pre>
     */
    public static final int emWifiLinkStateConnected_VALUE = 3;
    /**
     * <code>emWifiLinkStateConnecting = 4;</code>
     *
     * <pre>
     *连接中
     * </pre>
     */
    public static final int emWifiLinkStateConnecting_VALUE = 4;
    /**
     * <code>emWifiLinkStateDisConnected = 5;</code>
     *
     * <pre>
     *已断开
     * </pre>
     */
    public static final int emWifiLinkStateDisConnected_VALUE = 5;
    /**
     * <code>emWifiLinkStateDisConnecting = 6;</code>
     *
     * <pre>
     *断开中
     * </pre>
     */
    public static final int emWifiLinkStateDisConnecting_VALUE = 6;
    /**
     * <code>emWifiLinkStateFailed = 7;</code>
     *
     * <pre>
     *失败
     * </pre>
     */
    public static final int emWifiLinkStateFailed_VALUE = 7;
    /**
     * <code>emWifiLinkStateObtainingIpAddr = 8;</code>
     *
     * <pre>
     *获取IP中
     * </pre>
     */
    public static final int emWifiLinkStateObtainingIpAddr_VALUE = 8;
    /**
     * <code>emWifiLinkStateScanning = 9;</code>
     *
     * <pre>
     *扫描中
     * </pre>
     */
    public static final int emWifiLinkStateScanning_VALUE = 9;
    /**
     * <code>emWifiLinkStateSuspended = 10;</code>
     *
     * <pre>
     *挂起暂停中
     * </pre>
     */
    public static final int emWifiLinkStateSuspended_VALUE = 10;
    /**
     * <code>emWifiLinkStateVerifyingPoorLink = 11;</code>
     *
     * <pre>
     * </pre>
     */
    public static final int emWifiLinkStateVerifyingPoorLink_VALUE = 11;


    public final int getNumber() { return value; }

    public static EmWifiLinkState valueOf(int value) {
      switch (value) {
        case 0: return emWifiLinkStateIdle;
        case 1: return emWifiLinkStateAuthentication;
        case 2: return emWifiLinkStateBlocked;
        case 3: return emWifiLinkStateConnected;
        case 4: return emWifiLinkStateConnecting;
        case 5: return emWifiLinkStateDisConnected;
        case 6: return emWifiLinkStateDisConnecting;
        case 7: return emWifiLinkStateFailed;
        case 8: return emWifiLinkStateObtainingIpAddr;
        case 9: return emWifiLinkStateScanning;
        case 10: return emWifiLinkStateSuspended;
        case 11: return emWifiLinkStateVerifyingPoorLink;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWifiLinkState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWifiLinkState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWifiLinkState>() {
            public EmWifiLinkState findValueByNumber(int number) {
              return EmWifiLinkState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(160);
    }

    private static final EmWifiLinkState[] VALUES = values();

    public static EmWifiLinkState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWifiLinkState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWifiLinkState)
  }

  /**
   * Protobuf enum {@code mt.EmWifiLinkErrReason}
   *
   * <pre>
   ** WIFI连接失败原因 
   * </pre>
   */
  public enum EmWifiLinkErrReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWifiLinkErrReason_None = 0;</code>
     *
     * <pre>
     *连接成功
     * </pre>
     */
    emWifiLinkErrReason_None(0, 0),
    /**
     * <code>emWifiLinkErrReason_Failed = 1;</code>
     *
     * <pre>
     *连接失败
     * </pre>
     */
    emWifiLinkErrReason_Failed(1, 1),
    /**
     * <code>emWifiLinkErrReason_Timeout = 2;</code>
     *
     * <pre>
     *连接超时
     * </pre>
     */
    emWifiLinkErrReason_Timeout(2, 2),
    /**
     * <code>emWifiLinkErrReason_Unknown = 3;</code>
     *
     * <pre>
     *未知原因
     * </pre>
     */
    emWifiLinkErrReason_Unknown(3, 3),
    ;

    /**
     * <code>emWifiLinkErrReason_None = 0;</code>
     *
     * <pre>
     *连接成功
     * </pre>
     */
    public static final int emWifiLinkErrReason_None_VALUE = 0;
    /**
     * <code>emWifiLinkErrReason_Failed = 1;</code>
     *
     * <pre>
     *连接失败
     * </pre>
     */
    public static final int emWifiLinkErrReason_Failed_VALUE = 1;
    /**
     * <code>emWifiLinkErrReason_Timeout = 2;</code>
     *
     * <pre>
     *连接超时
     * </pre>
     */
    public static final int emWifiLinkErrReason_Timeout_VALUE = 2;
    /**
     * <code>emWifiLinkErrReason_Unknown = 3;</code>
     *
     * <pre>
     *未知原因
     * </pre>
     */
    public static final int emWifiLinkErrReason_Unknown_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmWifiLinkErrReason valueOf(int value) {
      switch (value) {
        case 0: return emWifiLinkErrReason_None;
        case 1: return emWifiLinkErrReason_Failed;
        case 2: return emWifiLinkErrReason_Timeout;
        case 3: return emWifiLinkErrReason_Unknown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWifiLinkErrReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWifiLinkErrReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWifiLinkErrReason>() {
            public EmWifiLinkErrReason findValueByNumber(int number) {
              return EmWifiLinkErrReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(161);
    }

    private static final EmWifiLinkErrReason[] VALUES = values();

    public static EmWifiLinkErrReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWifiLinkErrReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWifiLinkErrReason)
  }

  /**
   * Protobuf enum {@code mt.EmWifiApKeyType}
   *
   * <pre>
   ** WIFI-AP加密模式 
   * </pre>
   */
  public enum EmWifiApKeyType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWifiApKeyTypeNone = 0;</code>
     *
     * <pre>
     *未加密
     * </pre>
     */
    emWifiApKeyTypeNone(0, 0),
    /**
     * <code>emWifiApKeyTypeWPA2 = 1;</code>
     *
     * <pre>
     *WPA2-PSK AES
     * </pre>
     */
    emWifiApKeyTypeWPA2(1, 1),
    ;

    /**
     * <code>emWifiApKeyTypeNone = 0;</code>
     *
     * <pre>
     *未加密
     * </pre>
     */
    public static final int emWifiApKeyTypeNone_VALUE = 0;
    /**
     * <code>emWifiApKeyTypeWPA2 = 1;</code>
     *
     * <pre>
     *WPA2-PSK AES
     * </pre>
     */
    public static final int emWifiApKeyTypeWPA2_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmWifiApKeyType valueOf(int value) {
      switch (value) {
        case 0: return emWifiApKeyTypeNone;
        case 1: return emWifiApKeyTypeWPA2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWifiApKeyType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWifiApKeyType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWifiApKeyType>() {
            public EmWifiApKeyType findValueByNumber(int number) {
              return EmWifiApKeyType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(162);
    }

    private static final EmWifiApKeyType[] VALUES = values();

    public static EmWifiApKeyType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWifiApKeyType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWifiApKeyType)
  }

  /**
   * Protobuf enum {@code mt.EmWifiFrequencyBandType}
   *
   * <pre>
   ** WIFI-频段类型 
   * </pre>
   */
  public enum EmWifiFrequencyBandType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWifiFrequencyBandType_24GHz = 0;</code>
     *
     * <pre>
     *2.4GHz
     * </pre>
     */
    emWifiFrequencyBandType_24GHz(0, 0),
    /**
     * <code>emWifiFrequencyBandType_50GHz = 1;</code>
     *
     * <pre>
     *5.0GHz
     * </pre>
     */
    emWifiFrequencyBandType_50GHz(1, 1),
    ;

    /**
     * <code>emWifiFrequencyBandType_24GHz = 0;</code>
     *
     * <pre>
     *2.4GHz
     * </pre>
     */
    public static final int emWifiFrequencyBandType_24GHz_VALUE = 0;
    /**
     * <code>emWifiFrequencyBandType_50GHz = 1;</code>
     *
     * <pre>
     *5.0GHz
     * </pre>
     */
    public static final int emWifiFrequencyBandType_50GHz_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmWifiFrequencyBandType valueOf(int value) {
      switch (value) {
        case 0: return emWifiFrequencyBandType_24GHz;
        case 1: return emWifiFrequencyBandType_50GHz;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWifiFrequencyBandType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWifiFrequencyBandType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWifiFrequencyBandType>() {
            public EmWifiFrequencyBandType findValueByNumber(int number) {
              return EmWifiFrequencyBandType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(163);
    }

    private static final EmWifiFrequencyBandType[] VALUES = values();

    public static EmWifiFrequencyBandType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWifiFrequencyBandType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWifiFrequencyBandType)
  }

  /**
   * Protobuf enum {@code mt.EmMobileDataLinkState}
   *
   * <pre>
   ** MobileData移动数据连接状态 
   * </pre>
   */
  public enum EmMobileDataLinkState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMobileDataLinkStateUnUsed = 0;</code>
     *
     * <pre>
     *未启用
     * </pre>
     */
    emMobileDataLinkStateUnUsed(0, 0),
    /**
     * <code>emMobileDataLinkStateIdle = 1;</code>
     *
     * <pre>
     *未启用
     * </pre>
     */
    emMobileDataLinkStateIdle(1, 1),
    /**
     * <code>emMobileDataLinkStateConnecting = 2;</code>
     *
     * <pre>
     *连接中
     * </pre>
     */
    emMobileDataLinkStateConnecting(2, 2),
    /**
     * <code>emMobileDataLinkLinkStateConnected = 3;</code>
     *
     * <pre>
     *已连接
     * </pre>
     */
    emMobileDataLinkLinkStateConnected(3, 3),
    /**
     * <code>emMobileDataLinkLinkStateSuspended = 4;</code>
     *
     * <pre>
     *挂起
     * </pre>
     */
    emMobileDataLinkLinkStateSuspended(4, 4),
    /**
     * <code>emMobileDataLinkStateDisConnecting = 5;</code>
     *
     * <pre>
     *断开中
     * </pre>
     */
    emMobileDataLinkStateDisConnecting(5, 5),
    /**
     * <code>emMobileDataLinkLinkStateDisConnected = 6;</code>
     *
     * <pre>
     *已断开
     * </pre>
     */
    emMobileDataLinkLinkStateDisConnected(6, 6),
    /**
     * <code>emMobileDataLinkLinkStateUnknown = 7;</code>
     *
     * <pre>
     *未知
     * </pre>
     */
    emMobileDataLinkLinkStateUnknown(7, 7),
    ;

    /**
     * <code>emMobileDataLinkStateUnUsed = 0;</code>
     *
     * <pre>
     *未启用
     * </pre>
     */
    public static final int emMobileDataLinkStateUnUsed_VALUE = 0;
    /**
     * <code>emMobileDataLinkStateIdle = 1;</code>
     *
     * <pre>
     *未启用
     * </pre>
     */
    public static final int emMobileDataLinkStateIdle_VALUE = 1;
    /**
     * <code>emMobileDataLinkStateConnecting = 2;</code>
     *
     * <pre>
     *连接中
     * </pre>
     */
    public static final int emMobileDataLinkStateConnecting_VALUE = 2;
    /**
     * <code>emMobileDataLinkLinkStateConnected = 3;</code>
     *
     * <pre>
     *已连接
     * </pre>
     */
    public static final int emMobileDataLinkLinkStateConnected_VALUE = 3;
    /**
     * <code>emMobileDataLinkLinkStateSuspended = 4;</code>
     *
     * <pre>
     *挂起
     * </pre>
     */
    public static final int emMobileDataLinkLinkStateSuspended_VALUE = 4;
    /**
     * <code>emMobileDataLinkStateDisConnecting = 5;</code>
     *
     * <pre>
     *断开中
     * </pre>
     */
    public static final int emMobileDataLinkStateDisConnecting_VALUE = 5;
    /**
     * <code>emMobileDataLinkLinkStateDisConnected = 6;</code>
     *
     * <pre>
     *已断开
     * </pre>
     */
    public static final int emMobileDataLinkLinkStateDisConnected_VALUE = 6;
    /**
     * <code>emMobileDataLinkLinkStateUnknown = 7;</code>
     *
     * <pre>
     *未知
     * </pre>
     */
    public static final int emMobileDataLinkLinkStateUnknown_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmMobileDataLinkState valueOf(int value) {
      switch (value) {
        case 0: return emMobileDataLinkStateUnUsed;
        case 1: return emMobileDataLinkStateIdle;
        case 2: return emMobileDataLinkStateConnecting;
        case 3: return emMobileDataLinkLinkStateConnected;
        case 4: return emMobileDataLinkLinkStateSuspended;
        case 5: return emMobileDataLinkStateDisConnecting;
        case 6: return emMobileDataLinkLinkStateDisConnected;
        case 7: return emMobileDataLinkLinkStateUnknown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataLinkState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataLinkState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMobileDataLinkState>() {
            public EmMobileDataLinkState findValueByNumber(int number) {
              return EmMobileDataLinkState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(164);
    }

    private static final EmMobileDataLinkState[] VALUES = values();

    public static EmMobileDataLinkState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMobileDataLinkState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMobileDataLinkState)
  }

  /**
   * Protobuf enum {@code mt.EmMobileDataLinkErrReason}
   *
   * <pre>
   ** MobileData移动数据连接失败原因 
   * </pre>
   */
  public enum EmMobileDataLinkErrReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMobileDataLinkErrReason_None = 0;</code>
     *
     * <pre>
     *连接成功
     * </pre>
     */
    emMobileDataLinkErrReason_None(0, 0),
    /**
     * <code>emMobileDataLinkErrReason_Failed = 1;</code>
     *
     * <pre>
     *连接失败
     * </pre>
     */
    emMobileDataLinkErrReason_Failed(1, 1),
    /**
     * <code>emMobileDataLinkErrReason_Timeout = 2;</code>
     *
     * <pre>
     *连接超时
     * </pre>
     */
    emMobileDataLinkErrReason_Timeout(2, 2),
    /**
     * <code>emMobileDataLinkErrReason_Unknown = 3;</code>
     *
     * <pre>
     *未知原因
     * </pre>
     */
    emMobileDataLinkErrReason_Unknown(3, 3),
    ;

    /**
     * <code>emMobileDataLinkErrReason_None = 0;</code>
     *
     * <pre>
     *连接成功
     * </pre>
     */
    public static final int emMobileDataLinkErrReason_None_VALUE = 0;
    /**
     * <code>emMobileDataLinkErrReason_Failed = 1;</code>
     *
     * <pre>
     *连接失败
     * </pre>
     */
    public static final int emMobileDataLinkErrReason_Failed_VALUE = 1;
    /**
     * <code>emMobileDataLinkErrReason_Timeout = 2;</code>
     *
     * <pre>
     *连接超时
     * </pre>
     */
    public static final int emMobileDataLinkErrReason_Timeout_VALUE = 2;
    /**
     * <code>emMobileDataLinkErrReason_Unknown = 3;</code>
     *
     * <pre>
     *未知原因
     * </pre>
     */
    public static final int emMobileDataLinkErrReason_Unknown_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMobileDataLinkErrReason valueOf(int value) {
      switch (value) {
        case 0: return emMobileDataLinkErrReason_None;
        case 1: return emMobileDataLinkErrReason_Failed;
        case 2: return emMobileDataLinkErrReason_Timeout;
        case 3: return emMobileDataLinkErrReason_Unknown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataLinkErrReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataLinkErrReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMobileDataLinkErrReason>() {
            public EmMobileDataLinkErrReason findValueByNumber(int number) {
              return EmMobileDataLinkErrReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(165);
    }

    private static final EmMobileDataLinkErrReason[] VALUES = values();

    public static EmMobileDataLinkErrReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMobileDataLinkErrReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMobileDataLinkErrReason)
  }

  /**
   * Protobuf enum {@code mt.EmMobileDataSignalLevel}
   *
   * <pre>
   ** MobileData信号强度(4级) 
   * </pre>
   */
  public enum EmMobileDataSignalLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMobileDataSignalLevelNone = 0;</code>
     *
     * <pre>
     *无信号 0格信号
     * </pre>
     */
    emMobileDataSignalLevelNone(0, 0),
    /**
     * <code>emMobileDataSignalLevelLess = 1;</code>
     *
     * <pre>
     *弱     1格信号
     * </pre>
     */
    emMobileDataSignalLevelLess(1, 1),
    /**
     * <code>emMobileDataSignalLevelLow = 2;</code>
     *
     * <pre>
     *低     2格信号
     * </pre>
     */
    emMobileDataSignalLevelLow(2, 2),
    /**
     * <code>emMobileDataSignalLevelMid = 3;</code>
     *
     * <pre>
     *中     3格信号
     * </pre>
     */
    emMobileDataSignalLevelMid(3, 3),
    /**
     * <code>emMobileDataSignalLevelHigh = 4;</code>
     *
     * <pre>
     *高     4格信号
     * </pre>
     */
    emMobileDataSignalLevelHigh(4, 4),
    ;

    /**
     * <code>emMobileDataSignalLevelNone = 0;</code>
     *
     * <pre>
     *无信号 0格信号
     * </pre>
     */
    public static final int emMobileDataSignalLevelNone_VALUE = 0;
    /**
     * <code>emMobileDataSignalLevelLess = 1;</code>
     *
     * <pre>
     *弱     1格信号
     * </pre>
     */
    public static final int emMobileDataSignalLevelLess_VALUE = 1;
    /**
     * <code>emMobileDataSignalLevelLow = 2;</code>
     *
     * <pre>
     *低     2格信号
     * </pre>
     */
    public static final int emMobileDataSignalLevelLow_VALUE = 2;
    /**
     * <code>emMobileDataSignalLevelMid = 3;</code>
     *
     * <pre>
     *中     3格信号
     * </pre>
     */
    public static final int emMobileDataSignalLevelMid_VALUE = 3;
    /**
     * <code>emMobileDataSignalLevelHigh = 4;</code>
     *
     * <pre>
     *高     4格信号
     * </pre>
     */
    public static final int emMobileDataSignalLevelHigh_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmMobileDataSignalLevel valueOf(int value) {
      switch (value) {
        case 0: return emMobileDataSignalLevelNone;
        case 1: return emMobileDataSignalLevelLess;
        case 2: return emMobileDataSignalLevelLow;
        case 3: return emMobileDataSignalLevelMid;
        case 4: return emMobileDataSignalLevelHigh;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataSignalLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataSignalLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMobileDataSignalLevel>() {
            public EmMobileDataSignalLevel findValueByNumber(int number) {
              return EmMobileDataSignalLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(166);
    }

    private static final EmMobileDataSignalLevel[] VALUES = values();

    public static EmMobileDataSignalLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMobileDataSignalLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMobileDataSignalLevel)
  }

  /**
   * Protobuf enum {@code mt.EmNetAdapterWorkType}
   */
  public enum EmNetAdapterWorkType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNetAdapterWorkType_None = 0;</code>
     *
     * <pre>
     *不可用
     * </pre>
     */
    emNetAdapterWorkType_None(0, 0),
    /**
     * <code>emNetAdapterWorkType_Wifi = 1;</code>
     *
     * <pre>
     *WIFI
     * </pre>
     */
    emNetAdapterWorkType_Wifi(1, 1),
    /**
     * <code>emNetAdapterWorkType_PPPoE = 2;</code>
     *
     * <pre>
     *PPPOE
     * </pre>
     */
    emNetAdapterWorkType_PPPoE(2, 2),
    /**
     * <code>emNetAdapterWorkType_MobileData = 3;</code>
     *
     * <pre>
     *移动数据3G/4G
     * </pre>
     */
    emNetAdapterWorkType_MobileData(3, 3),
    /**
     * <code>emNetAdapterWorkType_EthnetCard1 = 4;</code>
     *
     * <pre>
     *以太网Lan1
     * </pre>
     */
    emNetAdapterWorkType_EthnetCard1(4, 4),
    /**
     * <code>emNetAdapterWorkType_EthnetCard2 = 5;</code>
     *
     * <pre>
     *以太网Lan2
     * </pre>
     */
    emNetAdapterWorkType_EthnetCard2(5, 5),
    /**
     * <code>emNetAdapterWorkType_E1 = 6;</code>
     *
     * <pre>
     *E1通讯
     * </pre>
     */
    emNetAdapterWorkType_E1(6, 6),
    ;

    /**
     * <code>emNetAdapterWorkType_None = 0;</code>
     *
     * <pre>
     *不可用
     * </pre>
     */
    public static final int emNetAdapterWorkType_None_VALUE = 0;
    /**
     * <code>emNetAdapterWorkType_Wifi = 1;</code>
     *
     * <pre>
     *WIFI
     * </pre>
     */
    public static final int emNetAdapterWorkType_Wifi_VALUE = 1;
    /**
     * <code>emNetAdapterWorkType_PPPoE = 2;</code>
     *
     * <pre>
     *PPPOE
     * </pre>
     */
    public static final int emNetAdapterWorkType_PPPoE_VALUE = 2;
    /**
     * <code>emNetAdapterWorkType_MobileData = 3;</code>
     *
     * <pre>
     *移动数据3G/4G
     * </pre>
     */
    public static final int emNetAdapterWorkType_MobileData_VALUE = 3;
    /**
     * <code>emNetAdapterWorkType_EthnetCard1 = 4;</code>
     *
     * <pre>
     *以太网Lan1
     * </pre>
     */
    public static final int emNetAdapterWorkType_EthnetCard1_VALUE = 4;
    /**
     * <code>emNetAdapterWorkType_EthnetCard2 = 5;</code>
     *
     * <pre>
     *以太网Lan2
     * </pre>
     */
    public static final int emNetAdapterWorkType_EthnetCard2_VALUE = 5;
    /**
     * <code>emNetAdapterWorkType_E1 = 6;</code>
     *
     * <pre>
     *E1通讯
     * </pre>
     */
    public static final int emNetAdapterWorkType_E1_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmNetAdapterWorkType valueOf(int value) {
      switch (value) {
        case 0: return emNetAdapterWorkType_None;
        case 1: return emNetAdapterWorkType_Wifi;
        case 2: return emNetAdapterWorkType_PPPoE;
        case 3: return emNetAdapterWorkType_MobileData;
        case 4: return emNetAdapterWorkType_EthnetCard1;
        case 5: return emNetAdapterWorkType_EthnetCard2;
        case 6: return emNetAdapterWorkType_E1;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNetAdapterWorkType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNetAdapterWorkType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNetAdapterWorkType>() {
            public EmNetAdapterWorkType findValueByNumber(int number) {
              return EmNetAdapterWorkType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(167);
    }

    private static final EmNetAdapterWorkType[] VALUES = values();

    public static EmNetAdapterWorkType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNetAdapterWorkType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmNetAdapterWorkType)
  }

  /**
   * Protobuf enum {@code mt.EmMobileDataNetType}
   */
  public enum EmMobileDataNetType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMobileDataNetType_None = 0;</code>
     *
     * <pre>
     *未知
     * </pre>
     */
    emMobileDataNetType_None(0, 0),
    /**
     * <code>emMobileDataNetType_CMCC = 1;</code>
     *
     * <pre>
     *中国移动
     * </pre>
     */
    emMobileDataNetType_CMCC(1, 1),
    /**
     * <code>emMobileDataNetType_CUCC = 2;</code>
     *
     * <pre>
     *中国联通
     * </pre>
     */
    emMobileDataNetType_CUCC(2, 2),
    /**
     * <code>emMobileDataNetType_CTCC = 3;</code>
     *
     * <pre>
     *中国电信
     * </pre>
     */
    emMobileDataNetType_CTCC(3, 3),
    ;

    /**
     * <code>emMobileDataNetType_None = 0;</code>
     *
     * <pre>
     *未知
     * </pre>
     */
    public static final int emMobileDataNetType_None_VALUE = 0;
    /**
     * <code>emMobileDataNetType_CMCC = 1;</code>
     *
     * <pre>
     *中国移动
     * </pre>
     */
    public static final int emMobileDataNetType_CMCC_VALUE = 1;
    /**
     * <code>emMobileDataNetType_CUCC = 2;</code>
     *
     * <pre>
     *中国联通
     * </pre>
     */
    public static final int emMobileDataNetType_CUCC_VALUE = 2;
    /**
     * <code>emMobileDataNetType_CTCC = 3;</code>
     *
     * <pre>
     *中国电信
     * </pre>
     */
    public static final int emMobileDataNetType_CTCC_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMobileDataNetType valueOf(int value) {
      switch (value) {
        case 0: return emMobileDataNetType_None;
        case 1: return emMobileDataNetType_CMCC;
        case 2: return emMobileDataNetType_CUCC;
        case 3: return emMobileDataNetType_CTCC;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataNetType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataNetType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMobileDataNetType>() {
            public EmMobileDataNetType findValueByNumber(int number) {
              return EmMobileDataNetType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(168);
    }

    private static final EmMobileDataNetType[] VALUES = values();

    public static EmMobileDataNetType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMobileDataNetType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMobileDataNetType)
  }

  /**
   * Protobuf enum {@code mt.EmMobileDataNetGenerationType}
   */
  public enum EmMobileDataNetGenerationType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMobileDataNetGenerationType_None = 0;</code>
     *
     * <pre>
     *未知
     * </pre>
     */
    emMobileDataNetGenerationType_None(0, 0),
    /**
     * <code>emMobileDataNetGenerationType_2G = 1;</code>
     *
     * <pre>
     *2G
     * </pre>
     */
    emMobileDataNetGenerationType_2G(1, 1),
    /**
     * <code>emMobileDataNetGenerationType_3G = 2;</code>
     *
     * <pre>
     *3G
     * </pre>
     */
    emMobileDataNetGenerationType_3G(2, 2),
    /**
     * <code>emMobileDataNetGenerationType_4G = 3;</code>
     *
     * <pre>
     *4G
     * </pre>
     */
    emMobileDataNetGenerationType_4G(3, 3),
    ;

    /**
     * <code>emMobileDataNetGenerationType_None = 0;</code>
     *
     * <pre>
     *未知
     * </pre>
     */
    public static final int emMobileDataNetGenerationType_None_VALUE = 0;
    /**
     * <code>emMobileDataNetGenerationType_2G = 1;</code>
     *
     * <pre>
     *2G
     * </pre>
     */
    public static final int emMobileDataNetGenerationType_2G_VALUE = 1;
    /**
     * <code>emMobileDataNetGenerationType_3G = 2;</code>
     *
     * <pre>
     *3G
     * </pre>
     */
    public static final int emMobileDataNetGenerationType_3G_VALUE = 2;
    /**
     * <code>emMobileDataNetGenerationType_4G = 3;</code>
     *
     * <pre>
     *4G
     * </pre>
     */
    public static final int emMobileDataNetGenerationType_4G_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMobileDataNetGenerationType valueOf(int value) {
      switch (value) {
        case 0: return emMobileDataNetGenerationType_None;
        case 1: return emMobileDataNetGenerationType_2G;
        case 2: return emMobileDataNetGenerationType_3G;
        case 3: return emMobileDataNetGenerationType_4G;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataNetGenerationType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMobileDataNetGenerationType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMobileDataNetGenerationType>() {
            public EmMobileDataNetGenerationType findValueByNumber(int number) {
              return EmMobileDataNetGenerationType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(169);
    }

    private static final EmMobileDataNetGenerationType[] VALUES = values();

    public static EmMobileDataNetGenerationType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMobileDataNetGenerationType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMobileDataNetGenerationType)
  }

  /**
   * Protobuf enum {@code mt.EmEthnetParamType}
   *
   * <pre>
   ** 设置以太网参数类型
   * </pre>
   */
  public enum EmEthnetParamType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emType_SetIpAndMask = 0;</code>
     *
     * <pre>
     *设置IP和掩码
     * </pre>
     */
    emType_SetIpAndMask(0, 0),
    /**
     * <code>emType_SetMacAddress = 1;</code>
     *
     * <pre>
     *设置MAC地址
     * </pre>
     */
    emType_SetMacAddress(1, 1),
    /**
     * <code>emType_SetAllParam = 2;</code>
     *
     * <pre>
     *设置所有参数
     * </pre>
     */
    emType_SetAllParam(2, 2),
    /**
     * <code>emType_SetSecondIp = 3;</code>
     *
     * <pre>
     *设置第二个IP信息
     * </pre>
     */
    emType_SetSecondIp(3, 3),
    ;

    /**
     * <code>emType_SetIpAndMask = 0;</code>
     *
     * <pre>
     *设置IP和掩码
     * </pre>
     */
    public static final int emType_SetIpAndMask_VALUE = 0;
    /**
     * <code>emType_SetMacAddress = 1;</code>
     *
     * <pre>
     *设置MAC地址
     * </pre>
     */
    public static final int emType_SetMacAddress_VALUE = 1;
    /**
     * <code>emType_SetAllParam = 2;</code>
     *
     * <pre>
     *设置所有参数
     * </pre>
     */
    public static final int emType_SetAllParam_VALUE = 2;
    /**
     * <code>emType_SetSecondIp = 3;</code>
     *
     * <pre>
     *设置第二个IP信息
     * </pre>
     */
    public static final int emType_SetSecondIp_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmEthnetParamType valueOf(int value) {
      switch (value) {
        case 0: return emType_SetIpAndMask;
        case 1: return emType_SetMacAddress;
        case 2: return emType_SetAllParam;
        case 3: return emType_SetSecondIp;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEthnetParamType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEthnetParamType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEthnetParamType>() {
            public EmEthnetParamType findValueByNumber(int number) {
              return EmEthnetParamType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(170);
    }

    private static final EmEthnetParamType[] VALUES = values();

    public static EmEthnetParamType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEthnetParamType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmEthnetParamType)
  }

  /**
   * Protobuf enum {@code mt.EmE1InterfaceType}
   *
   * <pre>
   ** E1接口类型 
   * </pre>
   */
  public enum EmE1InterfaceType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emE1IfType_Serial = 0;</code>
     *
     * <pre>
     *Serial类型
     * </pre>
     */
    emE1IfType_Serial(0, 0),
    /**
     * <code>emE1IfType_Virtual = 1;</code>
     *
     * <pre>
     *Virtual类型 
     * </pre>
     */
    emE1IfType_Virtual(1, 1),
    ;

    /**
     * <code>emE1IfType_Serial = 0;</code>
     *
     * <pre>
     *Serial类型
     * </pre>
     */
    public static final int emE1IfType_Serial_VALUE = 0;
    /**
     * <code>emE1IfType_Virtual = 1;</code>
     *
     * <pre>
     *Virtual类型 
     * </pre>
     */
    public static final int emE1IfType_Virtual_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmE1InterfaceType valueOf(int value) {
      switch (value) {
        case 0: return emE1IfType_Serial;
        case 1: return emE1IfType_Virtual;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmE1InterfaceType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmE1InterfaceType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmE1InterfaceType>() {
            public EmE1InterfaceType findValueByNumber(int number) {
              return EmE1InterfaceType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(171);
    }

    private static final EmE1InterfaceType[] VALUES = values();

    public static EmE1InterfaceType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmE1InterfaceType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmE1InterfaceType)
  }

  /**
   * Protobuf enum {@code mt.EmE1ClockType}
   *
   * <pre>
   ** E1 Colck类型 
   * </pre>
   */
  public enum EmE1ClockType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emClockType_Dce = 0;</code>
     */
    emClockType_Dce(0, 0),
    /**
     * <code>emClockType_Dte = 1;</code>
     */
    emClockType_Dte(1, 1),
    ;

    /**
     * <code>emClockType_Dce = 0;</code>
     */
    public static final int emClockType_Dce_VALUE = 0;
    /**
     * <code>emClockType_Dte = 1;</code>
     */
    public static final int emClockType_Dte_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmE1ClockType valueOf(int value) {
      switch (value) {
        case 0: return emClockType_Dce;
        case 1: return emClockType_Dte;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmE1ClockType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmE1ClockType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmE1ClockType>() {
            public EmE1ClockType findValueByNumber(int number) {
              return EmE1ClockType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(172);
    }

    private static final EmE1ClockType[] VALUES = values();

    public static EmE1ClockType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmE1ClockType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmE1ClockType)
  }

  /**
   * Protobuf enum {@code mt.EmE1ChainOptType}
   *
   * <pre>
   ** E1 Chain操作类型 
   * </pre>
   */
  public enum EmE1ChainOptType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emType_OpenSingle = 0;</code>
     *
     * <pre>
     *打开单通道
     * </pre>
     */
    emType_OpenSingle(0, 0),
    /**
     * <code>emType_CloseSingle = 1;</code>
     *
     * <pre>
     *关闭单通道
     * </pre>
     */
    emType_CloseSingle(1, 1),
    /**
     * <code>emType_OpenMult = 2;</code>
     *
     * <pre>
     *打开多通道
     * </pre>
     */
    emType_OpenMult(2, 2),
    /**
     * <code>emType_CloseMult = 3;</code>
     *
     * <pre>
     *关闭多通道	
     * </pre>
     */
    emType_CloseMult(3, 3),
    ;

    /**
     * <code>emType_OpenSingle = 0;</code>
     *
     * <pre>
     *打开单通道
     * </pre>
     */
    public static final int emType_OpenSingle_VALUE = 0;
    /**
     * <code>emType_CloseSingle = 1;</code>
     *
     * <pre>
     *关闭单通道
     * </pre>
     */
    public static final int emType_CloseSingle_VALUE = 1;
    /**
     * <code>emType_OpenMult = 2;</code>
     *
     * <pre>
     *打开多通道
     * </pre>
     */
    public static final int emType_OpenMult_VALUE = 2;
    /**
     * <code>emType_CloseMult = 3;</code>
     *
     * <pre>
     *关闭多通道	
     * </pre>
     */
    public static final int emType_CloseMult_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmE1ChainOptType valueOf(int value) {
      switch (value) {
        case 0: return emType_OpenSingle;
        case 1: return emType_CloseSingle;
        case 2: return emType_OpenMult;
        case 3: return emType_CloseMult;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmE1ChainOptType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmE1ChainOptType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmE1ChainOptType>() {
            public EmE1ChainOptType findValueByNumber(int number) {
              return EmE1ChainOptType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(173);
    }

    private static final EmE1ChainOptType[] VALUES = values();

    public static EmE1ChainOptType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmE1ChainOptType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmE1ChainOptType)
  }

  /**
   * Protobuf enum {@code mt.EmE1LinkErrReason}
   *
   * <pre>
   ** E1打开关闭单通道链路或多通道链路响应错误码 
   * </pre>
   */
  public enum EmE1LinkErrReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emE1ErrNone = 0;</code>
     */
    emE1ErrNone(0, 0),
    /**
     * <code>emE1ErrParamException = 1;</code>
     */
    emE1ErrParamException(1, 1),
    /**
     * <code>emE1ErrSerialIdInvalid = 2;</code>
     */
    emE1ErrSerialIdInvalid(2, 2),
    /**
     * <code>emE1ErrE1IdInvalid = 3;</code>
     */
    emE1ErrE1IdInvalid(3, 3),
    /**
     * <code>emE1ErrE1TsMaskInvalid = 4;</code>
     */
    emE1ErrE1TsMaskInvalid(4, 4),
    /**
     * <code>emE1ErrE1ChainGroupInvalid = 5;</code>
     */
    emE1ErrE1ChainGroupInvalid(5, 5),
    /**
     * <code>emE1ErrSerialProtocolTypeInvalid = 6;</code>
     */
    emE1ErrSerialProtocolTypeInvalid(6, 6),
    /**
     * <code>emE1ErrSerialEchoIntervalInvalid = 7;</code>
     */
    emE1ErrSerialEchoIntervalInvalid(7, 7),
    /**
     * <code>emE1ErrSerialEchoMaxRetryInvalid = 8;</code>
     */
    emE1ErrSerialEchoMaxRetryInvalid(8, 8),
    /**
     * <code>emE1ErrStringLenOverflow = 9;</code>
     */
    emE1ErrStringLenOverflow(9, 9),
    /**
     * <code>emE1ErrNipOptErr = 10;</code>
     */
    emE1ErrNipOptErr(10, 10),
    /**
     * <code>emE1ErrChainNotConfig = 11;</code>
     */
    emE1ErrChainNotConfig(11, 11),
    /**
     * <code>emE1ErrChainConflict = 12;</code>
     */
    emE1ErrChainConflict(12, 12),
    /**
     * <code>emE1ErrPppAuthTypeInvalid = 13;</code>
     */
    emE1ErrPppAuthTypeInvalid(13, 13),
    /**
     * <code>emE1ErrPppFragTooShort = 14;</code>
     */
    emE1ErrPppFragTooShort(14, 14),
    /**
     * <code>emE1ParamCheckErr = 15;</code>
     */
    emE1ParamCheckErr(15, 15),
    /**
     * <code>emE1ParamConflict = 16;</code>
     */
    emE1ParamConflict(16, 16),
    ;

    /**
     * <code>emE1ErrNone = 0;</code>
     */
    public static final int emE1ErrNone_VALUE = 0;
    /**
     * <code>emE1ErrParamException = 1;</code>
     */
    public static final int emE1ErrParamException_VALUE = 1;
    /**
     * <code>emE1ErrSerialIdInvalid = 2;</code>
     */
    public static final int emE1ErrSerialIdInvalid_VALUE = 2;
    /**
     * <code>emE1ErrE1IdInvalid = 3;</code>
     */
    public static final int emE1ErrE1IdInvalid_VALUE = 3;
    /**
     * <code>emE1ErrE1TsMaskInvalid = 4;</code>
     */
    public static final int emE1ErrE1TsMaskInvalid_VALUE = 4;
    /**
     * <code>emE1ErrE1ChainGroupInvalid = 5;</code>
     */
    public static final int emE1ErrE1ChainGroupInvalid_VALUE = 5;
    /**
     * <code>emE1ErrSerialProtocolTypeInvalid = 6;</code>
     */
    public static final int emE1ErrSerialProtocolTypeInvalid_VALUE = 6;
    /**
     * <code>emE1ErrSerialEchoIntervalInvalid = 7;</code>
     */
    public static final int emE1ErrSerialEchoIntervalInvalid_VALUE = 7;
    /**
     * <code>emE1ErrSerialEchoMaxRetryInvalid = 8;</code>
     */
    public static final int emE1ErrSerialEchoMaxRetryInvalid_VALUE = 8;
    /**
     * <code>emE1ErrStringLenOverflow = 9;</code>
     */
    public static final int emE1ErrStringLenOverflow_VALUE = 9;
    /**
     * <code>emE1ErrNipOptErr = 10;</code>
     */
    public static final int emE1ErrNipOptErr_VALUE = 10;
    /**
     * <code>emE1ErrChainNotConfig = 11;</code>
     */
    public static final int emE1ErrChainNotConfig_VALUE = 11;
    /**
     * <code>emE1ErrChainConflict = 12;</code>
     */
    public static final int emE1ErrChainConflict_VALUE = 12;
    /**
     * <code>emE1ErrPppAuthTypeInvalid = 13;</code>
     */
    public static final int emE1ErrPppAuthTypeInvalid_VALUE = 13;
    /**
     * <code>emE1ErrPppFragTooShort = 14;</code>
     */
    public static final int emE1ErrPppFragTooShort_VALUE = 14;
    /**
     * <code>emE1ParamCheckErr = 15;</code>
     */
    public static final int emE1ParamCheckErr_VALUE = 15;
    /**
     * <code>emE1ParamConflict = 16;</code>
     */
    public static final int emE1ParamConflict_VALUE = 16;


    public final int getNumber() { return value; }

    public static EmE1LinkErrReason valueOf(int value) {
      switch (value) {
        case 0: return emE1ErrNone;
        case 1: return emE1ErrParamException;
        case 2: return emE1ErrSerialIdInvalid;
        case 3: return emE1ErrE1IdInvalid;
        case 4: return emE1ErrE1TsMaskInvalid;
        case 5: return emE1ErrE1ChainGroupInvalid;
        case 6: return emE1ErrSerialProtocolTypeInvalid;
        case 7: return emE1ErrSerialEchoIntervalInvalid;
        case 8: return emE1ErrSerialEchoMaxRetryInvalid;
        case 9: return emE1ErrStringLenOverflow;
        case 10: return emE1ErrNipOptErr;
        case 11: return emE1ErrChainNotConfig;
        case 12: return emE1ErrChainConflict;
        case 13: return emE1ErrPppAuthTypeInvalid;
        case 14: return emE1ErrPppFragTooShort;
        case 15: return emE1ParamCheckErr;
        case 16: return emE1ParamConflict;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmE1LinkErrReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmE1LinkErrReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmE1LinkErrReason>() {
            public EmE1LinkErrReason findValueByNumber(int number) {
              return EmE1LinkErrReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(174);
    }

    private static final EmE1LinkErrReason[] VALUES = values();

    public static EmE1LinkErrReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmE1LinkErrReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmE1LinkErrReason)
  }

  /**
   * Protobuf enum {@code mt.EmPingErrcode}
   *
   * <pre>
   ** Ping错误码 
   * </pre>
   */
  public enum EmPingErrcode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPingReply = 0;</code>
     *
     * <pre>
     *ping包正常回应
     * </pre>
     */
    emPingReply(0, 0),
    /**
     * <code>emPingTimeout = 1;</code>
     *
     * <pre>
     *ping包超时
     * </pre>
     */
    emPingTimeout(1, 1),
    /**
     * <code>emPingError = 2;</code>
     *
     * <pre>
     *ping包系统错误
     * </pre>
     */
    emPingError(2, 2),
    /**
     * <code>emPingNetUnreach = 3;</code>
     *
     * <pre>
     *ping包网络不可达 
     * </pre>
     */
    emPingNetUnreach(3, 3),
    ;

    /**
     * <code>emPingReply = 0;</code>
     *
     * <pre>
     *ping包正常回应
     * </pre>
     */
    public static final int emPingReply_VALUE = 0;
    /**
     * <code>emPingTimeout = 1;</code>
     *
     * <pre>
     *ping包超时
     * </pre>
     */
    public static final int emPingTimeout_VALUE = 1;
    /**
     * <code>emPingError = 2;</code>
     *
     * <pre>
     *ping包系统错误
     * </pre>
     */
    public static final int emPingError_VALUE = 2;
    /**
     * <code>emPingNetUnreach = 3;</code>
     *
     * <pre>
     *ping包网络不可达 
     * </pre>
     */
    public static final int emPingNetUnreach_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmPingErrcode valueOf(int value) {
      switch (value) {
        case 0: return emPingReply;
        case 1: return emPingTimeout;
        case 2: return emPingError;
        case 3: return emPingNetUnreach;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPingErrcode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPingErrcode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPingErrcode>() {
            public EmPingErrcode findValueByNumber(int number) {
              return EmPingErrcode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(175);
    }

    private static final EmPingErrcode[] VALUES = values();

    public static EmPingErrcode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPingErrcode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPingErrcode)
  }

  /**
   * Protobuf enum {@code mt.EmUpgradeType}
   */
  public enum EmUpgradeType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSusUpgrade = 1;</code>
     *
     * <pre>
     *远端升级
     * </pre>
     */
    emSusUpgrade(0, 1),
    /**
     * <code>emLocalUpgrade = 2;</code>
     *
     * <pre>
     *本地升级
     * </pre>
     */
    emLocalUpgrade(1, 2),
    /**
     * <code>emMtcUpgrade = 3;</code>
     *
     * <pre>
     *mtc升级
     * </pre>
     */
    emMtcUpgrade(2, 3),
    /**
     * <code>emMtUpgrade = 4;</code>
     *
     * <pre>
     *终端自用升级
     * </pre>
     */
    emMtUpgrade(3, 4),
    ;

    /**
     * <code>emSusUpgrade = 1;</code>
     *
     * <pre>
     *远端升级
     * </pre>
     */
    public static final int emSusUpgrade_VALUE = 1;
    /**
     * <code>emLocalUpgrade = 2;</code>
     *
     * <pre>
     *本地升级
     * </pre>
     */
    public static final int emLocalUpgrade_VALUE = 2;
    /**
     * <code>emMtcUpgrade = 3;</code>
     *
     * <pre>
     *mtc升级
     * </pre>
     */
    public static final int emMtcUpgrade_VALUE = 3;
    /**
     * <code>emMtUpgrade = 4;</code>
     *
     * <pre>
     *终端自用升级
     * </pre>
     */
    public static final int emMtUpgrade_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmUpgradeType valueOf(int value) {
      switch (value) {
        case 1: return emSusUpgrade;
        case 2: return emLocalUpgrade;
        case 3: return emMtcUpgrade;
        case 4: return emMtUpgrade;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmUpgradeType>() {
            public EmUpgradeType findValueByNumber(int number) {
              return EmUpgradeType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(176);
    }

    private static final EmUpgradeType[] VALUES = values();

    public static EmUpgradeType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmUpgradeType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmUpgradeType)
  }

  /**
   * Protobuf enum {@code mt.EmUpgradeNotify}
   */
  public enum EmUpgradeNotify
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFileCheckBgn = 0;</code>
     *
     * <pre>
     * 文件检查开始
     * </pre>
     */
    emFileCheckBgn(0, 0),
    /**
     * <code>emWholeUpgradeBgn = 1;</code>
     *
     * <pre>
     * 整体升级开始
     * </pre>
     */
    emWholeUpgradeBgn(1, 1),
    /**
     * <code>emFileCheckSuccess = 2;</code>
     *
     * <pre>
     * 文件校验成功
     * </pre>
     */
    emFileCheckSuccess(2, 2),
    /**
     * <code>emWholeUpgradeSuccess = 3;</code>
     *
     * <pre>
     * 整体升级成功
     * </pre>
     */
    emWholeUpgradeSuccess(3, 3),
    /**
     * <code>emUnknownErr = 4;</code>
     *
     * <pre>
     * 未知错误
     * </pre>
     */
    emUnknownErr(4, 4),
    /**
     * <code>emInvalidFileErr = 5;</code>
     *
     * <pre>
     * 升级包错误
     * </pre>
     */
    emInvalidFileErr(5, 5),
    /**
     * <code>emLoadXmlFileErr = 6;</code>
     *
     * <pre>
     * 解析xml错误
     * </pre>
     */
    emLoadXmlFileErr(6, 6),
    /**
     * <code>emFileCheckErr = 7;</code>
     *
     * <pre>
     * 文件校验失败
     * </pre>
     */
    emFileCheckErr(7, 7),
    /**
     * <code>emSysMountBakErr = 8;</code>
     *
     * <pre>
     * 挂载备份分区失败
     * </pre>
     */
    emSysMountBakErr(8, 8),
    /**
     * <code>emUpgradeDriverModuleErr = 9;</code>
     *
     * <pre>
     * 驱动模块升级失败
     * </pre>
     */
    emUpgradeDriverModuleErr(9, 9),
    /**
     * <code>emUpgradeAppModuleErr = 10;</code>
     *
     * <pre>
     * 应用模块升级失败
     * </pre>
     */
    emUpgradeAppModuleErr(10, 10),
    /**
     * <code>emUpgradeExeModuleErr = 11;</code>
     *
     * <pre>
     * 可执行模块升级失败
     * </pre>
     */
    emUpgradeExeModuleErr(11, 11),
    ;

    /**
     * <code>emFileCheckBgn = 0;</code>
     *
     * <pre>
     * 文件检查开始
     * </pre>
     */
    public static final int emFileCheckBgn_VALUE = 0;
    /**
     * <code>emWholeUpgradeBgn = 1;</code>
     *
     * <pre>
     * 整体升级开始
     * </pre>
     */
    public static final int emWholeUpgradeBgn_VALUE = 1;
    /**
     * <code>emFileCheckSuccess = 2;</code>
     *
     * <pre>
     * 文件校验成功
     * </pre>
     */
    public static final int emFileCheckSuccess_VALUE = 2;
    /**
     * <code>emWholeUpgradeSuccess = 3;</code>
     *
     * <pre>
     * 整体升级成功
     * </pre>
     */
    public static final int emWholeUpgradeSuccess_VALUE = 3;
    /**
     * <code>emUnknownErr = 4;</code>
     *
     * <pre>
     * 未知错误
     * </pre>
     */
    public static final int emUnknownErr_VALUE = 4;
    /**
     * <code>emInvalidFileErr = 5;</code>
     *
     * <pre>
     * 升级包错误
     * </pre>
     */
    public static final int emInvalidFileErr_VALUE = 5;
    /**
     * <code>emLoadXmlFileErr = 6;</code>
     *
     * <pre>
     * 解析xml错误
     * </pre>
     */
    public static final int emLoadXmlFileErr_VALUE = 6;
    /**
     * <code>emFileCheckErr = 7;</code>
     *
     * <pre>
     * 文件校验失败
     * </pre>
     */
    public static final int emFileCheckErr_VALUE = 7;
    /**
     * <code>emSysMountBakErr = 8;</code>
     *
     * <pre>
     * 挂载备份分区失败
     * </pre>
     */
    public static final int emSysMountBakErr_VALUE = 8;
    /**
     * <code>emUpgradeDriverModuleErr = 9;</code>
     *
     * <pre>
     * 驱动模块升级失败
     * </pre>
     */
    public static final int emUpgradeDriverModuleErr_VALUE = 9;
    /**
     * <code>emUpgradeAppModuleErr = 10;</code>
     *
     * <pre>
     * 应用模块升级失败
     * </pre>
     */
    public static final int emUpgradeAppModuleErr_VALUE = 10;
    /**
     * <code>emUpgradeExeModuleErr = 11;</code>
     *
     * <pre>
     * 可执行模块升级失败
     * </pre>
     */
    public static final int emUpgradeExeModuleErr_VALUE = 11;


    public final int getNumber() { return value; }

    public static EmUpgradeNotify valueOf(int value) {
      switch (value) {
        case 0: return emFileCheckBgn;
        case 1: return emWholeUpgradeBgn;
        case 2: return emFileCheckSuccess;
        case 3: return emWholeUpgradeSuccess;
        case 4: return emUnknownErr;
        case 5: return emInvalidFileErr;
        case 6: return emLoadXmlFileErr;
        case 7: return emFileCheckErr;
        case 8: return emSysMountBakErr;
        case 9: return emUpgradeDriverModuleErr;
        case 10: return emUpgradeAppModuleErr;
        case 11: return emUpgradeExeModuleErr;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeNotify>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeNotify>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmUpgradeNotify>() {
            public EmUpgradeNotify findValueByNumber(int number) {
              return EmUpgradeNotify.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(177);
    }

    private static final EmUpgradeNotify[] VALUES = values();

    public static EmUpgradeNotify valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmUpgradeNotify(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmUpgradeNotify)
  }

  /**
   * Protobuf enum {@code mt.EmNetConflictType}
   *
   * <pre>
   **网络冲突类型
   * </pre>
   */
  public enum EmNetConflictType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConflictType_None = 0;</code>
     */
    emConflictType_None(0, 0),
    /**
     * <code>emConflictType_Ip = 1;</code>
     */
    emConflictType_Ip(1, 1),
    /**
     * <code>emConflictType_Mac = 2;</code>
     */
    emConflictType_Mac(2, 2),
    /**
     * <code>emConflictType_Both = 3;</code>
     */
    emConflictType_Both(3, 3),
    ;

    /**
     * <code>emConflictType_None = 0;</code>
     */
    public static final int emConflictType_None_VALUE = 0;
    /**
     * <code>emConflictType_Ip = 1;</code>
     */
    public static final int emConflictType_Ip_VALUE = 1;
    /**
     * <code>emConflictType_Mac = 2;</code>
     */
    public static final int emConflictType_Mac_VALUE = 2;
    /**
     * <code>emConflictType_Both = 3;</code>
     */
    public static final int emConflictType_Both_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNetConflictType valueOf(int value) {
      switch (value) {
        case 0: return emConflictType_None;
        case 1: return emConflictType_Ip;
        case 2: return emConflictType_Mac;
        case 3: return emConflictType_Both;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNetConflictType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNetConflictType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNetConflictType>() {
            public EmNetConflictType findValueByNumber(int number) {
              return EmNetConflictType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(178);
    }

    private static final EmNetConflictType[] VALUES = values();

    public static EmNetConflictType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNetConflictType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmNetConflictType)
  }

  /**
   * Protobuf enum {@code mt.EmHDMicGain}
   *
   * <pre>
   *MIC增益
   * </pre>
   */
  public enum EmHDMicGain
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMicGainOff = 0;</code>
     */
    emMicGainOff(0, 0),
    /**
     * <code>emMicGainLow = 1;</code>
     */
    emMicGainLow(1, 1),
    /**
     * <code>emMicGainMiddle = 2;</code>
     */
    emMicGainMiddle(2, 2),
    /**
     * <code>emMicGainHigh = 3;</code>
     */
    emMicGainHigh(3, 3),
    ;

    /**
     * <code>emMicGainOff = 0;</code>
     */
    public static final int emMicGainOff_VALUE = 0;
    /**
     * <code>emMicGainLow = 1;</code>
     */
    public static final int emMicGainLow_VALUE = 1;
    /**
     * <code>emMicGainMiddle = 2;</code>
     */
    public static final int emMicGainMiddle_VALUE = 2;
    /**
     * <code>emMicGainHigh = 3;</code>
     */
    public static final int emMicGainHigh_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmHDMicGain valueOf(int value) {
      switch (value) {
        case 0: return emMicGainOff;
        case 1: return emMicGainLow;
        case 2: return emMicGainMiddle;
        case 3: return emMicGainHigh;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHDMicGain>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHDMicGain>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHDMicGain>() {
            public EmHDMicGain findValueByNumber(int number) {
              return EmHDMicGain.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(179);
    }

    private static final EmHDMicGain[] VALUES = values();

    public static EmHDMicGain valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHDMicGain(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHDMicGain)
  }

  /**
   * Protobuf enum {@code mt.EmPPPoEDialMode}
   */
  public enum EmPPPoEDialMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPPPoEDialManual = 0;</code>
     */
    emPPPoEDialManual(0, 0),
    /**
     * <code>emPPPoEDialAuto = 1;</code>
     */
    emPPPoEDialAuto(1, 1),
    ;

    /**
     * <code>emPPPoEDialManual = 0;</code>
     */
    public static final int emPPPoEDialManual_VALUE = 0;
    /**
     * <code>emPPPoEDialAuto = 1;</code>
     */
    public static final int emPPPoEDialAuto_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmPPPoEDialMode valueOf(int value) {
      switch (value) {
        case 0: return emPPPoEDialManual;
        case 1: return emPPPoEDialAuto;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPPPoEDialMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPPPoEDialMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPPPoEDialMode>() {
            public EmPPPoEDialMode findValueByNumber(int number) {
              return EmPPPoEDialMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(180);
    }

    private static final EmPPPoEDialMode[] VALUES = values();

    public static EmPPPoEDialMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPPPoEDialMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPPPoEDialMode)
  }

  /**
   * Protobuf enum {@code mt.EmEquipmentUpgrading}
   */
  public enum EmEquipmentUpgrading
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEUbegin = 0;</code>
     */
    emEUbegin(0, 0),
    /**
     * <code>emEUHD120 = 1;</code>
     *
     * <pre>
     *摄像头Hd120
     * </pre>
     */
    emEUHD120(1, 1),
    /**
     * <code>emEUHD200 = 2;</code>
     *
     * <pre>
     *摄像头Hd200
     * </pre>
     */
    emEUHD200(2, 2),
    /**
     * <code>emEUHD120E = 3;</code>
     *
     * <pre>
     *摄像头Hd120E
     * </pre>
     */
    emEUHD120E(3, 3),
    /**
     * <code>emEUHD200E = 4;</code>
     *
     * <pre>
     *摄像头Hd200E
     * </pre>
     */
    emEUHD200E(4, 4),
    /**
     * <code>emEUMoon50 = 5;</code>
     *
     * <pre>
     *摄像头moon50_4k
     * </pre>
     */
    emEUMoon50(5, 5),
    /**
     * <code>emEUMoon50_1080p = 6;</code>
     *
     * <pre>
     *摄像头moon50_1080p
     * </pre>
     */
    emEUMoon50_1080p(6, 6),
    /**
     * <code>emEUMoon70_1080p = 7;</code>
     *
     * <pre>
     *摄像头moon70_1080p
     * </pre>
     */
    emEUMoon70_1080p(7, 7),
    ;

    /**
     * <code>emEUbegin = 0;</code>
     */
    public static final int emEUbegin_VALUE = 0;
    /**
     * <code>emEUHD120 = 1;</code>
     *
     * <pre>
     *摄像头Hd120
     * </pre>
     */
    public static final int emEUHD120_VALUE = 1;
    /**
     * <code>emEUHD200 = 2;</code>
     *
     * <pre>
     *摄像头Hd200
     * </pre>
     */
    public static final int emEUHD200_VALUE = 2;
    /**
     * <code>emEUHD120E = 3;</code>
     *
     * <pre>
     *摄像头Hd120E
     * </pre>
     */
    public static final int emEUHD120E_VALUE = 3;
    /**
     * <code>emEUHD200E = 4;</code>
     *
     * <pre>
     *摄像头Hd200E
     * </pre>
     */
    public static final int emEUHD200E_VALUE = 4;
    /**
     * <code>emEUMoon50 = 5;</code>
     *
     * <pre>
     *摄像头moon50_4k
     * </pre>
     */
    public static final int emEUMoon50_VALUE = 5;
    /**
     * <code>emEUMoon50_1080p = 6;</code>
     *
     * <pre>
     *摄像头moon50_1080p
     * </pre>
     */
    public static final int emEUMoon50_1080p_VALUE = 6;
    /**
     * <code>emEUMoon70_1080p = 7;</code>
     *
     * <pre>
     *摄像头moon70_1080p
     * </pre>
     */
    public static final int emEUMoon70_1080p_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmEquipmentUpgrading valueOf(int value) {
      switch (value) {
        case 0: return emEUbegin;
        case 1: return emEUHD120;
        case 2: return emEUHD200;
        case 3: return emEUHD120E;
        case 4: return emEUHD200E;
        case 5: return emEUMoon50;
        case 6: return emEUMoon50_1080p;
        case 7: return emEUMoon70_1080p;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmEquipmentUpgrading>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmEquipmentUpgrading>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmEquipmentUpgrading>() {
            public EmEquipmentUpgrading findValueByNumber(int number) {
              return EmEquipmentUpgrading.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(181);
    }

    private static final EmEquipmentUpgrading[] VALUES = values();

    public static EmEquipmentUpgrading valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmEquipmentUpgrading(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmEquipmentUpgrading)
  }

  /**
   * Protobuf enum {@code mt.EmUartNum}
   *
   * <pre>
   *数字mic升级/查询的串口设备号
   * </pre>
   */
  public enum EmUartNum
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUartDMIC1 = 0;</code>
     *
     * <pre>
     *数字mic1
     * </pre>
     */
    emUartDMIC1(0, 0),
    /**
     * <code>emUartDMIC2 = 1;</code>
     *
     * <pre>
     *数字mic2
     * </pre>
     */
    emUartDMIC2(1, 1),
    ;

    /**
     * <code>emUartDMIC1 = 0;</code>
     *
     * <pre>
     *数字mic1
     * </pre>
     */
    public static final int emUartDMIC1_VALUE = 0;
    /**
     * <code>emUartDMIC2 = 1;</code>
     *
     * <pre>
     *数字mic2
     * </pre>
     */
    public static final int emUartDMIC2_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmUartNum valueOf(int value) {
      switch (value) {
        case 0: return emUartDMIC1;
        case 1: return emUartDMIC2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmUartNum>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmUartNum>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmUartNum>() {
            public EmUartNum findValueByNumber(int number) {
              return EmUartNum.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(182);
    }

    private static final EmUartNum[] VALUES = values();

    public static EmUartNum valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmUartNum(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmUartNum)
  }

  /**
   * Protobuf enum {@code mt.EmPicFormat}
   *
   * <pre>
   *图片格式
   * </pre>
   */
  public enum EmPicFormat
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emJPEG = 0;</code>
     */
    emJPEG(0, 0),
    /**
     * <code>emBMP = 1;</code>
     */
    emBMP(1, 1),
    ;

    /**
     * <code>emJPEG = 0;</code>
     */
    public static final int emJPEG_VALUE = 0;
    /**
     * <code>emBMP = 1;</code>
     */
    public static final int emBMP_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmPicFormat valueOf(int value) {
      switch (value) {
        case 0: return emJPEG;
        case 1: return emBMP;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPicFormat>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPicFormat>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPicFormat>() {
            public EmPicFormat findValueByNumber(int number) {
              return EmPicFormat.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(183);
    }

    private static final EmPicFormat[] VALUES = values();

    public static EmPicFormat valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPicFormat(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPicFormat)
  }

  /**
   * Protobuf enum {@code mt.EmImgParam}
   *
   * <pre>
   *图像参数
   * </pre>
   */
  public enum EmImgParam
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emHue = 0;</code>
     *
     * <pre>
     *色度
     * </pre>
     */
    emHue(0, 0),
    /**
     * <code>emWhiteBalance = 1;</code>
     *
     * <pre>
     *白平衡
     * </pre>
     */
    emWhiteBalance(1, 1),
    /**
     * <code>emContrast = 2;</code>
     *
     * <pre>
     *对比度
     * </pre>
     */
    emContrast(2, 2),
    /**
     * <code>emSaturation = 3;</code>
     *
     * <pre>
     *饱和度
     * </pre>
     */
    emSaturation(3, 3),
    /**
     * <code>emSharpness = 4;</code>
     *
     * <pre>
     *锐度
     * </pre>
     */
    emSharpness(4, 4),
    /**
     * <code>emBright = 5;</code>
     *
     * <pre>
     *亮度
     * </pre>
     */
    emBright(5, 5),
    ;

    /**
     * <code>emHue = 0;</code>
     *
     * <pre>
     *色度
     * </pre>
     */
    public static final int emHue_VALUE = 0;
    /**
     * <code>emWhiteBalance = 1;</code>
     *
     * <pre>
     *白平衡
     * </pre>
     */
    public static final int emWhiteBalance_VALUE = 1;
    /**
     * <code>emContrast = 2;</code>
     *
     * <pre>
     *对比度
     * </pre>
     */
    public static final int emContrast_VALUE = 2;
    /**
     * <code>emSaturation = 3;</code>
     *
     * <pre>
     *饱和度
     * </pre>
     */
    public static final int emSaturation_VALUE = 3;
    /**
     * <code>emSharpness = 4;</code>
     *
     * <pre>
     *锐度
     * </pre>
     */
    public static final int emSharpness_VALUE = 4;
    /**
     * <code>emBright = 5;</code>
     *
     * <pre>
     *亮度
     * </pre>
     */
    public static final int emBright_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmImgParam valueOf(int value) {
      switch (value) {
        case 0: return emHue;
        case 1: return emWhiteBalance;
        case 2: return emContrast;
        case 3: return emSaturation;
        case 4: return emSharpness;
        case 5: return emBright;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmImgParam>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmImgParam>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmImgParam>() {
            public EmImgParam findValueByNumber(int number) {
              return EmImgParam.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(184);
    }

    private static final EmImgParam[] VALUES = values();

    public static EmImgParam valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmImgParam(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmImgParam)
  }

  /**
   * Protobuf enum {@code mt.EmFxoState}
   *
   * <pre>
   *Fxo电话状态
   * </pre>
   */
  public enum EmFxoState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFxoIdle = 0;</code>
     */
    emFxoIdle(0, 0),
    /**
     * <code>emFxoCallIn = 1;</code>
     */
    emFxoCallIn(1, 1),
    /**
     * <code>emFxoCalling = 2;</code>
     */
    emFxoCalling(2, 2),
    /**
     * <code>emFxoConnect = 3;</code>
     */
    emFxoConnect(3, 3),
    ;

    /**
     * <code>emFxoIdle = 0;</code>
     */
    public static final int emFxoIdle_VALUE = 0;
    /**
     * <code>emFxoCallIn = 1;</code>
     */
    public static final int emFxoCallIn_VALUE = 1;
    /**
     * <code>emFxoCalling = 2;</code>
     */
    public static final int emFxoCalling_VALUE = 2;
    /**
     * <code>emFxoConnect = 3;</code>
     */
    public static final int emFxoConnect_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmFxoState valueOf(int value) {
      switch (value) {
        case 0: return emFxoIdle;
        case 1: return emFxoCallIn;
        case 2: return emFxoCalling;
        case 3: return emFxoConnect;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFxoState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFxoState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFxoState>() {
            public EmFxoState findValueByNumber(int number) {
              return EmFxoState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(185);
    }

    private static final EmFxoState[] VALUES = values();

    public static EmFxoState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFxoState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFxoState)
  }

  /**
   * Protobuf enum {@code mt.EmSdiInOut}
   *
   * <pre>
   *SDI接口数量
   * </pre>
   */
  public enum EmSdiInOut
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSdiNone = 0;</code>
     *
     * <pre>
     *无sdi
     * </pre>
     */
    emSdiNone(0, 0),
    /**
     * <code>emSdiTwoIn = 1;</code>
     *
     * <pre>
     *两进口
     * </pre>
     */
    emSdiTwoIn(1, 1),
    /**
     * <code>emSdiOneInOneOut = 2;</code>
     *
     * <pre>
     *一进口一出口
     * </pre>
     */
    emSdiOneInOneOut(2, 2),
    ;

    /**
     * <code>emSdiNone = 0;</code>
     *
     * <pre>
     *无sdi
     * </pre>
     */
    public static final int emSdiNone_VALUE = 0;
    /**
     * <code>emSdiTwoIn = 1;</code>
     *
     * <pre>
     *两进口
     * </pre>
     */
    public static final int emSdiTwoIn_VALUE = 1;
    /**
     * <code>emSdiOneInOneOut = 2;</code>
     *
     * <pre>
     *一进口一出口
     * </pre>
     */
    public static final int emSdiOneInOneOut_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmSdiInOut valueOf(int value) {
      switch (value) {
        case 0: return emSdiNone;
        case 1: return emSdiTwoIn;
        case 2: return emSdiOneInOneOut;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSdiInOut>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSdiInOut>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSdiInOut>() {
            public EmSdiInOut findValueByNumber(int number) {
              return EmSdiInOut.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(186);
    }

    private static final EmSdiInOut[] VALUES = values();

    public static EmSdiInOut valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSdiInOut(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSdiInOut)
  }

  /**
   * Protobuf enum {@code mt.EmMsgFromSource}
   *
   * <pre>
   *消息来源
   * </pre>
   */
  public enum EmMsgFromSource
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMsgFromInvalid = 0;</code>
     */
    emMsgFromInvalid(0, 0),
    /**
     * <code>emMsgFromWebMtc = 1;</code>
     */
    emMsgFromWebMtc(1, 1),
    /**
     * <code>emMsgFromOsd = 2;</code>
     */
    emMsgFromOsd(2, 2),
    ;

    /**
     * <code>emMsgFromInvalid = 0;</code>
     */
    public static final int emMsgFromInvalid_VALUE = 0;
    /**
     * <code>emMsgFromWebMtc = 1;</code>
     */
    public static final int emMsgFromWebMtc_VALUE = 1;
    /**
     * <code>emMsgFromOsd = 2;</code>
     */
    public static final int emMsgFromOsd_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMsgFromSource valueOf(int value) {
      switch (value) {
        case 0: return emMsgFromInvalid;
        case 1: return emMsgFromWebMtc;
        case 2: return emMsgFromOsd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMsgFromSource>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMsgFromSource>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMsgFromSource>() {
            public EmMsgFromSource findValueByNumber(int number) {
              return EmMsgFromSource.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(187);
    }

    private static final EmMsgFromSource[] VALUES = values();

    public static EmMsgFromSource valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMsgFromSource(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMsgFromSource)
  }

  /**
   * Protobuf enum {@code mt.EmNmsLoginResult}
   *
   * <pre>
   *登录网服务器结果
   * </pre>
   */
  public enum EmNmsLoginResult
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNmsLogin_Success = 0;</code>
     *
     * <pre>
     *登录成功
     * </pre>
     */
    emNmsLogin_Success(0, 0),
    /**
     * <code>emNmsLogin_ErrorID = 1;</code>
     *
     * <pre>
     *登录ID错误
     * </pre>
     */
    emNmsLogin_ErrorID(1, 1),
    /**
     * <code>emNmsLogin_RepeatLogin = 2;</code>
     *
     * <pre>
     *终端ID重复登录
     * </pre>
     */
    emNmsLogin_RepeatLogin(2, 2),
    /**
     * <code>emNmsLogin_ErrorDevType = 3;</code>
     *
     * <pre>
     *错误设备类型
     * </pre>
     */
    emNmsLogin_ErrorDevType(3, 3),
    /**
     * <code>emNmsLogin_DisConnect = 255;</code>
     *
     * <pre>
     *断链
     * </pre>
     */
    emNmsLogin_DisConnect(4, 255),
    ;

    /**
     * <code>emNmsLogin_Success = 0;</code>
     *
     * <pre>
     *登录成功
     * </pre>
     */
    public static final int emNmsLogin_Success_VALUE = 0;
    /**
     * <code>emNmsLogin_ErrorID = 1;</code>
     *
     * <pre>
     *登录ID错误
     * </pre>
     */
    public static final int emNmsLogin_ErrorID_VALUE = 1;
    /**
     * <code>emNmsLogin_RepeatLogin = 2;</code>
     *
     * <pre>
     *终端ID重复登录
     * </pre>
     */
    public static final int emNmsLogin_RepeatLogin_VALUE = 2;
    /**
     * <code>emNmsLogin_ErrorDevType = 3;</code>
     *
     * <pre>
     *错误设备类型
     * </pre>
     */
    public static final int emNmsLogin_ErrorDevType_VALUE = 3;
    /**
     * <code>emNmsLogin_DisConnect = 255;</code>
     *
     * <pre>
     *断链
     * </pre>
     */
    public static final int emNmsLogin_DisConnect_VALUE = 255;


    public final int getNumber() { return value; }

    public static EmNmsLoginResult valueOf(int value) {
      switch (value) {
        case 0: return emNmsLogin_Success;
        case 1: return emNmsLogin_ErrorID;
        case 2: return emNmsLogin_RepeatLogin;
        case 3: return emNmsLogin_ErrorDevType;
        case 255: return emNmsLogin_DisConnect;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNmsLoginResult>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNmsLoginResult>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNmsLoginResult>() {
            public EmNmsLoginResult findValueByNumber(int number) {
              return EmNmsLoginResult.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(188);
    }

    private static final EmNmsLoginResult[] VALUES = values();

    public static EmNmsLoginResult valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNmsLoginResult(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmNmsLoginResult)
  }

  /**
   * Protobuf enum {@code mt.EmTimeZone}
   *
   * <pre>
   *时区选项内容
   * </pre>
   */
  public enum EmTimeZone
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emTimeZone_GMT = 0;</code>
     *
     * <pre>
     * 格林威治标准时间 GMT
     * </pre>
     */
    emTimeZone_GMT(0, 0),
    /**
     * <code>emTimeZone_UTC = 1;</code>
     *
     * <pre>
     * 全球标准时间 GMT 
     * </pre>
     */
    emTimeZone_UTC(1, 1),
    /**
     * <code>emTimeZone_ECT = 2;</code>
     *
     * <pre>
     *欧洲中部时间 GMT+1:00 
     * </pre>
     */
    emTimeZone_ECT(2, 2),
    /**
     * <code>emTimeZone_EET = 3;</code>
     *
     * <pre>
     *东欧时间 GMT+2:00 
     * </pre>
     */
    emTimeZone_EET(3, 3),
    /**
     * <code>emTimeZone_ART = 4;</code>
     *
     * <pre>
     *（阿拉伯）埃及标准时间 GMT+2:00
     * </pre>
     */
    emTimeZone_ART(4, 4),
    /**
     * <code>emTimeZone_EAT = 5;</code>
     *
     * <pre>
     *东非时间 GMT+3:00 
     * </pre>
     */
    emTimeZone_EAT(5, 5),
    /**
     * <code>emTimeZone_MET = 6;</code>
     *
     * <pre>
     *中东时间 GMT+3:30 
     * </pre>
     */
    emTimeZone_MET(6, 6),
    /**
     * <code>emTimeZone_NET = 7;</code>
     *
     * <pre>
     *近东时间 GMT+4:00 
     * </pre>
     */
    emTimeZone_NET(7, 7),
    /**
     * <code>emTimeZone_PLT = 8;</code>
     *
     * <pre>
     *巴基斯坦拉合尔时间 GMT+5:00 
     * </pre>
     */
    emTimeZone_PLT(8, 8),
    /**
     * <code>emTimeZone_IST = 9;</code>
     *
     * <pre>
     *印度标准时间 GMT+5:30 
     * </pre>
     */
    emTimeZone_IST(9, 9),
    /**
     * <code>emTimeZone_BST = 10;</code>
     *
     * <pre>
     *孟加拉国标准时间 GMT+6:00 
     * </pre>
     */
    emTimeZone_BST(10, 10),
    /**
     * <code>emTimeZone_VST = 11;</code>
     *
     * <pre>
     *越南标准时间 GMT+7:00 
     * </pre>
     */
    emTimeZone_VST(11, 11),
    /**
     * <code>emTimeZone_CTT = 12;</code>
     *
     * <pre>
     *中国北京时间 GMT+8:00 
     * </pre>
     */
    emTimeZone_CTT(12, 12),
    /**
     * <code>emTimeZone_JST = 13;</code>
     *
     * <pre>
     *日本标准时间 GMT+9:00 
     * </pre>
     */
    emTimeZone_JST(13, 13),
    /**
     * <code>emTimeZone_ACT = 14;</code>
     *
     * <pre>
     *澳大利亚中部时间 GMT+9:30 
     * </pre>
     */
    emTimeZone_ACT(14, 14),
    /**
     * <code>emTimeZone_AET = 15;</code>
     *
     * <pre>
     *澳大利亚东部时间 GMT+10:00
     * </pre>
     */
    emTimeZone_AET(15, 15),
    /**
     * <code>emTimeZone_SST = 16;</code>
     *
     * <pre>
     *所罗门标准时间 GMT+11:00 
     * </pre>
     */
    emTimeZone_SST(16, 16),
    /**
     * <code>emTimeZone_NST = 17;</code>
     *
     * <pre>
     *新西兰标准时间 GMT+12:00 
     * </pre>
     */
    emTimeZone_NST(17, 17),
    /**
     * <code>emTimeZone_MIT = 18;</code>
     *
     * <pre>
     *中途岛时间 GMT-11:00 
     * </pre>
     */
    emTimeZone_MIT(18, 18),
    /**
     * <code>emTimeZone_HST = 19;</code>
     *
     * <pre>
     *夏威夷标准时间 GMT-10:00 
     * </pre>
     */
    emTimeZone_HST(19, 19),
    /**
     * <code>emTimeZone_AST = 20;</code>
     *
     * <pre>
     *阿拉斯加标准时间 GMT-9:00 
     * </pre>
     */
    emTimeZone_AST(20, 20),
    /**
     * <code>emTimeZone_PST = 21;</code>
     *
     * <pre>
     *太平洋标准时间 GMT-8:00 
     * </pre>
     */
    emTimeZone_PST(21, 21),
    /**
     * <code>emTimeZone_PNT = 22;</code>
     *
     * <pre>
     *菲尼克斯标准时间 GMT-7:00 
     * </pre>
     */
    emTimeZone_PNT(22, 22),
    /**
     * <code>emTimeZone_MST = 23;</code>
     *
     * <pre>
     *西部山脉标准时间 GMT-7:00 
     * </pre>
     */
    emTimeZone_MST(23, 23),
    /**
     * <code>emTimeZone_CST = 24;</code>
     *
     * <pre>
     *中部标准时间 GMT-6:00 
     * </pre>
     */
    emTimeZone_CST(24, 24),
    /**
     * <code>emTimeZone_EST = 25;</code>
     *
     * <pre>
     *东部标准时间 GMT-5:00 
     * </pre>
     */
    emTimeZone_EST(25, 25),
    /**
     * <code>emTimeZone_IET = 26;</code>
     *
     * <pre>
     *印第安那东部标准时间 GMT-5:00 
     * </pre>
     */
    emTimeZone_IET(26, 26),
    /**
     * <code>emTimeZone_PRT = 27;</code>
     *
     * <pre>
     *波多黎各和美属维尔京群岛时间 GMT-4:00 
     * </pre>
     */
    emTimeZone_PRT(27, 27),
    /**
     * <code>emTimeZone_CNT = 28;</code>
     *
     * <pre>
     *加拿大纽芬兰时间 GMT-3:30 
     * </pre>
     */
    emTimeZone_CNT(28, 28),
    /**
     * <code>emTimeZone_AGT = 29;</code>
     *
     * <pre>
     *阿根廷标准时间 GMT-3:00 
     * </pre>
     */
    emTimeZone_AGT(29, 29),
    /**
     * <code>emTimeZone_BET = 30;</code>
     *
     * <pre>
     *巴西东部时间 GMT-3:00 
     * </pre>
     */
    emTimeZone_BET(30, 30),
    /**
     * <code>emTimeZone_CAT = 31;</code>
     *
     * <pre>
     *中非时间 GMT-1:00
     * </pre>
     */
    emTimeZone_CAT(31, 31),
    ;

    /**
     * <code>emTimeZone_GMT = 0;</code>
     *
     * <pre>
     * 格林威治标准时间 GMT
     * </pre>
     */
    public static final int emTimeZone_GMT_VALUE = 0;
    /**
     * <code>emTimeZone_UTC = 1;</code>
     *
     * <pre>
     * 全球标准时间 GMT 
     * </pre>
     */
    public static final int emTimeZone_UTC_VALUE = 1;
    /**
     * <code>emTimeZone_ECT = 2;</code>
     *
     * <pre>
     *欧洲中部时间 GMT+1:00 
     * </pre>
     */
    public static final int emTimeZone_ECT_VALUE = 2;
    /**
     * <code>emTimeZone_EET = 3;</code>
     *
     * <pre>
     *东欧时间 GMT+2:00 
     * </pre>
     */
    public static final int emTimeZone_EET_VALUE = 3;
    /**
     * <code>emTimeZone_ART = 4;</code>
     *
     * <pre>
     *（阿拉伯）埃及标准时间 GMT+2:00
     * </pre>
     */
    public static final int emTimeZone_ART_VALUE = 4;
    /**
     * <code>emTimeZone_EAT = 5;</code>
     *
     * <pre>
     *东非时间 GMT+3:00 
     * </pre>
     */
    public static final int emTimeZone_EAT_VALUE = 5;
    /**
     * <code>emTimeZone_MET = 6;</code>
     *
     * <pre>
     *中东时间 GMT+3:30 
     * </pre>
     */
    public static final int emTimeZone_MET_VALUE = 6;
    /**
     * <code>emTimeZone_NET = 7;</code>
     *
     * <pre>
     *近东时间 GMT+4:00 
     * </pre>
     */
    public static final int emTimeZone_NET_VALUE = 7;
    /**
     * <code>emTimeZone_PLT = 8;</code>
     *
     * <pre>
     *巴基斯坦拉合尔时间 GMT+5:00 
     * </pre>
     */
    public static final int emTimeZone_PLT_VALUE = 8;
    /**
     * <code>emTimeZone_IST = 9;</code>
     *
     * <pre>
     *印度标准时间 GMT+5:30 
     * </pre>
     */
    public static final int emTimeZone_IST_VALUE = 9;
    /**
     * <code>emTimeZone_BST = 10;</code>
     *
     * <pre>
     *孟加拉国标准时间 GMT+6:00 
     * </pre>
     */
    public static final int emTimeZone_BST_VALUE = 10;
    /**
     * <code>emTimeZone_VST = 11;</code>
     *
     * <pre>
     *越南标准时间 GMT+7:00 
     * </pre>
     */
    public static final int emTimeZone_VST_VALUE = 11;
    /**
     * <code>emTimeZone_CTT = 12;</code>
     *
     * <pre>
     *中国北京时间 GMT+8:00 
     * </pre>
     */
    public static final int emTimeZone_CTT_VALUE = 12;
    /**
     * <code>emTimeZone_JST = 13;</code>
     *
     * <pre>
     *日本标准时间 GMT+9:00 
     * </pre>
     */
    public static final int emTimeZone_JST_VALUE = 13;
    /**
     * <code>emTimeZone_ACT = 14;</code>
     *
     * <pre>
     *澳大利亚中部时间 GMT+9:30 
     * </pre>
     */
    public static final int emTimeZone_ACT_VALUE = 14;
    /**
     * <code>emTimeZone_AET = 15;</code>
     *
     * <pre>
     *澳大利亚东部时间 GMT+10:00
     * </pre>
     */
    public static final int emTimeZone_AET_VALUE = 15;
    /**
     * <code>emTimeZone_SST = 16;</code>
     *
     * <pre>
     *所罗门标准时间 GMT+11:00 
     * </pre>
     */
    public static final int emTimeZone_SST_VALUE = 16;
    /**
     * <code>emTimeZone_NST = 17;</code>
     *
     * <pre>
     *新西兰标准时间 GMT+12:00 
     * </pre>
     */
    public static final int emTimeZone_NST_VALUE = 17;
    /**
     * <code>emTimeZone_MIT = 18;</code>
     *
     * <pre>
     *中途岛时间 GMT-11:00 
     * </pre>
     */
    public static final int emTimeZone_MIT_VALUE = 18;
    /**
     * <code>emTimeZone_HST = 19;</code>
     *
     * <pre>
     *夏威夷标准时间 GMT-10:00 
     * </pre>
     */
    public static final int emTimeZone_HST_VALUE = 19;
    /**
     * <code>emTimeZone_AST = 20;</code>
     *
     * <pre>
     *阿拉斯加标准时间 GMT-9:00 
     * </pre>
     */
    public static final int emTimeZone_AST_VALUE = 20;
    /**
     * <code>emTimeZone_PST = 21;</code>
     *
     * <pre>
     *太平洋标准时间 GMT-8:00 
     * </pre>
     */
    public static final int emTimeZone_PST_VALUE = 21;
    /**
     * <code>emTimeZone_PNT = 22;</code>
     *
     * <pre>
     *菲尼克斯标准时间 GMT-7:00 
     * </pre>
     */
    public static final int emTimeZone_PNT_VALUE = 22;
    /**
     * <code>emTimeZone_MST = 23;</code>
     *
     * <pre>
     *西部山脉标准时间 GMT-7:00 
     * </pre>
     */
    public static final int emTimeZone_MST_VALUE = 23;
    /**
     * <code>emTimeZone_CST = 24;</code>
     *
     * <pre>
     *中部标准时间 GMT-6:00 
     * </pre>
     */
    public static final int emTimeZone_CST_VALUE = 24;
    /**
     * <code>emTimeZone_EST = 25;</code>
     *
     * <pre>
     *东部标准时间 GMT-5:00 
     * </pre>
     */
    public static final int emTimeZone_EST_VALUE = 25;
    /**
     * <code>emTimeZone_IET = 26;</code>
     *
     * <pre>
     *印第安那东部标准时间 GMT-5:00 
     * </pre>
     */
    public static final int emTimeZone_IET_VALUE = 26;
    /**
     * <code>emTimeZone_PRT = 27;</code>
     *
     * <pre>
     *波多黎各和美属维尔京群岛时间 GMT-4:00 
     * </pre>
     */
    public static final int emTimeZone_PRT_VALUE = 27;
    /**
     * <code>emTimeZone_CNT = 28;</code>
     *
     * <pre>
     *加拿大纽芬兰时间 GMT-3:30 
     * </pre>
     */
    public static final int emTimeZone_CNT_VALUE = 28;
    /**
     * <code>emTimeZone_AGT = 29;</code>
     *
     * <pre>
     *阿根廷标准时间 GMT-3:00 
     * </pre>
     */
    public static final int emTimeZone_AGT_VALUE = 29;
    /**
     * <code>emTimeZone_BET = 30;</code>
     *
     * <pre>
     *巴西东部时间 GMT-3:00 
     * </pre>
     */
    public static final int emTimeZone_BET_VALUE = 30;
    /**
     * <code>emTimeZone_CAT = 31;</code>
     *
     * <pre>
     *中非时间 GMT-1:00
     * </pre>
     */
    public static final int emTimeZone_CAT_VALUE = 31;


    public final int getNumber() { return value; }

    public static EmTimeZone valueOf(int value) {
      switch (value) {
        case 0: return emTimeZone_GMT;
        case 1: return emTimeZone_UTC;
        case 2: return emTimeZone_ECT;
        case 3: return emTimeZone_EET;
        case 4: return emTimeZone_ART;
        case 5: return emTimeZone_EAT;
        case 6: return emTimeZone_MET;
        case 7: return emTimeZone_NET;
        case 8: return emTimeZone_PLT;
        case 9: return emTimeZone_IST;
        case 10: return emTimeZone_BST;
        case 11: return emTimeZone_VST;
        case 12: return emTimeZone_CTT;
        case 13: return emTimeZone_JST;
        case 14: return emTimeZone_ACT;
        case 15: return emTimeZone_AET;
        case 16: return emTimeZone_SST;
        case 17: return emTimeZone_NST;
        case 18: return emTimeZone_MIT;
        case 19: return emTimeZone_HST;
        case 20: return emTimeZone_AST;
        case 21: return emTimeZone_PST;
        case 22: return emTimeZone_PNT;
        case 23: return emTimeZone_MST;
        case 24: return emTimeZone_CST;
        case 25: return emTimeZone_EST;
        case 26: return emTimeZone_IET;
        case 27: return emTimeZone_PRT;
        case 28: return emTimeZone_CNT;
        case 29: return emTimeZone_AGT;
        case 30: return emTimeZone_BET;
        case 31: return emTimeZone_CAT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmTimeZone>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmTimeZone>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmTimeZone>() {
            public EmTimeZone findValueByNumber(int number) {
              return EmTimeZone.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(189);
    }

    private static final EmTimeZone[] VALUES = values();

    public static EmTimeZone valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmTimeZone(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmTimeZone)
  }

  /**
   * Protobuf enum {@code mt.EmMtSmoothSendLevel}
   *
   * <pre>
   *平滑发送等级
   * </pre>
   */
  public enum EmMtSmoothSendLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSmoothSendLevel_Off = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    emSmoothSendLevel_Off(0, 0),
    /**
     * <code>emSmoothSendLevel_High = 1;</code>
     *
     * <pre>
     *高
     * </pre>
     */
    emSmoothSendLevel_High(1, 1),
    /**
     * <code>emSmoothSendLevel_Middle = 2;</code>
     *
     * <pre>
     *中
     * </pre>
     */
    emSmoothSendLevel_Middle(2, 2),
    /**
     * <code>emSmoothSendLevel_Low = 3;</code>
     *
     * <pre>
     *低
     * </pre>
     */
    emSmoothSendLevel_Low(3, 3),
    ;

    /**
     * <code>emSmoothSendLevel_Off = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    public static final int emSmoothSendLevel_Off_VALUE = 0;
    /**
     * <code>emSmoothSendLevel_High = 1;</code>
     *
     * <pre>
     *高
     * </pre>
     */
    public static final int emSmoothSendLevel_High_VALUE = 1;
    /**
     * <code>emSmoothSendLevel_Middle = 2;</code>
     *
     * <pre>
     *中
     * </pre>
     */
    public static final int emSmoothSendLevel_Middle_VALUE = 2;
    /**
     * <code>emSmoothSendLevel_Low = 3;</code>
     *
     * <pre>
     *低
     * </pre>
     */
    public static final int emSmoothSendLevel_Low_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMtSmoothSendLevel valueOf(int value) {
      switch (value) {
        case 0: return emSmoothSendLevel_Off;
        case 1: return emSmoothSendLevel_High;
        case 2: return emSmoothSendLevel_Middle;
        case 3: return emSmoothSendLevel_Low;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtSmoothSendLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtSmoothSendLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtSmoothSendLevel>() {
            public EmMtSmoothSendLevel findValueByNumber(int number) {
              return EmMtSmoothSendLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(190);
    }

    private static final EmMtSmoothSendLevel[] VALUES = values();

    public static EmMtSmoothSendLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtSmoothSendLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtSmoothSendLevel)
  }

  /**
   * Protobuf enum {@code mt.EmRestDualMode}
   */
  public enum EmRestDualMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRestDual_Speaker = 0;</code>
     *
     * <pre>
     * 发言会场
     * </pre>
     */
    emRestDual_Speaker(0, 0),
    /**
     * <code>emRestDual_any = 1;</code>
     *
     * <pre>
     * 任意会场
     * </pre>
     */
    emRestDual_any(1, 1),
    /**
     * <code>emRestDual_assign = 2;</code>
     *
     * <pre>
     * 指定会场
     * </pre>
     */
    emRestDual_assign(2, 2),
    ;

    /**
     * <code>emRestDual_Speaker = 0;</code>
     *
     * <pre>
     * 发言会场
     * </pre>
     */
    public static final int emRestDual_Speaker_VALUE = 0;
    /**
     * <code>emRestDual_any = 1;</code>
     *
     * <pre>
     * 任意会场
     * </pre>
     */
    public static final int emRestDual_any_VALUE = 1;
    /**
     * <code>emRestDual_assign = 2;</code>
     *
     * <pre>
     * 指定会场
     * </pre>
     */
    public static final int emRestDual_assign_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmRestDualMode valueOf(int value) {
      switch (value) {
        case 0: return emRestDual_Speaker;
        case 1: return emRestDual_any;
        case 2: return emRestDual_assign;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRestDualMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRestDualMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRestDualMode>() {
            public EmRestDualMode findValueByNumber(int number) {
              return EmRestDualMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(191);
    }

    private static final EmRestDualMode[] VALUES = values();

    public static EmRestDualMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRestDualMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRestDualMode)
  }

  /**
   * Protobuf enum {@code mt.EmRestMeetingSafeType}
   */
  public enum EmRestMeetingSafeType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRestMeetingType_Public = 0;</code>
     *
     * <pre>
     * 传统媒体会议
     * </pre>
     */
    emRestMeetingType_Public(0, 0),
    /**
     * <code>emRestMeetingType_Port = 1;</code>
     *
     * <pre>
     * 端口会议
     * </pre>
     */
    emRestMeetingType_Port(1, 1),
    ;

    /**
     * <code>emRestMeetingType_Public = 0;</code>
     *
     * <pre>
     * 传统媒体会议
     * </pre>
     */
    public static final int emRestMeetingType_Public_VALUE = 0;
    /**
     * <code>emRestMeetingType_Port = 1;</code>
     *
     * <pre>
     * 端口会议
     * </pre>
     */
    public static final int emRestMeetingType_Port_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmRestMeetingSafeType valueOf(int value) {
      switch (value) {
        case 0: return emRestMeetingType_Public;
        case 1: return emRestMeetingType_Port;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRestMeetingSafeType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRestMeetingSafeType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRestMeetingSafeType>() {
            public EmRestMeetingSafeType findValueByNumber(int number) {
              return EmRestMeetingSafeType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(192);
    }

    private static final EmRestMeetingSafeType[] VALUES = values();

    public static EmRestMeetingSafeType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRestMeetingSafeType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRestMeetingSafeType)
  }

  /**
   * Protobuf enum {@code mt.EmRestVideoQuality}
   *
   * <pre>
   *视频质量
   * </pre>
   */
  public enum EmRestVideoQuality
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRestQualityPrecedence = 0;</code>
     *
     * <pre>
     * 质量优先
     * </pre>
     */
    emRestQualityPrecedence(0, 0),
    /**
     * <code>emRestSpeedPrecedence = 1;</code>
     *
     * <pre>
     * 速度优先
     * </pre>
     */
    emRestSpeedPrecedence(1, 1),
    ;

    /**
     * <code>emRestQualityPrecedence = 0;</code>
     *
     * <pre>
     * 质量优先
     * </pre>
     */
    public static final int emRestQualityPrecedence_VALUE = 0;
    /**
     * <code>emRestSpeedPrecedence = 1;</code>
     *
     * <pre>
     * 速度优先
     * </pre>
     */
    public static final int emRestSpeedPrecedence_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmRestVideoQuality valueOf(int value) {
      switch (value) {
        case 0: return emRestQualityPrecedence;
        case 1: return emRestSpeedPrecedence;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRestVideoQuality>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRestVideoQuality>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRestVideoQuality>() {
            public EmRestVideoQuality findValueByNumber(int number) {
              return EmRestVideoQuality.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(193);
    }

    private static final EmRestVideoQuality[] VALUES = values();

    public static EmRestVideoQuality valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRestVideoQuality(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRestVideoQuality)
  }

  /**
   * Protobuf enum {@code mt.EmRestCascadeMode}
   *
   * <pre>
   *级联模式
   * </pre>
   */
  public enum EmRestCascadeMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRestCascade_Simple = 0;</code>
     *
     * <pre>
     * 简单级联
     * </pre>
     */
    emRestCascade_Simple(0, 0),
    /**
     * <code>emRestCascade_Merge = 1;</code>
     *
     * <pre>
     * 合并级联
     * </pre>
     */
    emRestCascade_Merge(1, 1),
    ;

    /**
     * <code>emRestCascade_Simple = 0;</code>
     *
     * <pre>
     * 简单级联
     * </pre>
     */
    public static final int emRestCascade_Simple_VALUE = 0;
    /**
     * <code>emRestCascade_Merge = 1;</code>
     *
     * <pre>
     * 合并级联
     * </pre>
     */
    public static final int emRestCascade_Merge_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmRestCascadeMode valueOf(int value) {
      switch (value) {
        case 0: return emRestCascade_Simple;
        case 1: return emRestCascade_Merge;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRestCascadeMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRestCascadeMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRestCascadeMode>() {
            public EmRestCascadeMode findValueByNumber(int number) {
              return EmRestCascadeMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(194);
    }

    private static final EmRestCascadeMode[] VALUES = values();

    public static EmRestCascadeMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRestCascadeMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRestCascadeMode)
  }

  /**
   * Protobuf enum {@code mt.EmRemoteType}
   */
  public enum EmRemoteType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRemoteTypeUnknown = 0;</code>
     *
     * <pre>
     * 未知遥控器
     * </pre>
     */
    emRemoteTypeUnknown(0, 0),
    /**
     * <code>emRemoteTypeShortBlack = 1;</code>
     *
     * <pre>
     * 短黑色遥控器
     * </pre>
     */
    emRemoteTypeShortBlack(1, 1),
    /**
     * <code>emRemoteTypeLongBlack = 2;</code>
     *
     * <pre>
     * 长黑色遥控器
     * </pre>
     */
    emRemoteTypeLongBlack(2, 2),
    /**
     * <code>emRemoteTypeSilver = 3;</code>
     *
     * <pre>
     * 银色遥控器
     * </pre>
     */
    emRemoteTypeSilver(3, 3),
    /**
     * <code>emRemoteTypeV3CamCtrl = 4;</code>
     *
     * <pre>
     * V3Cam遥控器
     * </pre>
     */
    emRemoteTypeV3CamCtrl(4, 4),
    /**
     * <code>emRemoteTypeSkyWalker = 5;</code>
     *
     * <pre>
     * SkyWalker遥控器
     * </pre>
     */
    emRemoteTypeSkyWalker(5, 5),
    /**
     * <code>emRemoteTypeIRLongBlack = 6;</code>
     *
     * <pre>
     * 红外盒子指令
     * </pre>
     */
    emRemoteTypeIRLongBlack(6, 6),
    ;

    /**
     * <code>emRemoteTypeUnknown = 0;</code>
     *
     * <pre>
     * 未知遥控器
     * </pre>
     */
    public static final int emRemoteTypeUnknown_VALUE = 0;
    /**
     * <code>emRemoteTypeShortBlack = 1;</code>
     *
     * <pre>
     * 短黑色遥控器
     * </pre>
     */
    public static final int emRemoteTypeShortBlack_VALUE = 1;
    /**
     * <code>emRemoteTypeLongBlack = 2;</code>
     *
     * <pre>
     * 长黑色遥控器
     * </pre>
     */
    public static final int emRemoteTypeLongBlack_VALUE = 2;
    /**
     * <code>emRemoteTypeSilver = 3;</code>
     *
     * <pre>
     * 银色遥控器
     * </pre>
     */
    public static final int emRemoteTypeSilver_VALUE = 3;
    /**
     * <code>emRemoteTypeV3CamCtrl = 4;</code>
     *
     * <pre>
     * V3Cam遥控器
     * </pre>
     */
    public static final int emRemoteTypeV3CamCtrl_VALUE = 4;
    /**
     * <code>emRemoteTypeSkyWalker = 5;</code>
     *
     * <pre>
     * SkyWalker遥控器
     * </pre>
     */
    public static final int emRemoteTypeSkyWalker_VALUE = 5;
    /**
     * <code>emRemoteTypeIRLongBlack = 6;</code>
     *
     * <pre>
     * 红外盒子指令
     * </pre>
     */
    public static final int emRemoteTypeIRLongBlack_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmRemoteType valueOf(int value) {
      switch (value) {
        case 0: return emRemoteTypeUnknown;
        case 1: return emRemoteTypeShortBlack;
        case 2: return emRemoteTypeLongBlack;
        case 3: return emRemoteTypeSilver;
        case 4: return emRemoteTypeV3CamCtrl;
        case 5: return emRemoteTypeSkyWalker;
        case 6: return emRemoteTypeIRLongBlack;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRemoteType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRemoteType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRemoteType>() {
            public EmRemoteType findValueByNumber(int number) {
              return EmRemoteType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(195);
    }

    private static final EmRemoteType[] VALUES = values();

    public static EmRemoteType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRemoteType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRemoteType)
  }

  /**
   * Protobuf enum {@code mt.EmRemoteScanCode}
   */
  public enum EmRemoteScanCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emScanCode0 = 0;</code>
     *
     * <pre>
     * 0 
     * </pre>
     */
    emScanCode0(0, 0),
    /**
     * <code>emScanCode1 = 1;</code>
     *
     * <pre>
     * 1 
     * </pre>
     */
    emScanCode1(1, 1),
    /**
     * <code>emScanCode2 = 2;</code>
     *
     * <pre>
     * 2 
     * </pre>
     */
    emScanCode2(2, 2),
    /**
     * <code>emScanCode3 = 3;</code>
     *
     * <pre>
     * 3 
     * </pre>
     */
    emScanCode3(3, 3),
    /**
     * <code>emScanCode4 = 4;</code>
     *
     * <pre>
     * 4 
     * </pre>
     */
    emScanCode4(4, 4),
    /**
     * <code>emScanCode5 = 5;</code>
     *
     * <pre>
     * 5 
     * </pre>
     */
    emScanCode5(5, 5),
    /**
     * <code>emScanCode6 = 6;</code>
     *
     * <pre>
     * 6 
     * </pre>
     */
    emScanCode6(6, 6),
    /**
     * <code>emScanCode7 = 7;</code>
     *
     * <pre>
     * 7 
     * </pre>
     */
    emScanCode7(7, 7),
    /**
     * <code>emScanCode8 = 8;</code>
     *
     * <pre>
     * 8 
     * </pre>
     */
    emScanCode8(8, 8),
    /**
     * <code>emScanCode9 = 9;</code>
     *
     * <pre>
     * 9   
     * </pre>
     */
    emScanCode9(9, 9),
    /**
     * <code>emScanCodePoint = 10;</code>
     *
     * <pre>
     * . 
     * </pre>
     */
    emScanCodePoint(10, 10),
    /**
     * <code>emScanCodeSharp = 11;</code>
     *
     * <pre>
     * #   
     * </pre>
     */
    emScanCodeSharp(11, 11),
    /**
     * <code>emScanCodeMenu = 12;</code>
     *
     * <pre>
     * 菜单 
     * </pre>
     */
    emScanCodeMenu(12, 12),
    /**
     * <code>emScanCodeBackspace = 13;</code>
     *
     * <pre>
     * 删除 
     * </pre>
     */
    emScanCodeBackspace(13, 13),
    /**
     * <code>emScanCodeEnter = 14;</code>
     *
     * <pre>
     * 确定 
     * </pre>
     */
    emScanCodeEnter(14, 14),
    /**
     * <code>emScanCodeUp = 15;</code>
     *
     * <pre>
     * 上 
     * </pre>
     */
    emScanCodeUp(15, 15),
    /**
     * <code>emScanCodeDown = 16;</code>
     *
     * <pre>
     * 下 
     * </pre>
     */
    emScanCodeDown(16, 16),
    /**
     * <code>emScanCodeLeft = 17;</code>
     *
     * <pre>
     * 左 
     * </pre>
     */
    emScanCodeLeft(17, 17),
    /**
     * <code>emScanCodeRight = 18;</code>
     *
     * <pre>
     * 右 
     * </pre>
     */
    emScanCodeRight(18, 18),
    /**
     * <code>emScanCodePower = 19;</code>
     *
     * <pre>
     * 电源 
     * </pre>
     */
    emScanCodePower(19, 19),
    /**
     * <code>emScanCodeMainVSrc = 20;</code>
     *
     * <pre>
     * 主视频源 
     * </pre>
     */
    emScanCodeMainVSrc(20, 20),
    /**
     * <code>emScanCodeAV = 21;</code>
     *
     * <pre>
     * AV
     * </pre>
     */
    emScanCodeAV(21, 21),
    /**
     * <code>emScanCodeFarCtrl = 22;</code>
     *
     * <pre>
     * 远遥
     * </pre>
     */
    emScanCodeFarCtrl(22, 22),
    /**
     * <code>emScanCodeMute = 23;</code>
     *
     * <pre>
     * 哑音
     * </pre>
     */
    emScanCodeMute(23, 23),
    /**
     * <code>emScanCodeQuiet = 24;</code>
     *
     * <pre>
     * 静音
     * </pre>
     */
    emScanCodeQuiet(24, 24),
    /**
     * <code>emScanCodeVGA = 25;</code>
     *
     * <pre>
     * VGA
     * </pre>
     */
    emScanCodeVGA(25, 25),
    /**
     * <code>emScanCodeS = 26;</code>
     *
     * <pre>
     * S端子
     * </pre>
     */
    emScanCodeS(26, 26),
    /**
     * <code>emScanCodeShotSnap = 27;</code>
     *
     * <pre>
     * 快照
     * </pre>
     */
    emScanCodeShotSnap(27, 27),
    /**
     * <code>emScanCodeVolumeUp = 28;</code>
     *
     * <pre>
     * 音量+
     * </pre>
     */
    emScanCodeVolumeUp(28, 28),
    /**
     * <code>emScanCodeVolumeDown = 29;</code>
     *
     * <pre>
     * 音量-
     * </pre>
     */
    emScanCodeVolumeDown(29, 29),
    /**
     * <code>emScanCodeConnect = 30;</code>
     *
     * <pre>
     * 拨号 
     * </pre>
     */
    emScanCodeConnect(30, 30),
    /**
     * <code>emScanCodeDisconnect = 31;</code>
     *
     * <pre>
     * 挂断 
     * </pre>
     */
    emScanCodeDisconnect(31, 31),
    /**
     * <code>emScanCodeDirectory = 32;</code>
     *
     * <pre>
     * 地址簿 
     * </pre>
     */
    emScanCodeDirectory(32, 32),
    /**
     * <code>emScanCodePipEnable = 33;</code>
     *
     * <pre>
     * 画中画 
     * </pre>
     */
    emScanCodePipEnable(33, 33),
    /**
     * <code>emScanCodePipAdjust = 34;</code>
     *
     * <pre>
     * 画中画缩放 
     * </pre>
     */
    emScanCodePipAdjust(34, 34),
    /**
     * <code>emScanCodeSelfTest = 35;</code>
     *
     * <pre>
     * 自检 
     * </pre>
     */
    emScanCodeSelfTest(35, 35),
    /**
     * <code>emScanCodeAutoFocus = 36;</code>
     *
     * <pre>
     * 自动调焦 
     * </pre>
     */
    emScanCodeAutoFocus(36, 36),
    /**
     * <code>emScanCodeNearZoom = 37;</code>
     *
     * <pre>
     * 近视 
     * </pre>
     */
    emScanCodeNearZoom(37, 37),
    /**
     * <code>emScanCodeFarZoom = 38;</code>
     *
     * <pre>
     * 远视 
     * </pre>
     */
    emScanCodeFarZoom(38, 38),
    /**
     * <code>emScanCodePreSave = 39;</code>
     *
     * <pre>
     * 保存预置位 
     * </pre>
     */
    emScanCodePreSave(39, 39),
    /**
     * <code>emScanCodePreMove = 40;</code>
     *
     * <pre>
     * 加载预置位 
     * </pre>
     */
    emScanCodePreMove(40, 40),
    /**
     * <code>emScanCodeChairReq = 41;</code>
     *
     * <pre>
     * 申请主席 
     * </pre>
     */
    emScanCodeChairReq(41, 41),
    /**
     * <code>emScanCodeSpeakReq = 42;</code>
     *
     * <pre>
     * 申请发言 
     * </pre>
     */
    emScanCodeSpeakReq(42, 42),
    /**
     * <code>emScanCodeQuitReq = 43;</code>
     *
     * <pre>
     * 退会 
     * </pre>
     */
    emScanCodeQuitReq(43, 43),
    /**
     * <code>emScanCodeState = 44;</code>
     *
     * <pre>
     * 状态 
     * </pre>
     */
    emScanCodeState(44, 44),
    /**
     * <code>emScanCodeHotLeft = 45;</code>
     *
     * <pre>
     * 快捷键1 
     * </pre>
     */
    emScanCodeHotLeft(45, 45),
    /**
     * <code>emScanCodeHotCenter = 46;</code>
     *
     * <pre>
     * 快捷键2 
     * </pre>
     */
    emScanCodeHotCenter(46, 46),
    /**
     * <code>emScanCodeHotRight = 47;</code>
     *
     * <pre>
     * 快捷键3 
     * </pre>
     */
    emScanCodeHotRight(47, 47),
    /**
     * <code>emScanCodeHelp = 48;</code>
     *
     * <pre>
     * 帮助 
     * </pre>
     */
    emScanCodeHelp(48, 48),
    /**
     * <code>emScanCodeBrightUp = 49;</code>
     *
     * <pre>
     * 亮度+
     * </pre>
     */
    emScanCodeBrightUp(49, 49),
    /**
     * <code>emScanCodeBrightDown = 50;</code>
     *
     * <pre>
     * 亮度-
     * </pre>
     */
    emScanCodeBrightDown(50, 50),
    /**
     * <code>emScanCodeDual = 51;</code>
     *
     * <pre>
     * 双流
     * </pre>
     */
    emScanCodeDual(51, 51),
    /**
     * <code>emScanCodeReturn = 52;</code>
     *
     * <pre>
     * 返回
     * </pre>
     */
    emScanCodeReturn(52, 52),
    /**
     * <code>emScanCodeFunc = 53;</code>
     *
     * <pre>
     * 功能
     * </pre>
     */
    emScanCodeFunc(53, 53),
    /**
     * <code>emScanCodeSearch = 54;</code>
     *
     * <pre>
     * 搜索
     * </pre>
     */
    emScanCodeSearch(54, 54),
    /**
     * <code>emScanCodeImixMenu = 55;</code>
     *
     * <pre>
     * 用于网呈，在会议空闲时可以直接返回OSD主界面
     * </pre>
     */
    emScanCodeImixMenu(55, 55),
    /**
     * <code>emScanCodeNull = 98;</code>
     *
     * <pre>
     * 无键值
     * </pre>
     */
    emScanCodeNull(56, 98),
    /**
     * <code>emScanCodeInvalid = 99;</code>
     *
     * <pre>
     * 无效键值
     * </pre>
     */
    emScanCodeInvalid(57, 99),
    ;

    /**
     * <code>emScanCode0 = 0;</code>
     *
     * <pre>
     * 0 
     * </pre>
     */
    public static final int emScanCode0_VALUE = 0;
    /**
     * <code>emScanCode1 = 1;</code>
     *
     * <pre>
     * 1 
     * </pre>
     */
    public static final int emScanCode1_VALUE = 1;
    /**
     * <code>emScanCode2 = 2;</code>
     *
     * <pre>
     * 2 
     * </pre>
     */
    public static final int emScanCode2_VALUE = 2;
    /**
     * <code>emScanCode3 = 3;</code>
     *
     * <pre>
     * 3 
     * </pre>
     */
    public static final int emScanCode3_VALUE = 3;
    /**
     * <code>emScanCode4 = 4;</code>
     *
     * <pre>
     * 4 
     * </pre>
     */
    public static final int emScanCode4_VALUE = 4;
    /**
     * <code>emScanCode5 = 5;</code>
     *
     * <pre>
     * 5 
     * </pre>
     */
    public static final int emScanCode5_VALUE = 5;
    /**
     * <code>emScanCode6 = 6;</code>
     *
     * <pre>
     * 6 
     * </pre>
     */
    public static final int emScanCode6_VALUE = 6;
    /**
     * <code>emScanCode7 = 7;</code>
     *
     * <pre>
     * 7 
     * </pre>
     */
    public static final int emScanCode7_VALUE = 7;
    /**
     * <code>emScanCode8 = 8;</code>
     *
     * <pre>
     * 8 
     * </pre>
     */
    public static final int emScanCode8_VALUE = 8;
    /**
     * <code>emScanCode9 = 9;</code>
     *
     * <pre>
     * 9   
     * </pre>
     */
    public static final int emScanCode9_VALUE = 9;
    /**
     * <code>emScanCodePoint = 10;</code>
     *
     * <pre>
     * . 
     * </pre>
     */
    public static final int emScanCodePoint_VALUE = 10;
    /**
     * <code>emScanCodeSharp = 11;</code>
     *
     * <pre>
     * #   
     * </pre>
     */
    public static final int emScanCodeSharp_VALUE = 11;
    /**
     * <code>emScanCodeMenu = 12;</code>
     *
     * <pre>
     * 菜单 
     * </pre>
     */
    public static final int emScanCodeMenu_VALUE = 12;
    /**
     * <code>emScanCodeBackspace = 13;</code>
     *
     * <pre>
     * 删除 
     * </pre>
     */
    public static final int emScanCodeBackspace_VALUE = 13;
    /**
     * <code>emScanCodeEnter = 14;</code>
     *
     * <pre>
     * 确定 
     * </pre>
     */
    public static final int emScanCodeEnter_VALUE = 14;
    /**
     * <code>emScanCodeUp = 15;</code>
     *
     * <pre>
     * 上 
     * </pre>
     */
    public static final int emScanCodeUp_VALUE = 15;
    /**
     * <code>emScanCodeDown = 16;</code>
     *
     * <pre>
     * 下 
     * </pre>
     */
    public static final int emScanCodeDown_VALUE = 16;
    /**
     * <code>emScanCodeLeft = 17;</code>
     *
     * <pre>
     * 左 
     * </pre>
     */
    public static final int emScanCodeLeft_VALUE = 17;
    /**
     * <code>emScanCodeRight = 18;</code>
     *
     * <pre>
     * 右 
     * </pre>
     */
    public static final int emScanCodeRight_VALUE = 18;
    /**
     * <code>emScanCodePower = 19;</code>
     *
     * <pre>
     * 电源 
     * </pre>
     */
    public static final int emScanCodePower_VALUE = 19;
    /**
     * <code>emScanCodeMainVSrc = 20;</code>
     *
     * <pre>
     * 主视频源 
     * </pre>
     */
    public static final int emScanCodeMainVSrc_VALUE = 20;
    /**
     * <code>emScanCodeAV = 21;</code>
     *
     * <pre>
     * AV
     * </pre>
     */
    public static final int emScanCodeAV_VALUE = 21;
    /**
     * <code>emScanCodeFarCtrl = 22;</code>
     *
     * <pre>
     * 远遥
     * </pre>
     */
    public static final int emScanCodeFarCtrl_VALUE = 22;
    /**
     * <code>emScanCodeMute = 23;</code>
     *
     * <pre>
     * 哑音
     * </pre>
     */
    public static final int emScanCodeMute_VALUE = 23;
    /**
     * <code>emScanCodeQuiet = 24;</code>
     *
     * <pre>
     * 静音
     * </pre>
     */
    public static final int emScanCodeQuiet_VALUE = 24;
    /**
     * <code>emScanCodeVGA = 25;</code>
     *
     * <pre>
     * VGA
     * </pre>
     */
    public static final int emScanCodeVGA_VALUE = 25;
    /**
     * <code>emScanCodeS = 26;</code>
     *
     * <pre>
     * S端子
     * </pre>
     */
    public static final int emScanCodeS_VALUE = 26;
    /**
     * <code>emScanCodeShotSnap = 27;</code>
     *
     * <pre>
     * 快照
     * </pre>
     */
    public static final int emScanCodeShotSnap_VALUE = 27;
    /**
     * <code>emScanCodeVolumeUp = 28;</code>
     *
     * <pre>
     * 音量+
     * </pre>
     */
    public static final int emScanCodeVolumeUp_VALUE = 28;
    /**
     * <code>emScanCodeVolumeDown = 29;</code>
     *
     * <pre>
     * 音量-
     * </pre>
     */
    public static final int emScanCodeVolumeDown_VALUE = 29;
    /**
     * <code>emScanCodeConnect = 30;</code>
     *
     * <pre>
     * 拨号 
     * </pre>
     */
    public static final int emScanCodeConnect_VALUE = 30;
    /**
     * <code>emScanCodeDisconnect = 31;</code>
     *
     * <pre>
     * 挂断 
     * </pre>
     */
    public static final int emScanCodeDisconnect_VALUE = 31;
    /**
     * <code>emScanCodeDirectory = 32;</code>
     *
     * <pre>
     * 地址簿 
     * </pre>
     */
    public static final int emScanCodeDirectory_VALUE = 32;
    /**
     * <code>emScanCodePipEnable = 33;</code>
     *
     * <pre>
     * 画中画 
     * </pre>
     */
    public static final int emScanCodePipEnable_VALUE = 33;
    /**
     * <code>emScanCodePipAdjust = 34;</code>
     *
     * <pre>
     * 画中画缩放 
     * </pre>
     */
    public static final int emScanCodePipAdjust_VALUE = 34;
    /**
     * <code>emScanCodeSelfTest = 35;</code>
     *
     * <pre>
     * 自检 
     * </pre>
     */
    public static final int emScanCodeSelfTest_VALUE = 35;
    /**
     * <code>emScanCodeAutoFocus = 36;</code>
     *
     * <pre>
     * 自动调焦 
     * </pre>
     */
    public static final int emScanCodeAutoFocus_VALUE = 36;
    /**
     * <code>emScanCodeNearZoom = 37;</code>
     *
     * <pre>
     * 近视 
     * </pre>
     */
    public static final int emScanCodeNearZoom_VALUE = 37;
    /**
     * <code>emScanCodeFarZoom = 38;</code>
     *
     * <pre>
     * 远视 
     * </pre>
     */
    public static final int emScanCodeFarZoom_VALUE = 38;
    /**
     * <code>emScanCodePreSave = 39;</code>
     *
     * <pre>
     * 保存预置位 
     * </pre>
     */
    public static final int emScanCodePreSave_VALUE = 39;
    /**
     * <code>emScanCodePreMove = 40;</code>
     *
     * <pre>
     * 加载预置位 
     * </pre>
     */
    public static final int emScanCodePreMove_VALUE = 40;
    /**
     * <code>emScanCodeChairReq = 41;</code>
     *
     * <pre>
     * 申请主席 
     * </pre>
     */
    public static final int emScanCodeChairReq_VALUE = 41;
    /**
     * <code>emScanCodeSpeakReq = 42;</code>
     *
     * <pre>
     * 申请发言 
     * </pre>
     */
    public static final int emScanCodeSpeakReq_VALUE = 42;
    /**
     * <code>emScanCodeQuitReq = 43;</code>
     *
     * <pre>
     * 退会 
     * </pre>
     */
    public static final int emScanCodeQuitReq_VALUE = 43;
    /**
     * <code>emScanCodeState = 44;</code>
     *
     * <pre>
     * 状态 
     * </pre>
     */
    public static final int emScanCodeState_VALUE = 44;
    /**
     * <code>emScanCodeHotLeft = 45;</code>
     *
     * <pre>
     * 快捷键1 
     * </pre>
     */
    public static final int emScanCodeHotLeft_VALUE = 45;
    /**
     * <code>emScanCodeHotCenter = 46;</code>
     *
     * <pre>
     * 快捷键2 
     * </pre>
     */
    public static final int emScanCodeHotCenter_VALUE = 46;
    /**
     * <code>emScanCodeHotRight = 47;</code>
     *
     * <pre>
     * 快捷键3 
     * </pre>
     */
    public static final int emScanCodeHotRight_VALUE = 47;
    /**
     * <code>emScanCodeHelp = 48;</code>
     *
     * <pre>
     * 帮助 
     * </pre>
     */
    public static final int emScanCodeHelp_VALUE = 48;
    /**
     * <code>emScanCodeBrightUp = 49;</code>
     *
     * <pre>
     * 亮度+
     * </pre>
     */
    public static final int emScanCodeBrightUp_VALUE = 49;
    /**
     * <code>emScanCodeBrightDown = 50;</code>
     *
     * <pre>
     * 亮度-
     * </pre>
     */
    public static final int emScanCodeBrightDown_VALUE = 50;
    /**
     * <code>emScanCodeDual = 51;</code>
     *
     * <pre>
     * 双流
     * </pre>
     */
    public static final int emScanCodeDual_VALUE = 51;
    /**
     * <code>emScanCodeReturn = 52;</code>
     *
     * <pre>
     * 返回
     * </pre>
     */
    public static final int emScanCodeReturn_VALUE = 52;
    /**
     * <code>emScanCodeFunc = 53;</code>
     *
     * <pre>
     * 功能
     * </pre>
     */
    public static final int emScanCodeFunc_VALUE = 53;
    /**
     * <code>emScanCodeSearch = 54;</code>
     *
     * <pre>
     * 搜索
     * </pre>
     */
    public static final int emScanCodeSearch_VALUE = 54;
    /**
     * <code>emScanCodeImixMenu = 55;</code>
     *
     * <pre>
     * 用于网呈，在会议空闲时可以直接返回OSD主界面
     * </pre>
     */
    public static final int emScanCodeImixMenu_VALUE = 55;
    /**
     * <code>emScanCodeNull = 98;</code>
     *
     * <pre>
     * 无键值
     * </pre>
     */
    public static final int emScanCodeNull_VALUE = 98;
    /**
     * <code>emScanCodeInvalid = 99;</code>
     *
     * <pre>
     * 无效键值
     * </pre>
     */
    public static final int emScanCodeInvalid_VALUE = 99;


    public final int getNumber() { return value; }

    public static EmRemoteScanCode valueOf(int value) {
      switch (value) {
        case 0: return emScanCode0;
        case 1: return emScanCode1;
        case 2: return emScanCode2;
        case 3: return emScanCode3;
        case 4: return emScanCode4;
        case 5: return emScanCode5;
        case 6: return emScanCode6;
        case 7: return emScanCode7;
        case 8: return emScanCode8;
        case 9: return emScanCode9;
        case 10: return emScanCodePoint;
        case 11: return emScanCodeSharp;
        case 12: return emScanCodeMenu;
        case 13: return emScanCodeBackspace;
        case 14: return emScanCodeEnter;
        case 15: return emScanCodeUp;
        case 16: return emScanCodeDown;
        case 17: return emScanCodeLeft;
        case 18: return emScanCodeRight;
        case 19: return emScanCodePower;
        case 20: return emScanCodeMainVSrc;
        case 21: return emScanCodeAV;
        case 22: return emScanCodeFarCtrl;
        case 23: return emScanCodeMute;
        case 24: return emScanCodeQuiet;
        case 25: return emScanCodeVGA;
        case 26: return emScanCodeS;
        case 27: return emScanCodeShotSnap;
        case 28: return emScanCodeVolumeUp;
        case 29: return emScanCodeVolumeDown;
        case 30: return emScanCodeConnect;
        case 31: return emScanCodeDisconnect;
        case 32: return emScanCodeDirectory;
        case 33: return emScanCodePipEnable;
        case 34: return emScanCodePipAdjust;
        case 35: return emScanCodeSelfTest;
        case 36: return emScanCodeAutoFocus;
        case 37: return emScanCodeNearZoom;
        case 38: return emScanCodeFarZoom;
        case 39: return emScanCodePreSave;
        case 40: return emScanCodePreMove;
        case 41: return emScanCodeChairReq;
        case 42: return emScanCodeSpeakReq;
        case 43: return emScanCodeQuitReq;
        case 44: return emScanCodeState;
        case 45: return emScanCodeHotLeft;
        case 46: return emScanCodeHotCenter;
        case 47: return emScanCodeHotRight;
        case 48: return emScanCodeHelp;
        case 49: return emScanCodeBrightUp;
        case 50: return emScanCodeBrightDown;
        case 51: return emScanCodeDual;
        case 52: return emScanCodeReturn;
        case 53: return emScanCodeFunc;
        case 54: return emScanCodeSearch;
        case 55: return emScanCodeImixMenu;
        case 98: return emScanCodeNull;
        case 99: return emScanCodeInvalid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRemoteScanCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRemoteScanCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRemoteScanCode>() {
            public EmRemoteScanCode findValueByNumber(int number) {
              return EmRemoteScanCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(196);
    }

    private static final EmRemoteScanCode[] VALUES = values();

    public static EmRemoteScanCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRemoteScanCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRemoteScanCode)
  }

  /**
   * Protobuf enum {@code mt.EmParticipantResponse}
   *
   * <pre>
   *参与会议反馈
   * </pre>
   */
  public enum EmParticipantResponse
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emResponseNoFeedback = 0;</code>
     *
     * <pre>
     *未反馈
     * </pre>
     */
    emResponseNoFeedback(0, 0),
    /**
     * <code>emResponseReject = 1;</code>
     *
     * <pre>
     *拒绝入会
     * </pre>
     */
    emResponseReject(1, 1),
    /**
     * <code>emResponseParticipant = 2;</code>
     *
     * <pre>
     *入会
     * </pre>
     */
    emResponseParticipant(2, 2),
    /**
     * <code>emResponseCustom = 3;</code>
     *
     * <pre>
     *表示会议由当前用户创建
     * </pre>
     */
    emResponseCustom(3, 3),
    ;

    /**
     * <code>emResponseNoFeedback = 0;</code>
     *
     * <pre>
     *未反馈
     * </pre>
     */
    public static final int emResponseNoFeedback_VALUE = 0;
    /**
     * <code>emResponseReject = 1;</code>
     *
     * <pre>
     *拒绝入会
     * </pre>
     */
    public static final int emResponseReject_VALUE = 1;
    /**
     * <code>emResponseParticipant = 2;</code>
     *
     * <pre>
     *入会
     * </pre>
     */
    public static final int emResponseParticipant_VALUE = 2;
    /**
     * <code>emResponseCustom = 3;</code>
     *
     * <pre>
     *表示会议由当前用户创建
     * </pre>
     */
    public static final int emResponseCustom_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmParticipantResponse valueOf(int value) {
      switch (value) {
        case 0: return emResponseNoFeedback;
        case 1: return emResponseReject;
        case 2: return emResponseParticipant;
        case 3: return emResponseCustom;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmParticipantResponse>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmParticipantResponse>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmParticipantResponse>() {
            public EmParticipantResponse findValueByNumber(int number) {
              return EmParticipantResponse.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(197);
    }

    private static final EmParticipantResponse[] VALUES = values();

    public static EmParticipantResponse valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmParticipantResponse(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmParticipantResponse)
  }

  /**
   * Protobuf enum {@code mt.EmClosedMeeting}
   *
   * <pre>
   *会议免打扰
   * </pre>
   */
  public enum EmClosedMeeting
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emClosedMeeting_Close = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    emClosedMeeting_Close(0, 0),
    /**
     * <code>emClosedMeeting_Open = 1;</code>
     *
     * <pre>
     *开启
     * </pre>
     */
    emClosedMeeting_Open(1, 1),
    ;

    /**
     * <code>emClosedMeeting_Close = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    public static final int emClosedMeeting_Close_VALUE = 0;
    /**
     * <code>emClosedMeeting_Open = 1;</code>
     *
     * <pre>
     *开启
     * </pre>
     */
    public static final int emClosedMeeting_Open_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmClosedMeeting valueOf(int value) {
      switch (value) {
        case 0: return emClosedMeeting_Close;
        case 1: return emClosedMeeting_Open;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmClosedMeeting>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmClosedMeeting>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmClosedMeeting>() {
            public EmClosedMeeting findValueByNumber(int number) {
              return EmClosedMeeting.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(198);
    }

    private static final EmClosedMeeting[] VALUES = values();

    public static EmClosedMeeting valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmClosedMeeting(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmClosedMeeting)
  }

  /**
   * Protobuf enum {@code mt.EmCameraSpeed}
   *
   * <pre>
   *摄像机转动速度
   * </pre>
   */
  public enum EmCameraSpeed
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCameraSlow = 0;</code>
     */
    emCameraSlow(0, 0),
    /**
     * <code>emCameraNormal = 1;</code>
     */
    emCameraNormal(1, 1),
    /**
     * <code>emCameraFast = 2;</code>
     */
    emCameraFast(2, 2),
    ;

    /**
     * <code>emCameraSlow = 0;</code>
     */
    public static final int emCameraSlow_VALUE = 0;
    /**
     * <code>emCameraNormal = 1;</code>
     */
    public static final int emCameraNormal_VALUE = 1;
    /**
     * <code>emCameraFast = 2;</code>
     */
    public static final int emCameraFast_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmCameraSpeed valueOf(int value) {
      switch (value) {
        case 0: return emCameraSlow;
        case 1: return emCameraNormal;
        case 2: return emCameraFast;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCameraSpeed>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCameraSpeed>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCameraSpeed>() {
            public EmCameraSpeed findValueByNumber(int number) {
              return EmCameraSpeed.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(199);
    }

    private static final EmCameraSpeed[] VALUES = values();

    public static EmCameraSpeed valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCameraSpeed(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCameraSpeed)
  }

  /**
   * Protobuf enum {@code mt.EmCameraView}
   *
   * <pre>
   *摄像机控制当前画面
   * </pre>
   */
  public enum EmCameraView
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRestoreCameraView = 0;</code>
     */
    emRestoreCameraView(0, 0),
    /**
     * <code>em1stCameraView = 1;</code>
     */
    em1stCameraView(1, 1),
    /**
     * <code>em2ndCameraView = 2;</code>
     */
    em2ndCameraView(2, 2),
    /**
     * <code>emCameraMultiView = 3;</code>
     */
    emCameraMultiView(3, 3),
    /**
     * <code>em3rdCameraView = 4;</code>
     */
    em3rdCameraView(4, 4),
    ;

    /**
     * <code>emRestoreCameraView = 0;</code>
     */
    public static final int emRestoreCameraView_VALUE = 0;
    /**
     * <code>em1stCameraView = 1;</code>
     */
    public static final int em1stCameraView_VALUE = 1;
    /**
     * <code>em2ndCameraView = 2;</code>
     */
    public static final int em2ndCameraView_VALUE = 2;
    /**
     * <code>emCameraMultiView = 3;</code>
     */
    public static final int emCameraMultiView_VALUE = 3;
    /**
     * <code>em3rdCameraView = 4;</code>
     */
    public static final int em3rdCameraView_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmCameraView valueOf(int value) {
      switch (value) {
        case 0: return emRestoreCameraView;
        case 1: return em1stCameraView;
        case 2: return em2ndCameraView;
        case 3: return emCameraMultiView;
        case 4: return em3rdCameraView;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCameraView>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCameraView>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCameraView>() {
            public EmCameraView findValueByNumber(int number) {
              return EmCameraView.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(200);
    }

    private static final EmCameraView[] VALUES = values();

    public static EmCameraView valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCameraView(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCameraView)
  }

  /**
   * Protobuf enum {@code mt.EmRestNotifyType}
   *
   * <pre>
   *获取@、赞、粉丝等初始消息相关的消息类型
   * </pre>
   */
  public enum EmRestNotifyType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUnknownType = 0;</code>
     *
     * <pre>
     *未知消息
     * </pre>
     */
    emUnknownType(0, 0),
    /**
     * <code>emNewFan = 1;</code>
     *
     * <pre>
     *新粉丝
     * </pre>
     */
    emNewFan(1, 1),
    /**
     * <code>emNewFeed = 2;</code>
     *
     * <pre>
     *新消息 --目前NEW_FEED获取不到新消息数
     * </pre>
     */
    emNewFeed(2, 2),
    /**
     * <code>emNewRemindMe = 3;</code>
     *
     * <pre>
     *@我的消息
     * </pre>
     */
    emNewRemindMe(3, 3),
    /**
     * <code>emNewReply = 4;</code>
     *
     * <pre>
     *回复我的消息
     * </pre>
     */
    emNewReply(4, 4),
    /**
     * <code>emGroupInvite = 5;</code>
     *
     * <pre>
     *群组邀请的消息
     * </pre>
     */
    emGroupInvite(5, 5),
    /**
     * <code>emNewLike = 6;</code>
     *
     * <pre>
     *赞我的消息
     * </pre>
     */
    emNewLike(6, 6),
    /**
     * <code>emNewPrivateMsg = 7;</code>
     *
     * <pre>
     *私信的消息
     * </pre>
     */
    emNewPrivateMsg(7, 7),
    ;

    /**
     * <code>emUnknownType = 0;</code>
     *
     * <pre>
     *未知消息
     * </pre>
     */
    public static final int emUnknownType_VALUE = 0;
    /**
     * <code>emNewFan = 1;</code>
     *
     * <pre>
     *新粉丝
     * </pre>
     */
    public static final int emNewFan_VALUE = 1;
    /**
     * <code>emNewFeed = 2;</code>
     *
     * <pre>
     *新消息 --目前NEW_FEED获取不到新消息数
     * </pre>
     */
    public static final int emNewFeed_VALUE = 2;
    /**
     * <code>emNewRemindMe = 3;</code>
     *
     * <pre>
     *@我的消息
     * </pre>
     */
    public static final int emNewRemindMe_VALUE = 3;
    /**
     * <code>emNewReply = 4;</code>
     *
     * <pre>
     *回复我的消息
     * </pre>
     */
    public static final int emNewReply_VALUE = 4;
    /**
     * <code>emGroupInvite = 5;</code>
     *
     * <pre>
     *群组邀请的消息
     * </pre>
     */
    public static final int emGroupInvite_VALUE = 5;
    /**
     * <code>emNewLike = 6;</code>
     *
     * <pre>
     *赞我的消息
     * </pre>
     */
    public static final int emNewLike_VALUE = 6;
    /**
     * <code>emNewPrivateMsg = 7;</code>
     *
     * <pre>
     *私信的消息
     * </pre>
     */
    public static final int emNewPrivateMsg_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmRestNotifyType valueOf(int value) {
      switch (value) {
        case 0: return emUnknownType;
        case 1: return emNewFan;
        case 2: return emNewFeed;
        case 3: return emNewRemindMe;
        case 4: return emNewReply;
        case 5: return emGroupInvite;
        case 6: return emNewLike;
        case 7: return emNewPrivateMsg;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRestNotifyType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRestNotifyType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRestNotifyType>() {
            public EmRestNotifyType findValueByNumber(int number) {
              return EmRestNotifyType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(201);
    }

    private static final EmRestNotifyType[] VALUES = values();

    public static EmRestNotifyType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRestNotifyType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRestNotifyType)
  }

  /**
   * Protobuf enum {@code mt.EmVidRationStrategy}
   */
  public enum EmVidRationStrategy
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EmAssVidPri = 0;</code>
     *
     * <pre>
     *&#47;/辅流优先
     * </pre>
     */
    EmAssVidPri(0, 0),
    /**
     * <code>EmMainVidPri = 1;</code>
     *
     * <pre>
     *&#47;主流优先
     * </pre>
     */
    EmMainVidPri(1, 1),
    /**
     * <code>EmUserDefined = 2;</code>
     *
     * <pre>
     *&#47;自定义比例
     * </pre>
     */
    EmUserDefined(2, 2),
    ;

    /**
     * <code>EmAssVidPri = 0;</code>
     *
     * <pre>
     *&#47;/辅流优先
     * </pre>
     */
    public static final int EmAssVidPri_VALUE = 0;
    /**
     * <code>EmMainVidPri = 1;</code>
     *
     * <pre>
     *&#47;主流优先
     * </pre>
     */
    public static final int EmMainVidPri_VALUE = 1;
    /**
     * <code>EmUserDefined = 2;</code>
     *
     * <pre>
     *&#47;自定义比例
     * </pre>
     */
    public static final int EmUserDefined_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmVidRationStrategy valueOf(int value) {
      switch (value) {
        case 0: return EmAssVidPri;
        case 1: return EmMainVidPri;
        case 2: return EmUserDefined;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVidRationStrategy>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVidRationStrategy>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVidRationStrategy>() {
            public EmVidRationStrategy findValueByNumber(int number) {
              return EmVidRationStrategy.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(202);
    }

    private static final EmVidRationStrategy[] VALUES = values();

    public static EmVidRationStrategy valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVidRationStrategy(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVidRationStrategy)
  }

  /**
   * Protobuf enum {@code mt.EmSystemFileType}
   */
  public enum EmSystemFileType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFileNormal = 0;</code>
     *
     * <pre>
     *普通文件
     * </pre>
     */
    emFileNormal(0, 0),
    /**
     * <code>emFileDirectory = 1;</code>
     *
     * <pre>
     *目录文件
     * </pre>
     */
    emFileDirectory(1, 1),
    /**
     * <code>emFileLink = 2;</code>
     *
     * <pre>
     *链接文件
     * </pre>
     */
    emFileLink(2, 2),
    /**
     * <code>emFilePipe = 3;</code>
     *
     * <pre>
     *管道
     * </pre>
     */
    emFilePipe(3, 3),
    ;

    /**
     * <code>emFileNormal = 0;</code>
     *
     * <pre>
     *普通文件
     * </pre>
     */
    public static final int emFileNormal_VALUE = 0;
    /**
     * <code>emFileDirectory = 1;</code>
     *
     * <pre>
     *目录文件
     * </pre>
     */
    public static final int emFileDirectory_VALUE = 1;
    /**
     * <code>emFileLink = 2;</code>
     *
     * <pre>
     *链接文件
     * </pre>
     */
    public static final int emFileLink_VALUE = 2;
    /**
     * <code>emFilePipe = 3;</code>
     *
     * <pre>
     *管道
     * </pre>
     */
    public static final int emFilePipe_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmSystemFileType valueOf(int value) {
      switch (value) {
        case 0: return emFileNormal;
        case 1: return emFileDirectory;
        case 2: return emFileLink;
        case 3: return emFilePipe;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSystemFileType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSystemFileType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSystemFileType>() {
            public EmSystemFileType findValueByNumber(int number) {
              return EmSystemFileType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(203);
    }

    private static final EmSystemFileType[] VALUES = values();

    public static EmSystemFileType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSystemFileType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSystemFileType)
  }

  /**
   * Protobuf enum {@code mt.EmSaveJpegType}
   *
   * <pre>
   *需要保存Jpeg的功能
   * </pre>
   */
  public enum EmSaveJpegType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSJMonitor = 0;</code>
     *
     * <pre>
     *图片监控
     * </pre>
     */
    emSJMonitor(0, 0),
    /**
     * <code>emSJPresetPos = 1;</code>
     *
     * <pre>
     *预置位图片
     * </pre>
     */
    emSJPresetPos(1, 1),
    /**
     * <code>emSJFtpSnapshot = 2;</code>
     *
     * <pre>
     *ftp快照
     * </pre>
     */
    emSJFtpSnapshot(2, 2),
    ;

    /**
     * <code>emSJMonitor = 0;</code>
     *
     * <pre>
     *图片监控
     * </pre>
     */
    public static final int emSJMonitor_VALUE = 0;
    /**
     * <code>emSJPresetPos = 1;</code>
     *
     * <pre>
     *预置位图片
     * </pre>
     */
    public static final int emSJPresetPos_VALUE = 1;
    /**
     * <code>emSJFtpSnapshot = 2;</code>
     *
     * <pre>
     *ftp快照
     * </pre>
     */
    public static final int emSJFtpSnapshot_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmSaveJpegType valueOf(int value) {
      switch (value) {
        case 0: return emSJMonitor;
        case 1: return emSJPresetPos;
        case 2: return emSJFtpSnapshot;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSaveJpegType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSaveJpegType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSaveJpegType>() {
            public EmSaveJpegType findValueByNumber(int number) {
              return EmSaveJpegType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(204);
    }

    private static final EmSaveJpegType[] VALUES = values();

    public static EmSaveJpegType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSaveJpegType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSaveJpegType)
  }

  /**
   * Protobuf enum {@code mt.EmSleepFailReason}
   *
   * <pre>
   *待机失败原因
   * </pre>
   */
  public enum EmSleepFailReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSFRNoError = 0;</code>
     *
     * <pre>
     *没有失败，允许待机
     * </pre>
     */
    emSFRNoError(0, 0),
    /**
     * <code>emSFRProtectionTime = 1;</code>
     *
     * <pre>
     *待机保护时间(30秒)
     * </pre>
     */
    emSFRProtectionTime(1, 1),
    /**
     * <code>emSFRMonitor = 2;</code>
     *
     * <pre>
     *监控
     * </pre>
     */
    emSFRMonitor(2, 2),
    /**
     * <code>emSFRInConf = 3;</code>
     *
     * <pre>
     *会议
     * </pre>
     */
    emSFRInConf(3, 3),
    /**
     * <code>emSFRLoop = 4;</code>
     *
     * <pre>
     *自环
     * </pre>
     */
    emSFRLoop(4, 4),
    /**
     * <code>emSFRRibbonTest = 5;</code>
     *
     * <pre>
     *色带测试
     * </pre>
     */
    emSFRRibbonTest(5, 5),
    /**
     * <code>emSFRSnapView = 6;</code>
     *
     * <pre>
     *快照浏览
     * </pre>
     */
    emSFRSnapView(6, 6),
    /**
     * <code>emSFRVrs = 7;</code>
     *
     * <pre>
     *VRS
     * </pre>
     */
    emSFRVrs(7, 7),
    /**
     * <code>emSFRUpgrade = 8;</code>
     *
     * <pre>
     *升级
     * </pre>
     */
    emSFRUpgrade(8, 8),
    /**
     * <code>emSFRSusUpgrade = 9;</code>
     *
     * <pre>
     *SUS升级
     * </pre>
     */
    emSFRSusUpgrade(9, 9),
    /**
     * <code>emSFRNetCap = 10;</code>
     *
     * <pre>
     *抓包
     * </pre>
     */
    emSFRNetCap(10, 10),
    /**
     * <code>emSFRAddrbook = 11;</code>
     *
     * <pre>
     *地址簿导入或导出
     * </pre>
     */
    emSFRAddrbook(11, 11),
    /**
     * <code>emSFRSnapExport = 12;</code>
     *
     * <pre>
     *快照导出
     * </pre>
     */
    emSFRSnapExport(12, 12),
    /**
     * <code>emSFRCameraUpgrade = 13;</code>
     *
     * <pre>
     *摄像机升级
     * </pre>
     */
    emSFRCameraUpgrade(13, 13),
    /**
     * <code>emSFRMicPhoneUpgrade = 14;</code>
     *
     * <pre>
     *麦克风升级
     * </pre>
     */
    emSFRMicPhoneUpgrade(14, 14),
    /**
     * <code>emSFRMtRecorde = 15;</code>
     *
     * <pre>
     *本地录像
     * </pre>
     */
    emSFRMtRecorde(15, 15),
    /**
     * <code>emSFRMtAssStream = 16;</code>
     *
     * <pre>
     *skyshare双流
     * </pre>
     */
    emSFRMtAssStream(16, 16),
    ;

    /**
     * <code>emSFRNoError = 0;</code>
     *
     * <pre>
     *没有失败，允许待机
     * </pre>
     */
    public static final int emSFRNoError_VALUE = 0;
    /**
     * <code>emSFRProtectionTime = 1;</code>
     *
     * <pre>
     *待机保护时间(30秒)
     * </pre>
     */
    public static final int emSFRProtectionTime_VALUE = 1;
    /**
     * <code>emSFRMonitor = 2;</code>
     *
     * <pre>
     *监控
     * </pre>
     */
    public static final int emSFRMonitor_VALUE = 2;
    /**
     * <code>emSFRInConf = 3;</code>
     *
     * <pre>
     *会议
     * </pre>
     */
    public static final int emSFRInConf_VALUE = 3;
    /**
     * <code>emSFRLoop = 4;</code>
     *
     * <pre>
     *自环
     * </pre>
     */
    public static final int emSFRLoop_VALUE = 4;
    /**
     * <code>emSFRRibbonTest = 5;</code>
     *
     * <pre>
     *色带测试
     * </pre>
     */
    public static final int emSFRRibbonTest_VALUE = 5;
    /**
     * <code>emSFRSnapView = 6;</code>
     *
     * <pre>
     *快照浏览
     * </pre>
     */
    public static final int emSFRSnapView_VALUE = 6;
    /**
     * <code>emSFRVrs = 7;</code>
     *
     * <pre>
     *VRS
     * </pre>
     */
    public static final int emSFRVrs_VALUE = 7;
    /**
     * <code>emSFRUpgrade = 8;</code>
     *
     * <pre>
     *升级
     * </pre>
     */
    public static final int emSFRUpgrade_VALUE = 8;
    /**
     * <code>emSFRSusUpgrade = 9;</code>
     *
     * <pre>
     *SUS升级
     * </pre>
     */
    public static final int emSFRSusUpgrade_VALUE = 9;
    /**
     * <code>emSFRNetCap = 10;</code>
     *
     * <pre>
     *抓包
     * </pre>
     */
    public static final int emSFRNetCap_VALUE = 10;
    /**
     * <code>emSFRAddrbook = 11;</code>
     *
     * <pre>
     *地址簿导入或导出
     * </pre>
     */
    public static final int emSFRAddrbook_VALUE = 11;
    /**
     * <code>emSFRSnapExport = 12;</code>
     *
     * <pre>
     *快照导出
     * </pre>
     */
    public static final int emSFRSnapExport_VALUE = 12;
    /**
     * <code>emSFRCameraUpgrade = 13;</code>
     *
     * <pre>
     *摄像机升级
     * </pre>
     */
    public static final int emSFRCameraUpgrade_VALUE = 13;
    /**
     * <code>emSFRMicPhoneUpgrade = 14;</code>
     *
     * <pre>
     *麦克风升级
     * </pre>
     */
    public static final int emSFRMicPhoneUpgrade_VALUE = 14;
    /**
     * <code>emSFRMtRecorde = 15;</code>
     *
     * <pre>
     *本地录像
     * </pre>
     */
    public static final int emSFRMtRecorde_VALUE = 15;
    /**
     * <code>emSFRMtAssStream = 16;</code>
     *
     * <pre>
     *skyshare双流
     * </pre>
     */
    public static final int emSFRMtAssStream_VALUE = 16;


    public final int getNumber() { return value; }

    public static EmSleepFailReason valueOf(int value) {
      switch (value) {
        case 0: return emSFRNoError;
        case 1: return emSFRProtectionTime;
        case 2: return emSFRMonitor;
        case 3: return emSFRInConf;
        case 4: return emSFRLoop;
        case 5: return emSFRRibbonTest;
        case 6: return emSFRSnapView;
        case 7: return emSFRVrs;
        case 8: return emSFRUpgrade;
        case 9: return emSFRSusUpgrade;
        case 10: return emSFRNetCap;
        case 11: return emSFRAddrbook;
        case 12: return emSFRSnapExport;
        case 13: return emSFRCameraUpgrade;
        case 14: return emSFRMicPhoneUpgrade;
        case 15: return emSFRMtRecorde;
        case 16: return emSFRMtAssStream;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSleepFailReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSleepFailReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSleepFailReason>() {
            public EmSleepFailReason findValueByNumber(int number) {
              return EmSleepFailReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(205);
    }

    private static final EmSleepFailReason[] VALUES = values();

    public static EmSleepFailReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSleepFailReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSleepFailReason)
  }

  /**
   * Protobuf enum {@code mt.EmResizeMode}
   *
   * <pre>
   *解码后处理策略
   * </pre>
   */
  public enum EmResizeMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emBlackEdge = 0;</code>
     *
     * <pre>
     *加黑边
     * </pre>
     */
    emBlackEdge(0, 0),
    /**
     * <code>emCutEdge = 1;</code>
     *
     * <pre>
     *裁边
     * </pre>
     */
    emCutEdge(1, 1),
    /**
     * <code>emNoProportionally = 2;</code>
     *
     * <pre>
     *非等比
     * </pre>
     */
    emNoProportionally(2, 2),
    ;

    /**
     * <code>emBlackEdge = 0;</code>
     *
     * <pre>
     *加黑边
     * </pre>
     */
    public static final int emBlackEdge_VALUE = 0;
    /**
     * <code>emCutEdge = 1;</code>
     *
     * <pre>
     *裁边
     * </pre>
     */
    public static final int emCutEdge_VALUE = 1;
    /**
     * <code>emNoProportionally = 2;</code>
     *
     * <pre>
     *非等比
     * </pre>
     */
    public static final int emNoProportionally_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmResizeMode valueOf(int value) {
      switch (value) {
        case 0: return emBlackEdge;
        case 1: return emCutEdge;
        case 2: return emNoProportionally;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmResizeMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmResizeMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmResizeMode>() {
            public EmResizeMode findValueByNumber(int number) {
              return EmResizeMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(206);
    }

    private static final EmResizeMode[] VALUES = values();

    public static EmResizeMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmResizeMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmResizeMode)
  }

  /**
   * Protobuf enum {@code mt.EmLocalSoundType}
   *
   * <pre>
   *本地声音类型
   * </pre>
   */
  public enum EmLocalSoundType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emLSRing = 0;</code>
     *
     * <pre>
     *铃声
     * </pre>
     */
    emLSRing(0, 0),
    /**
     * <code>emLSKeyTone = 1;</code>
     *
     * <pre>
     *按键音效
     * </pre>
     */
    emLSKeyTone(1, 1),
    /**
     * <code>emLSSpecialEffects = 2;</code>
     *
     * <pre>
     *动画音效
     * </pre>
     */
    emLSSpecialEffects(2, 2),
    ;

    /**
     * <code>emLSRing = 0;</code>
     *
     * <pre>
     *铃声
     * </pre>
     */
    public static final int emLSRing_VALUE = 0;
    /**
     * <code>emLSKeyTone = 1;</code>
     *
     * <pre>
     *按键音效
     * </pre>
     */
    public static final int emLSKeyTone_VALUE = 1;
    /**
     * <code>emLSSpecialEffects = 2;</code>
     *
     * <pre>
     *动画音效
     * </pre>
     */
    public static final int emLSSpecialEffects_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmLocalSoundType valueOf(int value) {
      switch (value) {
        case 0: return emLSRing;
        case 1: return emLSKeyTone;
        case 2: return emLSSpecialEffects;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmLocalSoundType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmLocalSoundType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmLocalSoundType>() {
            public EmLocalSoundType findValueByNumber(int number) {
              return EmLocalSoundType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(207);
    }

    private static final EmLocalSoundType[] VALUES = values();

    public static EmLocalSoundType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmLocalSoundType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmLocalSoundType)
  }

  /**
   * Protobuf enum {@code mt.EmLocalSoundIndex}
   *
   * <pre>
   *本地音效索引
   * </pre>
   */
  public enum EmLocalSoundIndex
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSound1st = 0;</code>
     */
    emSound1st(0, 0),
    /**
     * <code>emSound2nd = 1;</code>
     */
    emSound2nd(1, 1),
    /**
     * <code>emSound3rd = 2;</code>
     */
    emSound3rd(2, 2),
    /**
     * <code>emSound4th = 3;</code>
     */
    emSound4th(3, 3),
    /**
     * <code>emSound5th = 4;</code>
     */
    emSound5th(4, 4),
    /**
     * <code>emSound6th = 5;</code>
     */
    emSound6th(5, 5),
    /**
     * <code>emSound7th = 6;</code>
     */
    emSound7th(6, 6),
    /**
     * <code>emSound8th = 7;</code>
     */
    emSound8th(7, 7),
    /**
     * <code>emSound9th = 8;</code>
     */
    emSound9th(8, 8),
    ;

    /**
     * <code>emSound1st = 0;</code>
     */
    public static final int emSound1st_VALUE = 0;
    /**
     * <code>emSound2nd = 1;</code>
     */
    public static final int emSound2nd_VALUE = 1;
    /**
     * <code>emSound3rd = 2;</code>
     */
    public static final int emSound3rd_VALUE = 2;
    /**
     * <code>emSound4th = 3;</code>
     */
    public static final int emSound4th_VALUE = 3;
    /**
     * <code>emSound5th = 4;</code>
     */
    public static final int emSound5th_VALUE = 4;
    /**
     * <code>emSound6th = 5;</code>
     */
    public static final int emSound6th_VALUE = 5;
    /**
     * <code>emSound7th = 6;</code>
     */
    public static final int emSound7th_VALUE = 6;
    /**
     * <code>emSound8th = 7;</code>
     */
    public static final int emSound8th_VALUE = 7;
    /**
     * <code>emSound9th = 8;</code>
     */
    public static final int emSound9th_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmLocalSoundIndex valueOf(int value) {
      switch (value) {
        case 0: return emSound1st;
        case 1: return emSound2nd;
        case 2: return emSound3rd;
        case 3: return emSound4th;
        case 4: return emSound5th;
        case 5: return emSound6th;
        case 6: return emSound7th;
        case 7: return emSound8th;
        case 8: return emSound9th;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmLocalSoundIndex>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmLocalSoundIndex>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmLocalSoundIndex>() {
            public EmLocalSoundIndex findValueByNumber(int number) {
              return EmLocalSoundIndex.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(208);
    }

    private static final EmLocalSoundIndex[] VALUES = values();

    public static EmLocalSoundIndex valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmLocalSoundIndex(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmLocalSoundIndex)
  }

  /**
   * Protobuf enum {@code mt.EmFileCopyErr}
   *
   * <pre>
   *文件拷贝错误码
   * </pre>
   */
  public enum EmFileCopyErr
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCopySuccess = 0;</code>
     *
     * <pre>
     *成功
     * </pre>
     */
    emCopySuccess(0, 0),
    /**
     * <code>emCopyUnknownErr = 1;</code>
     *
     * <pre>
     *未知错误
     * </pre>
     */
    emCopyUnknownErr(1, 1),
    /**
     * <code>emCopyNoSpace = 2;</code>
     *
     * <pre>
     *空间不足
     * </pre>
     */
    emCopyNoSpace(2, 2),
    /**
     * <code>emCopySrcFileNotFound = 3;</code>
     *
     * <pre>
     *源文件不存在
     * </pre>
     */
    emCopySrcFileNotFound(3, 3),
    /**
     * <code>emCopyDstPathNotFound = 4;</code>
     *
     * <pre>
     *目标路径不存在
     * </pre>
     */
    emCopyDstPathNotFound(4, 4),
    /**
     * <code>emCopyStop = 5;</code>
     *
     * <pre>
     *停止拷贝
     * </pre>
     */
    emCopyStop(5, 5),
    ;

    /**
     * <code>emCopySuccess = 0;</code>
     *
     * <pre>
     *成功
     * </pre>
     */
    public static final int emCopySuccess_VALUE = 0;
    /**
     * <code>emCopyUnknownErr = 1;</code>
     *
     * <pre>
     *未知错误
     * </pre>
     */
    public static final int emCopyUnknownErr_VALUE = 1;
    /**
     * <code>emCopyNoSpace = 2;</code>
     *
     * <pre>
     *空间不足
     * </pre>
     */
    public static final int emCopyNoSpace_VALUE = 2;
    /**
     * <code>emCopySrcFileNotFound = 3;</code>
     *
     * <pre>
     *源文件不存在
     * </pre>
     */
    public static final int emCopySrcFileNotFound_VALUE = 3;
    /**
     * <code>emCopyDstPathNotFound = 4;</code>
     *
     * <pre>
     *目标路径不存在
     * </pre>
     */
    public static final int emCopyDstPathNotFound_VALUE = 4;
    /**
     * <code>emCopyStop = 5;</code>
     *
     * <pre>
     *停止拷贝
     * </pre>
     */
    public static final int emCopyStop_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmFileCopyErr valueOf(int value) {
      switch (value) {
        case 0: return emCopySuccess;
        case 1: return emCopyUnknownErr;
        case 2: return emCopyNoSpace;
        case 3: return emCopySrcFileNotFound;
        case 4: return emCopyDstPathNotFound;
        case 5: return emCopyStop;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFileCopyErr>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFileCopyErr>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFileCopyErr>() {
            public EmFileCopyErr findValueByNumber(int number) {
              return EmFileCopyErr.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(209);
    }

    private static final EmFileCopyErr[] VALUES = values();

    public static EmFileCopyErr valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFileCopyErr(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFileCopyErr)
  }

  /**
   * Protobuf enum {@code mt.EmMicDevId}
   *
   * <pre>
   *数字麦对应的Id
   * </pre>
   */
  public enum EmMicDevId
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWiredMic0 = 0;</code>
     *
     * <pre>
     * 0-有线麦0
     * </pre>
     */
    emWiredMic0(0, 0),
    /**
     * <code>emWiredMic1 = 1;</code>
     *
     * <pre>
     * 1-有线麦1
     * </pre>
     */
    emWiredMic1(1, 1),
    /**
     * <code>emWirelessMic0 = 2;</code>
     *
     * <pre>
     * 2-无线麦0
     * </pre>
     */
    emWirelessMic0(2, 2),
    /**
     * <code>emWirelessMic1 = 3;</code>
     *
     * <pre>
     * 3-无线麦1
     * </pre>
     */
    emWirelessMic1(3, 3),
    /**
     * <code>emWirelessMic2 = 4;</code>
     *
     * <pre>
     * 4-无线麦2
     * </pre>
     */
    emWirelessMic2(4, 4),
    /**
     * <code>emWiredMic0Cascade1 = 5;</code>
     *
     * <pre>
     * 有线麦0级联1
     * </pre>
     */
    emWiredMic0Cascade1(5, 5),
    /**
     * <code>emWiredMic0Cascade2 = 6;</code>
     *
     * <pre>
     * 有线麦0级联2
     * </pre>
     */
    emWiredMic0Cascade2(6, 6),
    /**
     * <code>emWiredMic1Cascade1 = 7;</code>
     *
     * <pre>
     * 有线麦1级联1
     * </pre>
     */
    emWiredMic1Cascade1(7, 7),
    /**
     * <code>emWiredMic1Cascade2 = 8;</code>
     *
     * <pre>
     * 有线麦1级联2
     * </pre>
     */
    emWiredMic1Cascade2(8, 8),
    /**
     * <code>emBuiltinMic0 = 9;</code>
     *
     * <pre>
     * 内置麦1
     * </pre>
     */
    emBuiltinMic0(9, 9),
    /**
     * <code>emBuiltinMic1 = 10;</code>
     *
     * <pre>
     * 内置麦2
     * </pre>
     */
    emBuiltinMic1(10, 10),
    /**
     * <code>emMicDevEnd = 11;</code>
     *
     * <pre>
     * 麦克最大个数
     * </pre>
     */
    emMicDevEnd(11, 11),
    ;

    /**
     * <code>emWiredMic0 = 0;</code>
     *
     * <pre>
     * 0-有线麦0
     * </pre>
     */
    public static final int emWiredMic0_VALUE = 0;
    /**
     * <code>emWiredMic1 = 1;</code>
     *
     * <pre>
     * 1-有线麦1
     * </pre>
     */
    public static final int emWiredMic1_VALUE = 1;
    /**
     * <code>emWirelessMic0 = 2;</code>
     *
     * <pre>
     * 2-无线麦0
     * </pre>
     */
    public static final int emWirelessMic0_VALUE = 2;
    /**
     * <code>emWirelessMic1 = 3;</code>
     *
     * <pre>
     * 3-无线麦1
     * </pre>
     */
    public static final int emWirelessMic1_VALUE = 3;
    /**
     * <code>emWirelessMic2 = 4;</code>
     *
     * <pre>
     * 4-无线麦2
     * </pre>
     */
    public static final int emWirelessMic2_VALUE = 4;
    /**
     * <code>emWiredMic0Cascade1 = 5;</code>
     *
     * <pre>
     * 有线麦0级联1
     * </pre>
     */
    public static final int emWiredMic0Cascade1_VALUE = 5;
    /**
     * <code>emWiredMic0Cascade2 = 6;</code>
     *
     * <pre>
     * 有线麦0级联2
     * </pre>
     */
    public static final int emWiredMic0Cascade2_VALUE = 6;
    /**
     * <code>emWiredMic1Cascade1 = 7;</code>
     *
     * <pre>
     * 有线麦1级联1
     * </pre>
     */
    public static final int emWiredMic1Cascade1_VALUE = 7;
    /**
     * <code>emWiredMic1Cascade2 = 8;</code>
     *
     * <pre>
     * 有线麦1级联2
     * </pre>
     */
    public static final int emWiredMic1Cascade2_VALUE = 8;
    /**
     * <code>emBuiltinMic0 = 9;</code>
     *
     * <pre>
     * 内置麦1
     * </pre>
     */
    public static final int emBuiltinMic0_VALUE = 9;
    /**
     * <code>emBuiltinMic1 = 10;</code>
     *
     * <pre>
     * 内置麦2
     * </pre>
     */
    public static final int emBuiltinMic1_VALUE = 10;
    /**
     * <code>emMicDevEnd = 11;</code>
     *
     * <pre>
     * 麦克最大个数
     * </pre>
     */
    public static final int emMicDevEnd_VALUE = 11;


    public final int getNumber() { return value; }

    public static EmMicDevId valueOf(int value) {
      switch (value) {
        case 0: return emWiredMic0;
        case 1: return emWiredMic1;
        case 2: return emWirelessMic0;
        case 3: return emWirelessMic1;
        case 4: return emWirelessMic2;
        case 5: return emWiredMic0Cascade1;
        case 6: return emWiredMic0Cascade2;
        case 7: return emWiredMic1Cascade1;
        case 8: return emWiredMic1Cascade2;
        case 9: return emBuiltinMic0;
        case 10: return emBuiltinMic1;
        case 11: return emMicDevEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMicDevId>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMicDevId>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMicDevId>() {
            public EmMicDevId findValueByNumber(int number) {
              return EmMicDevId.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(210);
    }

    private static final EmMicDevId[] VALUES = values();

    public static EmMicDevId valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMicDevId(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMicDevId)
  }

  /**
   * Protobuf enum {@code mt.EmTemplateAccoutType}
   *
   * <pre>
   *会议模板账户类型
   * </pre>
   */
  public enum EmTemplateAccoutType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAccountNone = 0;</code>
     */
    emAccountNone(0, 0),
    /**
     * <code>emAccountMoid = 1;</code>
     *
     * <pre>
     *MOID
     * </pre>
     */
    emAccountMoid(1, 1),
    /**
     * <code>emAccountAny = 3;</code>
     *
     * <pre>
     *任意账号
     * </pre>
     */
    emAccountAny(2, 3),
    /**
     * <code>emAccountNonSysMail = 4;</code>
     *
     * <pre>
     *非系统邮箱
     * </pre>
     */
    emAccountNonSysMail(3, 4),
    /**
     * <code>emAccountE164 = 5;</code>
     *
     * <pre>
     *E164号码
     * </pre>
     */
    emAccountE164(4, 5),
    /**
     * <code>emAccountTelPhone = 6;</code>
     *
     * <pre>
     *电话
     * </pre>
     */
    emAccountTelPhone(5, 6),
    /**
     * <code>emAccountIP = 7;</code>
     *
     * <pre>
     *IP地址
     * </pre>
     */
    emAccountIP(6, 7),
    /**
     * <code>emAccountAlias = 8;</code>
     *
     * <pre>
     *别名@ip(监控前端)
     * </pre>
     */
    emAccountAlias(7, 8),
    ;

    /**
     * <code>emAccountNone = 0;</code>
     */
    public static final int emAccountNone_VALUE = 0;
    /**
     * <code>emAccountMoid = 1;</code>
     *
     * <pre>
     *MOID
     * </pre>
     */
    public static final int emAccountMoid_VALUE = 1;
    /**
     * <code>emAccountAny = 3;</code>
     *
     * <pre>
     *任意账号
     * </pre>
     */
    public static final int emAccountAny_VALUE = 3;
    /**
     * <code>emAccountNonSysMail = 4;</code>
     *
     * <pre>
     *非系统邮箱
     * </pre>
     */
    public static final int emAccountNonSysMail_VALUE = 4;
    /**
     * <code>emAccountE164 = 5;</code>
     *
     * <pre>
     *E164号码
     * </pre>
     */
    public static final int emAccountE164_VALUE = 5;
    /**
     * <code>emAccountTelPhone = 6;</code>
     *
     * <pre>
     *电话
     * </pre>
     */
    public static final int emAccountTelPhone_VALUE = 6;
    /**
     * <code>emAccountIP = 7;</code>
     *
     * <pre>
     *IP地址
     * </pre>
     */
    public static final int emAccountIP_VALUE = 7;
    /**
     * <code>emAccountAlias = 8;</code>
     *
     * <pre>
     *别名@ip(监控前端)
     * </pre>
     */
    public static final int emAccountAlias_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmTemplateAccoutType valueOf(int value) {
      switch (value) {
        case 0: return emAccountNone;
        case 1: return emAccountMoid;
        case 3: return emAccountAny;
        case 4: return emAccountNonSysMail;
        case 5: return emAccountE164;
        case 6: return emAccountTelPhone;
        case 7: return emAccountIP;
        case 8: return emAccountAlias;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmTemplateAccoutType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmTemplateAccoutType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmTemplateAccoutType>() {
            public EmTemplateAccoutType findValueByNumber(int number) {
              return EmTemplateAccoutType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(211);
    }

    private static final EmTemplateAccoutType[] VALUES = values();

    public static EmTemplateAccoutType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmTemplateAccoutType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmTemplateAccoutType)
  }

  /**
   * Protobuf enum {@code mt.EmPingUserId}
   *
   * <pre>
   *ping操作的时候，用于标识调用者的UID
   * </pre>
   */
  public enum EmPingUserId
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPingUidLan = 0;</code>
     *
     * <pre>
     *局域网可连接测试
     * </pre>
     */
    emPingUidLan(0, 0),
    /**
     * <code>emPingUidInternet = 1;</code>
     *
     * <pre>
     *互联网可连接测试
     * </pre>
     */
    emPingUidInternet(1, 1),
    /**
     * <code>emPingUidDns = 2;</code>
     *
     * <pre>
     *服务器DNS解析测试
     * </pre>
     */
    emPingUidDns(2, 2),
    /**
     * <code>emPingUidServer = 3;</code>
     *
     * <pre>
     *当前选择的服务器可连接测试
     * </pre>
     */
    emPingUidServer(3, 3),
    /**
     * <code>emPingUid4 = 4;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emPingUid4(4, 4),
    /**
     * <code>emPingUid5 = 5;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emPingUid5(5, 5),
    /**
     * <code>emPingUid6 = 6;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emPingUid6(6, 6),
    /**
     * <code>emPingUid7 = 7;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emPingUid7(7, 7),
    /**
     * <code>emPingUid8 = 8;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emPingUid8(8, 8),
    ;

    /**
     * <code>emPingUidLan = 0;</code>
     *
     * <pre>
     *局域网可连接测试
     * </pre>
     */
    public static final int emPingUidLan_VALUE = 0;
    /**
     * <code>emPingUidInternet = 1;</code>
     *
     * <pre>
     *互联网可连接测试
     * </pre>
     */
    public static final int emPingUidInternet_VALUE = 1;
    /**
     * <code>emPingUidDns = 2;</code>
     *
     * <pre>
     *服务器DNS解析测试
     * </pre>
     */
    public static final int emPingUidDns_VALUE = 2;
    /**
     * <code>emPingUidServer = 3;</code>
     *
     * <pre>
     *当前选择的服务器可连接测试
     * </pre>
     */
    public static final int emPingUidServer_VALUE = 3;
    /**
     * <code>emPingUid4 = 4;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emPingUid4_VALUE = 4;
    /**
     * <code>emPingUid5 = 5;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emPingUid5_VALUE = 5;
    /**
     * <code>emPingUid6 = 6;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emPingUid6_VALUE = 6;
    /**
     * <code>emPingUid7 = 7;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emPingUid7_VALUE = 7;
    /**
     * <code>emPingUid8 = 8;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emPingUid8_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmPingUserId valueOf(int value) {
      switch (value) {
        case 0: return emPingUidLan;
        case 1: return emPingUidInternet;
        case 2: return emPingUidDns;
        case 3: return emPingUidServer;
        case 4: return emPingUid4;
        case 5: return emPingUid5;
        case 6: return emPingUid6;
        case 7: return emPingUid7;
        case 8: return emPingUid8;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPingUserId>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPingUserId>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPingUserId>() {
            public EmPingUserId findValueByNumber(int number) {
              return EmPingUserId.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(212);
    }

    private static final EmPingUserId[] VALUES = values();

    public static EmPingUserId valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPingUserId(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPingUserId)
  }

  /**
   * Protobuf enum {@code mt.EmMicUpgradeState}
   *
   * <pre>
   *麦克风更新状态
   * </pre>
   */
  public enum EmMicUpgradeState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUploadEnable = 0;</code>
     *
     * <pre>
     *可上传
     * </pre>
     */
    emUploadEnable(0, 0),
    /**
     * <code>emUploading = 1;</code>
     *
     * <pre>
     *上传中
     * </pre>
     */
    emUploading(1, 1),
    /**
     * <code>emInstallable = 2;</code>
     *
     * <pre>
     *可安装
     * </pre>
     */
    emInstallable(2, 2),
    /**
     * <code>emInstalling = 3;</code>
     *
     * <pre>
     *安装中
     * </pre>
     */
    emInstalling(3, 3),
    /**
     * <code>emUpgradeSuccess = 4;</code>
     *
     * <pre>
     *安装成功
     * </pre>
     */
    emUpgradeSuccess(4, 4),
    /**
     * <code>emLatestVersion = 5;</code>
     *
     * <pre>
     *最新版本
     * </pre>
     */
    emLatestVersion(5, 5),
    /**
     * <code>emReserve1 = 6;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emReserve1(6, 6),
    /**
     * <code>emReserve2 = 7;</code>
     *
     * <pre>
     *未连接
     * </pre>
     */
    emReserve2(7, 7),
    ;

    /**
     * <code>emUploadEnable = 0;</code>
     *
     * <pre>
     *可上传
     * </pre>
     */
    public static final int emUploadEnable_VALUE = 0;
    /**
     * <code>emUploading = 1;</code>
     *
     * <pre>
     *上传中
     * </pre>
     */
    public static final int emUploading_VALUE = 1;
    /**
     * <code>emInstallable = 2;</code>
     *
     * <pre>
     *可安装
     * </pre>
     */
    public static final int emInstallable_VALUE = 2;
    /**
     * <code>emInstalling = 3;</code>
     *
     * <pre>
     *安装中
     * </pre>
     */
    public static final int emInstalling_VALUE = 3;
    /**
     * <code>emUpgradeSuccess = 4;</code>
     *
     * <pre>
     *安装成功
     * </pre>
     */
    public static final int emUpgradeSuccess_VALUE = 4;
    /**
     * <code>emLatestVersion = 5;</code>
     *
     * <pre>
     *最新版本
     * </pre>
     */
    public static final int emLatestVersion_VALUE = 5;
    /**
     * <code>emReserve1 = 6;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emReserve1_VALUE = 6;
    /**
     * <code>emReserve2 = 7;</code>
     *
     * <pre>
     *未连接
     * </pre>
     */
    public static final int emReserve2_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmMicUpgradeState valueOf(int value) {
      switch (value) {
        case 0: return emUploadEnable;
        case 1: return emUploading;
        case 2: return emInstallable;
        case 3: return emInstalling;
        case 4: return emUpgradeSuccess;
        case 5: return emLatestVersion;
        case 6: return emReserve1;
        case 7: return emReserve2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMicUpgradeState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMicUpgradeState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMicUpgradeState>() {
            public EmMicUpgradeState findValueByNumber(int number) {
              return EmMicUpgradeState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(213);
    }

    private static final EmMicUpgradeState[] VALUES = values();

    public static EmMicUpgradeState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMicUpgradeState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMicUpgradeState)
  }

  /**
   * Protobuf enum {@code mt.EmAudioDelayCheckState}
   *
   * <pre>
   *音频时延检测状态
   * </pre>
   */
  public enum EmAudioDelayCheckState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAudioDelayBegin = 0;</code>
     *
     * <pre>
     *初始状态
     * </pre>
     */
    emAudioDelayBegin(0, 0),
    /**
     * <code>emAudioDelayChecking = 1;</code>
     *
     * <pre>
     *正在检测
     * </pre>
     */
    emAudioDelayChecking(1, 1),
    /**
     * <code>emAudioDelayChecked = 2;</code>
     *
     * <pre>
     *检测完成
     * </pre>
     */
    emAudioDelayChecked(2, 2),
    /**
     * <code>emAudioDelayTimeout = 3;</code>
     *
     * <pre>
     *检测超时
     * </pre>
     */
    emAudioDelayTimeout(3, 3),
    /**
     * <code>emAudioDelayFailed = 4;</code>
     *
     * <pre>
     *检测失败
     * </pre>
     */
    emAudioDelayFailed(4, 4),
    /**
     * <code>emAudioDelayReserve1 = 5;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emAudioDelayReserve1(5, 5),
    /**
     * <code>emAudioDelayReserve2 = 6;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    emAudioDelayReserve2(6, 6),
    ;

    /**
     * <code>emAudioDelayBegin = 0;</code>
     *
     * <pre>
     *初始状态
     * </pre>
     */
    public static final int emAudioDelayBegin_VALUE = 0;
    /**
     * <code>emAudioDelayChecking = 1;</code>
     *
     * <pre>
     *正在检测
     * </pre>
     */
    public static final int emAudioDelayChecking_VALUE = 1;
    /**
     * <code>emAudioDelayChecked = 2;</code>
     *
     * <pre>
     *检测完成
     * </pre>
     */
    public static final int emAudioDelayChecked_VALUE = 2;
    /**
     * <code>emAudioDelayTimeout = 3;</code>
     *
     * <pre>
     *检测超时
     * </pre>
     */
    public static final int emAudioDelayTimeout_VALUE = 3;
    /**
     * <code>emAudioDelayFailed = 4;</code>
     *
     * <pre>
     *检测失败
     * </pre>
     */
    public static final int emAudioDelayFailed_VALUE = 4;
    /**
     * <code>emAudioDelayReserve1 = 5;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emAudioDelayReserve1_VALUE = 5;
    /**
     * <code>emAudioDelayReserve2 = 6;</code>
     *
     * <pre>
     *保留，使用时添加注释
     * </pre>
     */
    public static final int emAudioDelayReserve2_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmAudioDelayCheckState valueOf(int value) {
      switch (value) {
        case 0: return emAudioDelayBegin;
        case 1: return emAudioDelayChecking;
        case 2: return emAudioDelayChecked;
        case 3: return emAudioDelayTimeout;
        case 4: return emAudioDelayFailed;
        case 5: return emAudioDelayReserve1;
        case 6: return emAudioDelayReserve2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAudioDelayCheckState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAudioDelayCheckState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAudioDelayCheckState>() {
            public EmAudioDelayCheckState findValueByNumber(int number) {
              return EmAudioDelayCheckState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(214);
    }

    private static final EmAudioDelayCheckState[] VALUES = values();

    public static EmAudioDelayCheckState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAudioDelayCheckState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAudioDelayCheckState)
  }

  /**
   * Protobuf enum {@code mt.EmCameraUpgradeErrCode}
   *
   * <pre>
   *摄像机升级错误码
   * </pre>
   */
  public enum EmCameraUpgradeErrCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCUSuccess = 0;</code>
     *
     * <pre>
     *升级成功
     * </pre>
     */
    emCUSuccess(0, 0),
    /**
     * <code>emCUUpgrading = 1;</code>
     *
     * <pre>
     *正在升级中
     * </pre>
     */
    emCUUpgrading(1, 1),
    /**
     * <code>emCUErrType = 2;</code>
     *
     * <pre>
     *升级类型错误
     * </pre>
     */
    emCUErrType(2, 2),
    /**
     * <code>emCUNoDevice = 3;</code>
     *
     * <pre>
     *设备不存在
     * </pre>
     */
    emCUNoDevice(3, 3),
    /**
     * <code>emCUNoUpgradeFile = 4;</code>
     *
     * <pre>
     *升级文件不存在
     * </pre>
     */
    emCUNoUpgradeFile(4, 4),
    /**
     * <code>emCUFailure = 5;</code>
     *
     * <pre>
     *升级失败
     * </pre>
     */
    emCUFailure(5, 5),
    ;

    /**
     * <code>emCUSuccess = 0;</code>
     *
     * <pre>
     *升级成功
     * </pre>
     */
    public static final int emCUSuccess_VALUE = 0;
    /**
     * <code>emCUUpgrading = 1;</code>
     *
     * <pre>
     *正在升级中
     * </pre>
     */
    public static final int emCUUpgrading_VALUE = 1;
    /**
     * <code>emCUErrType = 2;</code>
     *
     * <pre>
     *升级类型错误
     * </pre>
     */
    public static final int emCUErrType_VALUE = 2;
    /**
     * <code>emCUNoDevice = 3;</code>
     *
     * <pre>
     *设备不存在
     * </pre>
     */
    public static final int emCUNoDevice_VALUE = 3;
    /**
     * <code>emCUNoUpgradeFile = 4;</code>
     *
     * <pre>
     *升级文件不存在
     * </pre>
     */
    public static final int emCUNoUpgradeFile_VALUE = 4;
    /**
     * <code>emCUFailure = 5;</code>
     *
     * <pre>
     *升级失败
     * </pre>
     */
    public static final int emCUFailure_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmCameraUpgradeErrCode valueOf(int value) {
      switch (value) {
        case 0: return emCUSuccess;
        case 1: return emCUUpgrading;
        case 2: return emCUErrType;
        case 3: return emCUNoDevice;
        case 4: return emCUNoUpgradeFile;
        case 5: return emCUFailure;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCameraUpgradeErrCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCameraUpgradeErrCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCameraUpgradeErrCode>() {
            public EmCameraUpgradeErrCode findValueByNumber(int number) {
              return EmCameraUpgradeErrCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(215);
    }

    private static final EmCameraUpgradeErrCode[] VALUES = values();

    public static EmCameraUpgradeErrCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCameraUpgradeErrCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCameraUpgradeErrCode)
  }

  /**
   * Protobuf enum {@code mt.EmUpgradeExitErrCode}
   *
   * <pre>
   *升级异常退出原因(下载升级文件阶段)
   * </pre>
   */
  public enum EmUpgradeExitErrCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUpgradeForceExit = 0;</code>
     *
     * <pre>
     *由于业务需求，需要停止升级文件下载
     * </pre>
     */
    emUpgradeForceExit(0, 0),
    /**
     * <code>emUpgradeNetWorkDisconnect = 1;</code>
     *
     * <pre>
     *网络断开
     * </pre>
     */
    emUpgradeNetWorkDisconnect(1, 1),
    ;

    /**
     * <code>emUpgradeForceExit = 0;</code>
     *
     * <pre>
     *由于业务需求，需要停止升级文件下载
     * </pre>
     */
    public static final int emUpgradeForceExit_VALUE = 0;
    /**
     * <code>emUpgradeNetWorkDisconnect = 1;</code>
     *
     * <pre>
     *网络断开
     * </pre>
     */
    public static final int emUpgradeNetWorkDisconnect_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmUpgradeExitErrCode valueOf(int value) {
      switch (value) {
        case 0: return emUpgradeForceExit;
        case 1: return emUpgradeNetWorkDisconnect;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeExitErrCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmUpgradeExitErrCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmUpgradeExitErrCode>() {
            public EmUpgradeExitErrCode findValueByNumber(int number) {
              return EmUpgradeExitErrCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(216);
    }

    private static final EmUpgradeExitErrCode[] VALUES = values();

    public static EmUpgradeExitErrCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmUpgradeExitErrCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmUpgradeExitErrCode)
  }

  /**
   * Protobuf enum {@code mt.EmGeneralLevel}
   *
   * <pre>
   *通用等级
   * </pre>
   */
  public enum EmGeneralLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emGeneralLevel0 = 0;</code>
     *
     * <pre>
     * 低	慢
     * </pre>
     */
    emGeneralLevel0(0, 0),
    /**
     * <code>emGeneralLevel1 = 1;</code>
     *
     * <pre>
     * 中	中
     * </pre>
     */
    emGeneralLevel1(1, 1),
    /**
     * <code>emGeneralLevel2 = 2;</code>
     *
     * <pre>
     * 高	快
     * </pre>
     */
    emGeneralLevel2(2, 2),
    ;

    /**
     * <code>emGeneralLevel0 = 0;</code>
     *
     * <pre>
     * 低	慢
     * </pre>
     */
    public static final int emGeneralLevel0_VALUE = 0;
    /**
     * <code>emGeneralLevel1 = 1;</code>
     *
     * <pre>
     * 中	中
     * </pre>
     */
    public static final int emGeneralLevel1_VALUE = 1;
    /**
     * <code>emGeneralLevel2 = 2;</code>
     *
     * <pre>
     * 高	快
     * </pre>
     */
    public static final int emGeneralLevel2_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmGeneralLevel valueOf(int value) {
      switch (value) {
        case 0: return emGeneralLevel0;
        case 1: return emGeneralLevel1;
        case 2: return emGeneralLevel2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmGeneralLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmGeneralLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmGeneralLevel>() {
            public EmGeneralLevel findValueByNumber(int number) {
              return EmGeneralLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(217);
    }

    private static final EmGeneralLevel[] VALUES = values();

    public static EmGeneralLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmGeneralLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmGeneralLevel)
  }

  /**
   * Protobuf enum {@code mt.EmISO}
   *
   * <pre>
   *感光度
   * </pre>
   */
  public enum EmISO
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emISOAuto = 0;</code>
     */
    emISOAuto(0, 0),
    /**
     * <code>emISO80 = 1;</code>
     */
    emISO80(1, 1),
    /**
     * <code>emISO100 = 2;</code>
     */
    emISO100(2, 2),
    /**
     * <code>emISO200 = 3;</code>
     */
    emISO200(3, 3),
    /**
     * <code>emISO400 = 4;</code>
     */
    emISO400(4, 4),
    /**
     * <code>emISO800 = 5;</code>
     */
    emISO800(5, 5),
    /**
     * <code>emISO1250 = 6;</code>
     */
    emISO1250(6, 6),
    ;

    /**
     * <code>emISOAuto = 0;</code>
     */
    public static final int emISOAuto_VALUE = 0;
    /**
     * <code>emISO80 = 1;</code>
     */
    public static final int emISO80_VALUE = 1;
    /**
     * <code>emISO100 = 2;</code>
     */
    public static final int emISO100_VALUE = 2;
    /**
     * <code>emISO200 = 3;</code>
     */
    public static final int emISO200_VALUE = 3;
    /**
     * <code>emISO400 = 4;</code>
     */
    public static final int emISO400_VALUE = 4;
    /**
     * <code>emISO800 = 5;</code>
     */
    public static final int emISO800_VALUE = 5;
    /**
     * <code>emISO1250 = 6;</code>
     */
    public static final int emISO1250_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmISO valueOf(int value) {
      switch (value) {
        case 0: return emISOAuto;
        case 1: return emISO80;
        case 2: return emISO100;
        case 3: return emISO200;
        case 4: return emISO400;
        case 5: return emISO800;
        case 6: return emISO1250;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmISO>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmISO>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmISO>() {
            public EmISO findValueByNumber(int number) {
              return EmISO.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(218);
    }

    private static final EmISO[] VALUES = values();

    public static EmISO valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmISO(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmISO)
  }

  /**
   * Protobuf enum {@code mt.EmExposureMode}
   *
   * <pre>
   *曝光模式
   * </pre>
   */
  public enum EmExposureMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emExMManual = 0;</code>
     *
     * <pre>
     *手动 光圈 快门 增益 同时设置
     * </pre>
     */
    emExMManual(0, 0),
    /**
     * <code>emExMAuto = 1;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    emExMAuto(1, 1),
    /**
     * <code>emExMAperturePri = 2;</code>
     *
     * <pre>
     *光圈优先
     * </pre>
     */
    emExMAperturePri(2, 2),
    /**
     * <code>emExMShutterPri = 3;</code>
     *
     * <pre>
     *快门优先
     * </pre>
     */
    emExMShutterPri(3, 3),
    /**
     * <code>emExLowLight = 4;</code>
     *
     * <pre>
     *低照
     * </pre>
     */
    emExLowLight(4, 4),
    /**
     * <code>emExHDR = 5;</code>
     *
     * <pre>
     *HDR
     * </pre>
     */
    emExHDR(5, 5),
    ;

    /**
     * <code>emExMManual = 0;</code>
     *
     * <pre>
     *手动 光圈 快门 增益 同时设置
     * </pre>
     */
    public static final int emExMManual_VALUE = 0;
    /**
     * <code>emExMAuto = 1;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    public static final int emExMAuto_VALUE = 1;
    /**
     * <code>emExMAperturePri = 2;</code>
     *
     * <pre>
     *光圈优先
     * </pre>
     */
    public static final int emExMAperturePri_VALUE = 2;
    /**
     * <code>emExMShutterPri = 3;</code>
     *
     * <pre>
     *快门优先
     * </pre>
     */
    public static final int emExMShutterPri_VALUE = 3;
    /**
     * <code>emExLowLight = 4;</code>
     *
     * <pre>
     *低照
     * </pre>
     */
    public static final int emExLowLight_VALUE = 4;
    /**
     * <code>emExHDR = 5;</code>
     *
     * <pre>
     *HDR
     * </pre>
     */
    public static final int emExHDR_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmExposureMode valueOf(int value) {
      switch (value) {
        case 0: return emExMManual;
        case 1: return emExMAuto;
        case 2: return emExMAperturePri;
        case 3: return emExMShutterPri;
        case 4: return emExLowLight;
        case 5: return emExHDR;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmExposureMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmExposureMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmExposureMode>() {
            public EmExposureMode findValueByNumber(int number) {
              return EmExposureMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(219);
    }

    private static final EmExposureMode[] VALUES = values();

    public static EmExposureMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmExposureMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmExposureMode)
  }

  /**
   * Protobuf enum {@code mt.EmAperture}
   *
   * <pre>
   *光圈大小
   * </pre>
   */
  public enum EmAperture
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emF1p2 = 0;</code>
     *
     * <pre>
     *F1.2
     * </pre>
     */
    emF1p2(0, 0),
    /**
     * <code>emF1p6 = 1;</code>
     *
     * <pre>
     *F1.6
     * </pre>
     */
    emF1p6(1, 1),
    /**
     * <code>emF1p8 = 2;</code>
     *
     * <pre>
     *F1.8
     * </pre>
     */
    emF1p8(2, 2),
    /**
     * <code>emF2p0 = 3;</code>
     *
     * <pre>
     *F2.0
     * </pre>
     */
    emF2p0(3, 3),
    /**
     * <code>emF2p8 = 4;</code>
     *
     * <pre>
     *F2.8
     * </pre>
     */
    emF2p8(4, 4),
    /**
     * <code>emF4p0 = 5;</code>
     *
     * <pre>
     *F4.0
     * </pre>
     */
    emF4p0(5, 5),
    /**
     * <code>emF5p6 = 6;</code>
     *
     * <pre>
     *F5.6
     * </pre>
     */
    emF5p6(6, 6),
    /**
     * <code>emF8p0 = 7;</code>
     *
     * <pre>
     *F8.0
     * </pre>
     */
    emF8p0(7, 7),
    /**
     * <code>emF11 = 8;</code>
     *
     * <pre>
     *F11
     * </pre>
     */
    emF11(8, 8),
    ;

    /**
     * <code>emF1p2 = 0;</code>
     *
     * <pre>
     *F1.2
     * </pre>
     */
    public static final int emF1p2_VALUE = 0;
    /**
     * <code>emF1p6 = 1;</code>
     *
     * <pre>
     *F1.6
     * </pre>
     */
    public static final int emF1p6_VALUE = 1;
    /**
     * <code>emF1p8 = 2;</code>
     *
     * <pre>
     *F1.8
     * </pre>
     */
    public static final int emF1p8_VALUE = 2;
    /**
     * <code>emF2p0 = 3;</code>
     *
     * <pre>
     *F2.0
     * </pre>
     */
    public static final int emF2p0_VALUE = 3;
    /**
     * <code>emF2p8 = 4;</code>
     *
     * <pre>
     *F2.8
     * </pre>
     */
    public static final int emF2p8_VALUE = 4;
    /**
     * <code>emF4p0 = 5;</code>
     *
     * <pre>
     *F4.0
     * </pre>
     */
    public static final int emF4p0_VALUE = 5;
    /**
     * <code>emF5p6 = 6;</code>
     *
     * <pre>
     *F5.6
     * </pre>
     */
    public static final int emF5p6_VALUE = 6;
    /**
     * <code>emF8p0 = 7;</code>
     *
     * <pre>
     *F8.0
     * </pre>
     */
    public static final int emF8p0_VALUE = 7;
    /**
     * <code>emF11 = 8;</code>
     *
     * <pre>
     *F11
     * </pre>
     */
    public static final int emF11_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmAperture valueOf(int value) {
      switch (value) {
        case 0: return emF1p2;
        case 1: return emF1p6;
        case 2: return emF1p8;
        case 3: return emF2p0;
        case 4: return emF2p8;
        case 5: return emF4p0;
        case 6: return emF5p6;
        case 7: return emF8p0;
        case 8: return emF11;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAperture>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAperture>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAperture>() {
            public EmAperture findValueByNumber(int number) {
              return EmAperture.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(220);
    }

    private static final EmAperture[] VALUES = values();

    public static EmAperture valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAperture(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAperture)
  }

  /**
   * Protobuf enum {@code mt.EmShutterType}
   *
   * <pre>
   * 快门类型
   * </pre>
   */
  public enum EmShutterType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emShutterTypeManual = 0;</code>
     *
     * <pre>
     * 手动
     * </pre>
     */
    emShutterTypeManual(0, 0),
    /**
     * <code>emShutterTypeAuto = 1;</code>
     *
     * <pre>
     * 自动
     * </pre>
     */
    emShutterTypeAuto(1, 1),
    ;

    /**
     * <code>emShutterTypeManual = 0;</code>
     *
     * <pre>
     * 手动
     * </pre>
     */
    public static final int emShutterTypeManual_VALUE = 0;
    /**
     * <code>emShutterTypeAuto = 1;</code>
     *
     * <pre>
     * 自动
     * </pre>
     */
    public static final int emShutterTypeAuto_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmShutterType valueOf(int value) {
      switch (value) {
        case 0: return emShutterTypeManual;
        case 1: return emShutterTypeAuto;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmShutterType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmShutterType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmShutterType>() {
            public EmShutterType findValueByNumber(int number) {
              return EmShutterType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(221);
    }

    private static final EmShutterType[] VALUES = values();

    public static EmShutterType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmShutterType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmShutterType)
  }

  /**
   * Protobuf enum {@code mt.EmShutterLevel}
   *
   * <pre>
   *快门速度
   * </pre>
   */
  public enum EmShutterLevel
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emShutter8 = 0;</code>
     *
     * <pre>
     *1/8
     * </pre>
     */
    emShutter8(0, 0),
    /**
     * <code>emShutter15 = 1;</code>
     *
     * <pre>
     *1/15
     * </pre>
     */
    emShutter15(1, 1),
    /**
     * <code>emShutter30 = 2;</code>
     *
     * <pre>
     *1/30
     * </pre>
     */
    emShutter30(2, 2),
    /**
     * <code>emShutter60 = 3;</code>
     *
     * <pre>
     *1/60
     * </pre>
     */
    emShutter60(3, 3),
    /**
     * <code>emShutter100 = 4;</code>
     *
     * <pre>
     *1/100
     * </pre>
     */
    emShutter100(4, 4),
    /**
     * <code>emShutter125 = 5;</code>
     *
     * <pre>
     *1/125
     * </pre>
     */
    emShutter125(5, 5),
    /**
     * <code>emShutter250 = 6;</code>
     *
     * <pre>
     *1/250
     * </pre>
     */
    emShutter250(6, 6),
    /**
     * <code>emShutter500 = 7;</code>
     *
     * <pre>
     *1/500
     * </pre>
     */
    emShutter500(7, 7),
    /**
     * <code>emShutter1000 = 8;</code>
     *
     * <pre>
     *1/1000
     * </pre>
     */
    emShutter1000(8, 8),
    /**
     * <code>emShutter2000 = 9;</code>
     *
     * <pre>
     *1/2000
     * </pre>
     */
    emShutter2000(9, 9),
    /**
     * <code>emShutter4000 = 10;</code>
     *
     * <pre>
     *1/4000
     * </pre>
     */
    emShutter4000(10, 10),
    ;

    /**
     * <code>emShutter8 = 0;</code>
     *
     * <pre>
     *1/8
     * </pre>
     */
    public static final int emShutter8_VALUE = 0;
    /**
     * <code>emShutter15 = 1;</code>
     *
     * <pre>
     *1/15
     * </pre>
     */
    public static final int emShutter15_VALUE = 1;
    /**
     * <code>emShutter30 = 2;</code>
     *
     * <pre>
     *1/30
     * </pre>
     */
    public static final int emShutter30_VALUE = 2;
    /**
     * <code>emShutter60 = 3;</code>
     *
     * <pre>
     *1/60
     * </pre>
     */
    public static final int emShutter60_VALUE = 3;
    /**
     * <code>emShutter100 = 4;</code>
     *
     * <pre>
     *1/100
     * </pre>
     */
    public static final int emShutter100_VALUE = 4;
    /**
     * <code>emShutter125 = 5;</code>
     *
     * <pre>
     *1/125
     * </pre>
     */
    public static final int emShutter125_VALUE = 5;
    /**
     * <code>emShutter250 = 6;</code>
     *
     * <pre>
     *1/250
     * </pre>
     */
    public static final int emShutter250_VALUE = 6;
    /**
     * <code>emShutter500 = 7;</code>
     *
     * <pre>
     *1/500
     * </pre>
     */
    public static final int emShutter500_VALUE = 7;
    /**
     * <code>emShutter1000 = 8;</code>
     *
     * <pre>
     *1/1000
     * </pre>
     */
    public static final int emShutter1000_VALUE = 8;
    /**
     * <code>emShutter2000 = 9;</code>
     *
     * <pre>
     *1/2000
     * </pre>
     */
    public static final int emShutter2000_VALUE = 9;
    /**
     * <code>emShutter4000 = 10;</code>
     *
     * <pre>
     *1/4000
     * </pre>
     */
    public static final int emShutter4000_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmShutterLevel valueOf(int value) {
      switch (value) {
        case 0: return emShutter8;
        case 1: return emShutter15;
        case 2: return emShutter30;
        case 3: return emShutter60;
        case 4: return emShutter100;
        case 5: return emShutter125;
        case 6: return emShutter250;
        case 7: return emShutter500;
        case 8: return emShutter1000;
        case 9: return emShutter2000;
        case 10: return emShutter4000;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmShutterLevel>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmShutterLevel>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmShutterLevel>() {
            public EmShutterLevel findValueByNumber(int number) {
              return EmShutterLevel.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(222);
    }

    private static final EmShutterLevel[] VALUES = values();

    public static EmShutterLevel valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmShutterLevel(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmShutterLevel)
  }

  /**
   * Protobuf enum {@code mt.EmWBAMode}
   *
   * <pre>
   *白平衡
   * </pre>
   */
  public enum EmWBAMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWBAAuto = 0;</code>
     *
     * <pre>
     *自动    自动
     * </pre>
     */
    emWBAAuto(0, 0),
    /**
     * <code>emWBADay = 1;</code>
     *
     * <pre>
     *白天    室内  无
     * </pre>
     */
    emWBADay(1, 1),
    /**
     * <code>emWBACloudy = 2;</code>
     *
     * <pre>
     *多云    户外	无
     * </pre>
     */
    emWBACloudy(2, 2),
    /**
     * <code>emWBAShade = 3;</code>
     *
     * <pre>
     *阴天    钠灯  无
     * </pre>
     */
    emWBAShade(3, 3),
    /**
     * <code>emWBAFluorescent = 4;</code>
     *
     * <pre>
     *荧光灯  无
     * </pre>
     */
    emWBAFluorescent(4, 4),
    /**
     * <code>emWBATUngsten = 5;</code>
     *
     * <pre>
     *白炽灯
     * </pre>
     */
    emWBATUngsten(5, 5),
    /**
     * <code>emWBAWarm = 6;</code>
     *
     * <pre>
     *暖光灯
     * </pre>
     */
    emWBAWarm(6, 6),
    /**
     * <code>emWBAStandard = 7;</code>
     *
     * <pre>
     *标准光
     * </pre>
     */
    emWBAStandard(7, 7),
    /**
     * <code>emWBANatural = 8;</code>
     *
     * <pre>
     *自然灯
     * </pre>
     */
    emWBANatural(8, 8),
    /**
     * <code>emWBASunlight = 9;</code>
     *
     * <pre>
     *日光灯
     * </pre>
     */
    emWBASunlight(9, 9),
    /**
     * <code>emWBAManual = 10;</code>
     *
     * <pre>
     *手动
     * </pre>
     */
    emWBAManual(10, 10),
    ;

    /**
     * <code>emWBAAuto = 0;</code>
     *
     * <pre>
     *自动    自动
     * </pre>
     */
    public static final int emWBAAuto_VALUE = 0;
    /**
     * <code>emWBADay = 1;</code>
     *
     * <pre>
     *白天    室内  无
     * </pre>
     */
    public static final int emWBADay_VALUE = 1;
    /**
     * <code>emWBACloudy = 2;</code>
     *
     * <pre>
     *多云    户外	无
     * </pre>
     */
    public static final int emWBACloudy_VALUE = 2;
    /**
     * <code>emWBAShade = 3;</code>
     *
     * <pre>
     *阴天    钠灯  无
     * </pre>
     */
    public static final int emWBAShade_VALUE = 3;
    /**
     * <code>emWBAFluorescent = 4;</code>
     *
     * <pre>
     *荧光灯  无
     * </pre>
     */
    public static final int emWBAFluorescent_VALUE = 4;
    /**
     * <code>emWBATUngsten = 5;</code>
     *
     * <pre>
     *白炽灯
     * </pre>
     */
    public static final int emWBATUngsten_VALUE = 5;
    /**
     * <code>emWBAWarm = 6;</code>
     *
     * <pre>
     *暖光灯
     * </pre>
     */
    public static final int emWBAWarm_VALUE = 6;
    /**
     * <code>emWBAStandard = 7;</code>
     *
     * <pre>
     *标准光
     * </pre>
     */
    public static final int emWBAStandard_VALUE = 7;
    /**
     * <code>emWBANatural = 8;</code>
     *
     * <pre>
     *自然灯
     * </pre>
     */
    public static final int emWBANatural_VALUE = 8;
    /**
     * <code>emWBASunlight = 9;</code>
     *
     * <pre>
     *日光灯
     * </pre>
     */
    public static final int emWBASunlight_VALUE = 9;
    /**
     * <code>emWBAManual = 10;</code>
     *
     * <pre>
     *手动
     * </pre>
     */
    public static final int emWBAManual_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmWBAMode valueOf(int value) {
      switch (value) {
        case 0: return emWBAAuto;
        case 1: return emWBADay;
        case 2: return emWBACloudy;
        case 3: return emWBAShade;
        case 4: return emWBAFluorescent;
        case 5: return emWBATUngsten;
        case 6: return emWBAWarm;
        case 7: return emWBAStandard;
        case 8: return emWBANatural;
        case 9: return emWBASunlight;
        case 10: return emWBAManual;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWBAMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWBAMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWBAMode>() {
            public EmWBAMode findValueByNumber(int number) {
              return EmWBAMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(223);
    }

    private static final EmWBAMode[] VALUES = values();

    public static EmWBAMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWBAMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWBAMode)
  }

  /**
   * Protobuf enum {@code mt.EMWBAModeGainType}
   */
  public enum EMWBAModeGainType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWBAModeGainRed = 0;</code>
     *
     * <pre>
     *红增益
     * </pre>
     */
    emWBAModeGainRed(0, 0),
    /**
     * <code>emWBAModeGainBlue = 1;</code>
     *
     * <pre>
     *蓝增益
     * </pre>
     */
    emWBAModeGainBlue(1, 1),
    ;

    /**
     * <code>emWBAModeGainRed = 0;</code>
     *
     * <pre>
     *红增益
     * </pre>
     */
    public static final int emWBAModeGainRed_VALUE = 0;
    /**
     * <code>emWBAModeGainBlue = 1;</code>
     *
     * <pre>
     *蓝增益
     * </pre>
     */
    public static final int emWBAModeGainBlue_VALUE = 1;


    public final int getNumber() { return value; }

    public static EMWBAModeGainType valueOf(int value) {
      switch (value) {
        case 0: return emWBAModeGainRed;
        case 1: return emWBAModeGainBlue;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EMWBAModeGainType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EMWBAModeGainType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EMWBAModeGainType>() {
            public EMWBAModeGainType findValueByNumber(int number) {
              return EMWBAModeGainType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(224);
    }

    private static final EMWBAModeGainType[] VALUES = values();

    public static EMWBAModeGainType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EMWBAModeGainType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EMWBAModeGainType)
  }

  /**
   * Protobuf enum {@code mt.EmSceneMode}
   *
   * <pre>
   *场景模式
   * </pre>
   */
  public enum EmSceneMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSceneOff = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    emSceneOff(0, 0),
    /**
     * <code>emSceneNight = 1;</code>
     *
     * <pre>
     *夜间
     * </pre>
     */
    emSceneNight(1, 1),
    /**
     * <code>emSceneAuto = 2;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    emSceneAuto(2, 2),
    /**
     * <code>emSceneWDR = 3;</code>
     *
     * <pre>
     *宽动态
     * </pre>
     */
    emSceneWDR(3, 3),
    /**
     * <code>emSceneHCT = 4;</code>
     *
     * <pre>
     *高色温
     * </pre>
     */
    emSceneHCT(4, 4),
    ;

    /**
     * <code>emSceneOff = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    public static final int emSceneOff_VALUE = 0;
    /**
     * <code>emSceneNight = 1;</code>
     *
     * <pre>
     *夜间
     * </pre>
     */
    public static final int emSceneNight_VALUE = 1;
    /**
     * <code>emSceneAuto = 2;</code>
     *
     * <pre>
     *自动
     * </pre>
     */
    public static final int emSceneAuto_VALUE = 2;
    /**
     * <code>emSceneWDR = 3;</code>
     *
     * <pre>
     *宽动态
     * </pre>
     */
    public static final int emSceneWDR_VALUE = 3;
    /**
     * <code>emSceneHCT = 4;</code>
     *
     * <pre>
     *高色温
     * </pre>
     */
    public static final int emSceneHCT_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmSceneMode valueOf(int value) {
      switch (value) {
        case 0: return emSceneOff;
        case 1: return emSceneNight;
        case 2: return emSceneAuto;
        case 3: return emSceneWDR;
        case 4: return emSceneHCT;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSceneMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSceneMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSceneMode>() {
            public EmSceneMode findValueByNumber(int number) {
              return EmSceneMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(225);
    }

    private static final EmSceneMode[] VALUES = values();

    public static EmSceneMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSceneMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSceneMode)
  }

  /**
   * Protobuf enum {@code mt.EmNFType}
   *
   * <pre>
   * 降噪类型
   * </pre>
   */
  public enum EmNFType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNFType_2D = 0;</code>
     *
     * <pre>
     * 2D降噪
     * </pre>
     */
    emNFType_2D(0, 0),
    /**
     * <code>emNFType_3D = 1;</code>
     *
     * <pre>
     * 3D降噪
     * </pre>
     */
    emNFType_3D(1, 1),
    ;

    /**
     * <code>emNFType_2D = 0;</code>
     *
     * <pre>
     * 2D降噪
     * </pre>
     */
    public static final int emNFType_2D_VALUE = 0;
    /**
     * <code>emNFType_3D = 1;</code>
     *
     * <pre>
     * 3D降噪
     * </pre>
     */
    public static final int emNFType_3D_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmNFType valueOf(int value) {
      switch (value) {
        case 0: return emNFType_2D;
        case 1: return emNFType_3D;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNFType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNFType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNFType>() {
            public EmNFType findValueByNumber(int number) {
              return EmNFType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(226);
    }

    private static final EmNFType[] VALUES = values();

    public static EmNFType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNFType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmNFType)
  }

  /**
   * Protobuf enum {@code mt.EmNFMode}
   *
   * <pre>
   *降噪级别
   * </pre>
   */
  public enum EmNFMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNF_Off = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    emNF_Off(0, 0),
    /**
     * <code>emNF_Low = 1;</code>
     *
     * <pre>
     *低
     * </pre>
     */
    emNF_Low(1, 1),
    /**
     * <code>emNF_Mid = 2;</code>
     *
     * <pre>
     *中
     * </pre>
     */
    emNF_Mid(2, 2),
    /**
     * <code>emNF_High = 3;</code>
     *
     * <pre>
     *高
     * </pre>
     */
    emNF_High(3, 3),
    ;

    /**
     * <code>emNF_Off = 0;</code>
     *
     * <pre>
     *关闭
     * </pre>
     */
    public static final int emNF_Off_VALUE = 0;
    /**
     * <code>emNF_Low = 1;</code>
     *
     * <pre>
     *低
     * </pre>
     */
    public static final int emNF_Low_VALUE = 1;
    /**
     * <code>emNF_Mid = 2;</code>
     *
     * <pre>
     *中
     * </pre>
     */
    public static final int emNF_Mid_VALUE = 2;
    /**
     * <code>emNF_High = 3;</code>
     *
     * <pre>
     *高
     * </pre>
     */
    public static final int emNF_High_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmNFMode valueOf(int value) {
      switch (value) {
        case 0: return emNF_Off;
        case 1: return emNF_Low;
        case 2: return emNF_Mid;
        case 3: return emNF_High;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmNFMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmNFMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmNFMode>() {
            public EmNFMode findValueByNumber(int number) {
              return EmNFMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(227);
    }

    private static final EmNFMode[] VALUES = values();

    public static EmNFMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmNFMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmNFMode)
  }

  /**
   * Protobuf enum {@code mt.EmBrightnessDirection}
   */
  public enum EmBrightnessDirection
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emBrightnessUp = 0;</code>
     */
    emBrightnessUp(0, 0),
    /**
     * <code>emBrightnessDown = 1;</code>
     */
    emBrightnessDown(1, 1),
    ;

    /**
     * <code>emBrightnessUp = 0;</code>
     */
    public static final int emBrightnessUp_VALUE = 0;
    /**
     * <code>emBrightnessDown = 1;</code>
     */
    public static final int emBrightnessDown_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmBrightnessDirection valueOf(int value) {
      switch (value) {
        case 0: return emBrightnessUp;
        case 1: return emBrightnessDown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmBrightnessDirection>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmBrightnessDirection>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmBrightnessDirection>() {
            public EmBrightnessDirection findValueByNumber(int number) {
              return EmBrightnessDirection.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(228);
    }

    private static final EmBrightnessDirection[] VALUES = values();

    public static EmBrightnessDirection valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmBrightnessDirection(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmBrightnessDirection)
  }

  /**
   * Protobuf enum {@code mt.EmIspImgInf}
   *
   * <pre>
   *Isp图像参数
   * </pre>
   */
  public enum EmIspImgInf
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>IspImgInf_Noise = 0;</code>
     *
     * <pre>
     * 降噪(EmNFMode) 暂不使用
     * </pre>
     */
    IspImgInf_Noise(0, 0),
    /**
     * <code>IspImgInf_Sharpness = 1;</code>
     *
     * <pre>
     * 锐度(EmGeneralLevel)在HD5里不进行处理
     * </pre>
     */
    IspImgInf_Sharpness(1, 1),
    /**
     * <code>IspImgInf_ISO = 2;</code>
     *
     * <pre>
     * 感光度(EmISO)
     * </pre>
     */
    IspImgInf_ISO(2, 2),
    /**
     * <code>IspImgInf_ExposureMode = 3;</code>
     *
     * <pre>
     * 曝光模式(EmExposureMode)
     * </pre>
     */
    IspImgInf_ExposureMode(3, 3),
    /**
     * <code>IspImgInf_Aperture = 4;</code>
     *
     * <pre>
     * 光圈大小(EmAperture)与曝光模式联动
     * </pre>
     */
    IspImgInf_Aperture(4, 4),
    /**
     * <code>IspImgInf_Shutter = 5;</code>
     *
     * <pre>
     * 快门速度(EmShutterLevel)与曝光模式联动
     * </pre>
     */
    IspImgInf_Shutter(5, 5),
    /**
     * <code>IspImgInf_Brightnesss = 6;</code>
     *
     * <pre>
     * 亮度调节(EmBrightnessDirection)
     * </pre>
     */
    IspImgInf_Brightnesss(6, 6),
    /**
     * <code>IspImgInf_WhiteBalance = 7;</code>
     *
     * <pre>
     * 白平衡(EmWBAMode)
     * </pre>
     */
    IspImgInf_WhiteBalance(7, 7),
    /**
     * <code>IspImgInf_Noise_2D = 8;</code>
     *
     * <pre>
     * 2D降噪(EmNFMode)
     * </pre>
     */
    IspImgInf_Noise_2D(8, 8),
    /**
     * <code>IspImgInf_Noise_3D = 9;</code>
     *
     * <pre>
     * 3D降噪(EmNFMode)
     * </pre>
     */
    IspImgInf_Noise_3D(9, 9),
    /**
     * <code>IspImgInf_BrightnesssValue = 10;</code>
     *
     * <pre>
     * 亮度数值，与亮度调节不同
     * </pre>
     */
    IspImgInf_BrightnesssValue(10, 10),
    /**
     * <code>IspImgInf_Contrast = 11;</code>
     *
     * <pre>
     * 对比度
     * </pre>
     */
    IspImgInf_Contrast(11, 11),
    /**
     * <code>IspImgInf_Saturation = 12;</code>
     *
     * <pre>
     * 饱和度
     * </pre>
     */
    IspImgInf_Saturation(12, 12),
    /**
     * <code>IspImgInf_Sharpness_Value = 13;</code>
     *
     * <pre>
     * 锐度数值
     * </pre>
     */
    IspImgInf_Sharpness_Value(13, 13),
    /**
     * <code>IspImgInf_Hue = 14;</code>
     *
     * <pre>
     * 色度
     * </pre>
     */
    IspImgInf_Hue(14, 14),
    /**
     * <code>IspImgInf_BackLight_Type = 15;</code>
     *
     * <pre>
     * 背光补偿类别 0为关 1为背光补偿 2为强光抑制
     * </pre>
     */
    IspImgInf_BackLight_Type(15, 15),
    /**
     * <code>IspImgInf_BackLight_Value = 16;</code>
     *
     * <pre>
     * 背光补偿数值
     * </pre>
     */
    IspImgInf_BackLight_Value(16, 16),
    /**
     * <code>IspImgInf_RedGain = 17;</code>
     *
     * <pre>
     * 红增益 与白平衡联动
     * </pre>
     */
    IspImgInf_RedGain(17, 17),
    /**
     * <code>IspImgInf_BlueGain = 18;</code>
     *
     * <pre>
     * 蓝增益 与白平衡联动
     * </pre>
     */
    IspImgInf_BlueGain(18, 18),
    /**
     * <code>IspImgInf_AotoExposureGain = 19;</code>
     *
     * <pre>
     * 自动曝光模式增益与曝光模式联动
     * </pre>
     */
    IspImgInf_AotoExposureGain(19, 19),
    /**
     * <code>IspImgInf_ManualExposureGain = 20;</code>
     *
     * <pre>
     * 手动曝光模式增益与曝光模式联动
     * </pre>
     */
    IspImgInf_ManualExposureGain(20, 20),
    /**
     * <code>IspImgInf_ImgGamma = 21;</code>
     *
     * <pre>
     * 图像增强 
     * </pre>
     */
    IspImgInf_ImgGamma(21, 21),
    /**
     * <code>IspImgInf_ImgDefog = 22;</code>
     *
     * <pre>
     * 数字去雾
     * </pre>
     */
    IspImgInf_ImgDefog(22, 22),
    /**
     * <code>IspImgInf_DigDynSwitch = 23;</code>
     *
     * <pre>
     * 数字宽动态开关
     * </pre>
     */
    IspImgInf_DigDynSwitch(23, 23),
    /**
     * <code>IspImgInf_DigDynLevel = 24;</code>
     *
     * <pre>
     * 数字宽动态等级
     * </pre>
     */
    IspImgInf_DigDynLevel(24, 24),
    ;

    /**
     * <code>IspImgInf_Noise = 0;</code>
     *
     * <pre>
     * 降噪(EmNFMode) 暂不使用
     * </pre>
     */
    public static final int IspImgInf_Noise_VALUE = 0;
    /**
     * <code>IspImgInf_Sharpness = 1;</code>
     *
     * <pre>
     * 锐度(EmGeneralLevel)在HD5里不进行处理
     * </pre>
     */
    public static final int IspImgInf_Sharpness_VALUE = 1;
    /**
     * <code>IspImgInf_ISO = 2;</code>
     *
     * <pre>
     * 感光度(EmISO)
     * </pre>
     */
    public static final int IspImgInf_ISO_VALUE = 2;
    /**
     * <code>IspImgInf_ExposureMode = 3;</code>
     *
     * <pre>
     * 曝光模式(EmExposureMode)
     * </pre>
     */
    public static final int IspImgInf_ExposureMode_VALUE = 3;
    /**
     * <code>IspImgInf_Aperture = 4;</code>
     *
     * <pre>
     * 光圈大小(EmAperture)与曝光模式联动
     * </pre>
     */
    public static final int IspImgInf_Aperture_VALUE = 4;
    /**
     * <code>IspImgInf_Shutter = 5;</code>
     *
     * <pre>
     * 快门速度(EmShutterLevel)与曝光模式联动
     * </pre>
     */
    public static final int IspImgInf_Shutter_VALUE = 5;
    /**
     * <code>IspImgInf_Brightnesss = 6;</code>
     *
     * <pre>
     * 亮度调节(EmBrightnessDirection)
     * </pre>
     */
    public static final int IspImgInf_Brightnesss_VALUE = 6;
    /**
     * <code>IspImgInf_WhiteBalance = 7;</code>
     *
     * <pre>
     * 白平衡(EmWBAMode)
     * </pre>
     */
    public static final int IspImgInf_WhiteBalance_VALUE = 7;
    /**
     * <code>IspImgInf_Noise_2D = 8;</code>
     *
     * <pre>
     * 2D降噪(EmNFMode)
     * </pre>
     */
    public static final int IspImgInf_Noise_2D_VALUE = 8;
    /**
     * <code>IspImgInf_Noise_3D = 9;</code>
     *
     * <pre>
     * 3D降噪(EmNFMode)
     * </pre>
     */
    public static final int IspImgInf_Noise_3D_VALUE = 9;
    /**
     * <code>IspImgInf_BrightnesssValue = 10;</code>
     *
     * <pre>
     * 亮度数值，与亮度调节不同
     * </pre>
     */
    public static final int IspImgInf_BrightnesssValue_VALUE = 10;
    /**
     * <code>IspImgInf_Contrast = 11;</code>
     *
     * <pre>
     * 对比度
     * </pre>
     */
    public static final int IspImgInf_Contrast_VALUE = 11;
    /**
     * <code>IspImgInf_Saturation = 12;</code>
     *
     * <pre>
     * 饱和度
     * </pre>
     */
    public static final int IspImgInf_Saturation_VALUE = 12;
    /**
     * <code>IspImgInf_Sharpness_Value = 13;</code>
     *
     * <pre>
     * 锐度数值
     * </pre>
     */
    public static final int IspImgInf_Sharpness_Value_VALUE = 13;
    /**
     * <code>IspImgInf_Hue = 14;</code>
     *
     * <pre>
     * 色度
     * </pre>
     */
    public static final int IspImgInf_Hue_VALUE = 14;
    /**
     * <code>IspImgInf_BackLight_Type = 15;</code>
     *
     * <pre>
     * 背光补偿类别 0为关 1为背光补偿 2为强光抑制
     * </pre>
     */
    public static final int IspImgInf_BackLight_Type_VALUE = 15;
    /**
     * <code>IspImgInf_BackLight_Value = 16;</code>
     *
     * <pre>
     * 背光补偿数值
     * </pre>
     */
    public static final int IspImgInf_BackLight_Value_VALUE = 16;
    /**
     * <code>IspImgInf_RedGain = 17;</code>
     *
     * <pre>
     * 红增益 与白平衡联动
     * </pre>
     */
    public static final int IspImgInf_RedGain_VALUE = 17;
    /**
     * <code>IspImgInf_BlueGain = 18;</code>
     *
     * <pre>
     * 蓝增益 与白平衡联动
     * </pre>
     */
    public static final int IspImgInf_BlueGain_VALUE = 18;
    /**
     * <code>IspImgInf_AotoExposureGain = 19;</code>
     *
     * <pre>
     * 自动曝光模式增益与曝光模式联动
     * </pre>
     */
    public static final int IspImgInf_AotoExposureGain_VALUE = 19;
    /**
     * <code>IspImgInf_ManualExposureGain = 20;</code>
     *
     * <pre>
     * 手动曝光模式增益与曝光模式联动
     * </pre>
     */
    public static final int IspImgInf_ManualExposureGain_VALUE = 20;
    /**
     * <code>IspImgInf_ImgGamma = 21;</code>
     *
     * <pre>
     * 图像增强 
     * </pre>
     */
    public static final int IspImgInf_ImgGamma_VALUE = 21;
    /**
     * <code>IspImgInf_ImgDefog = 22;</code>
     *
     * <pre>
     * 数字去雾
     * </pre>
     */
    public static final int IspImgInf_ImgDefog_VALUE = 22;
    /**
     * <code>IspImgInf_DigDynSwitch = 23;</code>
     *
     * <pre>
     * 数字宽动态开关
     * </pre>
     */
    public static final int IspImgInf_DigDynSwitch_VALUE = 23;
    /**
     * <code>IspImgInf_DigDynLevel = 24;</code>
     *
     * <pre>
     * 数字宽动态等级
     * </pre>
     */
    public static final int IspImgInf_DigDynLevel_VALUE = 24;


    public final int getNumber() { return value; }

    public static EmIspImgInf valueOf(int value) {
      switch (value) {
        case 0: return IspImgInf_Noise;
        case 1: return IspImgInf_Sharpness;
        case 2: return IspImgInf_ISO;
        case 3: return IspImgInf_ExposureMode;
        case 4: return IspImgInf_Aperture;
        case 5: return IspImgInf_Shutter;
        case 6: return IspImgInf_Brightnesss;
        case 7: return IspImgInf_WhiteBalance;
        case 8: return IspImgInf_Noise_2D;
        case 9: return IspImgInf_Noise_3D;
        case 10: return IspImgInf_BrightnesssValue;
        case 11: return IspImgInf_Contrast;
        case 12: return IspImgInf_Saturation;
        case 13: return IspImgInf_Sharpness_Value;
        case 14: return IspImgInf_Hue;
        case 15: return IspImgInf_BackLight_Type;
        case 16: return IspImgInf_BackLight_Value;
        case 17: return IspImgInf_RedGain;
        case 18: return IspImgInf_BlueGain;
        case 19: return IspImgInf_AotoExposureGain;
        case 20: return IspImgInf_ManualExposureGain;
        case 21: return IspImgInf_ImgGamma;
        case 22: return IspImgInf_ImgDefog;
        case 23: return IspImgInf_DigDynSwitch;
        case 24: return IspImgInf_DigDynLevel;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmIspImgInf>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmIspImgInf>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmIspImgInf>() {
            public EmIspImgInf findValueByNumber(int number) {
              return EmIspImgInf.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(229);
    }

    private static final EmIspImgInf[] VALUES = values();

    public static EmIspImgInf valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmIspImgInf(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmIspImgInf)
  }

  /**
   * Protobuf enum {@code mt.EmExposureModeGainType}
   *
   * <pre>
   *曝光增益类型
   * </pre>
   */
  public enum EmExposureModeGainType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emExposureModeGainAuto = 0;</code>
     */
    emExposureModeGainAuto(0, 0),
    /**
     * <code>emExposureModeGainManual = 1;</code>
     */
    emExposureModeGainManual(1, 1),
    ;

    /**
     * <code>emExposureModeGainAuto = 0;</code>
     */
    public static final int emExposureModeGainAuto_VALUE = 0;
    /**
     * <code>emExposureModeGainManual = 1;</code>
     */
    public static final int emExposureModeGainManual_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmExposureModeGainType valueOf(int value) {
      switch (value) {
        case 0: return emExposureModeGainAuto;
        case 1: return emExposureModeGainManual;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmExposureModeGainType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmExposureModeGainType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmExposureModeGainType>() {
            public EmExposureModeGainType findValueByNumber(int number) {
              return EmExposureModeGainType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(230);
    }

    private static final EmExposureModeGainType[] VALUES = values();

    public static EmExposureModeGainType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmExposureModeGainType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmExposureModeGainType)
  }

  /**
   * Protobuf enum {@code mt.EmExposureModeGainRestrict}
   *
   * <pre>
   *通用曝光增益限制（手动、自动）
   * </pre>
   */
  public enum EmExposureModeGainRestrict
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emGainRestrict15 = 0;</code>
     *
     * <pre>
     *15dB
     * </pre>
     */
    emGainRestrict15(0, 0),
    /**
     * <code>emGainRestrict18 = 1;</code>
     *
     * <pre>
     *18dB
     * </pre>
     */
    emGainRestrict18(1, 1),
    /**
     * <code>emGainRestrict21 = 2;</code>
     *
     * <pre>
     *21dB
     * </pre>
     */
    emGainRestrict21(2, 2),
    /**
     * <code>emGainRestrict24 = 3;</code>
     *
     * <pre>
     *24dB
     * </pre>
     */
    emGainRestrict24(3, 3),
    /**
     * <code>emGainRestrict27 = 4;</code>
     *
     * <pre>
     *27dB
     * </pre>
     */
    emGainRestrict27(4, 4),
    /**
     * <code>emGainRestrict30 = 5;</code>
     *
     * <pre>
     *30dB
     * </pre>
     */
    emGainRestrict30(5, 5),
    /**
     * <code>emGainRestrict33 = 6;</code>
     *
     * <pre>
     *33dB
     * </pre>
     */
    emGainRestrict33(6, 6),
    /**
     * <code>emGainRestrict36 = 7;</code>
     *
     * <pre>
     *36dB
     * </pre>
     */
    emGainRestrict36(7, 7),
    /**
     * <code>emGainRestrict39 = 8;</code>
     *
     * <pre>
     *39dB
     * </pre>
     */
    emGainRestrict39(8, 8),
    /**
     * <code>emGainRestrict42 = 9;</code>
     *
     * <pre>
     *42dB
     * </pre>
     */
    emGainRestrict42(9, 9),
    /**
     * <code>emGainRestrict45 = 10;</code>
     *
     * <pre>
     *45dB
     * </pre>
     */
    emGainRestrict45(10, 10),
    ;

    /**
     * <code>emGainRestrict15 = 0;</code>
     *
     * <pre>
     *15dB
     * </pre>
     */
    public static final int emGainRestrict15_VALUE = 0;
    /**
     * <code>emGainRestrict18 = 1;</code>
     *
     * <pre>
     *18dB
     * </pre>
     */
    public static final int emGainRestrict18_VALUE = 1;
    /**
     * <code>emGainRestrict21 = 2;</code>
     *
     * <pre>
     *21dB
     * </pre>
     */
    public static final int emGainRestrict21_VALUE = 2;
    /**
     * <code>emGainRestrict24 = 3;</code>
     *
     * <pre>
     *24dB
     * </pre>
     */
    public static final int emGainRestrict24_VALUE = 3;
    /**
     * <code>emGainRestrict27 = 4;</code>
     *
     * <pre>
     *27dB
     * </pre>
     */
    public static final int emGainRestrict27_VALUE = 4;
    /**
     * <code>emGainRestrict30 = 5;</code>
     *
     * <pre>
     *30dB
     * </pre>
     */
    public static final int emGainRestrict30_VALUE = 5;
    /**
     * <code>emGainRestrict33 = 6;</code>
     *
     * <pre>
     *33dB
     * </pre>
     */
    public static final int emGainRestrict33_VALUE = 6;
    /**
     * <code>emGainRestrict36 = 7;</code>
     *
     * <pre>
     *36dB
     * </pre>
     */
    public static final int emGainRestrict36_VALUE = 7;
    /**
     * <code>emGainRestrict39 = 8;</code>
     *
     * <pre>
     *39dB
     * </pre>
     */
    public static final int emGainRestrict39_VALUE = 8;
    /**
     * <code>emGainRestrict42 = 9;</code>
     *
     * <pre>
     *42dB
     * </pre>
     */
    public static final int emGainRestrict42_VALUE = 9;
    /**
     * <code>emGainRestrict45 = 10;</code>
     *
     * <pre>
     *45dB
     * </pre>
     */
    public static final int emGainRestrict45_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmExposureModeGainRestrict valueOf(int value) {
      switch (value) {
        case 0: return emGainRestrict15;
        case 1: return emGainRestrict18;
        case 2: return emGainRestrict21;
        case 3: return emGainRestrict24;
        case 4: return emGainRestrict27;
        case 5: return emGainRestrict30;
        case 6: return emGainRestrict33;
        case 7: return emGainRestrict36;
        case 8: return emGainRestrict39;
        case 9: return emGainRestrict42;
        case 10: return emGainRestrict45;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmExposureModeGainRestrict>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmExposureModeGainRestrict>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmExposureModeGainRestrict>() {
            public EmExposureModeGainRestrict findValueByNumber(int number) {
              return EmExposureModeGainRestrict.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(231);
    }

    private static final EmExposureModeGainRestrict[] VALUES = values();

    public static EmExposureModeGainRestrict valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmExposureModeGainRestrict(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmExposureModeGainRestrict)
  }

  /**
   * Protobuf enum {@code mt.EmFocusMode}
   *
   * <pre>
   *聚焦模式
   * </pre>
   */
  public enum EmFocusMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFocusModeManual = 0;</code>
     *
     * <pre>
     *手动聚焦
     * </pre>
     */
    emFocusModeManual(0, 0),
    /**
     * <code>emFocusModeAuto = 1;</code>
     *
     * <pre>
     *自动聚焦
     * </pre>
     */
    emFocusModeAuto(1, 1),
    ;

    /**
     * <code>emFocusModeManual = 0;</code>
     *
     * <pre>
     *手动聚焦
     * </pre>
     */
    public static final int emFocusModeManual_VALUE = 0;
    /**
     * <code>emFocusModeAuto = 1;</code>
     *
     * <pre>
     *自动聚焦
     * </pre>
     */
    public static final int emFocusModeAuto_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmFocusMode valueOf(int value) {
      switch (value) {
        case 0: return emFocusModeManual;
        case 1: return emFocusModeAuto;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFocusMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFocusMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFocusMode>() {
            public EmFocusMode findValueByNumber(int number) {
              return EmFocusMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(232);
    }

    private static final EmFocusMode[] VALUES = values();

    public static EmFocusMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFocusMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFocusMode)
  }

  /**
   * Protobuf enum {@code mt.EmImgMode}
   *
   * <pre>
   *摄像机图像模式
   * </pre>
   */
  public enum EmImgMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emImgStandard = 0;</code>
     *
     * <pre>
     *标准
     * </pre>
     */
    emImgStandard(0, 0),
    /**
     * <code>emImgSoft = 1;</code>
     *
     * <pre>
     *柔和
     * </pre>
     */
    emImgSoft(1, 1),
    /**
     * <code>emImgBright = 2;</code>
     *
     * <pre>
     *明亮
     * </pre>
     */
    emImgBright(2, 2),
    ;

    /**
     * <code>emImgStandard = 0;</code>
     *
     * <pre>
     *标准
     * </pre>
     */
    public static final int emImgStandard_VALUE = 0;
    /**
     * <code>emImgSoft = 1;</code>
     *
     * <pre>
     *柔和
     * </pre>
     */
    public static final int emImgSoft_VALUE = 1;
    /**
     * <code>emImgBright = 2;</code>
     *
     * <pre>
     *明亮
     * </pre>
     */
    public static final int emImgBright_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmImgMode valueOf(int value) {
      switch (value) {
        case 0: return emImgStandard;
        case 1: return emImgSoft;
        case 2: return emImgBright;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmImgMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmImgMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmImgMode>() {
            public EmImgMode findValueByNumber(int number) {
              return EmImgMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(233);
    }

    private static final EmImgMode[] VALUES = values();

    public static EmImgMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmImgMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmImgMode)
  }

  /**
   * Protobuf enum {@code mt.EmIspActionType}
   *
   * <pre>
   *动作控制相关,主要面向电机的控制
   * </pre>
   */
  public enum EmIspActionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>IspActSetZoomOut = 0;</code>
     *
     * <pre>
     * 设置小倍率动作，连续运动
     * </pre>
     */
    IspActSetZoomOut(0, 0),
    /**
     * <code>IspActSetZoomIn = 1;</code>
     *
     * <pre>
     * 设置大倍率动作，连续运动
     * </pre>
     */
    IspActSetZoomIn(1, 1),
    /**
     * <code>IspActSetZoomStop = 2;</code>
     *
     * <pre>
     * 设置拉伸动作停止
     * </pre>
     */
    IspActSetZoomStop(2, 2),
    /**
     * <code>IspActSetZoomAuto = 3;</code>
     *
     * <pre>
     * 设置拉伸动作停止
     * </pre>
     */
    IspActSetZoomAuto(3, 3),
    /**
     * <code>IspActSetZoomSpeed = 4;</code>
     *
     * <pre>
     * 设置倍率拉伸速度，参数是0~100
     * </pre>
     */
    IspActSetZoomSpeed(4, 4),
    /**
     * <code>IspActSetZoomLimit = 5;</code>
     *
     * <pre>
     * 设置zoom当前倍数，放大100，参数u32
     * </pre>
     */
    IspActSetZoomLimit(5, 5),
    /**
     * <code>IspActSetZoomPosition = 6;</code>
     *
     * <pre>
     * 设置倍率拉伸位置，参数是u32物理量
     * </pre>
     */
    IspActSetZoomPosition(6, 6),
    /**
     * <code>IspActGetZoomPosition = 7;</code>
     *
     * <pre>
     * 获取拉伸电机位置，参数是u32
     * </pre>
     */
    IspActGetZoomPosition(7, 7),
    /**
     * <code>IspActSetFocusNear = 8;</code>
     *
     * <pre>
     * 设置聚焦拉近动作，连续运动
     * </pre>
     */
    IspActSetFocusNear(8, 8),
    /**
     * <code>IspActSetFocusFar = 9;</code>
     *
     * <pre>
     * 设置聚焦拉远作，连续运动
     * </pre>
     */
    IspActSetFocusFar(9, 9),
    /**
     * <code>IspActSetFocusStop = 10;</code>
     *
     * <pre>
     * 设置聚焦动作停止
     * </pre>
     */
    IspActSetFocusStop(10, 10),
    /**
     * <code>IspActSetFocusAuto = 11;</code>
     *
     * <pre>
     * 设置自动聚焦
     * </pre>
     */
    IspActSetFocusAuto(11, 11),
    /**
     * <code>IspActSetFocusPosition = 12;</code>
     *
     * <pre>
     * 设置聚焦位置，参数是u32物理量
     * </pre>
     */
    IspActSetFocusPosition(12, 12),
    /**
     * <code>IspActGetFocusPosition = 13;</code>
     *
     * <pre>
     * 获取聚焦电机位置，参数是u32
     * </pre>
     */
    IspActGetFocusPosition(13, 13),
    /**
     * <code>IspActSetAperture = 14;</code>
     *
     * <pre>
     * 设置光圈
     * </pre>
     */
    IspActSetAperture(14, 14),
    /**
     * <code>IspActSetPiCalibrate = 15;</code>
     *
     * <pre>
     * 曲线校准
     * </pre>
     */
    IspActSetPiCalibrate(15, 15),
    /**
     * <code>IspActSetCameraStd = 16;</code>
     *
     * <pre>
     * 设置机芯制式
     * </pre>
     */
    IspActSetCameraStd(16, 16),
    /**
     * <code>IspActSetCameraFlip = 17;</code>
     *
     * <pre>
     * 设置摄像机图像倒装
     * </pre>
     */
    IspActSetCameraFlip(17, 17),
    ;

    /**
     * <code>IspActSetZoomOut = 0;</code>
     *
     * <pre>
     * 设置小倍率动作，连续运动
     * </pre>
     */
    public static final int IspActSetZoomOut_VALUE = 0;
    /**
     * <code>IspActSetZoomIn = 1;</code>
     *
     * <pre>
     * 设置大倍率动作，连续运动
     * </pre>
     */
    public static final int IspActSetZoomIn_VALUE = 1;
    /**
     * <code>IspActSetZoomStop = 2;</code>
     *
     * <pre>
     * 设置拉伸动作停止
     * </pre>
     */
    public static final int IspActSetZoomStop_VALUE = 2;
    /**
     * <code>IspActSetZoomAuto = 3;</code>
     *
     * <pre>
     * 设置拉伸动作停止
     * </pre>
     */
    public static final int IspActSetZoomAuto_VALUE = 3;
    /**
     * <code>IspActSetZoomSpeed = 4;</code>
     *
     * <pre>
     * 设置倍率拉伸速度，参数是0~100
     * </pre>
     */
    public static final int IspActSetZoomSpeed_VALUE = 4;
    /**
     * <code>IspActSetZoomLimit = 5;</code>
     *
     * <pre>
     * 设置zoom当前倍数，放大100，参数u32
     * </pre>
     */
    public static final int IspActSetZoomLimit_VALUE = 5;
    /**
     * <code>IspActSetZoomPosition = 6;</code>
     *
     * <pre>
     * 设置倍率拉伸位置，参数是u32物理量
     * </pre>
     */
    public static final int IspActSetZoomPosition_VALUE = 6;
    /**
     * <code>IspActGetZoomPosition = 7;</code>
     *
     * <pre>
     * 获取拉伸电机位置，参数是u32
     * </pre>
     */
    public static final int IspActGetZoomPosition_VALUE = 7;
    /**
     * <code>IspActSetFocusNear = 8;</code>
     *
     * <pre>
     * 设置聚焦拉近动作，连续运动
     * </pre>
     */
    public static final int IspActSetFocusNear_VALUE = 8;
    /**
     * <code>IspActSetFocusFar = 9;</code>
     *
     * <pre>
     * 设置聚焦拉远作，连续运动
     * </pre>
     */
    public static final int IspActSetFocusFar_VALUE = 9;
    /**
     * <code>IspActSetFocusStop = 10;</code>
     *
     * <pre>
     * 设置聚焦动作停止
     * </pre>
     */
    public static final int IspActSetFocusStop_VALUE = 10;
    /**
     * <code>IspActSetFocusAuto = 11;</code>
     *
     * <pre>
     * 设置自动聚焦
     * </pre>
     */
    public static final int IspActSetFocusAuto_VALUE = 11;
    /**
     * <code>IspActSetFocusPosition = 12;</code>
     *
     * <pre>
     * 设置聚焦位置，参数是u32物理量
     * </pre>
     */
    public static final int IspActSetFocusPosition_VALUE = 12;
    /**
     * <code>IspActGetFocusPosition = 13;</code>
     *
     * <pre>
     * 获取聚焦电机位置，参数是u32
     * </pre>
     */
    public static final int IspActGetFocusPosition_VALUE = 13;
    /**
     * <code>IspActSetAperture = 14;</code>
     *
     * <pre>
     * 设置光圈
     * </pre>
     */
    public static final int IspActSetAperture_VALUE = 14;
    /**
     * <code>IspActSetPiCalibrate = 15;</code>
     *
     * <pre>
     * 曲线校准
     * </pre>
     */
    public static final int IspActSetPiCalibrate_VALUE = 15;
    /**
     * <code>IspActSetCameraStd = 16;</code>
     *
     * <pre>
     * 设置机芯制式
     * </pre>
     */
    public static final int IspActSetCameraStd_VALUE = 16;
    /**
     * <code>IspActSetCameraFlip = 17;</code>
     *
     * <pre>
     * 设置摄像机图像倒装
     * </pre>
     */
    public static final int IspActSetCameraFlip_VALUE = 17;


    public final int getNumber() { return value; }

    public static EmIspActionType valueOf(int value) {
      switch (value) {
        case 0: return IspActSetZoomOut;
        case 1: return IspActSetZoomIn;
        case 2: return IspActSetZoomStop;
        case 3: return IspActSetZoomAuto;
        case 4: return IspActSetZoomSpeed;
        case 5: return IspActSetZoomLimit;
        case 6: return IspActSetZoomPosition;
        case 7: return IspActGetZoomPosition;
        case 8: return IspActSetFocusNear;
        case 9: return IspActSetFocusFar;
        case 10: return IspActSetFocusStop;
        case 11: return IspActSetFocusAuto;
        case 12: return IspActSetFocusPosition;
        case 13: return IspActGetFocusPosition;
        case 14: return IspActSetAperture;
        case 15: return IspActSetPiCalibrate;
        case 16: return IspActSetCameraStd;
        case 17: return IspActSetCameraFlip;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmIspActionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmIspActionType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmIspActionType>() {
            public EmIspActionType findValueByNumber(int number) {
              return EmIspActionType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(234);
    }

    private static final EmIspActionType[] VALUES = values();

    public static EmIspActionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmIspActionType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmIspActionType)
  }

  /**
   * Protobuf enum {@code mt.EmCameraVidStd}
   *
   * <pre>
   *机芯采集制式
   * </pre>
   */
  public enum EmCameraVidStd
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCamera_Auto = 0;</code>
     */
    emCamera_Auto(0, 0),
    /**
     * <code>emCamera_1080p_25 = 1;</code>
     */
    emCamera_1080p_25(1, 1),
    /**
     * <code>emCamera_1080p_30 = 2;</code>
     */
    emCamera_1080p_30(2, 2),
    /**
     * <code>emCamera_1080p_50 = 3;</code>
     */
    emCamera_1080p_50(3, 3),
    /**
     * <code>emCamera_1080p_60 = 4;</code>
     */
    emCamera_1080p_60(4, 4),
    /**
     * <code>emCamera_1080i_50 = 5;</code>
     */
    emCamera_1080i_50(5, 5),
    /**
     * <code>emCamera_1080i_60 = 6;</code>
     */
    emCamera_1080i_60(6, 6),
    /**
     * <code>emCamera_720p_50 = 7;</code>
     */
    emCamera_720p_50(7, 7),
    /**
     * <code>emCamera_720p_60 = 8;</code>
     */
    emCamera_720p_60(8, 8),
    ;

    /**
     * <code>emCamera_Auto = 0;</code>
     */
    public static final int emCamera_Auto_VALUE = 0;
    /**
     * <code>emCamera_1080p_25 = 1;</code>
     */
    public static final int emCamera_1080p_25_VALUE = 1;
    /**
     * <code>emCamera_1080p_30 = 2;</code>
     */
    public static final int emCamera_1080p_30_VALUE = 2;
    /**
     * <code>emCamera_1080p_50 = 3;</code>
     */
    public static final int emCamera_1080p_50_VALUE = 3;
    /**
     * <code>emCamera_1080p_60 = 4;</code>
     */
    public static final int emCamera_1080p_60_VALUE = 4;
    /**
     * <code>emCamera_1080i_50 = 5;</code>
     */
    public static final int emCamera_1080i_50_VALUE = 5;
    /**
     * <code>emCamera_1080i_60 = 6;</code>
     */
    public static final int emCamera_1080i_60_VALUE = 6;
    /**
     * <code>emCamera_720p_50 = 7;</code>
     */
    public static final int emCamera_720p_50_VALUE = 7;
    /**
     * <code>emCamera_720p_60 = 8;</code>
     */
    public static final int emCamera_720p_60_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmCameraVidStd valueOf(int value) {
      switch (value) {
        case 0: return emCamera_Auto;
        case 1: return emCamera_1080p_25;
        case 2: return emCamera_1080p_30;
        case 3: return emCamera_1080p_50;
        case 4: return emCamera_1080p_60;
        case 5: return emCamera_1080i_50;
        case 6: return emCamera_1080i_60;
        case 7: return emCamera_720p_50;
        case 8: return emCamera_720p_60;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCameraVidStd>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCameraVidStd>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCameraVidStd>() {
            public EmCameraVidStd findValueByNumber(int number) {
              return EmCameraVidStd.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(235);
    }

    private static final EmCameraVidStd[] VALUES = values();

    public static EmCameraVidStd valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCameraVidStd(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCameraVidStd)
  }

  /**
   * Protobuf enum {@code mt.EmFilpType}
   *
   * <pre>
   *图像倒装
   * </pre>
   */
  public enum EmFilpType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFlip_OFF = 0;</code>
     */
    emFlip_OFF(0, 0),
    /**
     * <code>emFlip_Vertical = 1;</code>
     */
    emFlip_Vertical(1, 1),
    /**
     * <code>emFlip_Horizontal = 2;</code>
     */
    emFlip_Horizontal(2, 2),
    /**
     * <code>emFlip_Center = 3;</code>
     */
    emFlip_Center(3, 3),
    ;

    /**
     * <code>emFlip_OFF = 0;</code>
     */
    public static final int emFlip_OFF_VALUE = 0;
    /**
     * <code>emFlip_Vertical = 1;</code>
     */
    public static final int emFlip_Vertical_VALUE = 1;
    /**
     * <code>emFlip_Horizontal = 2;</code>
     */
    public static final int emFlip_Horizontal_VALUE = 2;
    /**
     * <code>emFlip_Center = 3;</code>
     */
    public static final int emFlip_Center_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmFilpType valueOf(int value) {
      switch (value) {
        case 0: return emFlip_OFF;
        case 1: return emFlip_Vertical;
        case 2: return emFlip_Horizontal;
        case 3: return emFlip_Center;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFilpType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFilpType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFilpType>() {
            public EmFilpType findValueByNumber(int number) {
              return EmFilpType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(236);
    }

    private static final EmFilpType[] VALUES = values();

    public static EmFilpType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFilpType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFilpType)
  }

  /**
   * Protobuf enum {@code mt.EmVmpMode}
   */
  public enum EmVmpMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emScreenVmp = 0;</code>
     *
     * <pre>
     * </pre>
     */
    emScreenVmp(0, 0),
    /**
     * <code>emCustomScreenVmp = 1;</code>
     *
     * <pre>
     *&#47;&lt;定制画面合成
     * </pre>
     */
    emCustomScreenVmp(1, 1),
    /**
     * <code>emAutoScreenVmp = 2;</code>
     *
     * <pre>
     *&#47;&lt;自动画面合成
     * </pre>
     */
    emAutoScreenVmp(2, 2),
    ;

    /**
     * <code>emScreenVmp = 0;</code>
     *
     * <pre>
     * </pre>
     */
    public static final int emScreenVmp_VALUE = 0;
    /**
     * <code>emCustomScreenVmp = 1;</code>
     *
     * <pre>
     *&#47;&lt;定制画面合成
     * </pre>
     */
    public static final int emCustomScreenVmp_VALUE = 1;
    /**
     * <code>emAutoScreenVmp = 2;</code>
     *
     * <pre>
     *&#47;&lt;自动画面合成
     * </pre>
     */
    public static final int emAutoScreenVmp_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmVmpMode valueOf(int value) {
      switch (value) {
        case 0: return emScreenVmp;
        case 1: return emCustomScreenVmp;
        case 2: return emAutoScreenVmp;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVmpMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVmpMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVmpMode>() {
            public EmVmpMode findValueByNumber(int number) {
              return EmVmpMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(237);
    }

    private static final EmVmpMode[] VALUES = values();

    public static EmVmpMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVmpMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVmpMode)
  }

  /**
   * Protobuf enum {@code mt.EmPollMode}
   */
  public enum EmPollMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPollModeBegin = 0;</code>
     */
    emPollModeBegin(0, 0),
    /**
     * <code>emVideoPoll = 1;</code>
     *
     * <pre>
     *&#47;&lt;视频轮询
     * </pre>
     */
    emVideoPoll(1, 1),
    /**
     * <code>emReserveTwo = 2;</code>
     *
     * <pre>
     *&#47;&lt;如果平台发布对应2值，此项可以被替换
     * </pre>
     */
    emReserveTwo(2, 2),
    /**
     * <code>emAudioPoll = 3;</code>
     *
     * <pre>
     *&#47;&lt;音视频轮询
     * </pre>
     */
    emAudioPoll(3, 3),
    ;

    /**
     * <code>emPollModeBegin = 0;</code>
     */
    public static final int emPollModeBegin_VALUE = 0;
    /**
     * <code>emVideoPoll = 1;</code>
     *
     * <pre>
     *&#47;&lt;视频轮询
     * </pre>
     */
    public static final int emVideoPoll_VALUE = 1;
    /**
     * <code>emReserveTwo = 2;</code>
     *
     * <pre>
     *&#47;&lt;如果平台发布对应2值，此项可以被替换
     * </pre>
     */
    public static final int emReserveTwo_VALUE = 2;
    /**
     * <code>emAudioPoll = 3;</code>
     *
     * <pre>
     *&#47;&lt;音视频轮询
     * </pre>
     */
    public static final int emAudioPoll_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmPollMode valueOf(int value) {
      switch (value) {
        case 0: return emPollModeBegin;
        case 1: return emVideoPoll;
        case 2: return emReserveTwo;
        case 3: return emAudioPoll;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPollMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPollMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPollMode>() {
            public EmPollMode findValueByNumber(int number) {
              return EmPollMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(238);
    }

    private static final EmPollMode[] VALUES = values();

    public static EmPollMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPollMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPollMode)
  }

  /**
   * Protobuf enum {@code mt.EmStreamNumber}
   *
   * <pre>
   *本地录像流序号
   * </pre>
   */
  public enum EmStreamNumber
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emStreamBeg = 0;</code>
     */
    emStreamBeg(0, 0),
    /**
     * <code>emMainAudEnc = 1;</code>
     */
    emMainAudEnc(1, 1),
    /**
     * <code>emMainAudDec = 2;</code>
     */
    emMainAudDec(2, 2),
    /**
     * <code>emAssAudEnc = 3;</code>
     */
    emAssAudEnc(3, 3),
    /**
     * <code>emAssAudDec = 4;</code>
     */
    emAssAudDec(4, 4),
    /**
     * <code>em1stVidEnc = 5;</code>
     */
    em1stVidEnc(5, 5),
    /**
     * <code>em1stVidDec = 6;</code>
     */
    em1stVidDec(6, 6),
    /**
     * <code>em2ndVidEnc = 7;</code>
     */
    em2ndVidEnc(7, 7),
    /**
     * <code>em2ndVidDec = 8;</code>
     */
    em2ndVidDec(8, 8),
    /**
     * <code>em3rdVidEnc = 9;</code>
     */
    em3rdVidEnc(9, 9),
    /**
     * <code>em3rdVidDec = 10;</code>
     */
    em3rdVidDec(10, 10),
    /**
     * <code>emAssVidEnc = 11;</code>
     */
    emAssVidEnc(11, 11),
    /**
     * <code>emAssVidDec = 12;</code>
     */
    emAssVidDec(12, 12),
    /**
     * <code>emStreamEnd = 128;</code>
     */
    emStreamEnd(13, 128),
    ;

    /**
     * <code>emStreamBeg = 0;</code>
     */
    public static final int emStreamBeg_VALUE = 0;
    /**
     * <code>emMainAudEnc = 1;</code>
     */
    public static final int emMainAudEnc_VALUE = 1;
    /**
     * <code>emMainAudDec = 2;</code>
     */
    public static final int emMainAudDec_VALUE = 2;
    /**
     * <code>emAssAudEnc = 3;</code>
     */
    public static final int emAssAudEnc_VALUE = 3;
    /**
     * <code>emAssAudDec = 4;</code>
     */
    public static final int emAssAudDec_VALUE = 4;
    /**
     * <code>em1stVidEnc = 5;</code>
     */
    public static final int em1stVidEnc_VALUE = 5;
    /**
     * <code>em1stVidDec = 6;</code>
     */
    public static final int em1stVidDec_VALUE = 6;
    /**
     * <code>em2ndVidEnc = 7;</code>
     */
    public static final int em2ndVidEnc_VALUE = 7;
    /**
     * <code>em2ndVidDec = 8;</code>
     */
    public static final int em2ndVidDec_VALUE = 8;
    /**
     * <code>em3rdVidEnc = 9;</code>
     */
    public static final int em3rdVidEnc_VALUE = 9;
    /**
     * <code>em3rdVidDec = 10;</code>
     */
    public static final int em3rdVidDec_VALUE = 10;
    /**
     * <code>emAssVidEnc = 11;</code>
     */
    public static final int emAssVidEnc_VALUE = 11;
    /**
     * <code>emAssVidDec = 12;</code>
     */
    public static final int emAssVidDec_VALUE = 12;
    /**
     * <code>emStreamEnd = 128;</code>
     */
    public static final int emStreamEnd_VALUE = 128;


    public final int getNumber() { return value; }

    public static EmStreamNumber valueOf(int value) {
      switch (value) {
        case 0: return emStreamBeg;
        case 1: return emMainAudEnc;
        case 2: return emMainAudDec;
        case 3: return emAssAudEnc;
        case 4: return emAssAudDec;
        case 5: return em1stVidEnc;
        case 6: return em1stVidDec;
        case 7: return em2ndVidEnc;
        case 8: return em2ndVidDec;
        case 9: return em3rdVidEnc;
        case 10: return em3rdVidDec;
        case 11: return emAssVidEnc;
        case 12: return emAssVidDec;
        case 128: return emStreamEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmStreamNumber>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmStreamNumber>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmStreamNumber>() {
            public EmStreamNumber findValueByNumber(int number) {
              return EmStreamNumber.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(239);
    }

    private static final EmStreamNumber[] VALUES = values();

    public static EmStreamNumber valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmStreamNumber(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmStreamNumber)
  }

  /**
   * Protobuf enum {@code mt.EmCtrlType}
   *
   * <pre>
   *录像操作类序号
   * </pre>
   */
  public enum EmCtrlType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAudioEncType = 0;</code>
     */
    emAudioEncType(0, 0),
    /**
     * <code>emAudioDecType = 1;</code>
     */
    emAudioDecType(1, 1),
    /**
     * <code>emVideoEncType = 2;</code>
     */
    emVideoEncType(2, 2),
    /**
     * <code>emVideoDecType = 3;</code>
     */
    emVideoDecType(3, 3),
    ;

    /**
     * <code>emAudioEncType = 0;</code>
     */
    public static final int emAudioEncType_VALUE = 0;
    /**
     * <code>emAudioDecType = 1;</code>
     */
    public static final int emAudioDecType_VALUE = 1;
    /**
     * <code>emVideoEncType = 2;</code>
     */
    public static final int emVideoEncType_VALUE = 2;
    /**
     * <code>emVideoDecType = 3;</code>
     */
    public static final int emVideoDecType_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmCtrlType valueOf(int value) {
      switch (value) {
        case 0: return emAudioEncType;
        case 1: return emAudioDecType;
        case 2: return emVideoEncType;
        case 3: return emVideoDecType;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCtrlType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCtrlType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCtrlType>() {
            public EmCtrlType findValueByNumber(int number) {
              return EmCtrlType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(240);
    }

    private static final EmCtrlType[] VALUES = values();

    public static EmCtrlType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCtrlType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCtrlType)
  }

  /**
   * Protobuf enum {@code mt.EmVideoRecordErrorNum}
   */
  public enum EmVideoRecordErrorNum
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emErrorNoError = 0;</code>
     *
     * <pre>
     * 没有错误，正确返回
     * </pre>
     */
    emErrorNoError(0, 0),
    /**
     * <code>emErrorFileNotFound = 1;</code>
     *
     * <pre>
     * 文件没有找到
     * </pre>
     */
    emErrorFileNotFound(1, 1),
    /**
     * <code>emErrorInvalidASFFile = 2;</code>
     *
     * <pre>
     * 无效的ASF文件
     * </pre>
     */
    emErrorInvalidASFFile(2, 2),
    /**
     * <code>emErrorObjectNotFound = 3;</code>
     *
     * <pre>
     * 对象没有找到
     * </pre>
     */
    emErrorObjectNotFound(3, 3),
    /**
     * <code>emErrorBadIndex = 4;</code>
     *
     * <pre>
     * 错误的对象索引
     * </pre>
     */
    emErrorBadIndex(4, 4),
    /**
     * <code>emErrorValueNotFound = 5;</code>
     *
     * <pre>
     * 没有找到相应的值
     * </pre>
     */
    emErrorValueNotFound(5, 5),
    /**
     * <code>emErrorBadArgument = 6;</code>
     *
     * <pre>
     * 错误的参数
     * </pre>
     */
    emErrorBadArgument(6, 6),
    /**
     * <code>emErrorReadOnly = 7;</code>
     *
     * <pre>
     * 文件只读错误
     * </pre>
     */
    emErrorReadOnly(7, 7),
    /**
     * <code>emErrorNotEnoughSpace = 8;</code>
     *
     * <pre>
     * 存储空间不足错误
     * </pre>
     */
    emErrorNotEnoughSpace(8, 8),
    /**
     * <code>emErrorInternalError = 9;</code>
     *
     * <pre>
     * 无法申请内存的内部错误
     * </pre>
     */
    emErrorInternalError(9, 9),
    /**
     * <code>emErrorReadFileError = 10;</code>
     *
     * <pre>
     * 读文件内部错误
     * </pre>
     */
    emErrorReadFileError(10, 10),
    /**
     * <code>emErrorWriteFileError = 11;</code>
     *
     * <pre>
     * 写文件内部错误
     * </pre>
     */
    emErrorWriteFileError(11, 11),
    /**
     * <code>emErrorSeekFileError = 12;</code>
     *
     * <pre>
     * 查找文件错误
     * </pre>
     */
    emErrorSeekFileError(12, 12),
    /**
     * <code>emErrorCreateFileError = 13;</code>
     *
     * <pre>
     * 创建文件错误
     * </pre>
     */
    emErrorCreateFileError(13, 13),
    /**
     * <code>emErrorCreateThreadError = 14;</code>
     *
     * <pre>
     * 创建文件错误
     * </pre>
     */
    emErrorCreateThreadError(14, 14),
    /**
     * <code>emErrorObjectNULLError = 15;</code>
     *
     * <pre>
     * 参数指针为空的错误
     * </pre>
     */
    emErrorObjectNULLError(15, 15),
    /**
     * <code>emErrorTooMuchVideoStrream = 16;</code>
     *
     * <pre>
     * </pre>
     */
    emErrorTooMuchVideoStrream(16, 16),
    /**
     * <code>emErrorNotSupportedCodec = 17;</code>
     *
     * <pre>
     * </pre>
     */
    emErrorNotSupportedCodec(17, 17),
    /**
     * <code>emErrorFileEnd = 18;</code>
     *
     * <pre>
     * </pre>
     */
    emErrorFileEnd(18, 18),
    /**
     * <code>emErrorUnknownError = 19;</code>
     *
     * <pre>
     * 无法确定的错误		
     * </pre>
     */
    emErrorUnknownError(19, 19),
    /**
     * <code>emErrorWriteMemError = 20;</code>
     *
     * <pre>
     * [8/10/2011 liuxu] 写内存错误
     * </pre>
     */
    emErrorWriteMemError(20, 20),
    /**
     * <code>emErrorFileNameEmpty = 21;</code>
     *
     * <pre>
     * 文件名为空
     * </pre>
     */
    emErrorFileNameEmpty(21, 21),
    /**
     * <code>emErrorNotDir = 22;</code>
     *
     * <pre>
     * 路径中的目录存在但却非真正的目录
     * </pre>
     */
    emErrorNotDir(22, 22),
    /**
     * <code>emErrorLoop = 23;</code>
     *
     * <pre>
     * 欲打开的文件有过多符号连接问题，上限为16符号连接
     * </pre>
     */
    emErrorLoop(23, 23),
    /**
     * <code>emErrorAccess = 24;</code>
     *
     * <pre>
     *  存取文件时被拒绝
     * </pre>
     */
    emErrorAccess(24, 24),
    /**
     * <code>emErrorNameTooLong = 25;</code>
     *
     * <pre>
     * 	参数file_name的路径名称太长
     * </pre>
     */
    emErrorNameTooLong(25, 25),
    ;

    /**
     * <code>emErrorNoError = 0;</code>
     *
     * <pre>
     * 没有错误，正确返回
     * </pre>
     */
    public static final int emErrorNoError_VALUE = 0;
    /**
     * <code>emErrorFileNotFound = 1;</code>
     *
     * <pre>
     * 文件没有找到
     * </pre>
     */
    public static final int emErrorFileNotFound_VALUE = 1;
    /**
     * <code>emErrorInvalidASFFile = 2;</code>
     *
     * <pre>
     * 无效的ASF文件
     * </pre>
     */
    public static final int emErrorInvalidASFFile_VALUE = 2;
    /**
     * <code>emErrorObjectNotFound = 3;</code>
     *
     * <pre>
     * 对象没有找到
     * </pre>
     */
    public static final int emErrorObjectNotFound_VALUE = 3;
    /**
     * <code>emErrorBadIndex = 4;</code>
     *
     * <pre>
     * 错误的对象索引
     * </pre>
     */
    public static final int emErrorBadIndex_VALUE = 4;
    /**
     * <code>emErrorValueNotFound = 5;</code>
     *
     * <pre>
     * 没有找到相应的值
     * </pre>
     */
    public static final int emErrorValueNotFound_VALUE = 5;
    /**
     * <code>emErrorBadArgument = 6;</code>
     *
     * <pre>
     * 错误的参数
     * </pre>
     */
    public static final int emErrorBadArgument_VALUE = 6;
    /**
     * <code>emErrorReadOnly = 7;</code>
     *
     * <pre>
     * 文件只读错误
     * </pre>
     */
    public static final int emErrorReadOnly_VALUE = 7;
    /**
     * <code>emErrorNotEnoughSpace = 8;</code>
     *
     * <pre>
     * 存储空间不足错误
     * </pre>
     */
    public static final int emErrorNotEnoughSpace_VALUE = 8;
    /**
     * <code>emErrorInternalError = 9;</code>
     *
     * <pre>
     * 无法申请内存的内部错误
     * </pre>
     */
    public static final int emErrorInternalError_VALUE = 9;
    /**
     * <code>emErrorReadFileError = 10;</code>
     *
     * <pre>
     * 读文件内部错误
     * </pre>
     */
    public static final int emErrorReadFileError_VALUE = 10;
    /**
     * <code>emErrorWriteFileError = 11;</code>
     *
     * <pre>
     * 写文件内部错误
     * </pre>
     */
    public static final int emErrorWriteFileError_VALUE = 11;
    /**
     * <code>emErrorSeekFileError = 12;</code>
     *
     * <pre>
     * 查找文件错误
     * </pre>
     */
    public static final int emErrorSeekFileError_VALUE = 12;
    /**
     * <code>emErrorCreateFileError = 13;</code>
     *
     * <pre>
     * 创建文件错误
     * </pre>
     */
    public static final int emErrorCreateFileError_VALUE = 13;
    /**
     * <code>emErrorCreateThreadError = 14;</code>
     *
     * <pre>
     * 创建文件错误
     * </pre>
     */
    public static final int emErrorCreateThreadError_VALUE = 14;
    /**
     * <code>emErrorObjectNULLError = 15;</code>
     *
     * <pre>
     * 参数指针为空的错误
     * </pre>
     */
    public static final int emErrorObjectNULLError_VALUE = 15;
    /**
     * <code>emErrorTooMuchVideoStrream = 16;</code>
     *
     * <pre>
     * </pre>
     */
    public static final int emErrorTooMuchVideoStrream_VALUE = 16;
    /**
     * <code>emErrorNotSupportedCodec = 17;</code>
     *
     * <pre>
     * </pre>
     */
    public static final int emErrorNotSupportedCodec_VALUE = 17;
    /**
     * <code>emErrorFileEnd = 18;</code>
     *
     * <pre>
     * </pre>
     */
    public static final int emErrorFileEnd_VALUE = 18;
    /**
     * <code>emErrorUnknownError = 19;</code>
     *
     * <pre>
     * 无法确定的错误		
     * </pre>
     */
    public static final int emErrorUnknownError_VALUE = 19;
    /**
     * <code>emErrorWriteMemError = 20;</code>
     *
     * <pre>
     * [8/10/2011 liuxu] 写内存错误
     * </pre>
     */
    public static final int emErrorWriteMemError_VALUE = 20;
    /**
     * <code>emErrorFileNameEmpty = 21;</code>
     *
     * <pre>
     * 文件名为空
     * </pre>
     */
    public static final int emErrorFileNameEmpty_VALUE = 21;
    /**
     * <code>emErrorNotDir = 22;</code>
     *
     * <pre>
     * 路径中的目录存在但却非真正的目录
     * </pre>
     */
    public static final int emErrorNotDir_VALUE = 22;
    /**
     * <code>emErrorLoop = 23;</code>
     *
     * <pre>
     * 欲打开的文件有过多符号连接问题，上限为16符号连接
     * </pre>
     */
    public static final int emErrorLoop_VALUE = 23;
    /**
     * <code>emErrorAccess = 24;</code>
     *
     * <pre>
     *  存取文件时被拒绝
     * </pre>
     */
    public static final int emErrorAccess_VALUE = 24;
    /**
     * <code>emErrorNameTooLong = 25;</code>
     *
     * <pre>
     * 	参数file_name的路径名称太长
     * </pre>
     */
    public static final int emErrorNameTooLong_VALUE = 25;


    public final int getNumber() { return value; }

    public static EmVideoRecordErrorNum valueOf(int value) {
      switch (value) {
        case 0: return emErrorNoError;
        case 1: return emErrorFileNotFound;
        case 2: return emErrorInvalidASFFile;
        case 3: return emErrorObjectNotFound;
        case 4: return emErrorBadIndex;
        case 5: return emErrorValueNotFound;
        case 6: return emErrorBadArgument;
        case 7: return emErrorReadOnly;
        case 8: return emErrorNotEnoughSpace;
        case 9: return emErrorInternalError;
        case 10: return emErrorReadFileError;
        case 11: return emErrorWriteFileError;
        case 12: return emErrorSeekFileError;
        case 13: return emErrorCreateFileError;
        case 14: return emErrorCreateThreadError;
        case 15: return emErrorObjectNULLError;
        case 16: return emErrorTooMuchVideoStrream;
        case 17: return emErrorNotSupportedCodec;
        case 18: return emErrorFileEnd;
        case 19: return emErrorUnknownError;
        case 20: return emErrorWriteMemError;
        case 21: return emErrorFileNameEmpty;
        case 22: return emErrorNotDir;
        case 23: return emErrorLoop;
        case 24: return emErrorAccess;
        case 25: return emErrorNameTooLong;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVideoRecordErrorNum>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVideoRecordErrorNum>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVideoRecordErrorNum>() {
            public EmVideoRecordErrorNum findValueByNumber(int number) {
              return EmVideoRecordErrorNum.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(241);
    }

    private static final EmVideoRecordErrorNum[] VALUES = values();

    public static EmVideoRecordErrorNum valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVideoRecordErrorNum(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVideoRecordErrorNum)
  }

  /**
   * Protobuf enum {@code mt.EmKeyState}
   *
   * <pre>
   * 遥控器按键状态
   * </pre>
   */
  public enum EmKeyState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emKeyUp = 0;</code>
     *
     * <pre>
     *&#47;&lt;按键松开
     * </pre>
     */
    emKeyUp(0, 0),
    /**
     * <code>emKeyDown = 1;</code>
     *
     * <pre>
     *&#47;&lt;按键压下
     * </pre>
     */
    emKeyDown(1, 1),
    /**
     * <code>emKeyLongPressed = 2;</code>
     *
     * <pre>
     *&#47;&lt;按键长压
     * </pre>
     */
    emKeyLongPressed(2, 2),
    ;

    /**
     * <code>emKeyUp = 0;</code>
     *
     * <pre>
     *&#47;&lt;按键松开
     * </pre>
     */
    public static final int emKeyUp_VALUE = 0;
    /**
     * <code>emKeyDown = 1;</code>
     *
     * <pre>
     *&#47;&lt;按键压下
     * </pre>
     */
    public static final int emKeyDown_VALUE = 1;
    /**
     * <code>emKeyLongPressed = 2;</code>
     *
     * <pre>
     *&#47;&lt;按键长压
     * </pre>
     */
    public static final int emKeyLongPressed_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmKeyState valueOf(int value) {
      switch (value) {
        case 0: return emKeyUp;
        case 1: return emKeyDown;
        case 2: return emKeyLongPressed;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmKeyState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmKeyState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmKeyState>() {
            public EmKeyState findValueByNumber(int number) {
              return EmKeyState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(242);
    }

    private static final EmKeyState[] VALUES = values();

    public static EmKeyState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmKeyState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmKeyState)
  }

  /**
   * Protobuf enum {@code mt.EmVideoRecordStatus}
   *
   * <pre>
   * 录像状态
   * </pre>
   */
  public enum EmVideoRecordStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVideoRecordIdle = 0;</code>
     *
     * <pre>
     * 未录像
     * </pre>
     */
    emVideoRecordIdle(0, 0),
    /**
     * <code>emVideoRecordRecording = 1;</code>
     *
     * <pre>
     * 录像中
     * </pre>
     */
    emVideoRecordRecording(1, 1),
    /**
     * <code>emVideoRecordPause = 2;</code>
     *
     * <pre>
     * 录像暂停中
     * </pre>
     */
    emVideoRecordPause(2, 2),
    ;

    /**
     * <code>emVideoRecordIdle = 0;</code>
     *
     * <pre>
     * 未录像
     * </pre>
     */
    public static final int emVideoRecordIdle_VALUE = 0;
    /**
     * <code>emVideoRecordRecording = 1;</code>
     *
     * <pre>
     * 录像中
     * </pre>
     */
    public static final int emVideoRecordRecording_VALUE = 1;
    /**
     * <code>emVideoRecordPause = 2;</code>
     *
     * <pre>
     * 录像暂停中
     * </pre>
     */
    public static final int emVideoRecordPause_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmVideoRecordStatus valueOf(int value) {
      switch (value) {
        case 0: return emVideoRecordIdle;
        case 1: return emVideoRecordRecording;
        case 2: return emVideoRecordPause;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVideoRecordStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVideoRecordStatus>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVideoRecordStatus>() {
            public EmVideoRecordStatus findValueByNumber(int number) {
              return EmVideoRecordStatus.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(243);
    }

    private static final EmVideoRecordStatus[] VALUES = values();

    public static EmVideoRecordStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVideoRecordStatus(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVideoRecordStatus)
  }

  /**
   * Protobuf enum {@code mt.EmWirelessScreenState}
   *
   * <pre>
   *无线投屏状态
   * </pre>
   */
  public enum EmWirelessScreenState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWirelessScreen_enabled = 0;</code>
     *
     * <pre>
     *启用
     * </pre>
     */
    emWirelessScreen_enabled(0, 0),
    /**
     * <code>emWirelessScreen_disabled = 1;</code>
     *
     * <pre>
     *未启用
     * </pre>
     */
    emWirelessScreen_disabled(1, 1),
    ;

    /**
     * <code>emWirelessScreen_enabled = 0;</code>
     *
     * <pre>
     *启用
     * </pre>
     */
    public static final int emWirelessScreen_enabled_VALUE = 0;
    /**
     * <code>emWirelessScreen_disabled = 1;</code>
     *
     * <pre>
     *未启用
     * </pre>
     */
    public static final int emWirelessScreen_disabled_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmWirelessScreenState valueOf(int value) {
      switch (value) {
        case 0: return emWirelessScreen_enabled;
        case 1: return emWirelessScreen_disabled;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWirelessScreenState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWirelessScreenState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWirelessScreenState>() {
            public EmWirelessScreenState findValueByNumber(int number) {
              return EmWirelessScreenState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(244);
    }

    private static final EmWirelessScreenState[] VALUES = values();

    public static EmWirelessScreenState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWirelessScreenState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWirelessScreenState)
  }

  /**
   * Protobuf enum {@code mt.EmWirelessScreenErrReason}
   *
   * <pre>
   *无线投屏失败原因 *&#47;
   * </pre>
   */
  public enum EmWirelessScreenErrReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWirelessScreenErrReason_None = 0;</code>
     *
     * <pre>
     *成功
     * </pre>
     */
    emWirelessScreenErrReason_None(0, 0),
    /**
     * <code>emWirelessScreenErrReason_Failed = 1;</code>
     *
     * <pre>
     *失败
     * </pre>
     */
    emWirelessScreenErrReason_Failed(1, 1),
    /**
     * <code>emWirelessScreenErrReason_Timeout = 2;</code>
     *
     * <pre>
     *超时
     * </pre>
     */
    emWirelessScreenErrReason_Timeout(2, 2),
    /**
     * <code>emWirelessScreenErrReason_Unknown = 3;</code>
     *
     * <pre>
     *其他未知原因
     * </pre>
     */
    emWirelessScreenErrReason_Unknown(3, 3),
    ;

    /**
     * <code>emWirelessScreenErrReason_None = 0;</code>
     *
     * <pre>
     *成功
     * </pre>
     */
    public static final int emWirelessScreenErrReason_None_VALUE = 0;
    /**
     * <code>emWirelessScreenErrReason_Failed = 1;</code>
     *
     * <pre>
     *失败
     * </pre>
     */
    public static final int emWirelessScreenErrReason_Failed_VALUE = 1;
    /**
     * <code>emWirelessScreenErrReason_Timeout = 2;</code>
     *
     * <pre>
     *超时
     * </pre>
     */
    public static final int emWirelessScreenErrReason_Timeout_VALUE = 2;
    /**
     * <code>emWirelessScreenErrReason_Unknown = 3;</code>
     *
     * <pre>
     *其他未知原因
     * </pre>
     */
    public static final int emWirelessScreenErrReason_Unknown_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmWirelessScreenErrReason valueOf(int value) {
      switch (value) {
        case 0: return emWirelessScreenErrReason_None;
        case 1: return emWirelessScreenErrReason_Failed;
        case 2: return emWirelessScreenErrReason_Timeout;
        case 3: return emWirelessScreenErrReason_Unknown;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWirelessScreenErrReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWirelessScreenErrReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWirelessScreenErrReason>() {
            public EmWirelessScreenErrReason findValueByNumber(int number) {
              return EmWirelessScreenErrReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(245);
    }

    private static final EmWirelessScreenErrReason[] VALUES = values();

    public static EmWirelessScreenErrReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWirelessScreenErrReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWirelessScreenErrReason)
  }

  /**
   * Protobuf enum {@code mt.EmMtWarnType}
   *
   * <pre>
   *报警类型 以2的指数倍增加1,2,4,8,,,,,,
   * </pre>
   */
  public enum EmMtWarnType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMtWarnBegin = 0;</code>
     */
    emMtWarnBegin(0, 0),
    /**
     * <code>emMtWarnTemp = 1;</code>
     */
    emMtWarnTemp(1, 1),
    /**
     * <code>emMtWarnFanSpeed = 2;</code>
     */
    emMtWarnFanSpeed(2, 2),
    /**
     * <code>emMtWarnCpu = 4;</code>
     */
    emMtWarnCpu(3, 4),
    /**
     * <code>emMtWarnVolt = 8;</code>
     */
    emMtWarnVolt(4, 8),
    /**
     * <code>emMtWarnEnd = 32768;</code>
     */
    emMtWarnEnd(5, 32768),
    ;

    /**
     * <code>emMtWarnBegin = 0;</code>
     */
    public static final int emMtWarnBegin_VALUE = 0;
    /**
     * <code>emMtWarnTemp = 1;</code>
     */
    public static final int emMtWarnTemp_VALUE = 1;
    /**
     * <code>emMtWarnFanSpeed = 2;</code>
     */
    public static final int emMtWarnFanSpeed_VALUE = 2;
    /**
     * <code>emMtWarnCpu = 4;</code>
     */
    public static final int emMtWarnCpu_VALUE = 4;
    /**
     * <code>emMtWarnVolt = 8;</code>
     */
    public static final int emMtWarnVolt_VALUE = 8;
    /**
     * <code>emMtWarnEnd = 32768;</code>
     */
    public static final int emMtWarnEnd_VALUE = 32768;


    public final int getNumber() { return value; }

    public static EmMtWarnType valueOf(int value) {
      switch (value) {
        case 0: return emMtWarnBegin;
        case 1: return emMtWarnTemp;
        case 2: return emMtWarnFanSpeed;
        case 4: return emMtWarnCpu;
        case 8: return emMtWarnVolt;
        case 32768: return emMtWarnEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtWarnType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtWarnType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtWarnType>() {
            public EmMtWarnType findValueByNumber(int number) {
              return EmMtWarnType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(246);
    }

    private static final EmMtWarnType[] VALUES = values();

    public static EmMtWarnType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtWarnType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtWarnType)
  }

  /**
   * Protobuf enum {@code mt.EmLimitedIpType}
   *
   * <pre>
   *设置限定ip类型
   * </pre>
   */
  public enum EmLimitedIpType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emLimitedIpType_WhiteList = 0;</code>
     *
     * <pre>
     *白名单
     * </pre>
     */
    emLimitedIpType_WhiteList(0, 0),
    /**
     * <code>emLimitedIpType_BlackList = 1;</code>
     *
     * <pre>
     *黑名单
     * </pre>
     */
    emLimitedIpType_BlackList(1, 1),
    /**
     * <code>emLimitedIpType_Reset = 2;</code>
     *
     * <pre>
     *重置
     * </pre>
     */
    emLimitedIpType_Reset(2, 2),
    ;

    /**
     * <code>emLimitedIpType_WhiteList = 0;</code>
     *
     * <pre>
     *白名单
     * </pre>
     */
    public static final int emLimitedIpType_WhiteList_VALUE = 0;
    /**
     * <code>emLimitedIpType_BlackList = 1;</code>
     *
     * <pre>
     *黑名单
     * </pre>
     */
    public static final int emLimitedIpType_BlackList_VALUE = 1;
    /**
     * <code>emLimitedIpType_Reset = 2;</code>
     *
     * <pre>
     *重置
     * </pre>
     */
    public static final int emLimitedIpType_Reset_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmLimitedIpType valueOf(int value) {
      switch (value) {
        case 0: return emLimitedIpType_WhiteList;
        case 1: return emLimitedIpType_BlackList;
        case 2: return emLimitedIpType_Reset;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmLimitedIpType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmLimitedIpType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmLimitedIpType>() {
            public EmLimitedIpType findValueByNumber(int number) {
              return EmLimitedIpType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(247);
    }

    private static final EmLimitedIpType[] VALUES = values();

    public static EmLimitedIpType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmLimitedIpType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmLimitedIpType)
  }

  /**
   * Protobuf enum {@code mt.EmTerControlCameraOsdType}
   *
   * <pre>
   *终端反控摄像机操作osd类型
   * </pre>
   */
  public enum EmTerControlCameraOsdType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCameraOsdMenu = 0;</code>
     *
     * <pre>
     *弹出菜单
     * </pre>
     */
    emCameraOsdMenu(0, 0),
    /**
     * <code>emCameraOsdOk = 1;</code>
     *
     * <pre>
     *按下Ok键
     * </pre>
     */
    emCameraOsdOk(1, 1),
    /**
     * <code>emCameraOsdReture = 2;</code>
     *
     * <pre>
     *返回
     * </pre>
     */
    emCameraOsdReture(2, 2),
    ;

    /**
     * <code>emCameraOsdMenu = 0;</code>
     *
     * <pre>
     *弹出菜单
     * </pre>
     */
    public static final int emCameraOsdMenu_VALUE = 0;
    /**
     * <code>emCameraOsdOk = 1;</code>
     *
     * <pre>
     *按下Ok键
     * </pre>
     */
    public static final int emCameraOsdOk_VALUE = 1;
    /**
     * <code>emCameraOsdReture = 2;</code>
     *
     * <pre>
     *返回
     * </pre>
     */
    public static final int emCameraOsdReture_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmTerControlCameraOsdType valueOf(int value) {
      switch (value) {
        case 0: return emCameraOsdMenu;
        case 1: return emCameraOsdOk;
        case 2: return emCameraOsdReture;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmTerControlCameraOsdType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmTerControlCameraOsdType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmTerControlCameraOsdType>() {
            public EmTerControlCameraOsdType findValueByNumber(int number) {
              return EmTerControlCameraOsdType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(248);
    }

    private static final EmTerControlCameraOsdType[] VALUES = values();

    public static EmTerControlCameraOsdType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmTerControlCameraOsdType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmTerControlCameraOsdType)
  }

  /**
   * Protobuf enum {@code mt.EmDigestType}
   */
  public enum EmDigestType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSm3 = 0;</code>
     */
    emSm3(0, 0),
    /**
     * <code>emMd5 = 1;</code>
     */
    emMd5(1, 1),
    ;

    /**
     * <code>emSm3 = 0;</code>
     */
    public static final int emSm3_VALUE = 0;
    /**
     * <code>emMd5 = 1;</code>
     */
    public static final int emMd5_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmDigestType valueOf(int value) {
      switch (value) {
        case 0: return emSm3;
        case 1: return emMd5;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDigestType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDigestType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDigestType>() {
            public EmDigestType findValueByNumber(int number) {
              return EmDigestType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(249);
    }

    private static final EmDigestType[] VALUES = values();

    public static EmDigestType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDigestType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDigestType)
  }

  /**
   * Protobuf enum {@code mt.EmPubPriType}
   *
   * <pre>
   *&#47;公钥私钥算法
   * </pre>
   */
  public enum EmPubPriType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRsa = 1;</code>
     */
    emRsa(0, 1),
    /**
     * <code>emSm2 = 2;</code>
     */
    emSm2(1, 2),
    ;

    /**
     * <code>emRsa = 1;</code>
     */
    public static final int emRsa_VALUE = 1;
    /**
     * <code>emSm2 = 2;</code>
     */
    public static final int emSm2_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmPubPriType valueOf(int value) {
      switch (value) {
        case 1: return emRsa;
        case 2: return emSm2;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPubPriType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPubPriType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPubPriType>() {
            public EmPubPriType findValueByNumber(int number) {
              return EmPubPriType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(250);
    }

    private static final EmPubPriType[] VALUES = values();

    public static EmPubPriType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPubPriType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPubPriType)
  }

  /**
   * Protobuf enum {@code mt.EmSrtpCryptoType}
   *
   * <pre>
   *SRTP秘钥类型
   * </pre>
   */
  public enum EmSrtpCryptoType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSrtpCryptoNone = 0;</code>
     *
     * <pre>
     *不加密
     * </pre>
     */
    emSrtpCryptoNone(0, 0),
    /**
     * <code>emSrtpCryptoAES_CM_128 = 1;</code>
     */
    emSrtpCryptoAES_CM_128(1, 1),
    /**
     * <code>emSrtpCryptoAES_CM_192 = 2;</code>
     */
    emSrtpCryptoAES_CM_192(2, 2),
    /**
     * <code>emSrtpCryptoAES_CM_256 = 3;</code>
     */
    emSrtpCryptoAES_CM_256(3, 3),
    /**
     * <code>emSrtpCryptoAES_GCM_128 = 4;</code>
     */
    emSrtpCryptoAES_GCM_128(4, 4),
    /**
     * <code>emSrtpCryptoAES_GCM_192 = 5;</code>
     */
    emSrtpCryptoAES_GCM_192(5, 5),
    /**
     * <code>emSrtpCryptoAES_GCM_256 = 6;</code>
     */
    emSrtpCryptoAES_GCM_256(6, 6),
    /**
     * <code>emSrtpCryptoSM4_CM_128 = 7;</code>
     *
     * <pre>
     *SM目前只有128的  
     * </pre>
     */
    emSrtpCryptoSM4_CM_128(7, 7),
    /**
     * <code>emSrtpCryptoSM1_CM_128 = 8;</code>
     */
    emSrtpCryptoSM1_CM_128(8, 8),
    ;

    /**
     * <code>emSrtpCryptoNone = 0;</code>
     *
     * <pre>
     *不加密
     * </pre>
     */
    public static final int emSrtpCryptoNone_VALUE = 0;
    /**
     * <code>emSrtpCryptoAES_CM_128 = 1;</code>
     */
    public static final int emSrtpCryptoAES_CM_128_VALUE = 1;
    /**
     * <code>emSrtpCryptoAES_CM_192 = 2;</code>
     */
    public static final int emSrtpCryptoAES_CM_192_VALUE = 2;
    /**
     * <code>emSrtpCryptoAES_CM_256 = 3;</code>
     */
    public static final int emSrtpCryptoAES_CM_256_VALUE = 3;
    /**
     * <code>emSrtpCryptoAES_GCM_128 = 4;</code>
     */
    public static final int emSrtpCryptoAES_GCM_128_VALUE = 4;
    /**
     * <code>emSrtpCryptoAES_GCM_192 = 5;</code>
     */
    public static final int emSrtpCryptoAES_GCM_192_VALUE = 5;
    /**
     * <code>emSrtpCryptoAES_GCM_256 = 6;</code>
     */
    public static final int emSrtpCryptoAES_GCM_256_VALUE = 6;
    /**
     * <code>emSrtpCryptoSM4_CM_128 = 7;</code>
     *
     * <pre>
     *SM目前只有128的  
     * </pre>
     */
    public static final int emSrtpCryptoSM4_CM_128_VALUE = 7;
    /**
     * <code>emSrtpCryptoSM1_CM_128 = 8;</code>
     */
    public static final int emSrtpCryptoSM1_CM_128_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmSrtpCryptoType valueOf(int value) {
      switch (value) {
        case 0: return emSrtpCryptoNone;
        case 1: return emSrtpCryptoAES_CM_128;
        case 2: return emSrtpCryptoAES_CM_192;
        case 3: return emSrtpCryptoAES_CM_256;
        case 4: return emSrtpCryptoAES_GCM_128;
        case 5: return emSrtpCryptoAES_GCM_192;
        case 6: return emSrtpCryptoAES_GCM_256;
        case 7: return emSrtpCryptoSM4_CM_128;
        case 8: return emSrtpCryptoSM1_CM_128;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSrtpCryptoType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSrtpCryptoType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSrtpCryptoType>() {
            public EmSrtpCryptoType findValueByNumber(int number) {
              return EmSrtpCryptoType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(251);
    }

    private static final EmSrtpCryptoType[] VALUES = values();

    public static EmSrtpCryptoType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSrtpCryptoType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSrtpCryptoType)
  }

  /**
   * Protobuf enum {@code mt.EmSrtpAuthType}
   *
   * <pre>
   *SRTP秘钥类型
   * </pre>
   */
  public enum EmSrtpAuthType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSrtpAuthNone = 0;</code>
     *
     * <pre>
     *不认证
     * </pre>
     */
    emSrtpAuthNone(0, 0),
    /**
     * <code>emSrtpAuthTag_8 = 1;</code>
     */
    emSrtpAuthTag_8(1, 1),
    /**
     * <code>emSrtpAuthTag_16 = 2;</code>
     */
    emSrtpAuthTag_16(2, 2),
    /**
     * <code>emSrtpAuthTag_32 = 3;</code>
     */
    emSrtpAuthTag_32(3, 3),
    /**
     * <code>emSrtpAuthTag_80 = 4;</code>
     */
    emSrtpAuthTag_80(4, 4),
    ;

    /**
     * <code>emSrtpAuthNone = 0;</code>
     *
     * <pre>
     *不认证
     * </pre>
     */
    public static final int emSrtpAuthNone_VALUE = 0;
    /**
     * <code>emSrtpAuthTag_8 = 1;</code>
     */
    public static final int emSrtpAuthTag_8_VALUE = 1;
    /**
     * <code>emSrtpAuthTag_16 = 2;</code>
     */
    public static final int emSrtpAuthTag_16_VALUE = 2;
    /**
     * <code>emSrtpAuthTag_32 = 3;</code>
     */
    public static final int emSrtpAuthTag_32_VALUE = 3;
    /**
     * <code>emSrtpAuthTag_80 = 4;</code>
     */
    public static final int emSrtpAuthTag_80_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmSrtpAuthType valueOf(int value) {
      switch (value) {
        case 0: return emSrtpAuthNone;
        case 1: return emSrtpAuthTag_8;
        case 2: return emSrtpAuthTag_16;
        case 3: return emSrtpAuthTag_32;
        case 4: return emSrtpAuthTag_80;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSrtpAuthType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSrtpAuthType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSrtpAuthType>() {
            public EmSrtpAuthType findValueByNumber(int number) {
              return EmSrtpAuthType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(252);
    }

    private static final EmSrtpAuthType[] VALUES = values();

    public static EmSrtpAuthType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSrtpAuthType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSrtpAuthType)
  }

  /**
   * Protobuf enum {@code mt.EmSipConnectType}
   *
   * <pre>
   *SIP连接类型
   * </pre>
   */
  public enum EmSipConnectType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSipUdpConnect = 0;</code>
     */
    emSipUdpConnect(0, 0),
    /**
     * <code>emSipTcpConnect = 1;</code>
     */
    emSipTcpConnect(1, 1),
    /**
     * <code>emSipTlsConnect = 2;</code>
     */
    emSipTlsConnect(2, 2),
    /**
     * <code>emSipGMTlsConnect = 3;</code>
     */
    emSipGMTlsConnect(3, 3),
    ;

    /**
     * <code>emSipUdpConnect = 0;</code>
     */
    public static final int emSipUdpConnect_VALUE = 0;
    /**
     * <code>emSipTcpConnect = 1;</code>
     */
    public static final int emSipTcpConnect_VALUE = 1;
    /**
     * <code>emSipTlsConnect = 2;</code>
     */
    public static final int emSipTlsConnect_VALUE = 2;
    /**
     * <code>emSipGMTlsConnect = 3;</code>
     */
    public static final int emSipGMTlsConnect_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmSipConnectType valueOf(int value) {
      switch (value) {
        case 0: return emSipUdpConnect;
        case 1: return emSipTcpConnect;
        case 2: return emSipTlsConnect;
        case 3: return emSipGMTlsConnect;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSipConnectType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSipConnectType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSipConnectType>() {
            public EmSipConnectType findValueByNumber(int number) {
              return EmSipConnectType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(253);
    }

    private static final EmSipConnectType[] VALUES = values();

    public static EmSipConnectType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSipConnectType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSipConnectType)
  }

  /**
   * Protobuf enum {@code mt.EmSecCertFormat}
   */
  public enum EmSecCertFormat
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSecCertFormart_NULL = 0;</code>
     */
    emSecCertFormart_NULL(0, 0),
    /**
     * <code>emSecCertFormart_PEM = 1;</code>
     */
    emSecCertFormart_PEM(1, 1),
    /**
     * <code>emSecCertFormart_DER = 2;</code>
     */
    emSecCertFormart_DER(2, 2),
    /**
     * <code>emSecCertFormart_PFX = 3;</code>
     */
    emSecCertFormart_PFX(3, 3),
    /**
     * <code>emSecCertFormart_B64 = 4;</code>
     */
    emSecCertFormart_B64(4, 4),
    ;

    /**
     * <code>emSecCertFormart_NULL = 0;</code>
     */
    public static final int emSecCertFormart_NULL_VALUE = 0;
    /**
     * <code>emSecCertFormart_PEM = 1;</code>
     */
    public static final int emSecCertFormart_PEM_VALUE = 1;
    /**
     * <code>emSecCertFormart_DER = 2;</code>
     */
    public static final int emSecCertFormart_DER_VALUE = 2;
    /**
     * <code>emSecCertFormart_PFX = 3;</code>
     */
    public static final int emSecCertFormart_PFX_VALUE = 3;
    /**
     * <code>emSecCertFormart_B64 = 4;</code>
     */
    public static final int emSecCertFormart_B64_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmSecCertFormat valueOf(int value) {
      switch (value) {
        case 0: return emSecCertFormart_NULL;
        case 1: return emSecCertFormart_PEM;
        case 2: return emSecCertFormart_DER;
        case 3: return emSecCertFormart_PFX;
        case 4: return emSecCertFormart_B64;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSecCertFormat>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSecCertFormat>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSecCertFormat>() {
            public EmSecCertFormat findValueByNumber(int number) {
              return EmSecCertFormat.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(254);
    }

    private static final EmSecCertFormat[] VALUES = values();

    public static EmSecCertFormat valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSecCertFormat(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSecCertFormat)
  }

  /**
   * Protobuf enum {@code mt.EmRecordType}
   *
   * <pre>
   *录像类型 
   * </pre>
   */
  public enum EmRecordType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emStartRecordType = 0;</code>
     */
    emStartRecordType(0, 0),
    /**
     * <code>emConferenceRecord = 1;</code>
     *
     * <pre>
     *&#47;会议录像
     * </pre>
     */
    emConferenceRecord(1, 1),
    /**
     * <code>emTerminalRecord = 2;</code>
     *
     * <pre>
     *&#47;终端录像
     * </pre>
     */
    emTerminalRecord(2, 2),
    ;

    /**
     * <code>emStartRecordType = 0;</code>
     */
    public static final int emStartRecordType_VALUE = 0;
    /**
     * <code>emConferenceRecord = 1;</code>
     *
     * <pre>
     *&#47;会议录像
     * </pre>
     */
    public static final int emConferenceRecord_VALUE = 1;
    /**
     * <code>emTerminalRecord = 2;</code>
     *
     * <pre>
     *&#47;终端录像
     * </pre>
     */
    public static final int emTerminalRecord_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmRecordType valueOf(int value) {
      switch (value) {
        case 0: return emStartRecordType;
        case 1: return emConferenceRecord;
        case 2: return emTerminalRecord;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRecordType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRecordType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRecordType>() {
            public EmRecordType findValueByNumber(int number) {
              return EmRecordType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(255);
    }

    private static final EmRecordType[] VALUES = values();

    public static EmRecordType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRecordType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRecordType)
  }

  /**
   * Protobuf enum {@code mt.EmPublishMode}
   *
   * <pre>
   *发布模式
   * </pre>
   */
  public enum EmPublishMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNotPublishMode = 0;</code>
     *
     * <pre>
     *&#47;不发布
     * </pre>
     */
    emNotPublishMode(0, 0),
    /**
     * <code>emPublishMode = 1;</code>
     *
     * <pre>
     *&#47;发布
     * </pre>
     */
    emPublishMode(1, 1),
    ;

    /**
     * <code>emNotPublishMode = 0;</code>
     *
     * <pre>
     *&#47;不发布
     * </pre>
     */
    public static final int emNotPublishMode_VALUE = 0;
    /**
     * <code>emPublishMode = 1;</code>
     *
     * <pre>
     *&#47;发布
     * </pre>
     */
    public static final int emPublishMode_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmPublishMode valueOf(int value) {
      switch (value) {
        case 0: return emNotPublishMode;
        case 1: return emPublishMode;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPublishMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPublishMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPublishMode>() {
            public EmPublishMode findValueByNumber(int number) {
              return EmPublishMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(256);
    }

    private static final EmPublishMode[] VALUES = values();

    public static EmPublishMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPublishMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPublishMode)
  }

  /**
   * Protobuf enum {@code mt.EmRecordMode}
   *
   * <pre>
   *&#47;录像模式
   * </pre>
   */
  public enum EmRecordMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emDisableRecordMode = 0;</code>
     *
     * <pre>
     *&#47;不开启录像或直播
     * </pre>
     */
    emDisableRecordMode(0, 0),
    /**
     * <code>emRecordMode = 1;</code>
     *
     * <pre>
     *&#47;录像
     * </pre>
     */
    emRecordMode(1, 1),
    /**
     * <code>emLiveMode = 2;</code>
     *
     * <pre>
     *&#47;直播
     * </pre>
     */
    emLiveMode(2, 2),
    /**
     * <code>emRecordLiveMode = 3;</code>
     *
     * <pre>
     *&#47;录像+直播
     * </pre>
     */
    emRecordLiveMode(3, 3),
    ;

    /**
     * <code>emDisableRecordMode = 0;</code>
     *
     * <pre>
     *&#47;不开启录像或直播
     * </pre>
     */
    public static final int emDisableRecordMode_VALUE = 0;
    /**
     * <code>emRecordMode = 1;</code>
     *
     * <pre>
     *&#47;录像
     * </pre>
     */
    public static final int emRecordMode_VALUE = 1;
    /**
     * <code>emLiveMode = 2;</code>
     *
     * <pre>
     *&#47;直播
     * </pre>
     */
    public static final int emLiveMode_VALUE = 2;
    /**
     * <code>emRecordLiveMode = 3;</code>
     *
     * <pre>
     *&#47;录像+直播
     * </pre>
     */
    public static final int emRecordLiveMode_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmRecordMode valueOf(int value) {
      switch (value) {
        case 0: return emDisableRecordMode;
        case 1: return emRecordMode;
        case 2: return emLiveMode;
        case 3: return emRecordLiveMode;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRecordMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRecordMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRecordMode>() {
            public EmRecordMode findValueByNumber(int number) {
              return EmRecordMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(257);
    }

    private static final EmRecordMode[] VALUES = values();

    public static EmRecordMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRecordMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRecordMode)
  }

  /**
   * Protobuf enum {@code mt.EmCallMode}
   *
   * <pre>
   *呼叫模式
   * </pre>
   */
  public enum EmCallMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMannualCall = 0;</code>
     *
     * <pre>
     *手动呼叫
     * </pre>
     */
    emMannualCall(0, 0),
    /**
     * <code>emAutoCall = 1;</code>
     *
     * <pre>
     *自动呼叫
     * </pre>
     */
    emAutoCall(1, 1),
    /**
     * <code>emTimingCall = 2;</code>
     *
     * <pre>
     *定时呼叫
     * </pre>
     */
    emTimingCall(2, 2),
    /**
     * <code>emChasingCall = 3;</code>
     *
     * <pre>
     *追呼
     * </pre>
     */
    emChasingCall(3, 3),
    ;

    /**
     * <code>emMannualCall = 0;</code>
     *
     * <pre>
     *手动呼叫
     * </pre>
     */
    public static final int emMannualCall_VALUE = 0;
    /**
     * <code>emAutoCall = 1;</code>
     *
     * <pre>
     *自动呼叫
     * </pre>
     */
    public static final int emAutoCall_VALUE = 1;
    /**
     * <code>emTimingCall = 2;</code>
     *
     * <pre>
     *定时呼叫
     * </pre>
     */
    public static final int emTimingCall_VALUE = 2;
    /**
     * <code>emChasingCall = 3;</code>
     *
     * <pre>
     *追呼
     * </pre>
     */
    public static final int emChasingCall_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmCallMode valueOf(int value) {
      switch (value) {
        case 0: return emMannualCall;
        case 1: return emAutoCall;
        case 2: return emTimingCall;
        case 3: return emChasingCall;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCallMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCallMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCallMode>() {
            public EmCallMode findValueByNumber(int number) {
              return EmCallMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(258);
    }

    private static final EmCallMode[] VALUES = values();

    public static EmCallMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCallMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCallMode)
  }

  /**
   * Protobuf enum {@code mt.EmRecordState}
   *
   * <pre>
   *录像状态
   * </pre>
   */
  public enum EmRecordState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emDoNotRecord = 0;</code>
     *
     * <pre>
     *未录像
     * </pre>
     */
    emDoNotRecord(0, 0),
    /**
     * <code>emRecording = 1;</code>
     *
     * <pre>
     *正在录像
     * </pre>
     */
    emRecording(1, 1),
    /**
     * <code>emSuspendRecord = 2;</code>
     *
     * <pre>
     *暂停
     * </pre>
     */
    emSuspendRecord(2, 2),
    /**
     * <code>emCallingMT = 3;</code>
     *
     * <pre>
     *正在呼叫实体
     * </pre>
     */
    emCallingMT(3, 3),
    /**
     * <code>emPrepareRecord = 4;</code>
     *
     * <pre>
     *准备录像
     * </pre>
     */
    emPrepareRecord(4, 4),
    ;

    /**
     * <code>emDoNotRecord = 0;</code>
     *
     * <pre>
     *未录像
     * </pre>
     */
    public static final int emDoNotRecord_VALUE = 0;
    /**
     * <code>emRecording = 1;</code>
     *
     * <pre>
     *正在录像
     * </pre>
     */
    public static final int emRecording_VALUE = 1;
    /**
     * <code>emSuspendRecord = 2;</code>
     *
     * <pre>
     *暂停
     * </pre>
     */
    public static final int emSuspendRecord_VALUE = 2;
    /**
     * <code>emCallingMT = 3;</code>
     *
     * <pre>
     *正在呼叫实体
     * </pre>
     */
    public static final int emCallingMT_VALUE = 3;
    /**
     * <code>emPrepareRecord = 4;</code>
     *
     * <pre>
     *准备录像
     * </pre>
     */
    public static final int emPrepareRecord_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmRecordState valueOf(int value) {
      switch (value) {
        case 0: return emDoNotRecord;
        case 1: return emRecording;
        case 2: return emSuspendRecord;
        case 3: return emCallingMT;
        case 4: return emPrepareRecord;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRecordState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRecordState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRecordState>() {
            public EmRecordState findValueByNumber(int number) {
              return EmRecordState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(259);
    }

    private static final EmRecordState[] VALUES = values();

    public static EmRecordState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRecordState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRecordState)
  }

  /**
   * Protobuf enum {@code mt.EmRecordCmd}
   */
  public enum EmRecordCmd
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRecordCmdBak = 0;</code>
     *
     * <pre>
     *备用参数
     * </pre>
     */
    emRecordCmdBak(0, 0),
    /**
     * <code>emPauseRecord = 1;</code>
     *
     * <pre>
     *暂停录像
     * </pre>
     */
    emPauseRecord(1, 1),
    /**
     * <code>emContinueRecord = 2;</code>
     *
     * <pre>
     *继续录像
     * </pre>
     */
    emContinueRecord(2, 2),
    ;

    /**
     * <code>emRecordCmdBak = 0;</code>
     *
     * <pre>
     *备用参数
     * </pre>
     */
    public static final int emRecordCmdBak_VALUE = 0;
    /**
     * <code>emPauseRecord = 1;</code>
     *
     * <pre>
     *暂停录像
     * </pre>
     */
    public static final int emPauseRecord_VALUE = 1;
    /**
     * <code>emContinueRecord = 2;</code>
     *
     * <pre>
     *继续录像
     * </pre>
     */
    public static final int emContinueRecord_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmRecordCmd valueOf(int value) {
      switch (value) {
        case 0: return emRecordCmdBak;
        case 1: return emPauseRecord;
        case 2: return emContinueRecord;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRecordCmd>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRecordCmd>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRecordCmd>() {
            public EmRecordCmd findValueByNumber(int number) {
              return EmRecordCmd.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(260);
    }

    private static final EmRecordCmd[] VALUES = values();

    public static EmRecordCmd valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRecordCmd(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRecordCmd)
  }

  /**
   * Protobuf enum {@code mt.EmMtDcsType}
   */
  public enum EmMtDcsType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emTypeUnknown = 0;</code>
     *
     * <pre>
     * 未知
     * </pre>
     */
    emTypeUnknown(0, 0),
    /**
     * <code>emTypeTrueLink = 1;</code>
     *
     * <pre>
     * 致玲
     * </pre>
     */
    emTypeTrueLink(1, 1),
    /**
     * <code>emTypeTrueTouchPhoneIOS = 2;</code>
     *
     * <pre>
     * 手机-IOS
     * </pre>
     */
    emTypeTrueTouchPhoneIOS(2, 2),
    /**
     * <code>emTypeTrueTouchPadIOS = 3;</code>
     *
     * <pre>
     * 平板-IOS
     * </pre>
     */
    emTypeTrueTouchPadIOS(3, 3),
    /**
     * <code>emTypeTrueTouchPhoneAndroid = 4;</code>
     *
     * <pre>
     * 手机-android
     * </pre>
     */
    emTypeTrueTouchPhoneAndroid(4, 4),
    /**
     * <code>emTypeTrueTouchPadAndroid = 5;</code>
     *
     * <pre>
     * 平板-android
     * </pre>
     */
    emTypeTrueTouchPadAndroid(5, 5),
    /**
     * <code>emTypeTrueSens = 6;</code>
     *
     * <pre>
     * 硬终端
     * </pre>
     */
    emTypeTrueSens(6, 6),
    /**
     * <code>emTypeIMIX = 7;</code>
     *
     * <pre>
     * imix
     * </pre>
     */
    emTypeIMIX(7, 7),
    /**
     * <code>emTypeThirdPartyTer = 8;</code>
     *
     * <pre>
     * 第三方终端
     * </pre>
     */
    emTypeThirdPartyTer(8, 8),
    /**
     * <code>emTypeButt = 9;</code>
     */
    emTypeButt(9, 9),
    ;

    /**
     * <code>emTypeUnknown = 0;</code>
     *
     * <pre>
     * 未知
     * </pre>
     */
    public static final int emTypeUnknown_VALUE = 0;
    /**
     * <code>emTypeTrueLink = 1;</code>
     *
     * <pre>
     * 致玲
     * </pre>
     */
    public static final int emTypeTrueLink_VALUE = 1;
    /**
     * <code>emTypeTrueTouchPhoneIOS = 2;</code>
     *
     * <pre>
     * 手机-IOS
     * </pre>
     */
    public static final int emTypeTrueTouchPhoneIOS_VALUE = 2;
    /**
     * <code>emTypeTrueTouchPadIOS = 3;</code>
     *
     * <pre>
     * 平板-IOS
     * </pre>
     */
    public static final int emTypeTrueTouchPadIOS_VALUE = 3;
    /**
     * <code>emTypeTrueTouchPhoneAndroid = 4;</code>
     *
     * <pre>
     * 手机-android
     * </pre>
     */
    public static final int emTypeTrueTouchPhoneAndroid_VALUE = 4;
    /**
     * <code>emTypeTrueTouchPadAndroid = 5;</code>
     *
     * <pre>
     * 平板-android
     * </pre>
     */
    public static final int emTypeTrueTouchPadAndroid_VALUE = 5;
    /**
     * <code>emTypeTrueSens = 6;</code>
     *
     * <pre>
     * 硬终端
     * </pre>
     */
    public static final int emTypeTrueSens_VALUE = 6;
    /**
     * <code>emTypeIMIX = 7;</code>
     *
     * <pre>
     * imix
     * </pre>
     */
    public static final int emTypeIMIX_VALUE = 7;
    /**
     * <code>emTypeThirdPartyTer = 8;</code>
     *
     * <pre>
     * 第三方终端
     * </pre>
     */
    public static final int emTypeThirdPartyTer_VALUE = 8;
    /**
     * <code>emTypeButt = 9;</code>
     */
    public static final int emTypeButt_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmMtDcsType valueOf(int value) {
      switch (value) {
        case 0: return emTypeUnknown;
        case 1: return emTypeTrueLink;
        case 2: return emTypeTrueTouchPhoneIOS;
        case 3: return emTypeTrueTouchPadIOS;
        case 4: return emTypeTrueTouchPhoneAndroid;
        case 5: return emTypeTrueTouchPadAndroid;
        case 6: return emTypeTrueSens;
        case 7: return emTypeIMIX;
        case 8: return emTypeThirdPartyTer;
        case 9: return emTypeButt;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtDcsType>() {
            public EmMtDcsType findValueByNumber(int number) {
              return EmMtDcsType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(261);
    }

    private static final EmMtDcsType[] VALUES = values();

    public static EmMtDcsType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtDcsType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtDcsType)
  }

  /**
   * Protobuf enum {@code mt.EmMtDcsRole}
   */
  public enum EmMtDcsRole
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRoleManage = 0;</code>
     *
     * <pre>
     * 管理方
     * </pre>
     */
    emRoleManage(0, 0),
    /**
     * <code>emRoleOper = 1;</code>
     *
     * <pre>
     * 协作方
     * </pre>
     */
    emRoleOper(1, 1),
    /**
     * <code>emRoleUser = 2;</code>
     *
     * <pre>
     * 与会方
     * </pre>
     */
    emRoleUser(2, 2),
    /**
     * <code>emRoleErr = 10;</code>
     *
     * <pre>
     *未填
     * </pre>
     */
    emRoleErr(3, 10),
    ;

    /**
     * <code>emRoleManage = 0;</code>
     *
     * <pre>
     * 管理方
     * </pre>
     */
    public static final int emRoleManage_VALUE = 0;
    /**
     * <code>emRoleOper = 1;</code>
     *
     * <pre>
     * 协作方
     * </pre>
     */
    public static final int emRoleOper_VALUE = 1;
    /**
     * <code>emRoleUser = 2;</code>
     *
     * <pre>
     * 与会方
     * </pre>
     */
    public static final int emRoleUser_VALUE = 2;
    /**
     * <code>emRoleErr = 10;</code>
     *
     * <pre>
     *未填
     * </pre>
     */
    public static final int emRoleErr_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmMtDcsRole valueOf(int value) {
      switch (value) {
        case 0: return emRoleManage;
        case 1: return emRoleOper;
        case 2: return emRoleUser;
        case 10: return emRoleErr;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsRole>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsRole>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtDcsRole>() {
            public EmMtDcsRole findValueByNumber(int number) {
              return EmMtDcsRole.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(262);
    }

    private static final EmMtDcsRole[] VALUES = values();

    public static EmMtDcsRole valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtDcsRole(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtDcsRole)
  }

  /**
   * Protobuf enum {@code mt.EmMtDcsConfMode}
   */
  public enum EmMtDcsConfMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConfModeStop = 0;</code>
     *
     * <pre>
     * 关闭数据协作
     * </pre>
     */
    emConfModeStop(0, 0),
    /**
     * <code>emConfModeManage = 1;</code>
     *
     * <pre>
     * 主席控制
     * </pre>
     */
    emConfModeManage(1, 1),
    /**
     * <code>emConfModeAuto = 2;</code>
     *
     * <pre>
     * 自动协作
     * </pre>
     */
    emConfModeAuto(2, 2),
    ;

    /**
     * <code>emConfModeStop = 0;</code>
     *
     * <pre>
     * 关闭数据协作
     * </pre>
     */
    public static final int emConfModeStop_VALUE = 0;
    /**
     * <code>emConfModeManage = 1;</code>
     *
     * <pre>
     * 主席控制
     * </pre>
     */
    public static final int emConfModeManage_VALUE = 1;
    /**
     * <code>emConfModeAuto = 2;</code>
     *
     * <pre>
     * 自动协作
     * </pre>
     */
    public static final int emConfModeAuto_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmMtDcsConfMode valueOf(int value) {
      switch (value) {
        case 0: return emConfModeStop;
        case 1: return emConfModeManage;
        case 2: return emConfModeAuto;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsConfMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsConfMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtDcsConfMode>() {
            public EmMtDcsConfMode findValueByNumber(int number) {
              return EmMtDcsConfMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(263);
    }

    private static final EmMtDcsConfMode[] VALUES = values();

    public static EmMtDcsConfMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtDcsConfMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtDcsConfMode)
  }

  /**
   * Protobuf enum {@code mt.EmMtDcsConfType}
   */
  public enum EmMtDcsConfType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConfTypeP2P = 0;</code>
     *
     * <pre>
     * 点对点
     * </pre>
     */
    emConfTypeP2P(0, 0),
    /**
     * <code>emConfTypeMCC = 1;</code>
     *
     * <pre>
     * 多点
     * </pre>
     */
    emConfTypeMCC(1, 1),
    ;

    /**
     * <code>emConfTypeP2P = 0;</code>
     *
     * <pre>
     * 点对点
     * </pre>
     */
    public static final int emConfTypeP2P_VALUE = 0;
    /**
     * <code>emConfTypeMCC = 1;</code>
     *
     * <pre>
     * 多点
     * </pre>
     */
    public static final int emConfTypeMCC_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmMtDcsConfType valueOf(int value) {
      switch (value) {
        case 0: return emConfTypeP2P;
        case 1: return emConfTypeMCC;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsConfType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsConfType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtDcsConfType>() {
            public EmMtDcsConfType findValueByNumber(int number) {
              return EmMtDcsConfType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(264);
    }

    private static final EmMtDcsConfType[] VALUES = values();

    public static EmMtDcsConfType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtDcsConfType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtDcsConfType)
  }

  /**
   * Protobuf enum {@code mt.EmMtDcsWbMode}
   */
  public enum EmMtDcsWbMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWbModeWB = 0;</code>
     *
     * <pre>
     * 白板
     * </pre>
     */
    emWbModeWB(0, 0),
    /**
     * <code>emWBModeDOC = 1;</code>
     *
     * <pre>
     * 文档
     * </pre>
     */
    emWBModeDOC(1, 1),
    ;

    /**
     * <code>emWbModeWB = 0;</code>
     *
     * <pre>
     * 白板
     * </pre>
     */
    public static final int emWbModeWB_VALUE = 0;
    /**
     * <code>emWBModeDOC = 1;</code>
     *
     * <pre>
     * 文档
     * </pre>
     */
    public static final int emWBModeDOC_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmMtDcsWbMode valueOf(int value) {
      switch (value) {
        case 0: return emWbModeWB;
        case 1: return emWBModeDOC;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsWbMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtDcsWbMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtDcsWbMode>() {
            public EmMtDcsWbMode findValueByNumber(int number) {
              return EmMtDcsWbMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(265);
    }

    private static final EmMtDcsWbMode[] VALUES = values();

    public static EmMtDcsWbMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtDcsWbMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtDcsWbMode)
  }

  /**
   * Protobuf enum {@code mt.EmWbEntityType}
   */
  public enum EmWbEntityType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUnknow = 0;</code>
     */
    emUnknow(0, 0),
    /**
     * <code>emLine = 1;</code>
     *
     * <pre>
     * 直线
     * </pre>
     */
    emLine(1, 1),
    /**
     * <code>emCircle = 2;</code>
     *
     * <pre>
     * 圆形
     * </pre>
     */
    emCircle(2, 2),
    /**
     * <code>emPencil = 3;</code>
     *
     * <pre>
     * 铅笔
     * </pre>
     */
    emPencil(3, 3),
    /**
     * <code>emColorPen = 4;</code>
     *
     * <pre>
     * 水彩笔
     * </pre>
     */
    emColorPen(4, 4),
    /**
     * <code>emImage = 5;</code>
     *
     * <pre>
     * 图片
     * </pre>
     */
    emImage(5, 5),
    ;

    /**
     * <code>emUnknow = 0;</code>
     */
    public static final int emUnknow_VALUE = 0;
    /**
     * <code>emLine = 1;</code>
     *
     * <pre>
     * 直线
     * </pre>
     */
    public static final int emLine_VALUE = 1;
    /**
     * <code>emCircle = 2;</code>
     *
     * <pre>
     * 圆形
     * </pre>
     */
    public static final int emCircle_VALUE = 2;
    /**
     * <code>emPencil = 3;</code>
     *
     * <pre>
     * 铅笔
     * </pre>
     */
    public static final int emPencil_VALUE = 3;
    /**
     * <code>emColorPen = 4;</code>
     *
     * <pre>
     * 水彩笔
     * </pre>
     */
    public static final int emColorPen_VALUE = 4;
    /**
     * <code>emImage = 5;</code>
     *
     * <pre>
     * 图片
     * </pre>
     */
    public static final int emImage_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmWbEntityType valueOf(int value) {
      switch (value) {
        case 0: return emUnknow;
        case 1: return emLine;
        case 2: return emCircle;
        case 3: return emPencil;
        case 4: return emColorPen;
        case 5: return emImage;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWbEntityType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWbEntityType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWbEntityType>() {
            public EmWbEntityType findValueByNumber(int number) {
              return EmWbEntityType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(266);
    }

    private static final EmWbEntityType[] VALUES = values();

    public static EmWbEntityType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWbEntityType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWbEntityType)
  }

  /**
   * Protobuf enum {@code mt.EmWbImageState}
   *
   * <pre>
   * 图片文件所处状态
   * </pre>
   */
  public enum EmWbImageState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emImageStateDownloading = 0;</code>
     *
     * <pre>
     * 文件正在接收，请耐心等待... 
     * </pre>
     */
    emImageStateDownloading(0, 0),
    /**
     * <code>emImageStateDownLoadFail = 1;</code>
     *
     * <pre>
     * 文件接收失败，非常抱歉！！！
     * </pre>
     */
    emImageStateDownLoadFail(1, 1),
    /**
     * <code>emImageStateOwnerAlreadyLeave = 2;</code>
     *
     * <pre>
     * 文件同步失败，发起方可能已断开连接
     * </pre>
     */
    emImageStateOwnerAlreadyLeave(2, 2),
    /**
     * <code>emImageStateDownLoadOk = 3;</code>
     *
     * <pre>
     * 文件接收成功，即将显示
     * </pre>
     */
    emImageStateDownLoadOk(3, 3),
    /**
     * <code>emImageStateInit = 4;</code>
     *
     * <pre>
     * 初始状态
     * </pre>
     */
    emImageStateInit(4, 4),
    /**
     * <code>emImageStateConvertFail = 5;</code>
     *
     * <pre>
     * 文件转换失败，可能文件错误或已损坏
     * </pre>
     */
    emImageStateConvertFail(5, 5),
    /**
     * <code>emImageStateSelfAlreadyLeave = 6;</code>
     *
     * <pre>
     * 文件接收未完成，已离开会议
     * </pre>
     */
    emImageStateSelfAlreadyLeave(6, 6),
    ;

    /**
     * <code>emImageStateDownloading = 0;</code>
     *
     * <pre>
     * 文件正在接收，请耐心等待... 
     * </pre>
     */
    public static final int emImageStateDownloading_VALUE = 0;
    /**
     * <code>emImageStateDownLoadFail = 1;</code>
     *
     * <pre>
     * 文件接收失败，非常抱歉！！！
     * </pre>
     */
    public static final int emImageStateDownLoadFail_VALUE = 1;
    /**
     * <code>emImageStateOwnerAlreadyLeave = 2;</code>
     *
     * <pre>
     * 文件同步失败，发起方可能已断开连接
     * </pre>
     */
    public static final int emImageStateOwnerAlreadyLeave_VALUE = 2;
    /**
     * <code>emImageStateDownLoadOk = 3;</code>
     *
     * <pre>
     * 文件接收成功，即将显示
     * </pre>
     */
    public static final int emImageStateDownLoadOk_VALUE = 3;
    /**
     * <code>emImageStateInit = 4;</code>
     *
     * <pre>
     * 初始状态
     * </pre>
     */
    public static final int emImageStateInit_VALUE = 4;
    /**
     * <code>emImageStateConvertFail = 5;</code>
     *
     * <pre>
     * 文件转换失败，可能文件错误或已损坏
     * </pre>
     */
    public static final int emImageStateConvertFail_VALUE = 5;
    /**
     * <code>emImageStateSelfAlreadyLeave = 6;</code>
     *
     * <pre>
     * 文件接收未完成，已离开会议
     * </pre>
     */
    public static final int emImageStateSelfAlreadyLeave_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmWbImageState valueOf(int value) {
      switch (value) {
        case 0: return emImageStateDownloading;
        case 1: return emImageStateDownLoadFail;
        case 2: return emImageStateOwnerAlreadyLeave;
        case 3: return emImageStateDownLoadOk;
        case 4: return emImageStateInit;
        case 5: return emImageStateConvertFail;
        case 6: return emImageStateSelfAlreadyLeave;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWbImageState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWbImageState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWbImageState>() {
            public EmWbImageState findValueByNumber(int number) {
              return EmWbImageState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(267);
    }

    private static final EmWbImageState[] VALUES = values();

    public static EmWbImageState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWbImageState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWbImageState)
  }

  /**
   * Protobuf enum {@code mt.EmWBMode}
   *
   * <pre>
   * 白板模式
   * </pre>
   */
  public enum EmWBMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWbModeUnkown = 0;</code>
     *
     * <pre>
     * 未知
     * </pre>
     */
    emWbModeUnkown(0, 0),
    /**
     * <code>emWbModeWhiteBoard = 1;</code>
     *
     * <pre>
     * 空白白板模式（非文档模式）
     * </pre>
     */
    emWbModeWhiteBoard(1, 1),
    /**
     * <code>emWbModeDOC = 2;</code>
     *
     * <pre>
     * 文档模式
     * </pre>
     */
    emWbModeDOC(2, 2),
    ;

    /**
     * <code>emWbModeUnkown = 0;</code>
     *
     * <pre>
     * 未知
     * </pre>
     */
    public static final int emWbModeUnkown_VALUE = 0;
    /**
     * <code>emWbModeWhiteBoard = 1;</code>
     *
     * <pre>
     * 空白白板模式（非文档模式）
     * </pre>
     */
    public static final int emWbModeWhiteBoard_VALUE = 1;
    /**
     * <code>emWbModeDOC = 2;</code>
     *
     * <pre>
     * 文档模式
     * </pre>
     */
    public static final int emWbModeDOC_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmWBMode valueOf(int value) {
      switch (value) {
        case 0: return emWbModeUnkown;
        case 1: return emWbModeWhiteBoard;
        case 2: return emWbModeDOC;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmWBMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmWBMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmWBMode>() {
            public EmWBMode findValueByNumber(int number) {
              return EmWBMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(268);
    }

    private static final EmWBMode[] VALUES = values();

    public static EmWBMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmWBMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmWBMode)
  }

  /**
   * Protobuf enum {@code mt.EmDcsConnectType}
   */
  public enum EmDcsConnectType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConnectLogin = 0;</code>
     *
     * <pre>
     * 用于登录注册
     * </pre>
     */
    emConnectLogin(0, 0),
    /**
     * <code>emConnectConf = 1;</code>
     *
     * <pre>
     * 用于会议相关
     * </pre>
     */
    emConnectConf(1, 1),
    ;

    /**
     * <code>emConnectLogin = 0;</code>
     *
     * <pre>
     * 用于登录注册
     * </pre>
     */
    public static final int emConnectLogin_VALUE = 0;
    /**
     * <code>emConnectConf = 1;</code>
     *
     * <pre>
     * 用于会议相关
     * </pre>
     */
    public static final int emConnectConf_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmDcsConnectType valueOf(int value) {
      switch (value) {
        case 0: return emConnectLogin;
        case 1: return emConnectConf;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDcsConnectType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDcsConnectType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDcsConnectType>() {
            public EmDcsConnectType findValueByNumber(int number) {
              return EmDcsConnectType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(269);
    }

    private static final EmDcsConnectType[] VALUES = values();

    public static EmDcsConnectType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDcsConnectType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDcsConnectType)
  }

  /**
   * Protobuf enum {@code mt.EmDcsOper}
   */
  public enum EmDcsOper
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWbLineOperInfo = 0;</code>
     *
     * <pre>
     * TDCSWbLineOperInfo
     * </pre>
     */
    emWbLineOperInfo(0, 0),
    /**
     * <code>emWbCircleOperInfo = 1;</code>
     *
     * <pre>
     * TDCSWbCircleOperInfo
     * </pre>
     */
    emWbCircleOperInfo(1, 1),
    /**
     * <code>emWbRectangleOperInfo = 2;</code>
     */
    emWbRectangleOperInfo(2, 2),
    /**
     * <code>emWbPencilOperInfo = 3;</code>
     *
     * <pre>
     * TDCSWbPencilOperInfo
     * </pre>
     */
    emWbPencilOperInfo(3, 3),
    /**
     * <code>emWbColorPenOperInfo = 4;</code>
     *
     * <pre>
     * TDCSWbColorPenOperInfo
     * </pre>
     */
    emWbColorPenOperInfo(4, 4),
    /**
     * <code>emWbImageOperInfo = 5;</code>
     */
    emWbImageOperInfo(5, 5),
    /**
     * <code>emWbAddSubPageInfo = 6;</code>
     *
     * <pre>
     * TDCSWbAddSubPageInfo
     * </pre>
     */
    emWbAddSubPageInfo(6, 6),
    /**
     * <code>emWbEraseOperInfo = 7;</code>
     *
     * <pre>
     * TDCSWbEraseOperInfo
     * </pre>
     */
    emWbEraseOperInfo(7, 7),
    /**
     * <code>emWbZoomInfo = 8;</code>
     *
     * <pre>
     * TDCSWbZoomInfo
     * </pre>
     */
    emWbZoomInfo(8, 8),
    /**
     * <code>emWbUndo = 9;</code>
     */
    emWbUndo(9, 9),
    /**
     * <code>emWbRedo = 10;</code>
     */
    emWbRedo(10, 10),
    /**
     * <code>emWbRotateLeft = 11;</code>
     */
    emWbRotateLeft(11, 11),
    /**
     * <code>emWbRotateRight = 12;</code>
     */
    emWbRotateRight(12, 12),
    /**
     * <code>emWbClearScreen = 13;</code>
     */
    emWbClearScreen(13, 13),
    /**
     * <code>emWbScrollScreen = 14;</code>
     */
    emWbScrollScreen(14, 14),
    /**
     * <code>emWbFullScreen = 15;</code>
     */
    emWbFullScreen(15, 15),
    /**
     * <code>emWb100ProportionScreen = 16;</code>
     */
    emWb100ProportionScreen(16, 16),
    /**
     * <code>emWbReginErase = 17;</code>
     */
    emWbReginErase(17, 17),
    /**
     * <code>emWbInsertPic = 18;</code>
     */
    emWbInsertPic(18, 18),
    /**
     * <code>emWbPitchPicZoom = 19;</code>
     */
    emWbPitchPicZoom(19, 19),
    /**
     * <code>emWbPitchPicRotate = 20;</code>
     */
    emWbPitchPicRotate(20, 20),
    /**
     * <code>emWbPitchPicDrag = 21;</code>
     */
    emWbPitchPicDrag(21, 21),
    /**
     * <code>emWbPitchPicDel = 22;</code>
     */
    emWbPitchPicDel(22, 22),
    ;

    /**
     * <code>emWbLineOperInfo = 0;</code>
     *
     * <pre>
     * TDCSWbLineOperInfo
     * </pre>
     */
    public static final int emWbLineOperInfo_VALUE = 0;
    /**
     * <code>emWbCircleOperInfo = 1;</code>
     *
     * <pre>
     * TDCSWbCircleOperInfo
     * </pre>
     */
    public static final int emWbCircleOperInfo_VALUE = 1;
    /**
     * <code>emWbRectangleOperInfo = 2;</code>
     */
    public static final int emWbRectangleOperInfo_VALUE = 2;
    /**
     * <code>emWbPencilOperInfo = 3;</code>
     *
     * <pre>
     * TDCSWbPencilOperInfo
     * </pre>
     */
    public static final int emWbPencilOperInfo_VALUE = 3;
    /**
     * <code>emWbColorPenOperInfo = 4;</code>
     *
     * <pre>
     * TDCSWbColorPenOperInfo
     * </pre>
     */
    public static final int emWbColorPenOperInfo_VALUE = 4;
    /**
     * <code>emWbImageOperInfo = 5;</code>
     */
    public static final int emWbImageOperInfo_VALUE = 5;
    /**
     * <code>emWbAddSubPageInfo = 6;</code>
     *
     * <pre>
     * TDCSWbAddSubPageInfo
     * </pre>
     */
    public static final int emWbAddSubPageInfo_VALUE = 6;
    /**
     * <code>emWbEraseOperInfo = 7;</code>
     *
     * <pre>
     * TDCSWbEraseOperInfo
     * </pre>
     */
    public static final int emWbEraseOperInfo_VALUE = 7;
    /**
     * <code>emWbZoomInfo = 8;</code>
     *
     * <pre>
     * TDCSWbZoomInfo
     * </pre>
     */
    public static final int emWbZoomInfo_VALUE = 8;
    /**
     * <code>emWbUndo = 9;</code>
     */
    public static final int emWbUndo_VALUE = 9;
    /**
     * <code>emWbRedo = 10;</code>
     */
    public static final int emWbRedo_VALUE = 10;
    /**
     * <code>emWbRotateLeft = 11;</code>
     */
    public static final int emWbRotateLeft_VALUE = 11;
    /**
     * <code>emWbRotateRight = 12;</code>
     */
    public static final int emWbRotateRight_VALUE = 12;
    /**
     * <code>emWbClearScreen = 13;</code>
     */
    public static final int emWbClearScreen_VALUE = 13;
    /**
     * <code>emWbScrollScreen = 14;</code>
     */
    public static final int emWbScrollScreen_VALUE = 14;
    /**
     * <code>emWbFullScreen = 15;</code>
     */
    public static final int emWbFullScreen_VALUE = 15;
    /**
     * <code>emWb100ProportionScreen = 16;</code>
     */
    public static final int emWb100ProportionScreen_VALUE = 16;
    /**
     * <code>emWbReginErase = 17;</code>
     */
    public static final int emWbReginErase_VALUE = 17;
    /**
     * <code>emWbInsertPic = 18;</code>
     */
    public static final int emWbInsertPic_VALUE = 18;
    /**
     * <code>emWbPitchPicZoom = 19;</code>
     */
    public static final int emWbPitchPicZoom_VALUE = 19;
    /**
     * <code>emWbPitchPicRotate = 20;</code>
     */
    public static final int emWbPitchPicRotate_VALUE = 20;
    /**
     * <code>emWbPitchPicDrag = 21;</code>
     */
    public static final int emWbPitchPicDrag_VALUE = 21;
    /**
     * <code>emWbPitchPicDel = 22;</code>
     */
    public static final int emWbPitchPicDel_VALUE = 22;


    public final int getNumber() { return value; }

    public static EmDcsOper valueOf(int value) {
      switch (value) {
        case 0: return emWbLineOperInfo;
        case 1: return emWbCircleOperInfo;
        case 2: return emWbRectangleOperInfo;
        case 3: return emWbPencilOperInfo;
        case 4: return emWbColorPenOperInfo;
        case 5: return emWbImageOperInfo;
        case 6: return emWbAddSubPageInfo;
        case 7: return emWbEraseOperInfo;
        case 8: return emWbZoomInfo;
        case 9: return emWbUndo;
        case 10: return emWbRedo;
        case 11: return emWbRotateLeft;
        case 12: return emWbRotateRight;
        case 13: return emWbClearScreen;
        case 14: return emWbScrollScreen;
        case 15: return emWbFullScreen;
        case 16: return emWb100ProportionScreen;
        case 17: return emWbReginErase;
        case 18: return emWbInsertPic;
        case 19: return emWbPitchPicZoom;
        case 20: return emWbPitchPicRotate;
        case 21: return emWbPitchPicDrag;
        case 22: return emWbPitchPicDel;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDcsOper>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDcsOper>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDcsOper>() {
            public EmDcsOper findValueByNumber(int number) {
              return EmDcsOper.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(270);
    }

    private static final EmDcsOper[] VALUES = values();

    public static EmDcsOper valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDcsOper(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDcsOper)
  }

  /**
   * Protobuf enum {@code mt.EmDcsConnectErrCode}
   */
  public enum EmDcsConnectErrCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emConfSuccess = 1;</code>
     *
     * <pre>
     * 会议服务器建链成功
     * </pre>
     */
    emConfSuccess(0, 1),
    /**
     * <code>emConfFailed = 2;</code>
     *
     * <pre>
     * 会议服务器建链失败
     * </pre>
     */
    emConfFailed(1, 2),
    /**
     * <code>emConfDisconnect = 3;</code>
     *
     * <pre>
     * 会议服务器中途断链
     * </pre>
     */
    emConfDisconnect(2, 3),
    /**
     * <code>emLoginSuccess = 4;</code>
     *
     * <pre>
     * 注册服务器建链成功
     * </pre>
     */
    emLoginSuccess(3, 4),
    /**
     * <code>emLoginFailed = 5;</code>
     *
     * <pre>
     * 注册服务器建链失败
     * </pre>
     */
    emLoginFailed(4, 5),
    /**
     * <code>emLoginDisconnect = 6;</code>
     *
     * <pre>
     * 注册服务器建链中途断链
     * </pre>
     */
    emLoginDisconnect(5, 6),
    ;

    /**
     * <code>emConfSuccess = 1;</code>
     *
     * <pre>
     * 会议服务器建链成功
     * </pre>
     */
    public static final int emConfSuccess_VALUE = 1;
    /**
     * <code>emConfFailed = 2;</code>
     *
     * <pre>
     * 会议服务器建链失败
     * </pre>
     */
    public static final int emConfFailed_VALUE = 2;
    /**
     * <code>emConfDisconnect = 3;</code>
     *
     * <pre>
     * 会议服务器中途断链
     * </pre>
     */
    public static final int emConfDisconnect_VALUE = 3;
    /**
     * <code>emLoginSuccess = 4;</code>
     *
     * <pre>
     * 注册服务器建链成功
     * </pre>
     */
    public static final int emLoginSuccess_VALUE = 4;
    /**
     * <code>emLoginFailed = 5;</code>
     *
     * <pre>
     * 注册服务器建链失败
     * </pre>
     */
    public static final int emLoginFailed_VALUE = 5;
    /**
     * <code>emLoginDisconnect = 6;</code>
     *
     * <pre>
     * 注册服务器建链中途断链
     * </pre>
     */
    public static final int emLoginDisconnect_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmDcsConnectErrCode valueOf(int value) {
      switch (value) {
        case 1: return emConfSuccess;
        case 2: return emConfFailed;
        case 3: return emConfDisconnect;
        case 4: return emLoginSuccess;
        case 5: return emLoginFailed;
        case 6: return emLoginDisconnect;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDcsConnectErrCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDcsConnectErrCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDcsConnectErrCode>() {
            public EmDcsConnectErrCode findValueByNumber(int number) {
              return EmDcsConnectErrCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(271);
    }

    private static final EmDcsConnectErrCode[] VALUES = values();

    public static EmDcsConnectErrCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDcsConnectErrCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDcsConnectErrCode)
  }

  /**
   * Protobuf enum {@code mt.EmDcsAdpRejectJoinConfCode}
   */
  public enum EmDcsAdpRejectJoinConfCode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRejectJoinConf_start = 1;</code>
     */
    emRejectJoinConf_start(0, 1),
    /**
     * <code>emRejectJoinConf_busy = 2;</code>
     */
    emRejectJoinConf_busy(1, 2),
    /**
     * <code>emRejectJoinConf_normal = 3;</code>
     */
    emRejectJoinConf_normal(2, 3),
    /**
     * <code>emRejectJoinConf_rejected = 4;</code>
     */
    emRejectJoinConf_rejected(3, 4),
    /**
     * <code>emRejectJoinConf_unreachable = 5;</code>
     */
    emRejectJoinConf_unreachable(4, 5),
    /**
     * <code>emRejectJoinConf_unknown = 6;</code>
     */
    emRejectJoinConf_unknown(5, 6),
    /**
     * <code>emRejectJoinConf_end = 7;</code>
     */
    emRejectJoinConf_end(6, 7),
    ;

    /**
     * <code>emRejectJoinConf_start = 1;</code>
     */
    public static final int emRejectJoinConf_start_VALUE = 1;
    /**
     * <code>emRejectJoinConf_busy = 2;</code>
     */
    public static final int emRejectJoinConf_busy_VALUE = 2;
    /**
     * <code>emRejectJoinConf_normal = 3;</code>
     */
    public static final int emRejectJoinConf_normal_VALUE = 3;
    /**
     * <code>emRejectJoinConf_rejected = 4;</code>
     */
    public static final int emRejectJoinConf_rejected_VALUE = 4;
    /**
     * <code>emRejectJoinConf_unreachable = 5;</code>
     */
    public static final int emRejectJoinConf_unreachable_VALUE = 5;
    /**
     * <code>emRejectJoinConf_unknown = 6;</code>
     */
    public static final int emRejectJoinConf_unknown_VALUE = 6;
    /**
     * <code>emRejectJoinConf_end = 7;</code>
     */
    public static final int emRejectJoinConf_end_VALUE = 7;


    public final int getNumber() { return value; }

    public static EmDcsAdpRejectJoinConfCode valueOf(int value) {
      switch (value) {
        case 1: return emRejectJoinConf_start;
        case 2: return emRejectJoinConf_busy;
        case 3: return emRejectJoinConf_normal;
        case 4: return emRejectJoinConf_rejected;
        case 5: return emRejectJoinConf_unreachable;
        case 6: return emRejectJoinConf_unknown;
        case 7: return emRejectJoinConf_end;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDcsAdpRejectJoinConfCode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDcsAdpRejectJoinConfCode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDcsAdpRejectJoinConfCode>() {
            public EmDcsAdpRejectJoinConfCode findValueByNumber(int number) {
              return EmDcsAdpRejectJoinConfCode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(272);
    }

    private static final EmDcsAdpRejectJoinConfCode[] VALUES = values();

    public static EmDcsAdpRejectJoinConfCode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDcsAdpRejectJoinConfCode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDcsAdpRejectJoinConfCode)
  }

  /**
   * Protobuf enum {@code mt.EmSecAutState}
   */
  public enum EmSecAutState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSecAutidle = 0;</code>
     */
    emSecAutidle(0, 0),
    /**
     * <code>emSecAuting = 1;</code>
     */
    emSecAuting(1, 1),
    /**
     * <code>emSecAutsuc = 2;</code>
     */
    emSecAutsuc(2, 2),
    ;

    /**
     * <code>emSecAutidle = 0;</code>
     */
    public static final int emSecAutidle_VALUE = 0;
    /**
     * <code>emSecAuting = 1;</code>
     */
    public static final int emSecAuting_VALUE = 1;
    /**
     * <code>emSecAutsuc = 2;</code>
     */
    public static final int emSecAutsuc_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmSecAutState valueOf(int value) {
      switch (value) {
        case 0: return emSecAutidle;
        case 1: return emSecAuting;
        case 2: return emSecAutsuc;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSecAutState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSecAutState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSecAutState>() {
            public EmSecAutState findValueByNumber(int number) {
              return EmSecAutState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(273);
    }

    private static final EmSecAutState[] VALUES = values();

    public static EmSecAutState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSecAutState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSecAutState)
  }

  /**
   * Protobuf enum {@code mt.EmAuthCancelReason}
   */
  public enum EmAuthCancelReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSecAuth_Cancel = 1;</code>
     *
     * <pre>
     *主动取消
     * </pre>
     */
    emSecAuth_Cancel(0, 1),
    /**
     * <code>emSecAuth_ErrOverTime = 2;</code>
     *
     * <pre>
     *认证失败超次数 
     * </pre>
     */
    emSecAuth_ErrOverTime(1, 2),
    /**
     * <code>emSecAut_TimeOut = 3;</code>
     *
     * <pre>
     *认证超时
     * </pre>
     */
    emSecAut_TimeOut(2, 3),
    /**
     * <code>emSecAut_ErrConnect = 4;</code>
     *
     * <pre>
     *错误连接方式
     * </pre>
     */
    emSecAut_ErrConnect(3, 4),
    ;

    /**
     * <code>emSecAuth_Cancel = 1;</code>
     *
     * <pre>
     *主动取消
     * </pre>
     */
    public static final int emSecAuth_Cancel_VALUE = 1;
    /**
     * <code>emSecAuth_ErrOverTime = 2;</code>
     *
     * <pre>
     *认证失败超次数 
     * </pre>
     */
    public static final int emSecAuth_ErrOverTime_VALUE = 2;
    /**
     * <code>emSecAut_TimeOut = 3;</code>
     *
     * <pre>
     *认证超时
     * </pre>
     */
    public static final int emSecAut_TimeOut_VALUE = 3;
    /**
     * <code>emSecAut_ErrConnect = 4;</code>
     *
     * <pre>
     *错误连接方式
     * </pre>
     */
    public static final int emSecAut_ErrConnect_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmAuthCancelReason valueOf(int value) {
      switch (value) {
        case 1: return emSecAuth_Cancel;
        case 2: return emSecAuth_ErrOverTime;
        case 3: return emSecAut_TimeOut;
        case 4: return emSecAut_ErrConnect;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAuthCancelReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAuthCancelReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAuthCancelReason>() {
            public EmAuthCancelReason findValueByNumber(int number) {
              return EmAuthCancelReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(274);
    }

    private static final EmAuthCancelReason[] VALUES = values();

    public static EmAuthCancelReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAuthCancelReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAuthCancelReason)
  }

  /**
   * Protobuf enum {@code mt.EmSecKeyUpdateMode}
   */
  public enum EmSecKeyUpdateMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EmSecKeyUpdateModeByPeriod = 0;</code>
     *
     * <pre>
     * 按照时间周期更新
     * </pre>
     */
    EmSecKeyUpdateModeByPeriod(0, 0),
    /**
     * <code>EmSecKeyUpdateModeByPackage = 1;</code>
     *
     * <pre>
     * 按照包的个数更新
     * </pre>
     */
    EmSecKeyUpdateModeByPackage(1, 1),
    ;

    /**
     * <code>EmSecKeyUpdateModeByPeriod = 0;</code>
     *
     * <pre>
     * 按照时间周期更新
     * </pre>
     */
    public static final int EmSecKeyUpdateModeByPeriod_VALUE = 0;
    /**
     * <code>EmSecKeyUpdateModeByPackage = 1;</code>
     *
     * <pre>
     * 按照包的个数更新
     * </pre>
     */
    public static final int EmSecKeyUpdateModeByPackage_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmSecKeyUpdateMode valueOf(int value) {
      switch (value) {
        case 0: return EmSecKeyUpdateModeByPeriod;
        case 1: return EmSecKeyUpdateModeByPackage;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSecKeyUpdateMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSecKeyUpdateMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSecKeyUpdateMode>() {
            public EmSecKeyUpdateMode findValueByNumber(int number) {
              return EmSecKeyUpdateMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(275);
    }

    private static final EmSecKeyUpdateMode[] VALUES = values();

    public static EmSecKeyUpdateMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSecKeyUpdateMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSecKeyUpdateMode)
  }

  /**
   * Protobuf enum {@code mt.EmCameraCtrlType}
   *
   * <pre>
   *SKY300机芯控制类型
   * </pre>
   */
  public enum EmCameraCtrlType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emIspImgCtrl = 1;</code>
     *
     * <pre>
     *ISP控制
     * </pre>
     */
    emIspImgCtrl(0, 1),
    /**
     * <code>emSerialCtrl = 2;</code>
     *
     * <pre>
     *串口控制（同H650）
     * </pre>
     */
    emSerialCtrl(1, 2),
    ;

    /**
     * <code>emIspImgCtrl = 1;</code>
     *
     * <pre>
     *ISP控制
     * </pre>
     */
    public static final int emIspImgCtrl_VALUE = 1;
    /**
     * <code>emSerialCtrl = 2;</code>
     *
     * <pre>
     *串口控制（同H650）
     * </pre>
     */
    public static final int emSerialCtrl_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmCameraCtrlType valueOf(int value) {
      switch (value) {
        case 1: return emIspImgCtrl;
        case 2: return emSerialCtrl;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCameraCtrlType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCameraCtrlType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCameraCtrlType>() {
            public EmCameraCtrlType findValueByNumber(int number) {
              return EmCameraCtrlType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(276);
    }

    private static final EmCameraCtrlType[] VALUES = values();

    public static EmCameraCtrlType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCameraCtrlType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCameraCtrlType)
  }

  /**
   * Protobuf enum {@code mt.EmVersionType}
   */
  public enum EmVersionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emChannel = 0;</code>
     *
     * <pre>
     *CHANNEL代表渠道版本
     * </pre>
     */
    emChannel(0, 0),
    /**
     * <code>emOthers = 1;</code>
     *
     * <pre>
     *暂时代表非渠道
     * </pre>
     */
    emOthers(1, 1),
    ;

    /**
     * <code>emChannel = 0;</code>
     *
     * <pre>
     *CHANNEL代表渠道版本
     * </pre>
     */
    public static final int emChannel_VALUE = 0;
    /**
     * <code>emOthers = 1;</code>
     *
     * <pre>
     *暂时代表非渠道
     * </pre>
     */
    public static final int emOthers_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmVersionType valueOf(int value) {
      switch (value) {
        case 0: return emChannel;
        case 1: return emOthers;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVersionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVersionType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVersionType>() {
            public EmVersionType findValueByNumber(int number) {
              return EmVersionType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(277);
    }

    private static final EmVersionType[] VALUES = values();

    public static EmVersionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVersionType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVersionType)
  }

  /**
   * Protobuf enum {@code mt.EmLicenseKeyCheckValue}
   */
  public enum EmLicenseKeyCheckValue
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emWrongKey = 0;</code>
     *
     * <pre>
     *license错误
     * </pre>
     */
    emWrongKey(0, 0),
    /**
     * <code>emRightKey = 1;</code>
     *
     * <pre>
     *正确
     * </pre>
     */
    emRightKey(1, 1),
    /**
     * <code>emNotExist = 2;</code>
     *
     * <pre>
     *不存在
     * </pre>
     */
    emNotExist(2, 2),
    /**
     * <code>emParseError = 3;</code>
     *
     * <pre>
     *格式错误
     * </pre>
     */
    emParseError(3, 3),
    ;

    /**
     * <code>emWrongKey = 0;</code>
     *
     * <pre>
     *license错误
     * </pre>
     */
    public static final int emWrongKey_VALUE = 0;
    /**
     * <code>emRightKey = 1;</code>
     *
     * <pre>
     *正确
     * </pre>
     */
    public static final int emRightKey_VALUE = 1;
    /**
     * <code>emNotExist = 2;</code>
     *
     * <pre>
     *不存在
     * </pre>
     */
    public static final int emNotExist_VALUE = 2;
    /**
     * <code>emParseError = 3;</code>
     *
     * <pre>
     *格式错误
     * </pre>
     */
    public static final int emParseError_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmLicenseKeyCheckValue valueOf(int value) {
      switch (value) {
        case 0: return emWrongKey;
        case 1: return emRightKey;
        case 2: return emNotExist;
        case 3: return emParseError;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmLicenseKeyCheckValue>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmLicenseKeyCheckValue>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmLicenseKeyCheckValue>() {
            public EmLicenseKeyCheckValue findValueByNumber(int number) {
              return EmLicenseKeyCheckValue.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(278);
    }

    private static final EmLicenseKeyCheckValue[] VALUES = values();

    public static EmLicenseKeyCheckValue valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmLicenseKeyCheckValue(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmLicenseKeyCheckValue)
  }

  /**
   * Protobuf enum {@code mt.EmCameraErrorType}
   *
   * <pre>
   * 摄像机操作错误类型
   * </pre>
   */
  public enum EmCameraErrorType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EmCameraErrorType_unknown = 0;</code>
     */
    EmCameraErrorType_unknown(0, 0),
    /**
     * <code>EmCameraErrorType_ZoominEnd = 1;</code>
     *
     * <pre>
     * 视野到底
     * </pre>
     */
    EmCameraErrorType_ZoominEnd(1, 1),
    /**
     * <code>EmCameraErrorType_ZoomoutEnd = 2;</code>
     *
     * <pre>
     * 视野到底
     * </pre>
     */
    EmCameraErrorType_ZoomoutEnd(2, 2),
    /**
     * <code>EmCameraErrorType_TiltUpEnd = 3;</code>
     *
     * <pre>
     * 云台到底
     * </pre>
     */
    EmCameraErrorType_TiltUpEnd(3, 3),
    /**
     * <code>EmCameraErrorType_TiltDownEnd = 4;</code>
     *
     * <pre>
     * 云台到底
     * </pre>
     */
    EmCameraErrorType_TiltDownEnd(4, 4),
    /**
     * <code>EmCameraErrorType_PanLeftEnd = 5;</code>
     *
     * <pre>
     * 云台到底
     * </pre>
     */
    EmCameraErrorType_PanLeftEnd(5, 5),
    /**
     * <code>EmCameraErrorType_PanRightEnd = 6;</code>
     *
     * <pre>
     * 云台到底
     * </pre>
     */
    EmCameraErrorType_PanRightEnd(6, 6),
    ;

    /**
     * <code>EmCameraErrorType_unknown = 0;</code>
     */
    public static final int EmCameraErrorType_unknown_VALUE = 0;
    /**
     * <code>EmCameraErrorType_ZoominEnd = 1;</code>
     *
     * <pre>
     * 视野到底
     * </pre>
     */
    public static final int EmCameraErrorType_ZoominEnd_VALUE = 1;
    /**
     * <code>EmCameraErrorType_ZoomoutEnd = 2;</code>
     *
     * <pre>
     * 视野到底
     * </pre>
     */
    public static final int EmCameraErrorType_ZoomoutEnd_VALUE = 2;
    /**
     * <code>EmCameraErrorType_TiltUpEnd = 3;</code>
     *
     * <pre>
     * 云台到底
     * </pre>
     */
    public static final int EmCameraErrorType_TiltUpEnd_VALUE = 3;
    /**
     * <code>EmCameraErrorType_TiltDownEnd = 4;</code>
     *
     * <pre>
     * 云台到底
     * </pre>
     */
    public static final int EmCameraErrorType_TiltDownEnd_VALUE = 4;
    /**
     * <code>EmCameraErrorType_PanLeftEnd = 5;</code>
     *
     * <pre>
     * 云台到底
     * </pre>
     */
    public static final int EmCameraErrorType_PanLeftEnd_VALUE = 5;
    /**
     * <code>EmCameraErrorType_PanRightEnd = 6;</code>
     *
     * <pre>
     * 云台到底
     * </pre>
     */
    public static final int EmCameraErrorType_PanRightEnd_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmCameraErrorType valueOf(int value) {
      switch (value) {
        case 0: return EmCameraErrorType_unknown;
        case 1: return EmCameraErrorType_ZoominEnd;
        case 2: return EmCameraErrorType_ZoomoutEnd;
        case 3: return EmCameraErrorType_TiltUpEnd;
        case 4: return EmCameraErrorType_TiltDownEnd;
        case 5: return EmCameraErrorType_PanLeftEnd;
        case 6: return EmCameraErrorType_PanRightEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCameraErrorType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCameraErrorType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCameraErrorType>() {
            public EmCameraErrorType findValueByNumber(int number) {
              return EmCameraErrorType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(279);
    }

    private static final EmCameraErrorType[] VALUES = values();

    public static EmCameraErrorType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCameraErrorType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCameraErrorType)
  }

  /**
   * Protobuf enum {@code mt.EmCameraSceneMode}
   *
   * <pre>
   * 摄像机场景模式类型
   * </pre>
   */
  public enum EmCameraSceneMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EmCameraSceneMode_Standard = 0;</code>
     *
     * <pre>
     * 标准会场
     * </pre>
     */
    EmCameraSceneMode_Standard(0, 0),
    /**
     * <code>EmCameraSceneMode_Projector = 1;</code>
     *
     * <pre>
     * 投影仪
     * </pre>
     */
    EmCameraSceneMode_Projector(1, 1),
    /**
     * <code>EmCameraSceneMode_Peoplefeature = 2;</code>
     *
     * <pre>
     * 人物特写
     * </pre>
     */
    EmCameraSceneMode_Peoplefeature(2, 2),
    /**
     * <code>EmCameraSceneMode_Peoplebacklight = 3;</code>
     *
     * <pre>
     * 人物逆光
     * </pre>
     */
    EmCameraSceneMode_Peoplebacklight(3, 3),
    ;

    /**
     * <code>EmCameraSceneMode_Standard = 0;</code>
     *
     * <pre>
     * 标准会场
     * </pre>
     */
    public static final int EmCameraSceneMode_Standard_VALUE = 0;
    /**
     * <code>EmCameraSceneMode_Projector = 1;</code>
     *
     * <pre>
     * 投影仪
     * </pre>
     */
    public static final int EmCameraSceneMode_Projector_VALUE = 1;
    /**
     * <code>EmCameraSceneMode_Peoplefeature = 2;</code>
     *
     * <pre>
     * 人物特写
     * </pre>
     */
    public static final int EmCameraSceneMode_Peoplefeature_VALUE = 2;
    /**
     * <code>EmCameraSceneMode_Peoplebacklight = 3;</code>
     *
     * <pre>
     * 人物逆光
     * </pre>
     */
    public static final int EmCameraSceneMode_Peoplebacklight_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmCameraSceneMode valueOf(int value) {
      switch (value) {
        case 0: return EmCameraSceneMode_Standard;
        case 1: return EmCameraSceneMode_Projector;
        case 2: return EmCameraSceneMode_Peoplefeature;
        case 3: return EmCameraSceneMode_Peoplebacklight;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCameraSceneMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCameraSceneMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCameraSceneMode>() {
            public EmCameraSceneMode findValueByNumber(int number) {
              return EmCameraSceneMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(280);
    }

    private static final EmCameraSceneMode[] VALUES = values();

    public static EmCameraSceneMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCameraSceneMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCameraSceneMode)
  }

  /**
   * Protobuf enum {@code mt.EmMtVConfStatus}
   *
   * <pre>
   * 虚拟会议室
   * </pre>
   */
  public enum EmMtVConfStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVConf_Idle = 0;</code>
     *
     * <pre>
     *&#47;&lt; 0-空闲
     * </pre>
     */
    emVConf_Idle(0, 0),
    /**
     * <code>emVConf_Busy = 1;</code>
     *
     * <pre>
     *&#47;&lt; 1-使用中
     * </pre>
     */
    emVConf_Busy(1, 1),
    ;

    /**
     * <code>emVConf_Idle = 0;</code>
     *
     * <pre>
     *&#47;&lt; 0-空闲
     * </pre>
     */
    public static final int emVConf_Idle_VALUE = 0;
    /**
     * <code>emVConf_Busy = 1;</code>
     *
     * <pre>
     *&#47;&lt; 1-使用中
     * </pre>
     */
    public static final int emVConf_Busy_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmMtVConfStatus valueOf(int value) {
      switch (value) {
        case 0: return emVConf_Idle;
        case 1: return emVConf_Busy;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtVConfStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtVConfStatus>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtVConfStatus>() {
            public EmMtVConfStatus findValueByNumber(int number) {
              return EmMtVConfStatus.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(281);
    }

    private static final EmMtVConfStatus[] VALUES = values();

    public static EmMtVConfStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtVConfStatus(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtVConfStatus)
  }

  /**
   * Protobuf enum {@code mt.EmMtMaxJoinMt}
   *
   * <pre>
   * 最大与会终端数 
   * </pre>
   */
  public enum EmMtMaxJoinMt
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMaxJoinMt_8 = 0;</code>
     *
     * <pre>
     *&#47;&lt; 8-小型8方会议
     * </pre>
     */
    emMaxJoinMt_8(0, 0),
    /**
     * <code>emMaxJoinMt_32 = 1;</code>
     *
     * <pre>
     *&#47;&lt; 32-小型32方会议
     * </pre>
     */
    emMaxJoinMt_32(1, 1),
    /**
     * <code>emMaxJoinMt_64 = 2;</code>
     *
     * <pre>
     *&#47;&lt; 864-小型64方会议
     * </pre>
     */
    emMaxJoinMt_64(2, 2),
    /**
     * <code>emMaxJoinMt_192 = 3;</code>
     *
     * <pre>
     *&#47;&lt; 192-大型192方会议
     * </pre>
     */
    emMaxJoinMt_192(3, 3),
    ;

    /**
     * <code>emMaxJoinMt_8 = 0;</code>
     *
     * <pre>
     *&#47;&lt; 8-小型8方会议
     * </pre>
     */
    public static final int emMaxJoinMt_8_VALUE = 0;
    /**
     * <code>emMaxJoinMt_32 = 1;</code>
     *
     * <pre>
     *&#47;&lt; 32-小型32方会议
     * </pre>
     */
    public static final int emMaxJoinMt_32_VALUE = 1;
    /**
     * <code>emMaxJoinMt_64 = 2;</code>
     *
     * <pre>
     *&#47;&lt; 864-小型64方会议
     * </pre>
     */
    public static final int emMaxJoinMt_64_VALUE = 2;
    /**
     * <code>emMaxJoinMt_192 = 3;</code>
     *
     * <pre>
     *&#47;&lt; 192-大型192方会议
     * </pre>
     */
    public static final int emMaxJoinMt_192_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmMtMaxJoinMt valueOf(int value) {
      switch (value) {
        case 0: return emMaxJoinMt_8;
        case 1: return emMaxJoinMt_32;
        case 2: return emMaxJoinMt_64;
        case 3: return emMaxJoinMt_192;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtMaxJoinMt>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtMaxJoinMt>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtMaxJoinMt>() {
            public EmMtMaxJoinMt findValueByNumber(int number) {
              return EmMtMaxJoinMt.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(282);
    }

    private static final EmMtMaxJoinMt[] VALUES = values();

    public static EmMtMaxJoinMt valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtMaxJoinMt(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtMaxJoinMt)
  }

  /**
   * Protobuf enum {@code mt.EmMtVConfResources}
   *
   * <pre>
   * 资源类型
   * </pre>
   */
  public enum EmMtVConfResources
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVConfResource_8_720 = 1;</code>
     *
     * <pre>
     *&#47;&lt; 8方720P；
     * </pre>
     */
    emVConfResource_8_720(0, 1),
    /**
     * <code>emVConfResource_8_1080 = 2;</code>
     *
     * <pre>
     *&#47;&lt; 8方1080P；
     * </pre>
     */
    emVConfResource_8_1080(1, 2),
    /**
     * <code>emVConfResource_32_720 = 3;</code>
     *
     * <pre>
     *&#47;&lt; 32方720P；
     * </pre>
     */
    emVConfResource_32_720(2, 3),
    /**
     * <code>emVConfResource_32_1080 = 4;</code>
     *
     * <pre>
     *&#47;&lt; 32方1080P；
     * </pre>
     */
    emVConfResource_32_1080(3, 4),
    /**
     * <code>emVConfResource_64_720 = 5;</code>
     *
     * <pre>
     *&#47;&lt; 64方720P；
     * </pre>
     */
    emVConfResource_64_720(4, 5),
    /**
     * <code>emVConfResource_64_1080 = 6;</code>
     *
     * <pre>
     *&#47;&lt; 64方1080P；
     * </pre>
     */
    emVConfResource_64_1080(5, 6),
    /**
     * <code>emVConfResource_192_720 = 7;</code>
     *
     * <pre>
     *&#47;&lt; 192方720P；
     * </pre>
     */
    emVConfResource_192_720(6, 7),
    /**
     * <code>emVConfResource_192_1080 = 8;</code>
     *
     * <pre>
     *&#47;&lt; 192方1080P；
     * </pre>
     */
    emVConfResource_192_1080(7, 8),
    ;

    /**
     * <code>emVConfResource_8_720 = 1;</code>
     *
     * <pre>
     *&#47;&lt; 8方720P；
     * </pre>
     */
    public static final int emVConfResource_8_720_VALUE = 1;
    /**
     * <code>emVConfResource_8_1080 = 2;</code>
     *
     * <pre>
     *&#47;&lt; 8方1080P；
     * </pre>
     */
    public static final int emVConfResource_8_1080_VALUE = 2;
    /**
     * <code>emVConfResource_32_720 = 3;</code>
     *
     * <pre>
     *&#47;&lt; 32方720P；
     * </pre>
     */
    public static final int emVConfResource_32_720_VALUE = 3;
    /**
     * <code>emVConfResource_32_1080 = 4;</code>
     *
     * <pre>
     *&#47;&lt; 32方1080P；
     * </pre>
     */
    public static final int emVConfResource_32_1080_VALUE = 4;
    /**
     * <code>emVConfResource_64_720 = 5;</code>
     *
     * <pre>
     *&#47;&lt; 64方720P；
     * </pre>
     */
    public static final int emVConfResource_64_720_VALUE = 5;
    /**
     * <code>emVConfResource_64_1080 = 6;</code>
     *
     * <pre>
     *&#47;&lt; 64方1080P；
     * </pre>
     */
    public static final int emVConfResource_64_1080_VALUE = 6;
    /**
     * <code>emVConfResource_192_720 = 7;</code>
     *
     * <pre>
     *&#47;&lt; 192方720P；
     * </pre>
     */
    public static final int emVConfResource_192_720_VALUE = 7;
    /**
     * <code>emVConfResource_192_1080 = 8;</code>
     *
     * <pre>
     *&#47;&lt; 192方1080P；
     * </pre>
     */
    public static final int emVConfResource_192_1080_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmMtVConfResources valueOf(int value) {
      switch (value) {
        case 1: return emVConfResource_8_720;
        case 2: return emVConfResource_8_1080;
        case 3: return emVConfResource_32_720;
        case 4: return emVConfResource_32_1080;
        case 5: return emVConfResource_64_720;
        case 6: return emVConfResource_64_1080;
        case 7: return emVConfResource_192_720;
        case 8: return emVConfResource_192_1080;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtVConfResources>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtVConfResources>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtVConfResources>() {
            public EmMtVConfResources findValueByNumber(int number) {
              return EmMtVConfResources.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(283);
    }

    private static final EmMtVConfResources[] VALUES = values();

    public static EmMtVConfResources valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtVConfResources(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtVConfResources)
  }

  /**
   * Protobuf enum {@code mt.EmMtFecMode}
   *
   * <pre>
   * FEC模式
   * </pre>
   */
  public enum EmMtFecMode
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMtFec_Close = 0;</code>
     */
    emMtFec_Close(0, 0),
    /**
     * <code>emMtFec_Open = 1;</code>
     */
    emMtFec_Open(1, 1),
    ;

    /**
     * <code>emMtFec_Close = 0;</code>
     */
    public static final int emMtFec_Close_VALUE = 0;
    /**
     * <code>emMtFec_Open = 1;</code>
     */
    public static final int emMtFec_Open_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmMtFecMode valueOf(int value) {
      switch (value) {
        case 0: return emMtFec_Close;
        case 1: return emMtFec_Open;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtFecMode>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtFecMode>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtFecMode>() {
            public EmMtFecMode findValueByNumber(int number) {
              return EmMtFecMode.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(284);
    }

    private static final EmMtFecMode[] VALUES = values();

    public static EmMtFecMode valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtFecMode(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtFecMode)
  }

  /**
   * Protobuf enum {@code mt.EmPlatform}
   */
  public enum EmPlatform
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emOLD_PLATFORM = 0;</code>
     *
     * <pre>
     *老平台
     * </pre>
     */
    emOLD_PLATFORM(0, 0),
    /**
     * <code>emBUSS_PLATFORM = 1;</code>
     *
     * <pre>
     *商密平台
     * </pre>
     */
    emBUSS_PLATFORM(1, 1),
    /**
     * <code>emCOMM_PLATFORM = 2;</code>
     *
     * <pre>
     *非商密的新平台
     * </pre>
     */
    emCOMM_PLATFORM(2, 2),
    ;

    /**
     * <code>emOLD_PLATFORM = 0;</code>
     *
     * <pre>
     *老平台
     * </pre>
     */
    public static final int emOLD_PLATFORM_VALUE = 0;
    /**
     * <code>emBUSS_PLATFORM = 1;</code>
     *
     * <pre>
     *商密平台
     * </pre>
     */
    public static final int emBUSS_PLATFORM_VALUE = 1;
    /**
     * <code>emCOMM_PLATFORM = 2;</code>
     *
     * <pre>
     *非商密的新平台
     * </pre>
     */
    public static final int emCOMM_PLATFORM_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmPlatform valueOf(int value) {
      switch (value) {
        case 0: return emOLD_PLATFORM;
        case 1: return emBUSS_PLATFORM;
        case 2: return emCOMM_PLATFORM;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPlatform>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPlatform>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPlatform>() {
            public EmPlatform findValueByNumber(int number) {
              return EmPlatform.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(285);
    }

    private static final EmPlatform[] VALUES = values();

    public static EmPlatform valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPlatform(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPlatform)
  }

  /**
   * Protobuf enum {@code mt.EmMtChipType}
   *
   * <pre>
   * 硬件芯片列举
   * </pre>
   */
  public enum EmMtChipType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMtChip_Main = 0;</code>
     *
     * <pre>
     * 主控
     * </pre>
     */
    emMtChip_Main(0, 0),
    /**
     * <code>emMtChip_VidEnc1 = 1;</code>
     *
     * <pre>
     * 视频编码1
     * </pre>
     */
    emMtChip_VidEnc1(1, 1),
    /**
     * <code>emMtChip_VidEnc2 = 2;</code>
     *
     * <pre>
     * 视频编码2
     * </pre>
     */
    emMtChip_VidEnc2(2, 2),
    /**
     * <code>emMtChip_VidEnc3 = 3;</code>
     *
     * <pre>
     * 视频编码3
     * </pre>
     */
    emMtChip_VidEnc3(3, 3),
    /**
     * <code>emMtChip_VidEnc4 = 4;</code>
     *
     * <pre>
     * 视频编码4
     * </pre>
     */
    emMtChip_VidEnc4(4, 4),
    /**
     * <code>emMtChip_VidEnc5 = 5;</code>
     *
     * <pre>
     * 视频编码5
     * </pre>
     */
    emMtChip_VidEnc5(5, 5),
    /**
     * <code>emMtChip_VidDec1 = 6;</code>
     *
     * <pre>
     * 视频解码1
     * </pre>
     */
    emMtChip_VidDec1(6, 6),
    /**
     * <code>emMtChip_VidDec2 = 7;</code>
     *
     * <pre>
     * 视频解码2
     * </pre>
     */
    emMtChip_VidDec2(7, 7),
    /**
     * <code>emMtChip_VidDec3 = 8;</code>
     *
     * <pre>
     * 视频解码3
     * </pre>
     */
    emMtChip_VidDec3(8, 8),
    /**
     * <code>emMtChip_VidDec4 = 9;</code>
     *
     * <pre>
     * 视频解码4
     * </pre>
     */
    emMtChip_VidDec4(9, 9),
    /**
     * <code>emMtChip_VidDec5 = 10;</code>
     *
     * <pre>
     * 视频解码5
     * </pre>
     */
    emMtChip_VidDec5(10, 10),
    /**
     * <code>emMtChip_AudEnc1 = 11;</code>
     *
     * <pre>
     * 音频编码1
     * </pre>
     */
    emMtChip_AudEnc1(11, 11),
    /**
     * <code>emMtChip_AudDec1 = 12;</code>
     *
     * <pre>
     * 音频解码1
     * </pre>
     */
    emMtChip_AudDec1(12, 12),
    ;

    /**
     * <code>emMtChip_Main = 0;</code>
     *
     * <pre>
     * 主控
     * </pre>
     */
    public static final int emMtChip_Main_VALUE = 0;
    /**
     * <code>emMtChip_VidEnc1 = 1;</code>
     *
     * <pre>
     * 视频编码1
     * </pre>
     */
    public static final int emMtChip_VidEnc1_VALUE = 1;
    /**
     * <code>emMtChip_VidEnc2 = 2;</code>
     *
     * <pre>
     * 视频编码2
     * </pre>
     */
    public static final int emMtChip_VidEnc2_VALUE = 2;
    /**
     * <code>emMtChip_VidEnc3 = 3;</code>
     *
     * <pre>
     * 视频编码3
     * </pre>
     */
    public static final int emMtChip_VidEnc3_VALUE = 3;
    /**
     * <code>emMtChip_VidEnc4 = 4;</code>
     *
     * <pre>
     * 视频编码4
     * </pre>
     */
    public static final int emMtChip_VidEnc4_VALUE = 4;
    /**
     * <code>emMtChip_VidEnc5 = 5;</code>
     *
     * <pre>
     * 视频编码5
     * </pre>
     */
    public static final int emMtChip_VidEnc5_VALUE = 5;
    /**
     * <code>emMtChip_VidDec1 = 6;</code>
     *
     * <pre>
     * 视频解码1
     * </pre>
     */
    public static final int emMtChip_VidDec1_VALUE = 6;
    /**
     * <code>emMtChip_VidDec2 = 7;</code>
     *
     * <pre>
     * 视频解码2
     * </pre>
     */
    public static final int emMtChip_VidDec2_VALUE = 7;
    /**
     * <code>emMtChip_VidDec3 = 8;</code>
     *
     * <pre>
     * 视频解码3
     * </pre>
     */
    public static final int emMtChip_VidDec3_VALUE = 8;
    /**
     * <code>emMtChip_VidDec4 = 9;</code>
     *
     * <pre>
     * 视频解码4
     * </pre>
     */
    public static final int emMtChip_VidDec4_VALUE = 9;
    /**
     * <code>emMtChip_VidDec5 = 10;</code>
     *
     * <pre>
     * 视频解码5
     * </pre>
     */
    public static final int emMtChip_VidDec5_VALUE = 10;
    /**
     * <code>emMtChip_AudEnc1 = 11;</code>
     *
     * <pre>
     * 音频编码1
     * </pre>
     */
    public static final int emMtChip_AudEnc1_VALUE = 11;
    /**
     * <code>emMtChip_AudDec1 = 12;</code>
     *
     * <pre>
     * 音频解码1
     * </pre>
     */
    public static final int emMtChip_AudDec1_VALUE = 12;


    public final int getNumber() { return value; }

    public static EmMtChipType valueOf(int value) {
      switch (value) {
        case 0: return emMtChip_Main;
        case 1: return emMtChip_VidEnc1;
        case 2: return emMtChip_VidEnc2;
        case 3: return emMtChip_VidEnc3;
        case 4: return emMtChip_VidEnc4;
        case 5: return emMtChip_VidEnc5;
        case 6: return emMtChip_VidDec1;
        case 7: return emMtChip_VidDec2;
        case 8: return emMtChip_VidDec3;
        case 9: return emMtChip_VidDec4;
        case 10: return emMtChip_VidDec5;
        case 11: return emMtChip_AudEnc1;
        case 12: return emMtChip_AudDec1;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtChipType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtChipType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtChipType>() {
            public EmMtChipType findValueByNumber(int number) {
              return EmMtChipType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(286);
    }

    private static final EmMtChipType[] VALUES = values();

    public static EmMtChipType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtChipType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtChipType)
  }

  /**
   * Protobuf enum {@code mt.EmClientAppType}
   */
  public enum EmClientAppType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emClientAppOsd = 0;</code>
     */
    emClientAppOsd(0, 0),
    /**
     * <code>emClientAppWebService = 1;</code>
     */
    emClientAppWebService(1, 1),
    /**
     * <code>emClientAppSkyShare = 2;</code>
     */
    emClientAppSkyShare(2, 2),
    /**
     * <code>emClientAppSkyRemote = 3;</code>
     */
    emClientAppSkyRemote(3, 3),
    /**
     * <code>emClientAppSkyMTC = 4;</code>
     */
    emClientAppSkyMTC(4, 4),
    /**
     * <code>emClientAppSkyWindows = 5;</code>
     */
    emClientAppSkyWindows(5, 5),
    /**
     * <code>emClientAppSkyAndroid = 6;</code>
     */
    emClientAppSkyAndroid(6, 6),
    /**
     * <code>emClientAppSkyIOS = 7;</code>
     */
    emClientAppSkyIOS(7, 7),
    /**
     * <code>emClientAppThirdParty = 8;</code>
     */
    emClientAppThirdParty(8, 8),
    /**
     * <code>emClientAppNexVison = 9;</code>
     */
    emClientAppNexVison(9, 9),
    /**
     * <code>emClientAppMTCEnd = 10;</code>
     */
    emClientAppMTCEnd(10, 10),
    ;

    /**
     * <code>emClientAppOsd = 0;</code>
     */
    public static final int emClientAppOsd_VALUE = 0;
    /**
     * <code>emClientAppWebService = 1;</code>
     */
    public static final int emClientAppWebService_VALUE = 1;
    /**
     * <code>emClientAppSkyShare = 2;</code>
     */
    public static final int emClientAppSkyShare_VALUE = 2;
    /**
     * <code>emClientAppSkyRemote = 3;</code>
     */
    public static final int emClientAppSkyRemote_VALUE = 3;
    /**
     * <code>emClientAppSkyMTC = 4;</code>
     */
    public static final int emClientAppSkyMTC_VALUE = 4;
    /**
     * <code>emClientAppSkyWindows = 5;</code>
     */
    public static final int emClientAppSkyWindows_VALUE = 5;
    /**
     * <code>emClientAppSkyAndroid = 6;</code>
     */
    public static final int emClientAppSkyAndroid_VALUE = 6;
    /**
     * <code>emClientAppSkyIOS = 7;</code>
     */
    public static final int emClientAppSkyIOS_VALUE = 7;
    /**
     * <code>emClientAppThirdParty = 8;</code>
     */
    public static final int emClientAppThirdParty_VALUE = 8;
    /**
     * <code>emClientAppNexVison = 9;</code>
     */
    public static final int emClientAppNexVison_VALUE = 9;
    /**
     * <code>emClientAppMTCEnd = 10;</code>
     */
    public static final int emClientAppMTCEnd_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmClientAppType valueOf(int value) {
      switch (value) {
        case 0: return emClientAppOsd;
        case 1: return emClientAppWebService;
        case 2: return emClientAppSkyShare;
        case 3: return emClientAppSkyRemote;
        case 4: return emClientAppSkyMTC;
        case 5: return emClientAppSkyWindows;
        case 6: return emClientAppSkyAndroid;
        case 7: return emClientAppSkyIOS;
        case 8: return emClientAppThirdParty;
        case 9: return emClientAppNexVison;
        case 10: return emClientAppMTCEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmClientAppType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmClientAppType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmClientAppType>() {
            public EmClientAppType findValueByNumber(int number) {
              return EmClientAppType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(287);
    }

    private static final EmClientAppType[] VALUES = values();

    public static EmClientAppType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmClientAppType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmClientAppType)
  }

  /**
   * Protobuf enum {@code mt.EmAuthType}
   */
  public enum EmAuthType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUserNamePwdAuth = 0;</code>
     */
    emUserNamePwdAuth(0, 0),
    /**
     * <code>emInnerPwdAuth = 1;</code>
     */
    emInnerPwdAuth(1, 1),
    /**
     * <code>emDynamicAuth = 2;</code>
     */
    emDynamicAuth(2, 2),
    /**
     * <code>emAuthEnd = 3;</code>
     */
    emAuthEnd(3, 3),
    ;

    /**
     * <code>emUserNamePwdAuth = 0;</code>
     */
    public static final int emUserNamePwdAuth_VALUE = 0;
    /**
     * <code>emInnerPwdAuth = 1;</code>
     */
    public static final int emInnerPwdAuth_VALUE = 1;
    /**
     * <code>emDynamicAuth = 2;</code>
     */
    public static final int emDynamicAuth_VALUE = 2;
    /**
     * <code>emAuthEnd = 3;</code>
     */
    public static final int emAuthEnd_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmAuthType valueOf(int value) {
      switch (value) {
        case 0: return emUserNamePwdAuth;
        case 1: return emInnerPwdAuth;
        case 2: return emDynamicAuth;
        case 3: return emAuthEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAuthType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAuthType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAuthType>() {
            public EmAuthType findValueByNumber(int number) {
              return EmAuthType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(288);
    }

    private static final EmAuthType[] VALUES = values();

    public static EmAuthType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAuthType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAuthType)
  }

  /**
   * Protobuf enum {@code mt.EmLoginFailReason}
   */
  public enum EmLoginFailReason
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPwdErr = 1;</code>
     *
     * <pre>
     *密码错误
     * </pre>
     */
    emPwdErr(0, 1),
    /**
     * <code>emTerStarting = 2;</code>
     *
     * <pre>
     *启动中
     * </pre>
     */
    emTerStarting(1, 2),
    /**
     * <code>emTerUpgrading = 3;</code>
     *
     * <pre>
     *升级中
     * </pre>
     */
    emTerUpgrading(2, 3),
    /**
     * <code>emFailReasonEnd = 10;</code>
     */
    emFailReasonEnd(3, 10),
    ;

    /**
     * <code>emPwdErr = 1;</code>
     *
     * <pre>
     *密码错误
     * </pre>
     */
    public static final int emPwdErr_VALUE = 1;
    /**
     * <code>emTerStarting = 2;</code>
     *
     * <pre>
     *启动中
     * </pre>
     */
    public static final int emTerStarting_VALUE = 2;
    /**
     * <code>emTerUpgrading = 3;</code>
     *
     * <pre>
     *升级中
     * </pre>
     */
    public static final int emTerUpgrading_VALUE = 3;
    /**
     * <code>emFailReasonEnd = 10;</code>
     */
    public static final int emFailReasonEnd_VALUE = 10;


    public final int getNumber() { return value; }

    public static EmLoginFailReason valueOf(int value) {
      switch (value) {
        case 1: return emPwdErr;
        case 2: return emTerStarting;
        case 3: return emTerUpgrading;
        case 10: return emFailReasonEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmLoginFailReason>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmLoginFailReason>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmLoginFailReason>() {
            public EmLoginFailReason findValueByNumber(int number) {
              return EmLoginFailReason.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(289);
    }

    private static final EmLoginFailReason[] VALUES = values();

    public static EmLoginFailReason valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmLoginFailReason(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmLoginFailReason)
  }

  /**
   * Protobuf enum {@code mt.EmVConfCreateType}
   */
  public enum EmVConfCreateType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCreateNormalConf = 0;</code>
     */
    emCreateNormalConf(0, 0),
    /**
     * <code>emCreateVirtualConf = 1;</code>
     */
    emCreateVirtualConf(1, 1),
    /**
     * <code>emCreateConfByTemplate = 2;</code>
     *
     * <pre>
     *&#47;&lt; 根据模板ID创会
     * </pre>
     */
    emCreateConfByTemplate(2, 2),
    ;

    /**
     * <code>emCreateNormalConf = 0;</code>
     */
    public static final int emCreateNormalConf_VALUE = 0;
    /**
     * <code>emCreateVirtualConf = 1;</code>
     */
    public static final int emCreateVirtualConf_VALUE = 1;
    /**
     * <code>emCreateConfByTemplate = 2;</code>
     *
     * <pre>
     *&#47;&lt; 根据模板ID创会
     * </pre>
     */
    public static final int emCreateConfByTemplate_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmVConfCreateType valueOf(int value) {
      switch (value) {
        case 0: return emCreateNormalConf;
        case 1: return emCreateVirtualConf;
        case 2: return emCreateConfByTemplate;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmVConfCreateType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmVConfCreateType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmVConfCreateType>() {
            public EmVConfCreateType findValueByNumber(int number) {
              return EmVConfCreateType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(290);
    }

    private static final EmVConfCreateType[] VALUES = values();

    public static EmVConfCreateType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmVConfCreateType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmVConfCreateType)
  }

  /**
   * Protobuf enum {@code mt.EmQkState}
   */
  public enum EmQkState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUsbOff = 0;</code>
     *
     * <pre>
     *Usb断开
     * </pre>
     */
    emUsbOff(0, 0),
    /**
     * <code>emUsbOn = 1;</code>
     *
     * <pre>
     *Usb连入
     * </pre>
     */
    emUsbOn(1, 1),
    /**
     * <code>emUpdating = 2;</code>
     *
     * <pre>
     *在升级中
     * </pre>
     */
    emUpdating(2, 2),
    /**
     * <code>emWps = 3;</code>
     *
     * <pre>
     *Wps配对
     * </pre>
     */
    emWps(3, 3),
    /**
     * <code>emWpsSucc = 4;</code>
     *
     * <pre>
     *Wps成功
     * </pre>
     */
    emWpsSucc(4, 4),
    /**
     * <code>emApLink = 5;</code>
     *
     * <pre>
     *Ap连入
     * </pre>
     */
    emApLink(5, 5),
    /**
     * <code>emApOff = 6;</code>
     *
     * <pre>
     *Ap断开
     * </pre>
     */
    emApOff(6, 6),
    /**
     * <code>emQkStart = 7;</code>
     *
     * <pre>
     *开始投屏
     * </pre>
     */
    emQkStart(7, 7),
    /**
     * <code>emQkOff = 8;</code>
     *
     * <pre>
     *停止投屏
     * </pre>
     */
    emQkOff(8, 8),
    /**
     * <code>emWpsTimeOut = 9;</code>
     *
     * <pre>
     *超时
     * </pre>
     */
    emWpsTimeOut(9, 9),
    ;

    /**
     * <code>emUsbOff = 0;</code>
     *
     * <pre>
     *Usb断开
     * </pre>
     */
    public static final int emUsbOff_VALUE = 0;
    /**
     * <code>emUsbOn = 1;</code>
     *
     * <pre>
     *Usb连入
     * </pre>
     */
    public static final int emUsbOn_VALUE = 1;
    /**
     * <code>emUpdating = 2;</code>
     *
     * <pre>
     *在升级中
     * </pre>
     */
    public static final int emUpdating_VALUE = 2;
    /**
     * <code>emWps = 3;</code>
     *
     * <pre>
     *Wps配对
     * </pre>
     */
    public static final int emWps_VALUE = 3;
    /**
     * <code>emWpsSucc = 4;</code>
     *
     * <pre>
     *Wps成功
     * </pre>
     */
    public static final int emWpsSucc_VALUE = 4;
    /**
     * <code>emApLink = 5;</code>
     *
     * <pre>
     *Ap连入
     * </pre>
     */
    public static final int emApLink_VALUE = 5;
    /**
     * <code>emApOff = 6;</code>
     *
     * <pre>
     *Ap断开
     * </pre>
     */
    public static final int emApOff_VALUE = 6;
    /**
     * <code>emQkStart = 7;</code>
     *
     * <pre>
     *开始投屏
     * </pre>
     */
    public static final int emQkStart_VALUE = 7;
    /**
     * <code>emQkOff = 8;</code>
     *
     * <pre>
     *停止投屏
     * </pre>
     */
    public static final int emQkOff_VALUE = 8;
    /**
     * <code>emWpsTimeOut = 9;</code>
     *
     * <pre>
     *超时
     * </pre>
     */
    public static final int emWpsTimeOut_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmQkState valueOf(int value) {
      switch (value) {
        case 0: return emUsbOff;
        case 1: return emUsbOn;
        case 2: return emUpdating;
        case 3: return emWps;
        case 4: return emWpsSucc;
        case 5: return emApLink;
        case 6: return emApOff;
        case 7: return emQkStart;
        case 8: return emQkOff;
        case 9: return emWpsTimeOut;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmQkState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmQkState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmQkState>() {
            public EmQkState findValueByNumber(int number) {
              return EmQkState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(291);
    }

    private static final EmQkState[] VALUES = values();

    public static EmQkState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmQkState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmQkState)
  }

  /**
   * Protobuf enum {@code mt.EmResourceType}
   */
  public enum EmResourceType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emResourceType_LimitP = 0;</code>
     *
     * <pre>
     *&#47;&lt; 仅限制方数
     * </pre>
     */
    emResourceType_LimitP(0, 0),
    /**
     * <code>emResourceType_LimitPR = 1;</code>
     *
     * <pre>
     *&#47;&lt; 同时限制方数及分辨率
     * </pre>
     */
    emResourceType_LimitPR(1, 1),
    /**
     * <code>emResourceType_None = 2;</code>
     *
     * <pre>
     *&#47;&lt; 平台不支持此功能
     * </pre>
     */
    emResourceType_None(2, 2),
    ;

    /**
     * <code>emResourceType_LimitP = 0;</code>
     *
     * <pre>
     *&#47;&lt; 仅限制方数
     * </pre>
     */
    public static final int emResourceType_LimitP_VALUE = 0;
    /**
     * <code>emResourceType_LimitPR = 1;</code>
     *
     * <pre>
     *&#47;&lt; 同时限制方数及分辨率
     * </pre>
     */
    public static final int emResourceType_LimitPR_VALUE = 1;
    /**
     * <code>emResourceType_None = 2;</code>
     *
     * <pre>
     *&#47;&lt; 平台不支持此功能
     * </pre>
     */
    public static final int emResourceType_None_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmResourceType valueOf(int value) {
      switch (value) {
        case 0: return emResourceType_LimitP;
        case 1: return emResourceType_LimitPR;
        case 2: return emResourceType_None;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmResourceType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmResourceType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmResourceType>() {
            public EmResourceType findValueByNumber(int number) {
              return EmResourceType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(292);
    }

    private static final EmResourceType[] VALUES = values();

    public static EmResourceType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmResourceType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmResourceType)
  }

  /**
   * Protobuf enum {@code mt.EmAgentPackFileState}
   *
   * <pre>
   ** 网管文件打包错误信息
   * </pre>
   */
  public enum EmAgentPackFileState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPackNotStart = 0;</code>
     *
     * <pre>
     *&#47;&lt; 未开始打包
     * </pre>
     */
    emPackNotStart(0, 0),
    /**
     * <code>emPacking = 1;</code>
     *
     * <pre>
     *&#47;&lt; 终端正在打包
     * </pre>
     */
    emPacking(1, 1),
    /**
     * <code>emPackError = 2;</code>
     *
     * <pre>
     *&#47;&lt; 打包失败
     * </pre>
     */
    emPackError(2, 2),
    ;

    /**
     * <code>emPackNotStart = 0;</code>
     *
     * <pre>
     *&#47;&lt; 未开始打包
     * </pre>
     */
    public static final int emPackNotStart_VALUE = 0;
    /**
     * <code>emPacking = 1;</code>
     *
     * <pre>
     *&#47;&lt; 终端正在打包
     * </pre>
     */
    public static final int emPacking_VALUE = 1;
    /**
     * <code>emPackError = 2;</code>
     *
     * <pre>
     *&#47;&lt; 打包失败
     * </pre>
     */
    public static final int emPackError_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmAgentPackFileState valueOf(int value) {
      switch (value) {
        case 0: return emPackNotStart;
        case 1: return emPacking;
        case 2: return emPackError;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAgentPackFileState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAgentPackFileState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAgentPackFileState>() {
            public EmAgentPackFileState findValueByNumber(int number) {
              return EmAgentPackFileState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(293);
    }

    private static final EmAgentPackFileState[] VALUES = values();

    public static EmAgentPackFileState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAgentPackFileState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAgentPackFileState)
  }

  /**
   * Protobuf enum {@code mt.EmMtUpgradeState}
   *
   * <pre>
   *&#47;升级状态
   * </pre>
   */
  public enum EmMtUpgradeState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMtUpgradeState_Invalid = 0;</code>
     *
     * <pre>
     *&#47;无效值
     * </pre>
     */
    emMtUpgradeState_Invalid(0, 0),
    /**
     * <code>emMtUpgradeState_WaitingTar = 1;</code>
     *
     * <pre>
     *&#47;等待解压
     * </pre>
     */
    emMtUpgradeState_WaitingTar(1, 1),
    /**
     * <code>emMtUpgradeState_Taring = 2;</code>
     *
     * <pre>
     *&#47;解压中
     * </pre>
     */
    emMtUpgradeState_Taring(2, 2),
    /**
     * <code>emMtUpgradeState_WaitingUpgrade = 3;</code>
     *
     * <pre>
     *&#47;等待升级
     * </pre>
     */
    emMtUpgradeState_WaitingUpgrade(3, 3),
    /**
     * <code>emMtUpgradeState_Upgrading = 4;</code>
     *
     * <pre>
     *&#47;升级中
     * </pre>
     */
    emMtUpgradeState_Upgrading(4, 4),
    /**
     * <code>emMtUpgradeState_FileCheckSuccess = 5;</code>
     *
     * <pre>
     *&#47;文件检查成功
     * </pre>
     */
    emMtUpgradeState_FileCheckSuccess(5, 5),
    /**
     * <code>emMtUpgradeState_FileCheckFail = 6;</code>
     *
     * <pre>
     *&#47;文件检查失败
     * </pre>
     */
    emMtUpgradeState_FileCheckFail(6, 6),
    /**
     * <code>emMtUpgradeState_UpgradeSuccess = 7;</code>
     *
     * <pre>
     *&#47;升级成功
     * </pre>
     */
    emMtUpgradeState_UpgradeSuccess(7, 7),
    /**
     * <code>emMtUpgradeState_UpgradeFail = 8;</code>
     *
     * <pre>
     *&#47;升级失败
     * </pre>
     */
    emMtUpgradeState_UpgradeFail(8, 8),
    ;

    /**
     * <code>emMtUpgradeState_Invalid = 0;</code>
     *
     * <pre>
     *&#47;无效值
     * </pre>
     */
    public static final int emMtUpgradeState_Invalid_VALUE = 0;
    /**
     * <code>emMtUpgradeState_WaitingTar = 1;</code>
     *
     * <pre>
     *&#47;等待解压
     * </pre>
     */
    public static final int emMtUpgradeState_WaitingTar_VALUE = 1;
    /**
     * <code>emMtUpgradeState_Taring = 2;</code>
     *
     * <pre>
     *&#47;解压中
     * </pre>
     */
    public static final int emMtUpgradeState_Taring_VALUE = 2;
    /**
     * <code>emMtUpgradeState_WaitingUpgrade = 3;</code>
     *
     * <pre>
     *&#47;等待升级
     * </pre>
     */
    public static final int emMtUpgradeState_WaitingUpgrade_VALUE = 3;
    /**
     * <code>emMtUpgradeState_Upgrading = 4;</code>
     *
     * <pre>
     *&#47;升级中
     * </pre>
     */
    public static final int emMtUpgradeState_Upgrading_VALUE = 4;
    /**
     * <code>emMtUpgradeState_FileCheckSuccess = 5;</code>
     *
     * <pre>
     *&#47;文件检查成功
     * </pre>
     */
    public static final int emMtUpgradeState_FileCheckSuccess_VALUE = 5;
    /**
     * <code>emMtUpgradeState_FileCheckFail = 6;</code>
     *
     * <pre>
     *&#47;文件检查失败
     * </pre>
     */
    public static final int emMtUpgradeState_FileCheckFail_VALUE = 6;
    /**
     * <code>emMtUpgradeState_UpgradeSuccess = 7;</code>
     *
     * <pre>
     *&#47;升级成功
     * </pre>
     */
    public static final int emMtUpgradeState_UpgradeSuccess_VALUE = 7;
    /**
     * <code>emMtUpgradeState_UpgradeFail = 8;</code>
     *
     * <pre>
     *&#47;升级失败
     * </pre>
     */
    public static final int emMtUpgradeState_UpgradeFail_VALUE = 8;


    public final int getNumber() { return value; }

    public static EmMtUpgradeState valueOf(int value) {
      switch (value) {
        case 0: return emMtUpgradeState_Invalid;
        case 1: return emMtUpgradeState_WaitingTar;
        case 2: return emMtUpgradeState_Taring;
        case 3: return emMtUpgradeState_WaitingUpgrade;
        case 4: return emMtUpgradeState_Upgrading;
        case 5: return emMtUpgradeState_FileCheckSuccess;
        case 6: return emMtUpgradeState_FileCheckFail;
        case 7: return emMtUpgradeState_UpgradeSuccess;
        case 8: return emMtUpgradeState_UpgradeFail;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMtUpgradeState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMtUpgradeState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMtUpgradeState>() {
            public EmMtUpgradeState findValueByNumber(int number) {
              return EmMtUpgradeState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(294);
    }

    private static final EmMtUpgradeState[] VALUES = values();

    public static EmMtUpgradeState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMtUpgradeState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMtUpgradeState)
  }

  /**
   * Protobuf enum {@code mt.EmCodecBoardType}
   *
   * <pre>
   *os
   * /开发板类型，和enBoardType对应
   * </pre>
   */
  public enum EmCodecBoardType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>em_H600_Board = 1;</code>
     */
    em_H600_Board(0, 1),
    /**
     * <code>em_H700_Board = 2;</code>
     */
    em_H700_Board(1, 2),
    /**
     * <code>em_H900_Board = 3;</code>
     */
    em_H900_Board(2, 3),
    /**
     * <code>em_HDU2_Board = 4;</code>
     */
    em_HDU2_Board(3, 4),
    /**
     * <code>em_MPU2_Board = 5;</code>
     */
    em_MPU2_Board(4, 5),
    /**
     * <code>em_APU2_Board = 6;</code>
     */
    em_APU2_Board(5, 6),
    /**
     * <code>em_HDU2_Board_S = 7;</code>
     */
    em_HDU2_Board_S(6, 7),
    /**
     * <code>em_X500_Board = 8;</code>
     */
    em_X500_Board(7, 8),
    /**
     * <code>em_T300_Board = 9;</code>
     */
    em_T300_Board(8, 9),
    /**
     * <code>em_MIC3D_WIRE_Board = 10;</code>
     */
    em_MIC3D_WIRE_Board(9, 10),
    /**
     * <code>em_MIC3D_WIRELESS_Board = 11;</code>
     */
    em_MIC3D_WIRELESS_Board(10, 11),
    /**
     * <code>em_TrueVoc3D_WIRE_Board = 12;</code>
     */
    em_TrueVoc3D_WIRE_Board(11, 12),
    /**
     * <code>em_X700_Board = 13;</code>
     */
    em_X700_Board(12, 13),
    /**
     * <code>em_X300_Board = 14;</code>
     */
    em_X300_Board(13, 14),
    /**
     * <code>em_SKY300_Board = 15;</code>
     */
    em_SKY300_Board(14, 15),
    /**
     * <code>em_SKY100_Board = 16;</code>
     */
    em_SKY100_Board(15, 16),
    /**
     * <code>em_SKY300_Board_650 = 17;</code>
     */
    em_SKY300_Board_650(16, 17),
    /**
     * <code>em_SKYD510_Board = 18;</code>
     */
    em_SKYD510_Board(17, 18),
    /**
     * <code>em_X510_Board = 19;</code>
     */
    em_X510_Board(18, 19),
    /**
     * <code>em_X310_Board = 20;</code>
     */
    em_X310_Board(19, 20),
    /**
     * <code>em_Sky310_Board = 21;</code>
     */
    em_Sky310_Board(20, 21),
    /**
     * <code>em_Invalid_Board = 32;</code>
     */
    em_Invalid_Board(21, 32),
    ;

    /**
     * <code>em_H600_Board = 1;</code>
     */
    public static final int em_H600_Board_VALUE = 1;
    /**
     * <code>em_H700_Board = 2;</code>
     */
    public static final int em_H700_Board_VALUE = 2;
    /**
     * <code>em_H900_Board = 3;</code>
     */
    public static final int em_H900_Board_VALUE = 3;
    /**
     * <code>em_HDU2_Board = 4;</code>
     */
    public static final int em_HDU2_Board_VALUE = 4;
    /**
     * <code>em_MPU2_Board = 5;</code>
     */
    public static final int em_MPU2_Board_VALUE = 5;
    /**
     * <code>em_APU2_Board = 6;</code>
     */
    public static final int em_APU2_Board_VALUE = 6;
    /**
     * <code>em_HDU2_Board_S = 7;</code>
     */
    public static final int em_HDU2_Board_S_VALUE = 7;
    /**
     * <code>em_X500_Board = 8;</code>
     */
    public static final int em_X500_Board_VALUE = 8;
    /**
     * <code>em_T300_Board = 9;</code>
     */
    public static final int em_T300_Board_VALUE = 9;
    /**
     * <code>em_MIC3D_WIRE_Board = 10;</code>
     */
    public static final int em_MIC3D_WIRE_Board_VALUE = 10;
    /**
     * <code>em_MIC3D_WIRELESS_Board = 11;</code>
     */
    public static final int em_MIC3D_WIRELESS_Board_VALUE = 11;
    /**
     * <code>em_TrueVoc3D_WIRE_Board = 12;</code>
     */
    public static final int em_TrueVoc3D_WIRE_Board_VALUE = 12;
    /**
     * <code>em_X700_Board = 13;</code>
     */
    public static final int em_X700_Board_VALUE = 13;
    /**
     * <code>em_X300_Board = 14;</code>
     */
    public static final int em_X300_Board_VALUE = 14;
    /**
     * <code>em_SKY300_Board = 15;</code>
     */
    public static final int em_SKY300_Board_VALUE = 15;
    /**
     * <code>em_SKY100_Board = 16;</code>
     */
    public static final int em_SKY100_Board_VALUE = 16;
    /**
     * <code>em_SKY300_Board_650 = 17;</code>
     */
    public static final int em_SKY300_Board_650_VALUE = 17;
    /**
     * <code>em_SKYD510_Board = 18;</code>
     */
    public static final int em_SKYD510_Board_VALUE = 18;
    /**
     * <code>em_X510_Board = 19;</code>
     */
    public static final int em_X510_Board_VALUE = 19;
    /**
     * <code>em_X310_Board = 20;</code>
     */
    public static final int em_X310_Board_VALUE = 20;
    /**
     * <code>em_Sky310_Board = 21;</code>
     */
    public static final int em_Sky310_Board_VALUE = 21;
    /**
     * <code>em_Invalid_Board = 32;</code>
     */
    public static final int em_Invalid_Board_VALUE = 32;


    public final int getNumber() { return value; }

    public static EmCodecBoardType valueOf(int value) {
      switch (value) {
        case 1: return em_H600_Board;
        case 2: return em_H700_Board;
        case 3: return em_H900_Board;
        case 4: return em_HDU2_Board;
        case 5: return em_MPU2_Board;
        case 6: return em_APU2_Board;
        case 7: return em_HDU2_Board_S;
        case 8: return em_X500_Board;
        case 9: return em_T300_Board;
        case 10: return em_MIC3D_WIRE_Board;
        case 11: return em_MIC3D_WIRELESS_Board;
        case 12: return em_TrueVoc3D_WIRE_Board;
        case 13: return em_X700_Board;
        case 14: return em_X300_Board;
        case 15: return em_SKY300_Board;
        case 16: return em_SKY100_Board;
        case 17: return em_SKY300_Board_650;
        case 18: return em_SKYD510_Board;
        case 19: return em_X510_Board;
        case 20: return em_X310_Board;
        case 21: return em_Sky310_Board;
        case 32: return em_Invalid_Board;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCodecBoardType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCodecBoardType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCodecBoardType>() {
            public EmCodecBoardType findValueByNumber(int number) {
              return EmCodecBoardType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(295);
    }

    private static final EmCodecBoardType[] VALUES = values();

    public static EmCodecBoardType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCodecBoardType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCodecBoardType)
  }

  /**
   * Protobuf enum {@code mt.EmFtSerialBandrate}
   *
   * <pre>
   *&#47;串口波特率
   * </pre>
   */
  public enum EmFtSerialBandrate
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSerialBandrate_300 = 0;</code>
     */
    emSerialBandrate_300(0, 0),
    /**
     * <code>emSerialBandrate_1200 = 1;</code>
     */
    emSerialBandrate_1200(1, 1),
    /**
     * <code>emSerialBandrate_2400 = 2;</code>
     */
    emSerialBandrate_2400(2, 2),
    /**
     * <code>emSerialBandrate_4800 = 3;</code>
     */
    emSerialBandrate_4800(3, 3),
    /**
     * <code>emSerialBandrate_9600 = 4;</code>
     */
    emSerialBandrate_9600(4, 4),
    /**
     * <code>emSerialBandrate_19200 = 5;</code>
     */
    emSerialBandrate_19200(5, 5),
    /**
     * <code>emSerialBandrate_38400 = 6;</code>
     */
    emSerialBandrate_38400(6, 6),
    /**
     * <code>emSerialBandrate_57600 = 7;</code>
     */
    emSerialBandrate_57600(7, 7),
    /**
     * <code>emSerialBandrate_115200 = 8;</code>
     */
    emSerialBandrate_115200(8, 8),
    /**
     * <code>emSerialBandrate_230400 = 9;</code>
     */
    emSerialBandrate_230400(9, 9),
    ;

    /**
     * <code>emSerialBandrate_300 = 0;</code>
     */
    public static final int emSerialBandrate_300_VALUE = 0;
    /**
     * <code>emSerialBandrate_1200 = 1;</code>
     */
    public static final int emSerialBandrate_1200_VALUE = 1;
    /**
     * <code>emSerialBandrate_2400 = 2;</code>
     */
    public static final int emSerialBandrate_2400_VALUE = 2;
    /**
     * <code>emSerialBandrate_4800 = 3;</code>
     */
    public static final int emSerialBandrate_4800_VALUE = 3;
    /**
     * <code>emSerialBandrate_9600 = 4;</code>
     */
    public static final int emSerialBandrate_9600_VALUE = 4;
    /**
     * <code>emSerialBandrate_19200 = 5;</code>
     */
    public static final int emSerialBandrate_19200_VALUE = 5;
    /**
     * <code>emSerialBandrate_38400 = 6;</code>
     */
    public static final int emSerialBandrate_38400_VALUE = 6;
    /**
     * <code>emSerialBandrate_57600 = 7;</code>
     */
    public static final int emSerialBandrate_57600_VALUE = 7;
    /**
     * <code>emSerialBandrate_115200 = 8;</code>
     */
    public static final int emSerialBandrate_115200_VALUE = 8;
    /**
     * <code>emSerialBandrate_230400 = 9;</code>
     */
    public static final int emSerialBandrate_230400_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmFtSerialBandrate valueOf(int value) {
      switch (value) {
        case 0: return emSerialBandrate_300;
        case 1: return emSerialBandrate_1200;
        case 2: return emSerialBandrate_2400;
        case 3: return emSerialBandrate_4800;
        case 4: return emSerialBandrate_9600;
        case 5: return emSerialBandrate_19200;
        case 6: return emSerialBandrate_38400;
        case 7: return emSerialBandrate_57600;
        case 8: return emSerialBandrate_115200;
        case 9: return emSerialBandrate_230400;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtSerialBandrate>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtSerialBandrate>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtSerialBandrate>() {
            public EmFtSerialBandrate findValueByNumber(int number) {
              return EmFtSerialBandrate.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(296);
    }

    private static final EmFtSerialBandrate[] VALUES = values();

    public static EmFtSerialBandrate valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtSerialBandrate(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtSerialBandrate)
  }

  /**
   * Protobuf enum {@code mt.EmFtSerialFunction}
   *
   * <pre>
   *&#47;串口功能
   * </pre>
   */
  public enum EmFtSerialFunction
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSerialConsole = 0;</code>
     *
     * <pre>
     *&#47;打印
     * </pre>
     */
    emSerialConsole(0, 0),
    /**
     * <code>emInfraredCtrl = 1;</code>
     *
     * <pre>
     *&#47;红外
     * </pre>
     */
    emInfraredCtrl(1, 1),
    /**
     * <code>emSerialVisca = 2;</code>
     *
     * <pre>
     *&#47;Visca控制
     * </pre>
     */
    emSerialVisca(2, 2),
    /**
     * <code>emRemoteCtrl = 3;</code>
     *
     * <pre>
     *&#47;反控
     * </pre>
     */
    emRemoteCtrl(3, 3),
    /**
     * <code>emSerialDigMic = 4;</code>
     *
     * <pre>
     *&#47;数字麦
     * </pre>
     */
    emSerialDigMic(4, 4),
    ;

    /**
     * <code>emSerialConsole = 0;</code>
     *
     * <pre>
     *&#47;打印
     * </pre>
     */
    public static final int emSerialConsole_VALUE = 0;
    /**
     * <code>emInfraredCtrl = 1;</code>
     *
     * <pre>
     *&#47;红外
     * </pre>
     */
    public static final int emInfraredCtrl_VALUE = 1;
    /**
     * <code>emSerialVisca = 2;</code>
     *
     * <pre>
     *&#47;Visca控制
     * </pre>
     */
    public static final int emSerialVisca_VALUE = 2;
    /**
     * <code>emRemoteCtrl = 3;</code>
     *
     * <pre>
     *&#47;反控
     * </pre>
     */
    public static final int emRemoteCtrl_VALUE = 3;
    /**
     * <code>emSerialDigMic = 4;</code>
     *
     * <pre>
     *&#47;数字麦
     * </pre>
     */
    public static final int emSerialDigMic_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmFtSerialFunction valueOf(int value) {
      switch (value) {
        case 0: return emSerialConsole;
        case 1: return emInfraredCtrl;
        case 2: return emSerialVisca;
        case 3: return emRemoteCtrl;
        case 4: return emSerialDigMic;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtSerialFunction>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtSerialFunction>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtSerialFunction>() {
            public EmFtSerialFunction findValueByNumber(int number) {
              return EmFtSerialFunction.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(297);
    }

    private static final EmFtSerialFunction[] VALUES = values();

    public static EmFtSerialFunction valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtSerialFunction(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtSerialFunction)
  }

  /**
   * Protobuf enum {@code mt.EmFtNetType}
   *
   * <pre>
   *&#47;网口类型
   * </pre>
   */
  public enum EmFtNetType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emEth10M = 0;</code>
     *
     * <pre>
     *&#47;以太网10M
     * </pre>
     */
    emEth10M(0, 0),
    /**
     * <code>emEth100M = 1;</code>
     *
     * <pre>
     *&#47;以太网100M
     * </pre>
     */
    emEth100M(1, 1),
    /**
     * <code>emEth1000M = 2;</code>
     *
     * <pre>
     *&#47;以太网1000M
     * </pre>
     */
    emEth1000M(2, 2),
    /**
     * <code>emPppoe = 3;</code>
     *
     * <pre>
     *&#47;pppoe
     * </pre>
     */
    emPppoe(3, 3),
    /**
     * <code>emWifi24G = 4;</code>
     *
     * <pre>
     *&#47;wifi2.4G
     * </pre>
     */
    emWifi24G(4, 4),
    /**
     * <code>emWifi5G = 5;</code>
     *
     * <pre>
     *&#47;wifi5G
     * </pre>
     */
    emWifi5G(5, 5),
    /**
     * <code>emNetE1 = 6;</code>
     *
     * <pre>
     *&#47;E1
     * </pre>
     */
    emNetE1(6, 6),
    ;

    /**
     * <code>emEth10M = 0;</code>
     *
     * <pre>
     *&#47;以太网10M
     * </pre>
     */
    public static final int emEth10M_VALUE = 0;
    /**
     * <code>emEth100M = 1;</code>
     *
     * <pre>
     *&#47;以太网100M
     * </pre>
     */
    public static final int emEth100M_VALUE = 1;
    /**
     * <code>emEth1000M = 2;</code>
     *
     * <pre>
     *&#47;以太网1000M
     * </pre>
     */
    public static final int emEth1000M_VALUE = 2;
    /**
     * <code>emPppoe = 3;</code>
     *
     * <pre>
     *&#47;pppoe
     * </pre>
     */
    public static final int emPppoe_VALUE = 3;
    /**
     * <code>emWifi24G = 4;</code>
     *
     * <pre>
     *&#47;wifi2.4G
     * </pre>
     */
    public static final int emWifi24G_VALUE = 4;
    /**
     * <code>emWifi5G = 5;</code>
     *
     * <pre>
     *&#47;wifi5G
     * </pre>
     */
    public static final int emWifi5G_VALUE = 5;
    /**
     * <code>emNetE1 = 6;</code>
     *
     * <pre>
     *&#47;E1
     * </pre>
     */
    public static final int emNetE1_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmFtNetType valueOf(int value) {
      switch (value) {
        case 0: return emEth10M;
        case 1: return emEth100M;
        case 2: return emEth1000M;
        case 3: return emPppoe;
        case 4: return emWifi24G;
        case 5: return emWifi5G;
        case 6: return emNetE1;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtNetType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtNetType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtNetType>() {
            public EmFtNetType findValueByNumber(int number) {
              return EmFtNetType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(298);
    }

    private static final EmFtNetType[] VALUES = values();

    public static EmFtNetType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtNetType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtNetType)
  }

  /**
   * Protobuf enum {@code mt.EmFtUsbType}
   *
   * <pre>
   *&#47;usb类型
   * </pre>
   */
  public enum EmFtUsbType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUsb20 = 0;</code>
     *
     * <pre>
     *&#47;usb2.0
     * </pre>
     */
    emUsb20(0, 0),
    /**
     * <code>emUsb30 = 1;</code>
     *
     * <pre>
     *&#47;usb3.0
     * </pre>
     */
    emUsb30(1, 1),
    ;

    /**
     * <code>emUsb20 = 0;</code>
     *
     * <pre>
     *&#47;usb2.0
     * </pre>
     */
    public static final int emUsb20_VALUE = 0;
    /**
     * <code>emUsb30 = 1;</code>
     *
     * <pre>
     *&#47;usb3.0
     * </pre>
     */
    public static final int emUsb30_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmFtUsbType valueOf(int value) {
      switch (value) {
        case 0: return emUsb20;
        case 1: return emUsb30;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtUsbType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtUsbType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtUsbType>() {
            public EmFtUsbType findValueByNumber(int number) {
              return EmFtUsbType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(299);
    }

    private static final EmFtUsbType[] VALUES = values();

    public static EmFtUsbType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtUsbType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtUsbType)
  }

  /**
   * Protobuf enum {@code mt.EmFtDualStreamType}
   *
   * <pre>
   *&#47;双流类型
   * </pre>
   */
  public enum EmFtDualStreamType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emDualStream_Hard = 0;</code>
     *
     * <pre>
     *&#47;硬双流
     * </pre>
     */
    emDualStream_Hard(0, 0),
    /**
     * <code>emDualStream_Soft = 1;</code>
     *
     * <pre>
     *&#47;软双流
     * </pre>
     */
    emDualStream_Soft(1, 1),
    /**
     * <code>emDualStream_Wireless = 2;</code>
     *
     * <pre>
     *&#47;无线投屏
     * </pre>
     */
    emDualStream_Wireless(2, 2),
    ;

    /**
     * <code>emDualStream_Hard = 0;</code>
     *
     * <pre>
     *&#47;硬双流
     * </pre>
     */
    public static final int emDualStream_Hard_VALUE = 0;
    /**
     * <code>emDualStream_Soft = 1;</code>
     *
     * <pre>
     *&#47;软双流
     * </pre>
     */
    public static final int emDualStream_Soft_VALUE = 1;
    /**
     * <code>emDualStream_Wireless = 2;</code>
     *
     * <pre>
     *&#47;无线投屏
     * </pre>
     */
    public static final int emDualStream_Wireless_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmFtDualStreamType valueOf(int value) {
      switch (value) {
        case 0: return emDualStream_Hard;
        case 1: return emDualStream_Soft;
        case 2: return emDualStream_Wireless;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtDualStreamType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtDualStreamType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtDualStreamType>() {
            public EmFtDualStreamType findValueByNumber(int number) {
              return EmFtDualStreamType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(300);
    }

    private static final EmFtDualStreamType[] VALUES = values();

    public static EmFtDualStreamType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtDualStreamType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtDualStreamType)
  }

  /**
   * Protobuf enum {@code mt.EmFtVideoInportGroup}
   *
   * <pre>
   *&#47;输入接口分组 如:HDBastT,HDMI1 二选一
   * </pre>
   */
  public enum EmFtVideoInportGroup
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVideoInportGroup1 = 0;</code>
     */
    emVideoInportGroup1(0, 0),
    /**
     * <code>emVideoInportGroup2 = 1;</code>
     */
    emVideoInportGroup2(1, 1),
    /**
     * <code>emVideoInportGroup3 = 2;</code>
     */
    emVideoInportGroup3(2, 2),
    /**
     * <code>emVideoInportGroup4 = 3;</code>
     */
    emVideoInportGroup4(3, 3),
    /**
     * <code>emVideoInportGroup5 = 4;</code>
     */
    emVideoInportGroup5(4, 4),
    /**
     * <code>emVideoInportGroup6 = 5;</code>
     */
    emVideoInportGroup6(5, 5),
    /**
     * <code>emVideoInportGroup7 = 6;</code>
     */
    emVideoInportGroup7(6, 6),
    /**
     * <code>emVideoInportGroup8 = 7;</code>
     */
    emVideoInportGroup8(7, 7),
    /**
     * <code>emVideoInportGroup9 = 8;</code>
     */
    emVideoInportGroup9(8, 8),
    /**
     * <code>emVideoInportGroup10 = 9;</code>
     */
    emVideoInportGroup10(9, 9),
    /**
     * <code>emVideoInportGroup11 = 10;</code>
     */
    emVideoInportGroup11(10, 10),
    /**
     * <code>emVideoInportGroup12 = 11;</code>
     */
    emVideoInportGroup12(11, 11),
    /**
     * <code>emVideoInportGroup13 = 12;</code>
     */
    emVideoInportGroup13(12, 12),
    /**
     * <code>emVideoInportGroup14 = 13;</code>
     */
    emVideoInportGroup14(13, 13),
    /**
     * <code>emVideoInportGroup15 = 14;</code>
     */
    emVideoInportGroup15(14, 14),
    /**
     * <code>emVideoInportGroup16 = 15;</code>
     */
    emVideoInportGroup16(15, 15),
    ;

    /**
     * <code>emVideoInportGroup1 = 0;</code>
     */
    public static final int emVideoInportGroup1_VALUE = 0;
    /**
     * <code>emVideoInportGroup2 = 1;</code>
     */
    public static final int emVideoInportGroup2_VALUE = 1;
    /**
     * <code>emVideoInportGroup3 = 2;</code>
     */
    public static final int emVideoInportGroup3_VALUE = 2;
    /**
     * <code>emVideoInportGroup4 = 3;</code>
     */
    public static final int emVideoInportGroup4_VALUE = 3;
    /**
     * <code>emVideoInportGroup5 = 4;</code>
     */
    public static final int emVideoInportGroup5_VALUE = 4;
    /**
     * <code>emVideoInportGroup6 = 5;</code>
     */
    public static final int emVideoInportGroup6_VALUE = 5;
    /**
     * <code>emVideoInportGroup7 = 6;</code>
     */
    public static final int emVideoInportGroup7_VALUE = 6;
    /**
     * <code>emVideoInportGroup8 = 7;</code>
     */
    public static final int emVideoInportGroup8_VALUE = 7;
    /**
     * <code>emVideoInportGroup9 = 8;</code>
     */
    public static final int emVideoInportGroup9_VALUE = 8;
    /**
     * <code>emVideoInportGroup10 = 9;</code>
     */
    public static final int emVideoInportGroup10_VALUE = 9;
    /**
     * <code>emVideoInportGroup11 = 10;</code>
     */
    public static final int emVideoInportGroup11_VALUE = 10;
    /**
     * <code>emVideoInportGroup12 = 11;</code>
     */
    public static final int emVideoInportGroup12_VALUE = 11;
    /**
     * <code>emVideoInportGroup13 = 12;</code>
     */
    public static final int emVideoInportGroup13_VALUE = 12;
    /**
     * <code>emVideoInportGroup14 = 13;</code>
     */
    public static final int emVideoInportGroup14_VALUE = 13;
    /**
     * <code>emVideoInportGroup15 = 14;</code>
     */
    public static final int emVideoInportGroup15_VALUE = 14;
    /**
     * <code>emVideoInportGroup16 = 15;</code>
     */
    public static final int emVideoInportGroup16_VALUE = 15;


    public final int getNumber() { return value; }

    public static EmFtVideoInportGroup valueOf(int value) {
      switch (value) {
        case 0: return emVideoInportGroup1;
        case 1: return emVideoInportGroup2;
        case 2: return emVideoInportGroup3;
        case 3: return emVideoInportGroup4;
        case 4: return emVideoInportGroup5;
        case 5: return emVideoInportGroup6;
        case 6: return emVideoInportGroup7;
        case 7: return emVideoInportGroup8;
        case 8: return emVideoInportGroup9;
        case 9: return emVideoInportGroup10;
        case 10: return emVideoInportGroup11;
        case 11: return emVideoInportGroup12;
        case 12: return emVideoInportGroup13;
        case 13: return emVideoInportGroup14;
        case 14: return emVideoInportGroup15;
        case 15: return emVideoInportGroup16;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtVideoInportGroup>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtVideoInportGroup>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtVideoInportGroup>() {
            public EmFtVideoInportGroup findValueByNumber(int number) {
              return EmFtVideoInportGroup.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(301);
    }

    private static final EmFtVideoInportGroup[] VALUES = values();

    public static EmFtVideoInportGroup valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtVideoInportGroup(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtVideoInportGroup)
  }

  /**
   * Protobuf enum {@code mt.EmFtSdiUseType}
   *
   * <pre>
   *sdi模块类型
   * </pre>
   */
  public enum EmFtSdiUseType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSdiInvalid = 0;</code>
     *
     * <pre>
     *初始状态固定
     * </pre>
     */
    emSdiInvalid(0, 0),
    /**
     * <code>emSdiReplaceable = 1;</code>
     *
     * <pre>
     *可插拔
     * </pre>
     */
    emSdiReplaceable(1, 1),
    /**
     * <code>emSdiConfigurable = 2;</code>
     *
     * <pre>
     *可界面配置
     * </pre>
     */
    emSdiConfigurable(2, 2),
    ;

    /**
     * <code>emSdiInvalid = 0;</code>
     *
     * <pre>
     *初始状态固定
     * </pre>
     */
    public static final int emSdiInvalid_VALUE = 0;
    /**
     * <code>emSdiReplaceable = 1;</code>
     *
     * <pre>
     *可插拔
     * </pre>
     */
    public static final int emSdiReplaceable_VALUE = 1;
    /**
     * <code>emSdiConfigurable = 2;</code>
     *
     * <pre>
     *可界面配置
     * </pre>
     */
    public static final int emSdiConfigurable_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmFtSdiUseType valueOf(int value) {
      switch (value) {
        case 0: return emSdiInvalid;
        case 1: return emSdiReplaceable;
        case 2: return emSdiConfigurable;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtSdiUseType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtSdiUseType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtSdiUseType>() {
            public EmFtSdiUseType findValueByNumber(int number) {
              return EmFtSdiUseType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(302);
    }

    private static final EmFtSdiUseType[] VALUES = values();

    public static EmFtSdiUseType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtSdiUseType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtSdiUseType)
  }

  /**
   * Protobuf enum {@code mt.EmSdiUseState}
   *
   * <pre>
   *单个sdi接口状态
   * </pre>
   */
  public enum EmSdiUseState
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSdiNotExist = 0;</code>
     */
    emSdiNotExist(0, 0),
    /**
     * <code>emSdiAsInput = 1;</code>
     */
    emSdiAsInput(1, 1),
    /**
     * <code>emSdiAsOutput = 2;</code>
     */
    emSdiAsOutput(2, 2),
    ;

    /**
     * <code>emSdiNotExist = 0;</code>
     */
    public static final int emSdiNotExist_VALUE = 0;
    /**
     * <code>emSdiAsInput = 1;</code>
     */
    public static final int emSdiAsInput_VALUE = 1;
    /**
     * <code>emSdiAsOutput = 2;</code>
     */
    public static final int emSdiAsOutput_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmSdiUseState valueOf(int value) {
      switch (value) {
        case 0: return emSdiNotExist;
        case 1: return emSdiAsInput;
        case 2: return emSdiAsOutput;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSdiUseState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSdiUseState>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSdiUseState>() {
            public EmSdiUseState findValueByNumber(int number) {
              return EmSdiUseState.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(303);
    }

    private static final EmSdiUseState[] VALUES = values();

    public static EmSdiUseState valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSdiUseState(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSdiUseState)
  }

  /**
   * Protobuf enum {@code mt.EmFtCutOutType}
   *
   * <pre>
   *抠图方式
   * </pre>
   */
  public enum EmFtCutOutType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFpgaNothing = 0;</code>
     *
     * <pre>
     *fpga不抠图
     * </pre>
     */
    emFpgaNothing(0, 0),
    /**
     * <code>emFpgaCutOut = 1;</code>
     *
     * <pre>
     *fpga抠图
     * </pre>
     */
    emFpgaCutOut(1, 1),
    /**
     * <code>emAlphaLayer = 2;</code>
     *
     * <pre>
     *alpha通道
     * </pre>
     */
    emAlphaLayer(2, 2),
    ;

    /**
     * <code>emFpgaNothing = 0;</code>
     *
     * <pre>
     *fpga不抠图
     * </pre>
     */
    public static final int emFpgaNothing_VALUE = 0;
    /**
     * <code>emFpgaCutOut = 1;</code>
     *
     * <pre>
     *fpga抠图
     * </pre>
     */
    public static final int emFpgaCutOut_VALUE = 1;
    /**
     * <code>emAlphaLayer = 2;</code>
     *
     * <pre>
     *alpha通道
     * </pre>
     */
    public static final int emAlphaLayer_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmFtCutOutType valueOf(int value) {
      switch (value) {
        case 0: return emFpgaNothing;
        case 1: return emFpgaCutOut;
        case 2: return emAlphaLayer;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtCutOutType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtCutOutType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtCutOutType>() {
            public EmFtCutOutType findValueByNumber(int number) {
              return EmFtCutOutType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(304);
    }

    private static final EmFtCutOutType[] VALUES = values();

    public static EmFtCutOutType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtCutOutType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtCutOutType)
  }

  /**
   * Protobuf enum {@code mt.EmFtStreamType}
   *
   * <pre>
   *数据流类型
   * </pre>
   */
  public enum EmFtStreamType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emStreamType_Send_Aud = 0;</code>
     */
    emStreamType_Send_Aud(0, 0),
    /**
     * <code>emStreamType_Send_Main = 1;</code>
     */
    emStreamType_Send_Main(1, 1),
    /**
     * <code>emStreamType_Send_VideoAss = 2;</code>
     */
    emStreamType_Send_VideoAss(2, 2),
    /**
     * <code>emStreamType_Send_PcAss = 3;</code>
     */
    emStreamType_Send_PcAss(3, 3),
    /**
     * <code>emStreamType_Send_Mul_Main1 = 4;</code>
     */
    emStreamType_Send_Mul_Main1(4, 4),
    /**
     * <code>emStreamType_Send_Mul_Main2 = 5;</code>
     */
    emStreamType_Send_Mul_Main2(5, 5),
    /**
     * <code>emStreamType_Send_Mul_Main3 = 6;</code>
     */
    emStreamType_Send_Mul_Main3(6, 6),
    /**
     * <code>emStreamType_Send_Mul_VideoAss = 7;</code>
     */
    emStreamType_Send_Mul_VideoAss(7, 7),
    /**
     * <code>emStreamType_Send_Mul_PcAss = 8;</code>
     */
    emStreamType_Send_Mul_PcAss(8, 8),
    /**
     * <code>emStreamType_Recv_Aud = 10;</code>
     */
    emStreamType_Recv_Aud(9, 10),
    /**
     * <code>emStreamType_Recv_Main = 11;</code>
     */
    emStreamType_Recv_Main(10, 11),
    /**
     * <code>emStreamType_Recv_VideoAss = 12;</code>
     */
    emStreamType_Recv_VideoAss(11, 12),
    /**
     * <code>emStreamType_Recv_PcAss = 13;</code>
     *
     * <pre>
     *硬终端不使用
     * </pre>
     */
    emStreamType_Recv_PcAss(12, 13),
    /**
     * <code>emStreamType_Recv_Mul_Main1 = 14;</code>
     */
    emStreamType_Recv_Mul_Main1(13, 14),
    /**
     * <code>emStreamType_Recv_Mul_Main2 = 15;</code>
     */
    emStreamType_Recv_Mul_Main2(14, 15),
    /**
     * <code>emStreamType_Recv_Mul_Main3 = 16;</code>
     */
    emStreamType_Recv_Mul_Main3(15, 16),
    /**
     * <code>emStreamType_Recv_Mul_VideoAss = 17;</code>
     */
    emStreamType_Recv_Mul_VideoAss(16, 17),
    /**
     * <code>emStreamType_Recv_Mul_PcAss = 18;</code>
     *
     * <pre>
     *硬终端不使用
     * </pre>
     */
    emStreamType_Recv_Mul_PcAss(17, 18),
    ;

    /**
     * <code>emStreamType_Send_Aud = 0;</code>
     */
    public static final int emStreamType_Send_Aud_VALUE = 0;
    /**
     * <code>emStreamType_Send_Main = 1;</code>
     */
    public static final int emStreamType_Send_Main_VALUE = 1;
    /**
     * <code>emStreamType_Send_VideoAss = 2;</code>
     */
    public static final int emStreamType_Send_VideoAss_VALUE = 2;
    /**
     * <code>emStreamType_Send_PcAss = 3;</code>
     */
    public static final int emStreamType_Send_PcAss_VALUE = 3;
    /**
     * <code>emStreamType_Send_Mul_Main1 = 4;</code>
     */
    public static final int emStreamType_Send_Mul_Main1_VALUE = 4;
    /**
     * <code>emStreamType_Send_Mul_Main2 = 5;</code>
     */
    public static final int emStreamType_Send_Mul_Main2_VALUE = 5;
    /**
     * <code>emStreamType_Send_Mul_Main3 = 6;</code>
     */
    public static final int emStreamType_Send_Mul_Main3_VALUE = 6;
    /**
     * <code>emStreamType_Send_Mul_VideoAss = 7;</code>
     */
    public static final int emStreamType_Send_Mul_VideoAss_VALUE = 7;
    /**
     * <code>emStreamType_Send_Mul_PcAss = 8;</code>
     */
    public static final int emStreamType_Send_Mul_PcAss_VALUE = 8;
    /**
     * <code>emStreamType_Recv_Aud = 10;</code>
     */
    public static final int emStreamType_Recv_Aud_VALUE = 10;
    /**
     * <code>emStreamType_Recv_Main = 11;</code>
     */
    public static final int emStreamType_Recv_Main_VALUE = 11;
    /**
     * <code>emStreamType_Recv_VideoAss = 12;</code>
     */
    public static final int emStreamType_Recv_VideoAss_VALUE = 12;
    /**
     * <code>emStreamType_Recv_PcAss = 13;</code>
     *
     * <pre>
     *硬终端不使用
     * </pre>
     */
    public static final int emStreamType_Recv_PcAss_VALUE = 13;
    /**
     * <code>emStreamType_Recv_Mul_Main1 = 14;</code>
     */
    public static final int emStreamType_Recv_Mul_Main1_VALUE = 14;
    /**
     * <code>emStreamType_Recv_Mul_Main2 = 15;</code>
     */
    public static final int emStreamType_Recv_Mul_Main2_VALUE = 15;
    /**
     * <code>emStreamType_Recv_Mul_Main3 = 16;</code>
     */
    public static final int emStreamType_Recv_Mul_Main3_VALUE = 16;
    /**
     * <code>emStreamType_Recv_Mul_VideoAss = 17;</code>
     */
    public static final int emStreamType_Recv_Mul_VideoAss_VALUE = 17;
    /**
     * <code>emStreamType_Recv_Mul_PcAss = 18;</code>
     *
     * <pre>
     *硬终端不使用
     * </pre>
     */
    public static final int emStreamType_Recv_Mul_PcAss_VALUE = 18;


    public final int getNumber() { return value; }

    public static EmFtStreamType valueOf(int value) {
      switch (value) {
        case 0: return emStreamType_Send_Aud;
        case 1: return emStreamType_Send_Main;
        case 2: return emStreamType_Send_VideoAss;
        case 3: return emStreamType_Send_PcAss;
        case 4: return emStreamType_Send_Mul_Main1;
        case 5: return emStreamType_Send_Mul_Main2;
        case 6: return emStreamType_Send_Mul_Main3;
        case 7: return emStreamType_Send_Mul_VideoAss;
        case 8: return emStreamType_Send_Mul_PcAss;
        case 10: return emStreamType_Recv_Aud;
        case 11: return emStreamType_Recv_Main;
        case 12: return emStreamType_Recv_VideoAss;
        case 13: return emStreamType_Recv_PcAss;
        case 14: return emStreamType_Recv_Mul_Main1;
        case 15: return emStreamType_Recv_Mul_Main2;
        case 16: return emStreamType_Recv_Mul_Main3;
        case 17: return emStreamType_Recv_Mul_VideoAss;
        case 18: return emStreamType_Recv_Mul_PcAss;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtStreamType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtStreamType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtStreamType>() {
            public EmFtStreamType findValueByNumber(int number) {
              return EmFtStreamType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(305);
    }

    private static final EmFtStreamType[] VALUES = values();

    public static EmFtStreamType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtStreamType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtStreamType)
  }

  /**
   * Protobuf enum {@code mt.EmFtAudFileFormat}
   *
   * <pre>
   *&#47;39.	音频文件（铃声/声场检测）
   * /格式：bit/pcm
   * </pre>
   */
  public enum EmFtAudFileFormat
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emAudFileBit = 1;</code>
     *
     * <pre>
     *bit
     * </pre>
     */
    emAudFileBit(0, 1),
    /**
     * <code>emAudFilePcm = 2;</code>
     *
     * <pre>
     *pcm
     * </pre>
     */
    emAudFilePcm(1, 2),
    ;

    /**
     * <code>emAudFileBit = 1;</code>
     *
     * <pre>
     *bit
     * </pre>
     */
    public static final int emAudFileBit_VALUE = 1;
    /**
     * <code>emAudFilePcm = 2;</code>
     *
     * <pre>
     *pcm
     * </pre>
     */
    public static final int emAudFilePcm_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmFtAudFileFormat valueOf(int value) {
      switch (value) {
        case 1: return emAudFileBit;
        case 2: return emAudFilePcm;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtAudFileFormat>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtAudFileFormat>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtAudFileFormat>() {
            public EmFtAudFileFormat findValueByNumber(int number) {
              return EmFtAudFileFormat.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(306);
    }

    private static final EmFtAudFileFormat[] VALUES = values();

    public static EmFtAudFileFormat valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtAudFileFormat(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtAudFileFormat)
  }

  /**
   * Protobuf enum {@code mt.EmFtFirmwareType}
   *
   * <pre>
   *&#47;42.	版本信息
   * /FPGA、CPLD、PTZ数量、版本信息 版本号统一（含子版本号）
   *终端及其固件类型
   * </pre>
   */
  public enum EmFtFirmwareType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFwMtHwType = 1;</code>
     *
     * <pre>
     *终端硬件类型
     * </pre>
     */
    emFwMtHwType(0, 1),
    /**
     * <code>emFwMtHwVer = 2;</code>
     *
     * <pre>
     *终端硬件版本
     * </pre>
     */
    emFwMtHwVer(1, 2),
    /**
     * <code>emFwMtSwVer = 3;</code>
     *
     * <pre>
     *终端软件版本
     * </pre>
     */
    emFwMtSwVer(2, 3),
    /**
     * <code>emFwMtSn = 4;</code>
     *
     * <pre>
     *终端序列号
     * </pre>
     */
    emFwMtSn(3, 4),
    /**
     * <code>emFwFpga = 5;</code>
     *
     * <pre>
     *FPGA
     * </pre>
     */
    emFwFpga(4, 5),
    /**
     * <code>emFwCpld = 6;</code>
     *
     * <pre>
     *CPLD
     * </pre>
     */
    emFwCpld(5, 6),
    /**
     * <code>emFwPtz = 7;</code>
     *
     * <pre>
     *云台
     * </pre>
     */
    emFwPtz(6, 7),
    /**
     * <code>emFwCamera = 8;</code>
     *
     * <pre>
     *摄像机(机芯)
     * </pre>
     */
    emFwCamera(7, 8),
    /**
     * <code>emFwInfrared = 9;</code>
     *
     * <pre>
     *红外
     * </pre>
     */
    emFwInfrared(8, 9),
    /**
     * <code>emFwMic = 10;</code>
     *
     * <pre>
     *数字麦
     * </pre>
     */
    emFwMic(9, 10),
    /**
     * <code>emFwRemote = 11;</code>
     *
     * <pre>
     *遥控器
     * </pre>
     */
    emFwRemote(10, 11),
    ;

    /**
     * <code>emFwMtHwType = 1;</code>
     *
     * <pre>
     *终端硬件类型
     * </pre>
     */
    public static final int emFwMtHwType_VALUE = 1;
    /**
     * <code>emFwMtHwVer = 2;</code>
     *
     * <pre>
     *终端硬件版本
     * </pre>
     */
    public static final int emFwMtHwVer_VALUE = 2;
    /**
     * <code>emFwMtSwVer = 3;</code>
     *
     * <pre>
     *终端软件版本
     * </pre>
     */
    public static final int emFwMtSwVer_VALUE = 3;
    /**
     * <code>emFwMtSn = 4;</code>
     *
     * <pre>
     *终端序列号
     * </pre>
     */
    public static final int emFwMtSn_VALUE = 4;
    /**
     * <code>emFwFpga = 5;</code>
     *
     * <pre>
     *FPGA
     * </pre>
     */
    public static final int emFwFpga_VALUE = 5;
    /**
     * <code>emFwCpld = 6;</code>
     *
     * <pre>
     *CPLD
     * </pre>
     */
    public static final int emFwCpld_VALUE = 6;
    /**
     * <code>emFwPtz = 7;</code>
     *
     * <pre>
     *云台
     * </pre>
     */
    public static final int emFwPtz_VALUE = 7;
    /**
     * <code>emFwCamera = 8;</code>
     *
     * <pre>
     *摄像机(机芯)
     * </pre>
     */
    public static final int emFwCamera_VALUE = 8;
    /**
     * <code>emFwInfrared = 9;</code>
     *
     * <pre>
     *红外
     * </pre>
     */
    public static final int emFwInfrared_VALUE = 9;
    /**
     * <code>emFwMic = 10;</code>
     *
     * <pre>
     *数字麦
     * </pre>
     */
    public static final int emFwMic_VALUE = 10;
    /**
     * <code>emFwRemote = 11;</code>
     *
     * <pre>
     *遥控器
     * </pre>
     */
    public static final int emFwRemote_VALUE = 11;


    public final int getNumber() { return value; }

    public static EmFtFirmwareType valueOf(int value) {
      switch (value) {
        case 1: return emFwMtHwType;
        case 2: return emFwMtHwVer;
        case 3: return emFwMtSwVer;
        case 4: return emFwMtSn;
        case 5: return emFwFpga;
        case 6: return emFwCpld;
        case 7: return emFwPtz;
        case 8: return emFwCamera;
        case 9: return emFwInfrared;
        case 10: return emFwMic;
        case 11: return emFwRemote;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtFirmwareType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtFirmwareType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtFirmwareType>() {
            public EmFtFirmwareType findValueByNumber(int number) {
              return EmFtFirmwareType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(307);
    }

    private static final EmFtFirmwareType[] VALUES = values();

    public static EmFtFirmwareType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtFirmwareType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtFirmwareType)
  }

  /**
   * Protobuf enum {@code mt.EmFtResetType}
   *
   * <pre>
   *&#47;可以进行重设的枚举
   * </pre>
   */
  public enum EmFtResetType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFtCallAndResponse = 1;</code>
     *
     * <pre>
     *呼叫与应答
     * </pre>
     */
    emFtCallAndResponse(0, 1),
    /**
     * <code>emFtCallProtocol = 2;</code>
     *
     * <pre>
     *呼叫协议
     * </pre>
     */
    emFtCallProtocol(1, 2),
    /**
     * <code>emFtNetworkService = 3;</code>
     *
     * <pre>
     *网络服务
     * </pre>
     */
    emFtNetworkService(2, 3),
    /**
     * <code>emFtNetAdaptAndPort = 4;</code>
     *
     * <pre>
     *网络适应性及端口
     * </pre>
     */
    emFtNetAdaptAndPort(3, 4),
    /**
     * <code>emFtDualStreamFormat = 5;</code>
     *
     * <pre>
     *多点会议双流格式
     * </pre>
     */
    emFtDualStreamFormat(4, 5),
    /**
     * <code>emFtStandby = 6;</code>
     *
     * <pre>
     *系统待机
     * </pre>
     */
    emFtStandby(5, 6),
    /**
     * <code>emFtSafety = 7;</code>
     *
     * <pre>
     *系统数据安全
     * </pre>
     */
    emFtSafety(6, 7),
    /**
     * <code>emFtMtcBox = 8;</code>
     *
     * <pre>
     *终端控制器(MTC-BOX)
     * </pre>
     */
    emFtMtcBox(7, 8),
    /**
     * <code>emFtSerial = 9;</code>
     *
     * <pre>
     *串口
     * </pre>
     */
    emFtSerial(8, 9),
    /**
     * <code>emFtSoundAndDisplay = 10;</code>
     *
     * <pre>
     *音效与显示
     * </pre>
     */
    emFtSoundAndDisplay(9, 10),
    /**
     * <code>emFtVolumeAndQuality = 11;</code>
     *
     * <pre>
     *音频音量以及质量
     * </pre>
     */
    emFtVolumeAndQuality(10, 11),
    /**
     * <code>emFtVideo = 19;</code>
     *
     * <pre>
     *视频
     * </pre>
     */
    emFtVideo(11, 19),
    /**
     * <code>emFtVidDisplayMode = 20;</code>
     *
     * <pre>
     *视频显示模式
     * </pre>
     */
    emFtVidDisplayMode(12, 20),
    /**
     * <code>emFtPreferredResolution = 21;</code>
     *
     * <pre>
     *优选分辨率
     * </pre>
     */
    emFtPreferredResolution(13, 21),
    /**
     * <code>emFtOutputResolution = 22;</code>
     *
     * <pre>
     *输出分辨率
     * </pre>
     */
    emFtOutputResolution(14, 22),
    /**
     * <code>emFtVidSourceTag = 23;</code>
     *
     * <pre>
     *视频源标签
     * </pre>
     */
    emFtVidSourceTag(15, 23),
    /**
     * <code>emFtVidDisplayRatio = 24;</code>
     *
     * <pre>
     *视频输出比例
     * </pre>
     */
    emFtVidDisplayRatio(16, 24),
    /**
     * <code>emFtImageAdjust = 25;</code>
     *
     * <pre>
     *图像调节
     * </pre>
     */
    emFtImageAdjust(17, 25),
    /**
     * <code>emFtImageParameter = 26;</code>
     *
     * <pre>
     *编码参数
     * </pre>
     */
    emFtImageParameter(18, 26),
    /**
     * <code>emFtImageQuality = 27;</code>
     *
     * <pre>
     *图像质量
     * </pre>
     */
    emFtImageQuality(19, 27),
    ;

    /**
     * <code>emFtCallAndResponse = 1;</code>
     *
     * <pre>
     *呼叫与应答
     * </pre>
     */
    public static final int emFtCallAndResponse_VALUE = 1;
    /**
     * <code>emFtCallProtocol = 2;</code>
     *
     * <pre>
     *呼叫协议
     * </pre>
     */
    public static final int emFtCallProtocol_VALUE = 2;
    /**
     * <code>emFtNetworkService = 3;</code>
     *
     * <pre>
     *网络服务
     * </pre>
     */
    public static final int emFtNetworkService_VALUE = 3;
    /**
     * <code>emFtNetAdaptAndPort = 4;</code>
     *
     * <pre>
     *网络适应性及端口
     * </pre>
     */
    public static final int emFtNetAdaptAndPort_VALUE = 4;
    /**
     * <code>emFtDualStreamFormat = 5;</code>
     *
     * <pre>
     *多点会议双流格式
     * </pre>
     */
    public static final int emFtDualStreamFormat_VALUE = 5;
    /**
     * <code>emFtStandby = 6;</code>
     *
     * <pre>
     *系统待机
     * </pre>
     */
    public static final int emFtStandby_VALUE = 6;
    /**
     * <code>emFtSafety = 7;</code>
     *
     * <pre>
     *系统数据安全
     * </pre>
     */
    public static final int emFtSafety_VALUE = 7;
    /**
     * <code>emFtMtcBox = 8;</code>
     *
     * <pre>
     *终端控制器(MTC-BOX)
     * </pre>
     */
    public static final int emFtMtcBox_VALUE = 8;
    /**
     * <code>emFtSerial = 9;</code>
     *
     * <pre>
     *串口
     * </pre>
     */
    public static final int emFtSerial_VALUE = 9;
    /**
     * <code>emFtSoundAndDisplay = 10;</code>
     *
     * <pre>
     *音效与显示
     * </pre>
     */
    public static final int emFtSoundAndDisplay_VALUE = 10;
    /**
     * <code>emFtVolumeAndQuality = 11;</code>
     *
     * <pre>
     *音频音量以及质量
     * </pre>
     */
    public static final int emFtVolumeAndQuality_VALUE = 11;
    /**
     * <code>emFtVideo = 19;</code>
     *
     * <pre>
     *视频
     * </pre>
     */
    public static final int emFtVideo_VALUE = 19;
    /**
     * <code>emFtVidDisplayMode = 20;</code>
     *
     * <pre>
     *视频显示模式
     * </pre>
     */
    public static final int emFtVidDisplayMode_VALUE = 20;
    /**
     * <code>emFtPreferredResolution = 21;</code>
     *
     * <pre>
     *优选分辨率
     * </pre>
     */
    public static final int emFtPreferredResolution_VALUE = 21;
    /**
     * <code>emFtOutputResolution = 22;</code>
     *
     * <pre>
     *输出分辨率
     * </pre>
     */
    public static final int emFtOutputResolution_VALUE = 22;
    /**
     * <code>emFtVidSourceTag = 23;</code>
     *
     * <pre>
     *视频源标签
     * </pre>
     */
    public static final int emFtVidSourceTag_VALUE = 23;
    /**
     * <code>emFtVidDisplayRatio = 24;</code>
     *
     * <pre>
     *视频输出比例
     * </pre>
     */
    public static final int emFtVidDisplayRatio_VALUE = 24;
    /**
     * <code>emFtImageAdjust = 25;</code>
     *
     * <pre>
     *图像调节
     * </pre>
     */
    public static final int emFtImageAdjust_VALUE = 25;
    /**
     * <code>emFtImageParameter = 26;</code>
     *
     * <pre>
     *编码参数
     * </pre>
     */
    public static final int emFtImageParameter_VALUE = 26;
    /**
     * <code>emFtImageQuality = 27;</code>
     *
     * <pre>
     *图像质量
     * </pre>
     */
    public static final int emFtImageQuality_VALUE = 27;


    public final int getNumber() { return value; }

    public static EmFtResetType valueOf(int value) {
      switch (value) {
        case 1: return emFtCallAndResponse;
        case 2: return emFtCallProtocol;
        case 3: return emFtNetworkService;
        case 4: return emFtNetAdaptAndPort;
        case 5: return emFtDualStreamFormat;
        case 6: return emFtStandby;
        case 7: return emFtSafety;
        case 8: return emFtMtcBox;
        case 9: return emFtSerial;
        case 10: return emFtSoundAndDisplay;
        case 11: return emFtVolumeAndQuality;
        case 19: return emFtVideo;
        case 20: return emFtVidDisplayMode;
        case 21: return emFtPreferredResolution;
        case 22: return emFtOutputResolution;
        case 23: return emFtVidSourceTag;
        case 24: return emFtVidDisplayRatio;
        case 25: return emFtImageAdjust;
        case 26: return emFtImageParameter;
        case 27: return emFtImageQuality;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtResetType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtResetType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtResetType>() {
            public EmFtResetType findValueByNumber(int number) {
              return EmFtResetType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(308);
    }

    private static final EmFtResetType[] VALUES = values();

    public static EmFtResetType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtResetType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtResetType)
  }

  /**
   * Protobuf enum {@code mt.EmFtOsdScalingType}
   *
   * <pre>
   *&#47;OSD叠加缩放类型
   * </pre>
   */
  public enum EmFtOsdScalingType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFpgaScaling = 1;</code>
     *
     * <pre>
     *FPGA缩放
     * </pre>
     */
    emFpgaScaling(0, 1),
    /**
     * <code>emMasterCtrlPlay = 2;</code>
     *
     * <pre>
     *主控播放制式缩放
     * </pre>
     */
    emMasterCtrlPlay(1, 2),
    ;

    /**
     * <code>emFpgaScaling = 1;</code>
     *
     * <pre>
     *FPGA缩放
     * </pre>
     */
    public static final int emFpgaScaling_VALUE = 1;
    /**
     * <code>emMasterCtrlPlay = 2;</code>
     *
     * <pre>
     *主控播放制式缩放
     * </pre>
     */
    public static final int emMasterCtrlPlay_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmFtOsdScalingType valueOf(int value) {
      switch (value) {
        case 1: return emFpgaScaling;
        case 2: return emMasterCtrlPlay;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtOsdScalingType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtOsdScalingType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtOsdScalingType>() {
            public EmFtOsdScalingType findValueByNumber(int number) {
              return EmFtOsdScalingType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(309);
    }

    private static final EmFtOsdScalingType[] VALUES = values();

    public static EmFtOsdScalingType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtOsdScalingType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtOsdScalingType)
  }

  /**
   * Protobuf enum {@code mt.EmFtMaxVidSrc}
   *
   * <pre>
   *&#47;终端支持最大源制式
   * </pre>
   */
  public enum EmFtMaxVidSrc
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emMaxVidSrcInvalid = 1;</code>
     */
    emMaxVidSrcInvalid(0, 1),
    /**
     * <code>emMaxVidSrc720p = 2;</code>
     */
    emMaxVidSrc720p(1, 2),
    /**
     * <code>emMaxVidSrc1080p = 3;</code>
     */
    emMaxVidSrc1080p(2, 3),
    /**
     * <code>emMaxVidSrc4k = 4;</code>
     */
    emMaxVidSrc4k(3, 4),
    ;

    /**
     * <code>emMaxVidSrcInvalid = 1;</code>
     */
    public static final int emMaxVidSrcInvalid_VALUE = 1;
    /**
     * <code>emMaxVidSrc720p = 2;</code>
     */
    public static final int emMaxVidSrc720p_VALUE = 2;
    /**
     * <code>emMaxVidSrc1080p = 3;</code>
     */
    public static final int emMaxVidSrc1080p_VALUE = 3;
    /**
     * <code>emMaxVidSrc4k = 4;</code>
     */
    public static final int emMaxVidSrc4k_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmFtMaxVidSrc valueOf(int value) {
      switch (value) {
        case 1: return emMaxVidSrcInvalid;
        case 2: return emMaxVidSrc720p;
        case 3: return emMaxVidSrc1080p;
        case 4: return emMaxVidSrc4k;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtMaxVidSrc>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtMaxVidSrc>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtMaxVidSrc>() {
            public EmFtMaxVidSrc findValueByNumber(int number) {
              return EmFtMaxVidSrc.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(310);
    }

    private static final EmFtMaxVidSrc[] VALUES = values();

    public static EmFtMaxVidSrc valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtMaxVidSrc(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtMaxVidSrc)
  }

  /**
   * Protobuf enum {@code mt.EmFtCameraType}
   *
   * <pre>
   *&#47;摄像机类型
   * </pre>
   */
  public enum EmFtCameraType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCameraGeneral = 0;</code>
     *
     * <pre>
     *通用
     * </pre>
     */
    emCameraGeneral(0, 0),
    /**
     * <code>emCameraInner = 1;</code>
     *
     * <pre>
     *内置摄像机
     * </pre>
     */
    emCameraInner(1, 1),
    /**
     * <code>emCameraMoon = 2;</code>
     *
     * <pre>
     *Moon系列摄像机
     * </pre>
     */
    emCameraMoon(2, 2),
    /**
     * <code>emCameraSony = 3;</code>
     *
     * <pre>
     *Sony系列摄像机
     * </pre>
     */
    emCameraSony(3, 3),
    ;

    /**
     * <code>emCameraGeneral = 0;</code>
     *
     * <pre>
     *通用
     * </pre>
     */
    public static final int emCameraGeneral_VALUE = 0;
    /**
     * <code>emCameraInner = 1;</code>
     *
     * <pre>
     *内置摄像机
     * </pre>
     */
    public static final int emCameraInner_VALUE = 1;
    /**
     * <code>emCameraMoon = 2;</code>
     *
     * <pre>
     *Moon系列摄像机
     * </pre>
     */
    public static final int emCameraMoon_VALUE = 2;
    /**
     * <code>emCameraSony = 3;</code>
     *
     * <pre>
     *Sony系列摄像机
     * </pre>
     */
    public static final int emCameraSony_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmFtCameraType valueOf(int value) {
      switch (value) {
        case 0: return emCameraGeneral;
        case 1: return emCameraInner;
        case 2: return emCameraMoon;
        case 3: return emCameraSony;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtCameraType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtCameraType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtCameraType>() {
            public EmFtCameraType findValueByNumber(int number) {
              return EmFtCameraType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(311);
    }

    private static final EmFtCameraType[] VALUES = values();

    public static EmFtCameraType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtCameraType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtCameraType)
  }

  /**
   * Protobuf enum {@code mt.EmFtCameraCtrlType}
   *
   * <pre>
   *&#47;云台/图像控制类型
   * </pre>
   */
  public enum EmFtCameraCtrlType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCtrlNone = 0;</code>
     */
    emCtrlNone(0, 0),
    /**
     * <code>emCtrlIspImg = 1;</code>
     *
     * <pre>
     *ISP控制
     * </pre>
     */
    emCtrlIspImg(1, 1),
    /**
     * <code>emCtrlVisca = 2;</code>
     *
     * <pre>
     *visca指令
     * </pre>
     */
    emCtrlVisca(2, 2),
    /**
     * <code>emCtrlBrdPtz = 3;</code>
     *
     * <pre>
     *驱动Ptz控制
     * </pre>
     */
    emCtrlBrdPtz(3, 3),
    /**
     * <code>emCtrlPelco = 4;</code>
     *
     * <pre>
     *pelco协议
     * </pre>
     */
    emCtrlPelco(4, 4),
    ;

    /**
     * <code>emCtrlNone = 0;</code>
     */
    public static final int emCtrlNone_VALUE = 0;
    /**
     * <code>emCtrlIspImg = 1;</code>
     *
     * <pre>
     *ISP控制
     * </pre>
     */
    public static final int emCtrlIspImg_VALUE = 1;
    /**
     * <code>emCtrlVisca = 2;</code>
     *
     * <pre>
     *visca指令
     * </pre>
     */
    public static final int emCtrlVisca_VALUE = 2;
    /**
     * <code>emCtrlBrdPtz = 3;</code>
     *
     * <pre>
     *驱动Ptz控制
     * </pre>
     */
    public static final int emCtrlBrdPtz_VALUE = 3;
    /**
     * <code>emCtrlPelco = 4;</code>
     *
     * <pre>
     *pelco协议
     * </pre>
     */
    public static final int emCtrlPelco_VALUE = 4;


    public final int getNumber() { return value; }

    public static EmFtCameraCtrlType valueOf(int value) {
      switch (value) {
        case 0: return emCtrlNone;
        case 1: return emCtrlIspImg;
        case 2: return emCtrlVisca;
        case 3: return emCtrlBrdPtz;
        case 4: return emCtrlPelco;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtCameraCtrlType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtCameraCtrlType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtCameraCtrlType>() {
            public EmFtCameraCtrlType findValueByNumber(int number) {
              return EmFtCameraCtrlType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(312);
    }

    private static final EmFtCameraCtrlType[] VALUES = values();

    public static EmFtCameraCtrlType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtCameraCtrlType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtCameraCtrlType)
  }

  /**
   * Protobuf enum {@code mt.EmFtUpgradeType}
   *
   * <pre>
   *&#47;升级类型
   * </pre>
   */
  public enum EmFtUpgradeType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUpgrade_None = 0;</code>
     */
    emUpgrade_None(0, 0),
    /**
     * <code>emUpgrade_UgDtb = 1;</code>
     *
     * <pre>
     *&#47;dtb升级
     * </pre>
     */
    emUpgrade_UgDtb(1, 1),
    /**
     * <code>emUpgrade_UbootBin = 2;</code>
     *
     * <pre>
     *&#47;uboot.bin升级
     * </pre>
     */
    emUpgrade_UbootBin(2, 2),
    /**
     * <code>emUpgrade_UbootImg = 3;</code>
     *
     * <pre>
     *&#47;uboot.img升级
     * </pre>
     */
    emUpgrade_UbootImg(3, 3),
    /**
     * <code>emUpgrade_Mlo = 4;</code>
     *
     * <pre>
     *&#47;MLO升级
     * </pre>
     */
    emUpgrade_Mlo(4, 4),
    /**
     * <code>emUpgrade_FpgaX500a = 5;</code>
     *
     * <pre>
     *&#47;fpga.x500a升级
     * </pre>
     */
    emUpgrade_FpgaX500a(5, 5),
    /**
     * <code>emUpgrade_UgPic = 6;</code>
     *
     * <pre>
     *&#47;UgPic升级
     * </pre>
     */
    emUpgrade_UgPic(6, 6),
    /**
     * <code>emUpgrade_UgIos = 7;</code>
     *
     * <pre>
     *&#47;UgIos升级
     * </pre>
     */
    emUpgrade_UgIos(7, 7),
    /**
     * <code>emUpgrade_UgVcmt = 8;</code>
     *
     * <pre>
     *&#47;UgVcmt升级
     * </pre>
     */
    emUpgrade_UgVcmt(8, 8),
    /**
     * <code>emUpgrade_UgApp = 9;</code>
     *
     * <pre>
     *&#47;UgApp升级
     * </pre>
     */
    emUpgrade_UgApp(9, 9),
    /**
     * <code>emUpgrade_UgRecovery = 10;</code>
     *
     * <pre>
     *&#47;UgRecovery升级
     * </pre>
     */
    emUpgrade_UgRecovery(10, 10),
    /**
     * <code>emUpgrade_Ugboot = 11;</code>
     *
     * <pre>
     *&#47;Ugboot升级
     * </pre>
     */
    emUpgrade_Ugboot(11, 11),
    /**
     * <code>emUpgrade_UgBaseparam = 12;</code>
     *
     * <pre>
     *&#47;UgBaseparam升级
     * </pre>
     */
    emUpgrade_UgBaseparam(12, 12),
    /**
     * <code>emUpgrade_UgPqparam = 13;</code>
     *
     * <pre>
     *&#47;UgPqparam升级
     * </pre>
     */
    emUpgrade_UgPqparam(13, 13),
    /**
     * <code>emUpgrade_Scm = 14;</code>
     *
     * <pre>
     *&#47;SCM升级
     * </pre>
     */
    emUpgrade_Scm(14, 14),
    /**
     * <code>emUpgrade_Camera = 15;</code>
     *
     * <pre>
     *&#47;Camera升级
     * </pre>
     */
    emUpgrade_Camera(15, 15),
    /**
     * <code>emUpgrade_Boot3519 = 16;</code>
     *
     * <pre>
     *&#47;3519升级
     * </pre>
     */
    emUpgrade_Boot3519(16, 16),
    /**
     * <code>emUpgrade_Boot3536 = 17;</code>
     *
     * <pre>
     *&#47;3536升级
     * </pre>
     */
    emUpgrade_Boot3536(17, 17),
    /**
     * <code>emUpgrade_Fpga0 = 18;</code>
     *
     * <pre>
     *&#47;Fpga0升级
     * </pre>
     */
    emUpgrade_Fpga0(18, 18),
    /**
     * <code>emUpgrade_Fpga1 = 19;</code>
     *
     * <pre>
     *&#47;Fpga1升级
     * </pre>
     */
    emUpgrade_Fpga1(19, 19),
    /**
     * <code>emUpgrade_Fpga2 = 20;</code>
     *
     * <pre>
     *&#47;Fpga2升级
     * </pre>
     */
    emUpgrade_Fpga2(20, 20),
    /**
     * <code>emUpgrade_Fpga3 = 21;</code>
     *
     * <pre>
     *&#47;Fpga3升级
     * </pre>
     */
    emUpgrade_Fpga3(21, 21),
    /**
     * <code>emUpgrade_Fpga4 = 22;</code>
     *
     * <pre>
     *&#47;Fpga4升级
     * </pre>
     */
    emUpgrade_Fpga4(22, 22),
    /**
     * <code>emUpgrade_Fpga5 = 23;</code>
     *
     * <pre>
     *&#47;Fpga5升级
     * </pre>
     */
    emUpgrade_Fpga5(23, 23),
    /**
     * <code>emUpgrade_JedFpga0 = 24;</code>
     *
     * <pre>
     *&#47;jedFpga0升级
     * </pre>
     */
    emUpgrade_JedFpga0(24, 24),
    ;

    /**
     * <code>emUpgrade_None = 0;</code>
     */
    public static final int emUpgrade_None_VALUE = 0;
    /**
     * <code>emUpgrade_UgDtb = 1;</code>
     *
     * <pre>
     *&#47;dtb升级
     * </pre>
     */
    public static final int emUpgrade_UgDtb_VALUE = 1;
    /**
     * <code>emUpgrade_UbootBin = 2;</code>
     *
     * <pre>
     *&#47;uboot.bin升级
     * </pre>
     */
    public static final int emUpgrade_UbootBin_VALUE = 2;
    /**
     * <code>emUpgrade_UbootImg = 3;</code>
     *
     * <pre>
     *&#47;uboot.img升级
     * </pre>
     */
    public static final int emUpgrade_UbootImg_VALUE = 3;
    /**
     * <code>emUpgrade_Mlo = 4;</code>
     *
     * <pre>
     *&#47;MLO升级
     * </pre>
     */
    public static final int emUpgrade_Mlo_VALUE = 4;
    /**
     * <code>emUpgrade_FpgaX500a = 5;</code>
     *
     * <pre>
     *&#47;fpga.x500a升级
     * </pre>
     */
    public static final int emUpgrade_FpgaX500a_VALUE = 5;
    /**
     * <code>emUpgrade_UgPic = 6;</code>
     *
     * <pre>
     *&#47;UgPic升级
     * </pre>
     */
    public static final int emUpgrade_UgPic_VALUE = 6;
    /**
     * <code>emUpgrade_UgIos = 7;</code>
     *
     * <pre>
     *&#47;UgIos升级
     * </pre>
     */
    public static final int emUpgrade_UgIos_VALUE = 7;
    /**
     * <code>emUpgrade_UgVcmt = 8;</code>
     *
     * <pre>
     *&#47;UgVcmt升级
     * </pre>
     */
    public static final int emUpgrade_UgVcmt_VALUE = 8;
    /**
     * <code>emUpgrade_UgApp = 9;</code>
     *
     * <pre>
     *&#47;UgApp升级
     * </pre>
     */
    public static final int emUpgrade_UgApp_VALUE = 9;
    /**
     * <code>emUpgrade_UgRecovery = 10;</code>
     *
     * <pre>
     *&#47;UgRecovery升级
     * </pre>
     */
    public static final int emUpgrade_UgRecovery_VALUE = 10;
    /**
     * <code>emUpgrade_Ugboot = 11;</code>
     *
     * <pre>
     *&#47;Ugboot升级
     * </pre>
     */
    public static final int emUpgrade_Ugboot_VALUE = 11;
    /**
     * <code>emUpgrade_UgBaseparam = 12;</code>
     *
     * <pre>
     *&#47;UgBaseparam升级
     * </pre>
     */
    public static final int emUpgrade_UgBaseparam_VALUE = 12;
    /**
     * <code>emUpgrade_UgPqparam = 13;</code>
     *
     * <pre>
     *&#47;UgPqparam升级
     * </pre>
     */
    public static final int emUpgrade_UgPqparam_VALUE = 13;
    /**
     * <code>emUpgrade_Scm = 14;</code>
     *
     * <pre>
     *&#47;SCM升级
     * </pre>
     */
    public static final int emUpgrade_Scm_VALUE = 14;
    /**
     * <code>emUpgrade_Camera = 15;</code>
     *
     * <pre>
     *&#47;Camera升级
     * </pre>
     */
    public static final int emUpgrade_Camera_VALUE = 15;
    /**
     * <code>emUpgrade_Boot3519 = 16;</code>
     *
     * <pre>
     *&#47;3519升级
     * </pre>
     */
    public static final int emUpgrade_Boot3519_VALUE = 16;
    /**
     * <code>emUpgrade_Boot3536 = 17;</code>
     *
     * <pre>
     *&#47;3536升级
     * </pre>
     */
    public static final int emUpgrade_Boot3536_VALUE = 17;
    /**
     * <code>emUpgrade_Fpga0 = 18;</code>
     *
     * <pre>
     *&#47;Fpga0升级
     * </pre>
     */
    public static final int emUpgrade_Fpga0_VALUE = 18;
    /**
     * <code>emUpgrade_Fpga1 = 19;</code>
     *
     * <pre>
     *&#47;Fpga1升级
     * </pre>
     */
    public static final int emUpgrade_Fpga1_VALUE = 19;
    /**
     * <code>emUpgrade_Fpga2 = 20;</code>
     *
     * <pre>
     *&#47;Fpga2升级
     * </pre>
     */
    public static final int emUpgrade_Fpga2_VALUE = 20;
    /**
     * <code>emUpgrade_Fpga3 = 21;</code>
     *
     * <pre>
     *&#47;Fpga3升级
     * </pre>
     */
    public static final int emUpgrade_Fpga3_VALUE = 21;
    /**
     * <code>emUpgrade_Fpga4 = 22;</code>
     *
     * <pre>
     *&#47;Fpga4升级
     * </pre>
     */
    public static final int emUpgrade_Fpga4_VALUE = 22;
    /**
     * <code>emUpgrade_Fpga5 = 23;</code>
     *
     * <pre>
     *&#47;Fpga5升级
     * </pre>
     */
    public static final int emUpgrade_Fpga5_VALUE = 23;
    /**
     * <code>emUpgrade_JedFpga0 = 24;</code>
     *
     * <pre>
     *&#47;jedFpga0升级
     * </pre>
     */
    public static final int emUpgrade_JedFpga0_VALUE = 24;


    public final int getNumber() { return value; }

    public static EmFtUpgradeType valueOf(int value) {
      switch (value) {
        case 0: return emUpgrade_None;
        case 1: return emUpgrade_UgDtb;
        case 2: return emUpgrade_UbootBin;
        case 3: return emUpgrade_UbootImg;
        case 4: return emUpgrade_Mlo;
        case 5: return emUpgrade_FpgaX500a;
        case 6: return emUpgrade_UgPic;
        case 7: return emUpgrade_UgIos;
        case 8: return emUpgrade_UgVcmt;
        case 9: return emUpgrade_UgApp;
        case 10: return emUpgrade_UgRecovery;
        case 11: return emUpgrade_Ugboot;
        case 12: return emUpgrade_UgBaseparam;
        case 13: return emUpgrade_UgPqparam;
        case 14: return emUpgrade_Scm;
        case 15: return emUpgrade_Camera;
        case 16: return emUpgrade_Boot3519;
        case 17: return emUpgrade_Boot3536;
        case 18: return emUpgrade_Fpga0;
        case 19: return emUpgrade_Fpga1;
        case 20: return emUpgrade_Fpga2;
        case 21: return emUpgrade_Fpga3;
        case 22: return emUpgrade_Fpga4;
        case 23: return emUpgrade_Fpga5;
        case 24: return emUpgrade_JedFpga0;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtUpgradeType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtUpgradeType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtUpgradeType>() {
            public EmFtUpgradeType findValueByNumber(int number) {
              return EmFtUpgradeType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(313);
    }

    private static final EmFtUpgradeType[] VALUES = values();

    public static EmFtUpgradeType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtUpgradeType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtUpgradeType)
  }

  /**
   * Protobuf enum {@code mt.EmFtUpgradeCondition}
   *
   * <pre>
   *&#47;升级条件
   * </pre>
   */
  public enum EmFtUpgradeCondition
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCondition_Always = 0;</code>
     *
     * <pre>
     *&#47;永远升级
     * </pre>
     */
    emCondition_Always(0, 0),
    /**
     * <code>emCondition_Changed = 1;</code>
     *
     * <pre>
     *&#47;变化时升级
     * </pre>
     */
    emCondition_Changed(1, 1),
    /**
     * <code>emCondition_Hwver0 = 2;</code>
     *
     * <pre>
     *&#47;hwver为0时升级
     * </pre>
     */
    emCondition_Hwver0(2, 2),
    /**
     * <code>emCondition_Hwver1 = 3;</code>
     *
     * <pre>
     *&#47;hwver为1时升级
     * </pre>
     */
    emCondition_Hwver1(3, 3),
    /**
     * <code>emCondition_Hwver2 = 4;</code>
     *
     * <pre>
     *&#47;hwver为2时升级
     * </pre>
     */
    emCondition_Hwver2(4, 4),
    /**
     * <code>emCondition_Hwver3 = 5;</code>
     *
     * <pre>
     *&#47;hwver为3时升级
     * </pre>
     */
    emCondition_Hwver3(5, 5),
    /**
     * <code>emCondition_Hwver4 = 6;</code>
     *
     * <pre>
     *&#47;hwver为4时升级
     * </pre>
     */
    emCondition_Hwver4(6, 6),
    ;

    /**
     * <code>emCondition_Always = 0;</code>
     *
     * <pre>
     *&#47;永远升级
     * </pre>
     */
    public static final int emCondition_Always_VALUE = 0;
    /**
     * <code>emCondition_Changed = 1;</code>
     *
     * <pre>
     *&#47;变化时升级
     * </pre>
     */
    public static final int emCondition_Changed_VALUE = 1;
    /**
     * <code>emCondition_Hwver0 = 2;</code>
     *
     * <pre>
     *&#47;hwver为0时升级
     * </pre>
     */
    public static final int emCondition_Hwver0_VALUE = 2;
    /**
     * <code>emCondition_Hwver1 = 3;</code>
     *
     * <pre>
     *&#47;hwver为1时升级
     * </pre>
     */
    public static final int emCondition_Hwver1_VALUE = 3;
    /**
     * <code>emCondition_Hwver2 = 4;</code>
     *
     * <pre>
     *&#47;hwver为2时升级
     * </pre>
     */
    public static final int emCondition_Hwver2_VALUE = 4;
    /**
     * <code>emCondition_Hwver3 = 5;</code>
     *
     * <pre>
     *&#47;hwver为3时升级
     * </pre>
     */
    public static final int emCondition_Hwver3_VALUE = 5;
    /**
     * <code>emCondition_Hwver4 = 6;</code>
     *
     * <pre>
     *&#47;hwver为4时升级
     * </pre>
     */
    public static final int emCondition_Hwver4_VALUE = 6;


    public final int getNumber() { return value; }

    public static EmFtUpgradeCondition valueOf(int value) {
      switch (value) {
        case 0: return emCondition_Always;
        case 1: return emCondition_Changed;
        case 2: return emCondition_Hwver0;
        case 3: return emCondition_Hwver1;
        case 4: return emCondition_Hwver2;
        case 5: return emCondition_Hwver3;
        case 6: return emCondition_Hwver4;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtUpgradeCondition>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtUpgradeCondition>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtUpgradeCondition>() {
            public EmFtUpgradeCondition findValueByNumber(int number) {
              return EmFtUpgradeCondition.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(314);
    }

    private static final EmFtUpgradeCondition[] VALUES = values();

    public static EmFtUpgradeCondition valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtUpgradeCondition(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtUpgradeCondition)
  }

  /**
   * Protobuf enum {@code mt.EmFtOpticalZoom}
   *
   * <pre>
   *&#47;光学变焦
   * </pre>
   */
  public enum EmFtOpticalZoom
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emOpticalZoom_Invalid = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    emOpticalZoom_Invalid(0, 0),
    /**
     * <code>emOpticalZoom_12X = 1;</code>
     *
     * <pre>
     *12倍光学变焦
     * </pre>
     */
    emOpticalZoom_12X(1, 1),
    /**
     * <code>emOpticalZoom_5X = 2;</code>
     *
     * <pre>
     *5倍光学变焦
     * </pre>
     */
    emOpticalZoom_5X(2, 2),
    ;

    /**
     * <code>emOpticalZoom_Invalid = 0;</code>
     *
     * <pre>
     *无效值
     * </pre>
     */
    public static final int emOpticalZoom_Invalid_VALUE = 0;
    /**
     * <code>emOpticalZoom_12X = 1;</code>
     *
     * <pre>
     *12倍光学变焦
     * </pre>
     */
    public static final int emOpticalZoom_12X_VALUE = 1;
    /**
     * <code>emOpticalZoom_5X = 2;</code>
     *
     * <pre>
     *5倍光学变焦
     * </pre>
     */
    public static final int emOpticalZoom_5X_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmFtOpticalZoom valueOf(int value) {
      switch (value) {
        case 0: return emOpticalZoom_Invalid;
        case 1: return emOpticalZoom_12X;
        case 2: return emOpticalZoom_5X;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtOpticalZoom>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtOpticalZoom>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtOpticalZoom>() {
            public EmFtOpticalZoom findValueByNumber(int number) {
              return EmFtOpticalZoom.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(315);
    }

    private static final EmFtOpticalZoom[] VALUES = values();

    public static EmFtOpticalZoom valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtOpticalZoom(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtOpticalZoom)
  }

  /**
   * Protobuf enum {@code mt.EmFtInfoType}
   *
   * <pre>
   *终端特性信息类型
   * </pre>
   */
  public enum EmFtInfoType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFtInfoBegin = 0;</code>
     */
    emFtInfoBegin(0, 0),
    /**
     * <code>emFtCameraCtrl = 1;</code>
     *
     * <pre>
     *摄像机及其控制类型 (value: TFtCameraParamList)
     * </pre>
     */
    emFtCameraCtrl(1, 1),
    /**
     * <code>emFtDeviceSerial = 2;</code>
     *
     * <pre>
     *串口列表(value: TFtSerialCtrlList)
     * </pre>
     */
    emFtDeviceSerial(2, 2),
    /**
     * <code>emFtSupportNet = 3;</code>
     *
     * <pre>
     *支持网口列表(value: TFtNetCtrl)
     * </pre>
     */
    emFtSupportNet(3, 3),
    /**
     * <code>emFtDeviceUsb = 4;</code>
     *
     * <pre>
     *usb列表(value: TFtUsbParamList)
     * </pre>
     */
    emFtDeviceUsb(4, 4),
    /**
     * <code>emFtDualStream = 5;</code>
     *
     * <pre>
     *支持双流列表(value: TFtDualStreamList)
     * </pre>
     */
    emFtDualStream(5, 5),
    /**
     * <code>emFtSupportFxo = 6;</code>
     *
     * <pre>
     *支持fxo (BOOL32)
     * </pre>
     */
    emFtSupportFxo(6, 6),
    /**
     * <code>emFtAudioInfo = 7;</code>
     *
     * <pre>
     *支持音频列表(value: TFtAudioList)
     * </pre>
     */
    emFtAudioInfo(7, 7),
    /**
     * <code>emFtVideoInList = 8;</code>
     *
     * <pre>
     *暂时不用, 支持视频输入列表(value: TFtVideoInportList)          
     * </pre>
     */
    emFtVideoInList(8, 8),
    /**
     * <code>emFtVideoInPort = 9;</code>
     *
     * <pre>
     *支持视频输入口功能列表(value: TFtVideoInportList)           
     * </pre>
     */
    emFtVideoInPort(9, 9),
    /**
     * <code>emFtVideoOutPort = 10;</code>
     *
     * <pre>
     *支持视频输出口功能列表(value: TFtVideoOutportList)           
     * </pre>
     */
    emFtVideoOutPort(10, 10),
    /**
     * <code>emFtSdiinoutGet = 11;</code>
     *
     * <pre>
     *sdi输入输出获取方式(value: TFtSdiList)            
     * </pre>
     */
    emFtSdiinoutGet(11, 11),
    /**
     * <code>emFtOsdCut = 12;</code>
     *
     * <pre>
     *osd抠图方式(value: TFtOsdCutOutList)                
     * </pre>
     */
    emFtOsdCut(12, 12),
    /**
     * <code>emFtOutputModeDisplay = 13;</code>
     *
     * <pre>
     *界面支持的输出制式列表(value: TFtOutputModeList)       
     * </pre>
     */
    emFtOutputModeDisplay(13, 13),
    /**
     * <code>emFtSourceToOutputMode = 14;</code>
     *
     * <pre>
     *业务使用的码流转输出制式列表(value: TFtResolutionList)     
     * </pre>
     */
    emFtSourceToOutputMode(14, 14),
    /**
     * <code>emFtMediaCapbility = 15;</code>
     *
     * <pre>
     *能力集(value: TFtMediaCapbility)         
     * </pre>
     */
    emFtMediaCapbility(15, 15),
    /**
     * <code>emFtVidEncRestrict = 16;</code>
     *
     * <pre>
     *编码能力限制(value: TFtChanEncRelationList)
     * </pre>
     */
    emFtVidEncRestrict(16, 16),
    /**
     * <code>emFtMultiVideoCapbility = 17;</code>
     *
     * <pre>
     *多视多流能力(value: TFtMultiVideoParam)
     * </pre>
     */
    emFtMultiVideoCapbility(17, 17),
    /**
     * <code>emFtSupportMaxVidSrc = 18;</code>
     *
     * <pre>
     *终端支持的最大源制式 (u32)
     * </pre>
     */
    emFtSupportMaxVidSrc(18, 18),
    /**
     * <code>emFtInnerCamStdSupport = 19;</code>
     *
     * <pre>
     *内置摄像机支持制式(value: TFtInnerCameraVidStdList)
     * </pre>
     */
    emFtInnerCamStdSupport(19, 19),
    /**
     * <code>emFtMaxOsdSupportRes = 20;</code>
     *
     * <pre>
     *osd支持的最大制式(value: TFtMaxOsdParam)
     * </pre>
     */
    emFtMaxOsdSupportRes(20, 20),
    /**
     * <code>emFtAudPlyFormat = 21;</code>
     *
     * <pre>
     *音频文件格式 (u32)
     * </pre>
     */
    emFtAudPlyFormat(21, 21),
    /**
     * <code>emFtFirmwareInfo = 22;</code>
     *
     * <pre>
     *固件信息(value: TFtFirmwareInfoList)
     * </pre>
     */
    emFtFirmwareInfo(22, 22),
    /**
     * <code>emFtReleaseInfo = 23;</code>
     *
     * <pre>
     *发布文件信息(value: TFtReleaseInfo)
     * </pre>
     */
    emFtReleaseInfo(23, 23),
    /**
     * <code>emFtResetInfo = 24;</code>
     *
     * <pre>
     *重置信息列表(value: TFtResetInfoList)
     * </pre>
     */
    emFtResetInfo(24, 24),
    /**
     * <code>emFtShortMsgInfo = 25;</code>
     *
     * <pre>
     *短消息属性(value: TFtShortMsgInfoList)
     * </pre>
     */
    emFtShortMsgInfo(25, 25),
    /**
     * <code>emFtOsdScale = 26;</code>
     *
     * <pre>
     *osd叠加缩放类型 (u32)
     * </pre>
     */
    emFtOsdScale(26, 26),
    /**
     * <code>emFtH323StandardPro = 27;</code>
     *
     * <pre>
     *是否323标准协议栈 (BOOL32)
     * </pre>
     */
    emFtH323StandardPro(27, 27),
    /**
     * <code>emFtTerminalInfo = 28;</code>
     *
     * <pre>
     *终端属性：商密等(value: TFtTerminalInfo)
     * </pre>
     */
    emFtTerminalInfo(28, 28),
    /**
     * <code>emFtSupportMicNum = 29;</code>
     *
     * <pre>
     *终端支持麦克风数量(value: TFtSupportMicNum)
     * </pre>
     */
    emFtSupportMicNum(29, 29),
    /**
     * <code>emFtMtUpgradeCfg = 30;</code>
     *
     * <pre>
     *终端升级特征(value: TFtMtUpgradeList)
     * </pre>
     */
    emFtMtUpgradeCfg(30, 30),
    /**
     * <code>emFtMtVerRestrict = 31;</code>
     *
     * <pre>
     *终端版本限制 (s8)
     * </pre>
     */
    emFtMtVerRestrict(31, 31),
    /**
     * <code>emFtMediaBoardInfo = 32;</code>
     *
     * <pre>
     *媒体开发板信息(value: TMediaBoardInfo)
     * </pre>
     */
    emFtMediaBoardInfo(32, 32),
    /**
     * <code>emFtSrvLoginInfo = 33;</code>
     *
     * <pre>
     *支持的服务器登录列表(value: TFtLoginList)
     * </pre>
     */
    emFtSrvLoginInfo(33, 33),
    /**
     * <code>emFtLimitAttribute = 34;</code>
     *
     * <pre>
     *终端临界属性(value: TFtLimitAttribute)
     * </pre>
     */
    emFtLimitAttribute(34, 34),
    /**
     * <code>emFtUIDisplayInfo = 35;</code>
     *
     * <pre>
     *界面显示顺序列表(value: TFtDisplayList)
     * </pre>
     */
    emFtUIDisplayInfo(35, 35),
    /**
     * <code>emFtInnerCameraList = 36;</code>
     *
     * <pre>
     *内置摄像机支持功能(value: TFtInnerCameraParamList)
     * </pre>
     */
    emFtInnerCameraList(36, 36),
    ;

    /**
     * <code>emFtInfoBegin = 0;</code>
     */
    public static final int emFtInfoBegin_VALUE = 0;
    /**
     * <code>emFtCameraCtrl = 1;</code>
     *
     * <pre>
     *摄像机及其控制类型 (value: TFtCameraParamList)
     * </pre>
     */
    public static final int emFtCameraCtrl_VALUE = 1;
    /**
     * <code>emFtDeviceSerial = 2;</code>
     *
     * <pre>
     *串口列表(value: TFtSerialCtrlList)
     * </pre>
     */
    public static final int emFtDeviceSerial_VALUE = 2;
    /**
     * <code>emFtSupportNet = 3;</code>
     *
     * <pre>
     *支持网口列表(value: TFtNetCtrl)
     * </pre>
     */
    public static final int emFtSupportNet_VALUE = 3;
    /**
     * <code>emFtDeviceUsb = 4;</code>
     *
     * <pre>
     *usb列表(value: TFtUsbParamList)
     * </pre>
     */
    public static final int emFtDeviceUsb_VALUE = 4;
    /**
     * <code>emFtDualStream = 5;</code>
     *
     * <pre>
     *支持双流列表(value: TFtDualStreamList)
     * </pre>
     */
    public static final int emFtDualStream_VALUE = 5;
    /**
     * <code>emFtSupportFxo = 6;</code>
     *
     * <pre>
     *支持fxo (BOOL32)
     * </pre>
     */
    public static final int emFtSupportFxo_VALUE = 6;
    /**
     * <code>emFtAudioInfo = 7;</code>
     *
     * <pre>
     *支持音频列表(value: TFtAudioList)
     * </pre>
     */
    public static final int emFtAudioInfo_VALUE = 7;
    /**
     * <code>emFtVideoInList = 8;</code>
     *
     * <pre>
     *暂时不用, 支持视频输入列表(value: TFtVideoInportList)          
     * </pre>
     */
    public static final int emFtVideoInList_VALUE = 8;
    /**
     * <code>emFtVideoInPort = 9;</code>
     *
     * <pre>
     *支持视频输入口功能列表(value: TFtVideoInportList)           
     * </pre>
     */
    public static final int emFtVideoInPort_VALUE = 9;
    /**
     * <code>emFtVideoOutPort = 10;</code>
     *
     * <pre>
     *支持视频输出口功能列表(value: TFtVideoOutportList)           
     * </pre>
     */
    public static final int emFtVideoOutPort_VALUE = 10;
    /**
     * <code>emFtSdiinoutGet = 11;</code>
     *
     * <pre>
     *sdi输入输出获取方式(value: TFtSdiList)            
     * </pre>
     */
    public static final int emFtSdiinoutGet_VALUE = 11;
    /**
     * <code>emFtOsdCut = 12;</code>
     *
     * <pre>
     *osd抠图方式(value: TFtOsdCutOutList)                
     * </pre>
     */
    public static final int emFtOsdCut_VALUE = 12;
    /**
     * <code>emFtOutputModeDisplay = 13;</code>
     *
     * <pre>
     *界面支持的输出制式列表(value: TFtOutputModeList)       
     * </pre>
     */
    public static final int emFtOutputModeDisplay_VALUE = 13;
    /**
     * <code>emFtSourceToOutputMode = 14;</code>
     *
     * <pre>
     *业务使用的码流转输出制式列表(value: TFtResolutionList)     
     * </pre>
     */
    public static final int emFtSourceToOutputMode_VALUE = 14;
    /**
     * <code>emFtMediaCapbility = 15;</code>
     *
     * <pre>
     *能力集(value: TFtMediaCapbility)         
     * </pre>
     */
    public static final int emFtMediaCapbility_VALUE = 15;
    /**
     * <code>emFtVidEncRestrict = 16;</code>
     *
     * <pre>
     *编码能力限制(value: TFtChanEncRelationList)
     * </pre>
     */
    public static final int emFtVidEncRestrict_VALUE = 16;
    /**
     * <code>emFtMultiVideoCapbility = 17;</code>
     *
     * <pre>
     *多视多流能力(value: TFtMultiVideoParam)
     * </pre>
     */
    public static final int emFtMultiVideoCapbility_VALUE = 17;
    /**
     * <code>emFtSupportMaxVidSrc = 18;</code>
     *
     * <pre>
     *终端支持的最大源制式 (u32)
     * </pre>
     */
    public static final int emFtSupportMaxVidSrc_VALUE = 18;
    /**
     * <code>emFtInnerCamStdSupport = 19;</code>
     *
     * <pre>
     *内置摄像机支持制式(value: TFtInnerCameraVidStdList)
     * </pre>
     */
    public static final int emFtInnerCamStdSupport_VALUE = 19;
    /**
     * <code>emFtMaxOsdSupportRes = 20;</code>
     *
     * <pre>
     *osd支持的最大制式(value: TFtMaxOsdParam)
     * </pre>
     */
    public static final int emFtMaxOsdSupportRes_VALUE = 20;
    /**
     * <code>emFtAudPlyFormat = 21;</code>
     *
     * <pre>
     *音频文件格式 (u32)
     * </pre>
     */
    public static final int emFtAudPlyFormat_VALUE = 21;
    /**
     * <code>emFtFirmwareInfo = 22;</code>
     *
     * <pre>
     *固件信息(value: TFtFirmwareInfoList)
     * </pre>
     */
    public static final int emFtFirmwareInfo_VALUE = 22;
    /**
     * <code>emFtReleaseInfo = 23;</code>
     *
     * <pre>
     *发布文件信息(value: TFtReleaseInfo)
     * </pre>
     */
    public static final int emFtReleaseInfo_VALUE = 23;
    /**
     * <code>emFtResetInfo = 24;</code>
     *
     * <pre>
     *重置信息列表(value: TFtResetInfoList)
     * </pre>
     */
    public static final int emFtResetInfo_VALUE = 24;
    /**
     * <code>emFtShortMsgInfo = 25;</code>
     *
     * <pre>
     *短消息属性(value: TFtShortMsgInfoList)
     * </pre>
     */
    public static final int emFtShortMsgInfo_VALUE = 25;
    /**
     * <code>emFtOsdScale = 26;</code>
     *
     * <pre>
     *osd叠加缩放类型 (u32)
     * </pre>
     */
    public static final int emFtOsdScale_VALUE = 26;
    /**
     * <code>emFtH323StandardPro = 27;</code>
     *
     * <pre>
     *是否323标准协议栈 (BOOL32)
     * </pre>
     */
    public static final int emFtH323StandardPro_VALUE = 27;
    /**
     * <code>emFtTerminalInfo = 28;</code>
     *
     * <pre>
     *终端属性：商密等(value: TFtTerminalInfo)
     * </pre>
     */
    public static final int emFtTerminalInfo_VALUE = 28;
    /**
     * <code>emFtSupportMicNum = 29;</code>
     *
     * <pre>
     *终端支持麦克风数量(value: TFtSupportMicNum)
     * </pre>
     */
    public static final int emFtSupportMicNum_VALUE = 29;
    /**
     * <code>emFtMtUpgradeCfg = 30;</code>
     *
     * <pre>
     *终端升级特征(value: TFtMtUpgradeList)
     * </pre>
     */
    public static final int emFtMtUpgradeCfg_VALUE = 30;
    /**
     * <code>emFtMtVerRestrict = 31;</code>
     *
     * <pre>
     *终端版本限制 (s8)
     * </pre>
     */
    public static final int emFtMtVerRestrict_VALUE = 31;
    /**
     * <code>emFtMediaBoardInfo = 32;</code>
     *
     * <pre>
     *媒体开发板信息(value: TMediaBoardInfo)
     * </pre>
     */
    public static final int emFtMediaBoardInfo_VALUE = 32;
    /**
     * <code>emFtSrvLoginInfo = 33;</code>
     *
     * <pre>
     *支持的服务器登录列表(value: TFtLoginList)
     * </pre>
     */
    public static final int emFtSrvLoginInfo_VALUE = 33;
    /**
     * <code>emFtLimitAttribute = 34;</code>
     *
     * <pre>
     *终端临界属性(value: TFtLimitAttribute)
     * </pre>
     */
    public static final int emFtLimitAttribute_VALUE = 34;
    /**
     * <code>emFtUIDisplayInfo = 35;</code>
     *
     * <pre>
     *界面显示顺序列表(value: TFtDisplayList)
     * </pre>
     */
    public static final int emFtUIDisplayInfo_VALUE = 35;
    /**
     * <code>emFtInnerCameraList = 36;</code>
     *
     * <pre>
     *内置摄像机支持功能(value: TFtInnerCameraParamList)
     * </pre>
     */
    public static final int emFtInnerCameraList_VALUE = 36;


    public final int getNumber() { return value; }

    public static EmFtInfoType valueOf(int value) {
      switch (value) {
        case 0: return emFtInfoBegin;
        case 1: return emFtCameraCtrl;
        case 2: return emFtDeviceSerial;
        case 3: return emFtSupportNet;
        case 4: return emFtDeviceUsb;
        case 5: return emFtDualStream;
        case 6: return emFtSupportFxo;
        case 7: return emFtAudioInfo;
        case 8: return emFtVideoInList;
        case 9: return emFtVideoInPort;
        case 10: return emFtVideoOutPort;
        case 11: return emFtSdiinoutGet;
        case 12: return emFtOsdCut;
        case 13: return emFtOutputModeDisplay;
        case 14: return emFtSourceToOutputMode;
        case 15: return emFtMediaCapbility;
        case 16: return emFtVidEncRestrict;
        case 17: return emFtMultiVideoCapbility;
        case 18: return emFtSupportMaxVidSrc;
        case 19: return emFtInnerCamStdSupport;
        case 20: return emFtMaxOsdSupportRes;
        case 21: return emFtAudPlyFormat;
        case 22: return emFtFirmwareInfo;
        case 23: return emFtReleaseInfo;
        case 24: return emFtResetInfo;
        case 25: return emFtShortMsgInfo;
        case 26: return emFtOsdScale;
        case 27: return emFtH323StandardPro;
        case 28: return emFtTerminalInfo;
        case 29: return emFtSupportMicNum;
        case 30: return emFtMtUpgradeCfg;
        case 31: return emFtMtVerRestrict;
        case 32: return emFtMediaBoardInfo;
        case 33: return emFtSrvLoginInfo;
        case 34: return emFtLimitAttribute;
        case 35: return emFtUIDisplayInfo;
        case 36: return emFtInnerCameraList;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFtInfoType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFtInfoType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFtInfoType>() {
            public EmFtInfoType findValueByNumber(int number) {
              return EmFtInfoType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(316);
    }

    private static final EmFtInfoType[] VALUES = values();

    public static EmFtInfoType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFtInfoType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFtInfoType)
  }

  /**
   * Protobuf enum {@code mt.EmShortCutKeyType}
   */
  public enum EmShortCutKeyType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emUnkown = 0;</code>
     *
     * <pre>
     *&#47;未知
     * </pre>
     */
    emUnkown(0, 0),
    /**
     * <code>emRedShortCutKey = 1;</code>
     *
     * <pre>
     *&#47;红色快捷键
     * </pre>
     */
    emRedShortCutKey(1, 1),
    /**
     * <code>emYellowShortCutKey = 2;</code>
     *
     * <pre>
     *&#47;黄色快捷键
     * </pre>
     */
    emYellowShortCutKey(2, 2),
    /**
     * <code>emGreenShortCutKey = 3;</code>
     *
     * <pre>
     *&#47;绿色快捷键
     * </pre>
     */
    emGreenShortCutKey(3, 3),
    ;

    /**
     * <code>emUnkown = 0;</code>
     *
     * <pre>
     *&#47;未知
     * </pre>
     */
    public static final int emUnkown_VALUE = 0;
    /**
     * <code>emRedShortCutKey = 1;</code>
     *
     * <pre>
     *&#47;红色快捷键
     * </pre>
     */
    public static final int emRedShortCutKey_VALUE = 1;
    /**
     * <code>emYellowShortCutKey = 2;</code>
     *
     * <pre>
     *&#47;黄色快捷键
     * </pre>
     */
    public static final int emYellowShortCutKey_VALUE = 2;
    /**
     * <code>emGreenShortCutKey = 3;</code>
     *
     * <pre>
     *&#47;绿色快捷键
     * </pre>
     */
    public static final int emGreenShortCutKey_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmShortCutKeyType valueOf(int value) {
      switch (value) {
        case 0: return emUnkown;
        case 1: return emRedShortCutKey;
        case 2: return emYellowShortCutKey;
        case 3: return emGreenShortCutKey;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmShortCutKeyType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmShortCutKeyType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmShortCutKeyType>() {
            public EmShortCutKeyType findValueByNumber(int number) {
              return EmShortCutKeyType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(317);
    }

    private static final EmShortCutKeyType[] VALUES = values();

    public static EmShortCutKeyType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmShortCutKeyType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmShortCutKeyType)
  }

  /**
   * Protobuf enum {@code mt.EmShortCutKeyFuc}
   */
  public enum EmShortCutKeyFuc
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFucBegin = 0;</code>
     */
    emFucBegin(0, 0),
    /**
     * <code>emLoop = 1;</code>
     *
     * <pre>
     *&#47;自环
     * </pre>
     */
    emLoop(1, 1),
    /**
     * <code>emApplyChair = 2;</code>
     *
     * <pre>
     *&#47;申请主席
     * </pre>
     */
    emApplyChair(2, 2),
    /**
     * <code>emApplySpeaker = 3;</code>
     *
     * <pre>
     *&#47;申请主讲
     * </pre>
     */
    emApplySpeaker(3, 3),
    /**
     * <code>emShowSystemInfo = 4;</code>
     *
     * <pre>
     *&#47;显示系统信息
     * </pre>
     */
    emShowSystemInfo(4, 4),
    /**
     * <code>emFullMute = 5;</code>
     *
     * <pre>
     *&#47;全场哑音
     * </pre>
     */
    emFullMute(5, 5),
    /**
     * <code>emSpeechHelper = 6;</code>
     *
     * <pre>
     *&#47;语音助手
     * </pre>
     */
    emSpeechHelper(6, 6),
    /**
     * <code>emFaceCheckIn = 7;</code>
     *
     * <pre>
     *&#47;人脸签到
     * </pre>
     */
    emFaceCheckIn(7, 7),
    /**
     * <code>emClose = 20;</code>
     *
     * <pre>
     *&#47;关闭功能
     * </pre>
     */
    emClose(8, 20),
    ;

    /**
     * <code>emFucBegin = 0;</code>
     */
    public static final int emFucBegin_VALUE = 0;
    /**
     * <code>emLoop = 1;</code>
     *
     * <pre>
     *&#47;自环
     * </pre>
     */
    public static final int emLoop_VALUE = 1;
    /**
     * <code>emApplyChair = 2;</code>
     *
     * <pre>
     *&#47;申请主席
     * </pre>
     */
    public static final int emApplyChair_VALUE = 2;
    /**
     * <code>emApplySpeaker = 3;</code>
     *
     * <pre>
     *&#47;申请主讲
     * </pre>
     */
    public static final int emApplySpeaker_VALUE = 3;
    /**
     * <code>emShowSystemInfo = 4;</code>
     *
     * <pre>
     *&#47;显示系统信息
     * </pre>
     */
    public static final int emShowSystemInfo_VALUE = 4;
    /**
     * <code>emFullMute = 5;</code>
     *
     * <pre>
     *&#47;全场哑音
     * </pre>
     */
    public static final int emFullMute_VALUE = 5;
    /**
     * <code>emSpeechHelper = 6;</code>
     *
     * <pre>
     *&#47;语音助手
     * </pre>
     */
    public static final int emSpeechHelper_VALUE = 6;
    /**
     * <code>emFaceCheckIn = 7;</code>
     *
     * <pre>
     *&#47;人脸签到
     * </pre>
     */
    public static final int emFaceCheckIn_VALUE = 7;
    /**
     * <code>emClose = 20;</code>
     *
     * <pre>
     *&#47;关闭功能
     * </pre>
     */
    public static final int emClose_VALUE = 20;


    public final int getNumber() { return value; }

    public static EmShortCutKeyFuc valueOf(int value) {
      switch (value) {
        case 0: return emFucBegin;
        case 1: return emLoop;
        case 2: return emApplyChair;
        case 3: return emApplySpeaker;
        case 4: return emShowSystemInfo;
        case 5: return emFullMute;
        case 6: return emSpeechHelper;
        case 7: return emFaceCheckIn;
        case 20: return emClose;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmShortCutKeyFuc>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmShortCutKeyFuc>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmShortCutKeyFuc>() {
            public EmShortCutKeyFuc findValueByNumber(int number) {
              return EmShortCutKeyFuc.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(318);
    }

    private static final EmShortCutKeyFuc[] VALUES = values();

    public static EmShortCutKeyFuc valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmShortCutKeyFuc(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmShortCutKeyFuc)
  }

  /**
   * Protobuf enum {@code mt.EmHwStatus}
   */
  public enum EmHwStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emNotDetected = 0;</code>
     *
     * <pre>
     *还未检测是否支持硬编硬解功能（初始化状态）
     * </pre>
     */
    emNotDetected(0, 0),
    /**
     * <code>emUnsupported = 1;</code>
     *
     * <pre>
     *当前PC不支持硬编硬解功能（不支持）
     * </pre>
     */
    emUnsupported(1, 1),
    /**
     * <code>emSupportedAndOpened = 2;</code>
     *
     * <pre>
     *支持硬编硬解，并且已开启（已开启）
     * </pre>
     */
    emSupportedAndOpened(2, 2),
    /**
     * <code>emSupportedAndClosed = 3;</code>
     *
     * <pre>
     *支持硬编硬解，并且已关闭（未开启）
     * </pre>
     */
    emSupportedAndClosed(3, 3),
    ;

    /**
     * <code>emNotDetected = 0;</code>
     *
     * <pre>
     *还未检测是否支持硬编硬解功能（初始化状态）
     * </pre>
     */
    public static final int emNotDetected_VALUE = 0;
    /**
     * <code>emUnsupported = 1;</code>
     *
     * <pre>
     *当前PC不支持硬编硬解功能（不支持）
     * </pre>
     */
    public static final int emUnsupported_VALUE = 1;
    /**
     * <code>emSupportedAndOpened = 2;</code>
     *
     * <pre>
     *支持硬编硬解，并且已开启（已开启）
     * </pre>
     */
    public static final int emSupportedAndOpened_VALUE = 2;
    /**
     * <code>emSupportedAndClosed = 3;</code>
     *
     * <pre>
     *支持硬编硬解，并且已关闭（未开启）
     * </pre>
     */
    public static final int emSupportedAndClosed_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmHwStatus valueOf(int value) {
      switch (value) {
        case 0: return emNotDetected;
        case 1: return emUnsupported;
        case 2: return emSupportedAndOpened;
        case 3: return emSupportedAndClosed;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmHwStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmHwStatus>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmHwStatus>() {
            public EmHwStatus findValueByNumber(int number) {
              return EmHwStatus.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(319);
    }

    private static final EmHwStatus[] VALUES = values();

    public static EmHwStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmHwStatus(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmHwStatus)
  }

  /**
   * Protobuf enum {@code mt.EmDefaultCfgType}
   *
   * <pre>
   *mt os default cfg
   * </pre>
   */
  public enum EmDefaultCfgType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCfgInfoBegin = 0;</code>
     */
    emCfgInfoBegin(0, 0),
    /**
     * <code>emCfgPriVidEncParam = 1;</code>
     *
     * <pre>
     *主视频编码器参数  (value: TMTAllVideoEncoderParamCfg)
     * </pre>
     */
    emCfgPriVidEncParam(1, 1),
    /**
     * <code>emCfgAssVidEncParam = 2;</code>
     *
     * <pre>
     *辅视频编码器参数  (value: TMTAllVideoEncoderParamCfg)
     * </pre>
     */
    emCfgAssVidEncParam(2, 2),
    /**
     * <code>emCfgPriVidPrior = 3;</code>
     *
     * <pre>
     *主流优选(value: TMTMainVideoPriorCfg)
     * </pre>
     */
    emCfgPriVidPrior(3, 3),
    /**
     * <code>emCfgPcAssVidPrior = 4;</code>
     *
     * <pre>
     *pc辅流优选(value: TVidPriorParam)
     * </pre>
     */
    emCfgPcAssVidPrior(4, 4),
    /**
     * <code>emCfgVidAssVidPrior = 5;</code>
     *
     * <pre>
     *vido辅流优选(value: TVidPriorParam) 	
     * </pre>
     */
    emCfgVidAssVidPrior(5, 5),
    /**
     * <code>emCfgPort = 6;</code>
     *
     * <pre>
     *设置TCP/UDP起始端口配置信息 (value: TMTPortCfg)
     * </pre>
     */
    emCfgPort(6, 6),
    /**
     * <code>emCfgHDResOutput = 7;</code>
     *
     * <pre>
     *视频输出制式(value: TMTVideoOutPortMode )
     * </pre>
     */
    emCfgHDResOutput(7, 7),
    /**
     * <code>emCfgMtcBannerInfo = 8;</code>
     *
     * <pre>
     *mtc横幅预案配置(value: TMTBannerInfoList )
     * </pre>
     */
    emCfgMtcBannerInfo(8, 8),
    /**
     * <code>emCfgOsdBannerInfo = 9;</code>
     *
     * <pre>
     *OSD横幅配置(value: TMTBannerInfo )
     * </pre>
     */
    emCfgOsdBannerInfo(9, 9),
    /**
     * <code>emCfgAudOutPortList = 10;</code>
     *
     * <pre>
     *音频输出接口(value: TMTHDAudOutPortList )
     * </pre>
     */
    emCfgAudOutPortList(10, 10),
    /**
     * <code>emCfgAudInPortList = 11;</code>
     *
     * <pre>
     *主音频输入接口(value: TMTHDAudInPortList )
     * </pre>
     */
    emCfgAudInPortList(11, 11),
    /**
     * <code>emCfgPri1stVidInPort = 12;</code>
     *
     * <pre>
     *设置第一路主视频输入端口(value: TMTHDVidInPort )
     * </pre>
     */
    emCfgPri1stVidInPort(12, 12),
    /**
     * <code>emCfgPri2ndVidInPort = 13;</code>
     *
     * <pre>
     *设置第二路主视频输入端口(value: TMTHDVidInPort )
     * </pre>
     */
    emCfgPri2ndVidInPort(13, 13),
    /**
     * <code>emCfgPri3rdVidInPort = 14;</code>
     *
     * <pre>
     *设置第三路主视频输入端口(value: TMTHDVidInPort )
     * </pre>
     */
    emCfgPri3rdVidInPort(14, 14),
    /**
     * <code>emCfgAssVidInPort = 15;</code>
     *
     * <pre>
     *设置辅视频输入端口(value: TMTHDVidInPort )
     * </pre>
     */
    emCfgAssVidInPort(15, 15),
    /**
     * <code>emCfgMultiVideo = 16;</code>
     *
     * <pre>
     *设置多视或多流(value: TMTHDMultiVideo )
     * </pre>
     */
    emCfgMultiVideo(16, 16),
    /**
     * <code>emCfgVideoMatrixScheme = 17;</code>
     *
     * <pre>
     *视频矩阵(value: TMTAllVideoMatrixScheme )
     * </pre>
     */
    emCfgVideoMatrixScheme(17, 17),
    /**
     * <code>emCfgSerialList = 18;</code>
     *
     * <pre>
     *串口配置(value: TMTHDSerialList )
     * </pre>
     */
    emCfgSerialList(18, 18),
    /**
     * <code>emCfgSerialMonitorList = 19;</code>
     *
     * <pre>
     *串口监听配置(value: TMTHDSerialMonitorList )
     * </pre>
     */
    emCfgSerialMonitorList(19, 19),
    /**
     * <code>emCfgVideoSrcTag = 20;</code>
     *
     * <pre>
     *视频源输入标签 (value:TMTVideoSrcTagList)
     * </pre>
     */
    emCfgVideoSrcTag(20, 20),
    /**
     * <code>emCfgVideoOutTag = 21;</code>
     *
     * <pre>
     *视频源输出标签 (value:TMTVideoOutTagList)
     * </pre>
     */
    emCfgVideoOutTag(21, 21),
    /**
     * <code>emCfgCameraList = 22;</code>
     *
     * <pre>
     *摄像机配置(value: TMTHDCameraList )
     * </pre>
     */
    emCfgCameraList(22, 22),
    /**
     * <code>emCfgVidInPortBright = 23;</code>
     *
     * <pre>
     *视频输入接口亮度 (value:TMtVideoPortParamList )
     * </pre>
     */
    emCfgVidInPortBright(23, 23),
    /**
     * <code>emCfgVidInPortContrast = 24;</code>
     *
     * <pre>
     *视频输入接口对比度 (value:TMtVideoPortParamList )
     * </pre>
     */
    emCfgVidInPortContrast(24, 24),
    /**
     * <code>emCfgVidInPortSaturation = 25;</code>
     *
     * <pre>
     *视频输入接口饱和度 (value:TMtVideoPortParamList )
     * </pre>
     */
    emCfgVidInPortSaturation(25, 25),
    /**
     * <code>emCfgAnswerMode = 26;</code>
     *
     * <pre>
     *应答模式(value:TU32)	
     * </pre>
     */
    emCfgAnswerMode(26, 26),
    /**
     * <code>emCfgAutoCall = 27;</code>
     *
     * <pre>
     *自动呼叫(value:TMTAutoCall)		
     * </pre>
     */
    emCfgAutoCall(27, 27),
    /**
     * <code>emCfgBandWithTest = 28;</code>
     *
     * <pre>
     *自动检测码率(value:TBOOL32)	
     * </pre>
     */
    emCfgBandWithTest(28, 28),
    /**
     * <code>emCfgCallBitrate = 29;</code>
     *
     * <pre>
     *呼叫码率与默认呼叫码率(value:TMultiU32)	
     * </pre>
     */
    emCfgCallBitrate(29, 29),
    /**
     * <code>emCfgkeepAliveItrvl = 30;</code>
     *
     * <pre>
     *323断链检测时间(value:TU32)
     * </pre>
     */
    emCfgkeepAliveItrvl(30, 30),
    /**
     * <code>emCfgSipkeepAliveItrvl = 31;</code>
     *
     * <pre>
     *sip断链检测时间(value:TU32)
     * </pre>
     */
    emCfgSipkeepAliveItrvl(31, 31),
    /**
     * <code>emCfgStaticPic = 32;</code>
     *
     * <pre>
     *静态图片(value:TBOOL32)		
     * </pre>
     */
    emCfgStaticPic(32, 32),
    /**
     * <code>emCfgAutoPip = 33;</code>
     *
     * <pre>
     *自动多画面显示(value:TBOOL32)		
     * </pre>
     */
    emCfgAutoPip(33, 33),
    /**
     * <code>emCfgAutoSendSharedCont = 34;</code>
     *
     * <pre>
     *自动发送内容共享(value:TBOOL32)
     * </pre>
     */
    emCfgAutoSendSharedCont(34, 34),
    /**
     * <code>emCfgDualStramSrcAdj = 35;</code>
     *
     * <pre>
     *辅视频源自动(value:TBOOL32)
     * </pre>
     */
    emCfgDualStramSrcAdj(35, 35),
    /**
     * <code>emCfgCallProtocol = 36;</code>
     *
     * <pre>
     *主呼协议(value:TMTCallerProtocol)	
     * </pre>
     */
    emCfgCallProtocol(36, 36),
    /**
     * <code>emCfgAudioPrior = 37;</code>
     *
     * <pre>
     *优选音频协议(value:TMTAudioPriorCfg)	
     * </pre>
     */
    emCfgAudioPrior(37, 37),
    /**
     * <code>emCfgH264Svc = 38;</code>
     *
     * <pre>
     *h264scv(value:TBOOL32)
     * </pre>
     */
    emCfgH264Svc(38, 38),
    /**
     * <code>emCfgH323 = 39;</code>
     *
     * <pre>
     *H239(value:TMtH323Cfg)
     * </pre>
     */
    emCfgH323(39, 39),
    /**
     * <code>emCfgSip = 40;</code>
     *
     * <pre>
     *bfcp(value:TMtSipCfg)
     * </pre>
     */
    emCfgSip(40, 40),
    /**
     * <code>emCfgLabelInfo = 41;</code>
     *
     * <pre>
     *台标(value:TMTLabelInfo)	
     * </pre>
     */
    emCfgLabelInfo(41, 41),
    /**
     * <code>emCfgCallInRing = 42;</code>
     *
     * <pre>
     *呼入铃声(value:TU32)
     * </pre>
     */
    emCfgCallInRing(42, 42),
    /**
     * <code>emCfgCallOutRing = 43;</code>
     *
     * <pre>
     *呼出铃声(value:TU32)
     * </pre>
     */
    emCfgCallOutRing(43, 43),
    /**
     * <code>emCfgKeyboardRing = 44;</code>
     *
     * <pre>
     *按键音效(value:TU32)
     * </pre>
     */
    emCfgKeyboardRing(44, 44),
    /**
     * <code>emCfgShowAppTips = 45;</code>
     *
     * <pre>
     *显示申请提示(value:TBOOL32)	
     * </pre>
     */
    emCfgShowAppTips(45, 45),
    /**
     * <code>emCfgShowInOutConf = 46;</code>
     *
     * <pre>
     *显示与会方入会或离会的提示(value:TBOOL32)
     * </pre>
     */
    emCfgShowInOutConf(46, 46),
    /**
     * <code>emCfgAiInfo = 47;</code>
     *
     * <pre>
     *人脸签到状态(skyos暂无)
     * </pre>
     */
    emCfgAiInfo(47, 47),
    /**
     * <code>emCfgShortMsg = 48;</code>
     *
     * <pre>
     *通知消息(value:TMTShortMsgCfg)
     * </pre>
     */
    emCfgShortMsg(48, 48),
    /**
     * <code>emCfgAutoSleep = 49;</code>
     *
     * <pre>
     *待机(value:TMTAutoSleep)
     * </pre>
     */
    emCfgAutoSleep(49, 49),
    /**
     * <code>emCfgSysTime = 50;</code>
     *
     * <pre>
     *系统时间配置信息(value:TMTCfgSystemTime)
     * </pre>
     */
    emCfgSysTime(50, 50),
    /**
     * <code>emCfgAudVolIn = 51;</code>
     *
     * <pre>
     *输入音量(value:TU32)
     * </pre>
     */
    emCfgAudVolIn(51, 51),
    /**
     * <code>emCfgMicGain = 52;</code>
     *
     * <pre>
     *mic增益(value:TU32)
     * </pre>
     */
    emCfgMicGain(52, 52),
    /**
     * <code>emCfgAudVolOut = 53;</code>
     *
     * <pre>
     *输出音量(value:TU32)
     * </pre>
     */
    emCfgAudVolOut(53, 53),
    /**
     * <code>emCfgAns = 54;</code>
     *
     * <pre>
     *自动噪声抑制(value:TBOOL32)
     * </pre>
     */
    emCfgAns(54, 54),
    /**
     * <code>emCfgAgc = 55;</code>
     *
     * <pre>
     *自动增益控制(value:TBOOL32)
     * </pre>
     */
    emCfgAgc(55, 55),
    /**
     * <code>emCfgAec = 56;</code>
     *
     * <pre>
     *自动回声抵消(value:TAdjustAecParamCfg)
     * </pre>
     */
    emCfgAec(56, 56),
    /**
     * <code>emCfgLastDisplay = 57;</code>
     *
     * <pre>
     *无码流视频输出配置(value:TMTLastDisplay)
     * </pre>
     */
    emCfgLastDisplay(57, 57),
    /**
     * <code>emCfgVidBitRation = 58;</code>
     *
     * <pre>
     *视频发送比率(value:TVidBitRationCfg)
     * </pre>
     */
    emCfgVidBitRation(58, 58),
    /**
     * <code>emCfgImageNoiseLevel = 59;</code>
     *
     * <pre>
     *图像降噪(value:TMTHDImageNoise)
     * </pre>
     */
    emCfgImageNoiseLevel(59, 59),
    /**
     * <code>emCfgVidEncQcMode = 60;</code>
     *
     * <pre>
     *图像质量(value:TU32)
     * </pre>
     */
    emCfgVidEncQcMode(60, 60),
    /**
     * <code>emCfgLoadAdaptiveVideo = 61;</code>
     *
     * <pre>
     *视频载荷自适应(value:TBOOL32)
     * </pre>
     */
    emCfgLoadAdaptiveVideo(61, 61),
    /**
     * <code>emCfgVGAImageAdjust = 62;</code>
     *
     * <pre>
     *VGA图像调节(value:TMTVgaImageAdjustCfg)
     * </pre>
     */
    emCfgVGAImageAdjust(62, 62),
    /**
     * <code>emCfgAsymmetricNet = 63;</code>
     *
     * <pre>
     *非对称网络(value:TMtAsymmetricNetInfo)
     * </pre>
     */
    emCfgAsymmetricNet(63, 63),
    /**
     * <code>emCfgFEC = 64;</code>
     *
     * <pre>
     *fec策略(value:TMTFecInfo)
     * </pre>
     */
    emCfgFEC(64, 64),
    /**
     * <code>emCfgAudioPrecedence = 65;</code>
     *
     * <pre>
     *音频优先(value:TBOOL32)
     * </pre>
     */
    emCfgAudioPrecedence(65, 65),
    /**
     * <code>emCfgLostPktResend = 66;</code>
     *
     * <pre>
     *丢包重传(value:TPrsParam)
     * </pre>
     */
    emCfgLostPktResend(66, 66),
    /**
     * <code>emCfgTRtpSamePort = 67;</code>
     *
     * <pre>
     *端口复用(value:TBOOL32)
     * </pre>
     */
    emCfgTRtpSamePort(67, 67),
    /**
     * <code>emCfgSnapShotFtpCfg = 68;</code>
     *
     * <pre>
     *快照ftp(value:TMTSnapShotFtpCfg)
     * </pre>
     */
    emCfgSnapShotFtpCfg(68, 68),
    /**
     * <code>emCfgSipConnection = 69;</code>
     *
     * <pre>
     *数据加密(value:TU32)
     * </pre>
     */
    emCfgSipConnection(69, 69),
    /**
     * <code>emCfgUseHTTP = 70;</code>
     *
     * <pre>
     *http服务(value:TBOOL32)
     * </pre>
     */
    emCfgUseHTTP(70, 70),
    /**
     * <code>emCfgCSU = 71;</code>
     *
     * <pre>
     *升级服务器地址(value:TMtCSUAddr)
     * </pre>
     */
    emCfgCSU(71, 71),
    /**
     * <code>emCfgLog = 72;</code>
     *
     * <pre>
     *日志配置(value:TBOOL32)
     * </pre>
     */
    emCfgLog(72, 72),
    /**
     * <code>emCfgShortCutKey = 73;</code>
     *
     * <pre>
     *快捷键配置(value:TMtShortCutKeyList)
     * </pre>
     */
    emCfgShortCutKey(73, 73),
    /**
     * <code>emCfgAiFuncCfgList = 74;</code>
     *
     * <pre>
     *ai功能配置(value:TAiMtFeatureList)
     * </pre>
     */
    emCfgAiFuncCfgList(74, 74),
    /**
     * <code>emCfgAiWakeupOrSleepMt = 75;</code>
     *
     * <pre>
     *智能模块唤醒或休眠终端配置(value:TBOOL32)
     * </pre>
     */
    emCfgAiWakeupOrSleepMt(75, 75),
    ;

    /**
     * <code>emCfgInfoBegin = 0;</code>
     */
    public static final int emCfgInfoBegin_VALUE = 0;
    /**
     * <code>emCfgPriVidEncParam = 1;</code>
     *
     * <pre>
     *主视频编码器参数  (value: TMTAllVideoEncoderParamCfg)
     * </pre>
     */
    public static final int emCfgPriVidEncParam_VALUE = 1;
    /**
     * <code>emCfgAssVidEncParam = 2;</code>
     *
     * <pre>
     *辅视频编码器参数  (value: TMTAllVideoEncoderParamCfg)
     * </pre>
     */
    public static final int emCfgAssVidEncParam_VALUE = 2;
    /**
     * <code>emCfgPriVidPrior = 3;</code>
     *
     * <pre>
     *主流优选(value: TMTMainVideoPriorCfg)
     * </pre>
     */
    public static final int emCfgPriVidPrior_VALUE = 3;
    /**
     * <code>emCfgPcAssVidPrior = 4;</code>
     *
     * <pre>
     *pc辅流优选(value: TVidPriorParam)
     * </pre>
     */
    public static final int emCfgPcAssVidPrior_VALUE = 4;
    /**
     * <code>emCfgVidAssVidPrior = 5;</code>
     *
     * <pre>
     *vido辅流优选(value: TVidPriorParam) 	
     * </pre>
     */
    public static final int emCfgVidAssVidPrior_VALUE = 5;
    /**
     * <code>emCfgPort = 6;</code>
     *
     * <pre>
     *设置TCP/UDP起始端口配置信息 (value: TMTPortCfg)
     * </pre>
     */
    public static final int emCfgPort_VALUE = 6;
    /**
     * <code>emCfgHDResOutput = 7;</code>
     *
     * <pre>
     *视频输出制式(value: TMTVideoOutPortMode )
     * </pre>
     */
    public static final int emCfgHDResOutput_VALUE = 7;
    /**
     * <code>emCfgMtcBannerInfo = 8;</code>
     *
     * <pre>
     *mtc横幅预案配置(value: TMTBannerInfoList )
     * </pre>
     */
    public static final int emCfgMtcBannerInfo_VALUE = 8;
    /**
     * <code>emCfgOsdBannerInfo = 9;</code>
     *
     * <pre>
     *OSD横幅配置(value: TMTBannerInfo )
     * </pre>
     */
    public static final int emCfgOsdBannerInfo_VALUE = 9;
    /**
     * <code>emCfgAudOutPortList = 10;</code>
     *
     * <pre>
     *音频输出接口(value: TMTHDAudOutPortList )
     * </pre>
     */
    public static final int emCfgAudOutPortList_VALUE = 10;
    /**
     * <code>emCfgAudInPortList = 11;</code>
     *
     * <pre>
     *主音频输入接口(value: TMTHDAudInPortList )
     * </pre>
     */
    public static final int emCfgAudInPortList_VALUE = 11;
    /**
     * <code>emCfgPri1stVidInPort = 12;</code>
     *
     * <pre>
     *设置第一路主视频输入端口(value: TMTHDVidInPort )
     * </pre>
     */
    public static final int emCfgPri1stVidInPort_VALUE = 12;
    /**
     * <code>emCfgPri2ndVidInPort = 13;</code>
     *
     * <pre>
     *设置第二路主视频输入端口(value: TMTHDVidInPort )
     * </pre>
     */
    public static final int emCfgPri2ndVidInPort_VALUE = 13;
    /**
     * <code>emCfgPri3rdVidInPort = 14;</code>
     *
     * <pre>
     *设置第三路主视频输入端口(value: TMTHDVidInPort )
     * </pre>
     */
    public static final int emCfgPri3rdVidInPort_VALUE = 14;
    /**
     * <code>emCfgAssVidInPort = 15;</code>
     *
     * <pre>
     *设置辅视频输入端口(value: TMTHDVidInPort )
     * </pre>
     */
    public static final int emCfgAssVidInPort_VALUE = 15;
    /**
     * <code>emCfgMultiVideo = 16;</code>
     *
     * <pre>
     *设置多视或多流(value: TMTHDMultiVideo )
     * </pre>
     */
    public static final int emCfgMultiVideo_VALUE = 16;
    /**
     * <code>emCfgVideoMatrixScheme = 17;</code>
     *
     * <pre>
     *视频矩阵(value: TMTAllVideoMatrixScheme )
     * </pre>
     */
    public static final int emCfgVideoMatrixScheme_VALUE = 17;
    /**
     * <code>emCfgSerialList = 18;</code>
     *
     * <pre>
     *串口配置(value: TMTHDSerialList )
     * </pre>
     */
    public static final int emCfgSerialList_VALUE = 18;
    /**
     * <code>emCfgSerialMonitorList = 19;</code>
     *
     * <pre>
     *串口监听配置(value: TMTHDSerialMonitorList )
     * </pre>
     */
    public static final int emCfgSerialMonitorList_VALUE = 19;
    /**
     * <code>emCfgVideoSrcTag = 20;</code>
     *
     * <pre>
     *视频源输入标签 (value:TMTVideoSrcTagList)
     * </pre>
     */
    public static final int emCfgVideoSrcTag_VALUE = 20;
    /**
     * <code>emCfgVideoOutTag = 21;</code>
     *
     * <pre>
     *视频源输出标签 (value:TMTVideoOutTagList)
     * </pre>
     */
    public static final int emCfgVideoOutTag_VALUE = 21;
    /**
     * <code>emCfgCameraList = 22;</code>
     *
     * <pre>
     *摄像机配置(value: TMTHDCameraList )
     * </pre>
     */
    public static final int emCfgCameraList_VALUE = 22;
    /**
     * <code>emCfgVidInPortBright = 23;</code>
     *
     * <pre>
     *视频输入接口亮度 (value:TMtVideoPortParamList )
     * </pre>
     */
    public static final int emCfgVidInPortBright_VALUE = 23;
    /**
     * <code>emCfgVidInPortContrast = 24;</code>
     *
     * <pre>
     *视频输入接口对比度 (value:TMtVideoPortParamList )
     * </pre>
     */
    public static final int emCfgVidInPortContrast_VALUE = 24;
    /**
     * <code>emCfgVidInPortSaturation = 25;</code>
     *
     * <pre>
     *视频输入接口饱和度 (value:TMtVideoPortParamList )
     * </pre>
     */
    public static final int emCfgVidInPortSaturation_VALUE = 25;
    /**
     * <code>emCfgAnswerMode = 26;</code>
     *
     * <pre>
     *应答模式(value:TU32)	
     * </pre>
     */
    public static final int emCfgAnswerMode_VALUE = 26;
    /**
     * <code>emCfgAutoCall = 27;</code>
     *
     * <pre>
     *自动呼叫(value:TMTAutoCall)		
     * </pre>
     */
    public static final int emCfgAutoCall_VALUE = 27;
    /**
     * <code>emCfgBandWithTest = 28;</code>
     *
     * <pre>
     *自动检测码率(value:TBOOL32)	
     * </pre>
     */
    public static final int emCfgBandWithTest_VALUE = 28;
    /**
     * <code>emCfgCallBitrate = 29;</code>
     *
     * <pre>
     *呼叫码率与默认呼叫码率(value:TMultiU32)	
     * </pre>
     */
    public static final int emCfgCallBitrate_VALUE = 29;
    /**
     * <code>emCfgkeepAliveItrvl = 30;</code>
     *
     * <pre>
     *323断链检测时间(value:TU32)
     * </pre>
     */
    public static final int emCfgkeepAliveItrvl_VALUE = 30;
    /**
     * <code>emCfgSipkeepAliveItrvl = 31;</code>
     *
     * <pre>
     *sip断链检测时间(value:TU32)
     * </pre>
     */
    public static final int emCfgSipkeepAliveItrvl_VALUE = 31;
    /**
     * <code>emCfgStaticPic = 32;</code>
     *
     * <pre>
     *静态图片(value:TBOOL32)		
     * </pre>
     */
    public static final int emCfgStaticPic_VALUE = 32;
    /**
     * <code>emCfgAutoPip = 33;</code>
     *
     * <pre>
     *自动多画面显示(value:TBOOL32)		
     * </pre>
     */
    public static final int emCfgAutoPip_VALUE = 33;
    /**
     * <code>emCfgAutoSendSharedCont = 34;</code>
     *
     * <pre>
     *自动发送内容共享(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgAutoSendSharedCont_VALUE = 34;
    /**
     * <code>emCfgDualStramSrcAdj = 35;</code>
     *
     * <pre>
     *辅视频源自动(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgDualStramSrcAdj_VALUE = 35;
    /**
     * <code>emCfgCallProtocol = 36;</code>
     *
     * <pre>
     *主呼协议(value:TMTCallerProtocol)	
     * </pre>
     */
    public static final int emCfgCallProtocol_VALUE = 36;
    /**
     * <code>emCfgAudioPrior = 37;</code>
     *
     * <pre>
     *优选音频协议(value:TMTAudioPriorCfg)	
     * </pre>
     */
    public static final int emCfgAudioPrior_VALUE = 37;
    /**
     * <code>emCfgH264Svc = 38;</code>
     *
     * <pre>
     *h264scv(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgH264Svc_VALUE = 38;
    /**
     * <code>emCfgH323 = 39;</code>
     *
     * <pre>
     *H239(value:TMtH323Cfg)
     * </pre>
     */
    public static final int emCfgH323_VALUE = 39;
    /**
     * <code>emCfgSip = 40;</code>
     *
     * <pre>
     *bfcp(value:TMtSipCfg)
     * </pre>
     */
    public static final int emCfgSip_VALUE = 40;
    /**
     * <code>emCfgLabelInfo = 41;</code>
     *
     * <pre>
     *台标(value:TMTLabelInfo)	
     * </pre>
     */
    public static final int emCfgLabelInfo_VALUE = 41;
    /**
     * <code>emCfgCallInRing = 42;</code>
     *
     * <pre>
     *呼入铃声(value:TU32)
     * </pre>
     */
    public static final int emCfgCallInRing_VALUE = 42;
    /**
     * <code>emCfgCallOutRing = 43;</code>
     *
     * <pre>
     *呼出铃声(value:TU32)
     * </pre>
     */
    public static final int emCfgCallOutRing_VALUE = 43;
    /**
     * <code>emCfgKeyboardRing = 44;</code>
     *
     * <pre>
     *按键音效(value:TU32)
     * </pre>
     */
    public static final int emCfgKeyboardRing_VALUE = 44;
    /**
     * <code>emCfgShowAppTips = 45;</code>
     *
     * <pre>
     *显示申请提示(value:TBOOL32)	
     * </pre>
     */
    public static final int emCfgShowAppTips_VALUE = 45;
    /**
     * <code>emCfgShowInOutConf = 46;</code>
     *
     * <pre>
     *显示与会方入会或离会的提示(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgShowInOutConf_VALUE = 46;
    /**
     * <code>emCfgAiInfo = 47;</code>
     *
     * <pre>
     *人脸签到状态(skyos暂无)
     * </pre>
     */
    public static final int emCfgAiInfo_VALUE = 47;
    /**
     * <code>emCfgShortMsg = 48;</code>
     *
     * <pre>
     *通知消息(value:TMTShortMsgCfg)
     * </pre>
     */
    public static final int emCfgShortMsg_VALUE = 48;
    /**
     * <code>emCfgAutoSleep = 49;</code>
     *
     * <pre>
     *待机(value:TMTAutoSleep)
     * </pre>
     */
    public static final int emCfgAutoSleep_VALUE = 49;
    /**
     * <code>emCfgSysTime = 50;</code>
     *
     * <pre>
     *系统时间配置信息(value:TMTCfgSystemTime)
     * </pre>
     */
    public static final int emCfgSysTime_VALUE = 50;
    /**
     * <code>emCfgAudVolIn = 51;</code>
     *
     * <pre>
     *输入音量(value:TU32)
     * </pre>
     */
    public static final int emCfgAudVolIn_VALUE = 51;
    /**
     * <code>emCfgMicGain = 52;</code>
     *
     * <pre>
     *mic增益(value:TU32)
     * </pre>
     */
    public static final int emCfgMicGain_VALUE = 52;
    /**
     * <code>emCfgAudVolOut = 53;</code>
     *
     * <pre>
     *输出音量(value:TU32)
     * </pre>
     */
    public static final int emCfgAudVolOut_VALUE = 53;
    /**
     * <code>emCfgAns = 54;</code>
     *
     * <pre>
     *自动噪声抑制(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgAns_VALUE = 54;
    /**
     * <code>emCfgAgc = 55;</code>
     *
     * <pre>
     *自动增益控制(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgAgc_VALUE = 55;
    /**
     * <code>emCfgAec = 56;</code>
     *
     * <pre>
     *自动回声抵消(value:TAdjustAecParamCfg)
     * </pre>
     */
    public static final int emCfgAec_VALUE = 56;
    /**
     * <code>emCfgLastDisplay = 57;</code>
     *
     * <pre>
     *无码流视频输出配置(value:TMTLastDisplay)
     * </pre>
     */
    public static final int emCfgLastDisplay_VALUE = 57;
    /**
     * <code>emCfgVidBitRation = 58;</code>
     *
     * <pre>
     *视频发送比率(value:TVidBitRationCfg)
     * </pre>
     */
    public static final int emCfgVidBitRation_VALUE = 58;
    /**
     * <code>emCfgImageNoiseLevel = 59;</code>
     *
     * <pre>
     *图像降噪(value:TMTHDImageNoise)
     * </pre>
     */
    public static final int emCfgImageNoiseLevel_VALUE = 59;
    /**
     * <code>emCfgVidEncQcMode = 60;</code>
     *
     * <pre>
     *图像质量(value:TU32)
     * </pre>
     */
    public static final int emCfgVidEncQcMode_VALUE = 60;
    /**
     * <code>emCfgLoadAdaptiveVideo = 61;</code>
     *
     * <pre>
     *视频载荷自适应(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgLoadAdaptiveVideo_VALUE = 61;
    /**
     * <code>emCfgVGAImageAdjust = 62;</code>
     *
     * <pre>
     *VGA图像调节(value:TMTVgaImageAdjustCfg)
     * </pre>
     */
    public static final int emCfgVGAImageAdjust_VALUE = 62;
    /**
     * <code>emCfgAsymmetricNet = 63;</code>
     *
     * <pre>
     *非对称网络(value:TMtAsymmetricNetInfo)
     * </pre>
     */
    public static final int emCfgAsymmetricNet_VALUE = 63;
    /**
     * <code>emCfgFEC = 64;</code>
     *
     * <pre>
     *fec策略(value:TMTFecInfo)
     * </pre>
     */
    public static final int emCfgFEC_VALUE = 64;
    /**
     * <code>emCfgAudioPrecedence = 65;</code>
     *
     * <pre>
     *音频优先(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgAudioPrecedence_VALUE = 65;
    /**
     * <code>emCfgLostPktResend = 66;</code>
     *
     * <pre>
     *丢包重传(value:TPrsParam)
     * </pre>
     */
    public static final int emCfgLostPktResend_VALUE = 66;
    /**
     * <code>emCfgTRtpSamePort = 67;</code>
     *
     * <pre>
     *端口复用(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgTRtpSamePort_VALUE = 67;
    /**
     * <code>emCfgSnapShotFtpCfg = 68;</code>
     *
     * <pre>
     *快照ftp(value:TMTSnapShotFtpCfg)
     * </pre>
     */
    public static final int emCfgSnapShotFtpCfg_VALUE = 68;
    /**
     * <code>emCfgSipConnection = 69;</code>
     *
     * <pre>
     *数据加密(value:TU32)
     * </pre>
     */
    public static final int emCfgSipConnection_VALUE = 69;
    /**
     * <code>emCfgUseHTTP = 70;</code>
     *
     * <pre>
     *http服务(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgUseHTTP_VALUE = 70;
    /**
     * <code>emCfgCSU = 71;</code>
     *
     * <pre>
     *升级服务器地址(value:TMtCSUAddr)
     * </pre>
     */
    public static final int emCfgCSU_VALUE = 71;
    /**
     * <code>emCfgLog = 72;</code>
     *
     * <pre>
     *日志配置(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgLog_VALUE = 72;
    /**
     * <code>emCfgShortCutKey = 73;</code>
     *
     * <pre>
     *快捷键配置(value:TMtShortCutKeyList)
     * </pre>
     */
    public static final int emCfgShortCutKey_VALUE = 73;
    /**
     * <code>emCfgAiFuncCfgList = 74;</code>
     *
     * <pre>
     *ai功能配置(value:TAiMtFeatureList)
     * </pre>
     */
    public static final int emCfgAiFuncCfgList_VALUE = 74;
    /**
     * <code>emCfgAiWakeupOrSleepMt = 75;</code>
     *
     * <pre>
     *智能模块唤醒或休眠终端配置(value:TBOOL32)
     * </pre>
     */
    public static final int emCfgAiWakeupOrSleepMt_VALUE = 75;


    public final int getNumber() { return value; }

    public static EmDefaultCfgType valueOf(int value) {
      switch (value) {
        case 0: return emCfgInfoBegin;
        case 1: return emCfgPriVidEncParam;
        case 2: return emCfgAssVidEncParam;
        case 3: return emCfgPriVidPrior;
        case 4: return emCfgPcAssVidPrior;
        case 5: return emCfgVidAssVidPrior;
        case 6: return emCfgPort;
        case 7: return emCfgHDResOutput;
        case 8: return emCfgMtcBannerInfo;
        case 9: return emCfgOsdBannerInfo;
        case 10: return emCfgAudOutPortList;
        case 11: return emCfgAudInPortList;
        case 12: return emCfgPri1stVidInPort;
        case 13: return emCfgPri2ndVidInPort;
        case 14: return emCfgPri3rdVidInPort;
        case 15: return emCfgAssVidInPort;
        case 16: return emCfgMultiVideo;
        case 17: return emCfgVideoMatrixScheme;
        case 18: return emCfgSerialList;
        case 19: return emCfgSerialMonitorList;
        case 20: return emCfgVideoSrcTag;
        case 21: return emCfgVideoOutTag;
        case 22: return emCfgCameraList;
        case 23: return emCfgVidInPortBright;
        case 24: return emCfgVidInPortContrast;
        case 25: return emCfgVidInPortSaturation;
        case 26: return emCfgAnswerMode;
        case 27: return emCfgAutoCall;
        case 28: return emCfgBandWithTest;
        case 29: return emCfgCallBitrate;
        case 30: return emCfgkeepAliveItrvl;
        case 31: return emCfgSipkeepAliveItrvl;
        case 32: return emCfgStaticPic;
        case 33: return emCfgAutoPip;
        case 34: return emCfgAutoSendSharedCont;
        case 35: return emCfgDualStramSrcAdj;
        case 36: return emCfgCallProtocol;
        case 37: return emCfgAudioPrior;
        case 38: return emCfgH264Svc;
        case 39: return emCfgH323;
        case 40: return emCfgSip;
        case 41: return emCfgLabelInfo;
        case 42: return emCfgCallInRing;
        case 43: return emCfgCallOutRing;
        case 44: return emCfgKeyboardRing;
        case 45: return emCfgShowAppTips;
        case 46: return emCfgShowInOutConf;
        case 47: return emCfgAiInfo;
        case 48: return emCfgShortMsg;
        case 49: return emCfgAutoSleep;
        case 50: return emCfgSysTime;
        case 51: return emCfgAudVolIn;
        case 52: return emCfgMicGain;
        case 53: return emCfgAudVolOut;
        case 54: return emCfgAns;
        case 55: return emCfgAgc;
        case 56: return emCfgAec;
        case 57: return emCfgLastDisplay;
        case 58: return emCfgVidBitRation;
        case 59: return emCfgImageNoiseLevel;
        case 60: return emCfgVidEncQcMode;
        case 61: return emCfgLoadAdaptiveVideo;
        case 62: return emCfgVGAImageAdjust;
        case 63: return emCfgAsymmetricNet;
        case 64: return emCfgFEC;
        case 65: return emCfgAudioPrecedence;
        case 66: return emCfgLostPktResend;
        case 67: return emCfgTRtpSamePort;
        case 68: return emCfgSnapShotFtpCfg;
        case 69: return emCfgSipConnection;
        case 70: return emCfgUseHTTP;
        case 71: return emCfgCSU;
        case 72: return emCfgLog;
        case 73: return emCfgShortCutKey;
        case 74: return emCfgAiFuncCfgList;
        case 75: return emCfgAiWakeupOrSleepMt;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmDefaultCfgType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmDefaultCfgType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmDefaultCfgType>() {
            public EmDefaultCfgType findValueByNumber(int number) {
              return EmDefaultCfgType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(320);
    }

    private static final EmDefaultCfgType[] VALUES = values();

    public static EmDefaultCfgType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmDefaultCfgType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmDefaultCfgType)
  }

  /**
   * Protobuf enum {@code mt.EmPltSupportConfType}
   */
  public enum EmPltSupportConfType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emPltConfTypeInvalid = 0;</code>
     */
    emPltConfTypeInvalid(0, 0),
    /**
     * <code>emSupportMediaConf = 1;</code>
     *
     * <pre>
     *仅支持传统会议
     * </pre>
     */
    emSupportMediaConf(1, 1),
    /**
     * <code>emSupportPortConf = 2;</code>
     *
     * <pre>
     *仅支持端口会议
     * </pre>
     */
    emSupportPortConf(2, 2),
    /**
     * <code>emSupportMediaPortConf = 3;</code>
     *
     * <pre>
     *支持传统会议和端口会议
     * </pre>
     */
    emSupportMediaPortConf(3, 3),
    ;

    /**
     * <code>emPltConfTypeInvalid = 0;</code>
     */
    public static final int emPltConfTypeInvalid_VALUE = 0;
    /**
     * <code>emSupportMediaConf = 1;</code>
     *
     * <pre>
     *仅支持传统会议
     * </pre>
     */
    public static final int emSupportMediaConf_VALUE = 1;
    /**
     * <code>emSupportPortConf = 2;</code>
     *
     * <pre>
     *仅支持端口会议
     * </pre>
     */
    public static final int emSupportPortConf_VALUE = 2;
    /**
     * <code>emSupportMediaPortConf = 3;</code>
     *
     * <pre>
     *支持传统会议和端口会议
     * </pre>
     */
    public static final int emSupportMediaPortConf_VALUE = 3;


    public final int getNumber() { return value; }

    public static EmPltSupportConfType valueOf(int value) {
      switch (value) {
        case 0: return emPltConfTypeInvalid;
        case 1: return emSupportMediaConf;
        case 2: return emSupportPortConf;
        case 3: return emSupportMediaPortConf;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmPltSupportConfType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmPltSupportConfType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmPltSupportConfType>() {
            public EmPltSupportConfType findValueByNumber(int number) {
              return EmPltSupportConfType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(321);
    }

    private static final EmPltSupportConfType[] VALUES = values();

    public static EmPltSupportConfType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmPltSupportConfType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmPltSupportConfType)
  }

  /**
   * Protobuf enum {@code mt.EmFunctionIcon}
   */
  public enum EmFunctionIcon
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emFunctionIconBegin = 0;</code>
     */
    emFunctionIconBegin(0, 0),
    /**
     * <code>emFaceCheckIcon = 1;</code>
     *
     * <pre>
     *&#47;&lt;人脸签到
     * </pre>
     */
    emFaceCheckIcon(1, 1),
    ;

    /**
     * <code>emFunctionIconBegin = 0;</code>
     */
    public static final int emFunctionIconBegin_VALUE = 0;
    /**
     * <code>emFaceCheckIcon = 1;</code>
     *
     * <pre>
     *&#47;&lt;人脸签到
     * </pre>
     */
    public static final int emFaceCheckIcon_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmFunctionIcon valueOf(int value) {
      switch (value) {
        case 0: return emFunctionIconBegin;
        case 1: return emFaceCheckIcon;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmFunctionIcon>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmFunctionIcon>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmFunctionIcon>() {
            public EmFunctionIcon findValueByNumber(int number) {
              return EmFunctionIcon.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(322);
    }

    private static final EmFunctionIcon[] VALUES = values();

    public static EmFunctionIcon valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmFunctionIcon(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmFunctionIcon)
  }

  /**
   * Protobuf enum {@code mt.EmCommEnableEvt}
   */
  public enum EmCommEnableEvt
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emBweEnable = 0;</code>
     */
    emBweEnable(0, 0),
    /**
     * <code>emIPv6Enable = 1;</code>
     */
    emIPv6Enable(1, 1),
    /**
     * <code>emCommEnableEnd = 5;</code>
     */
    emCommEnableEnd(2, 5),
    ;

    /**
     * <code>emBweEnable = 0;</code>
     */
    public static final int emBweEnable_VALUE = 0;
    /**
     * <code>emIPv6Enable = 1;</code>
     */
    public static final int emIPv6Enable_VALUE = 1;
    /**
     * <code>emCommEnableEnd = 5;</code>
     */
    public static final int emCommEnableEnd_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmCommEnableEvt valueOf(int value) {
      switch (value) {
        case 0: return emBweEnable;
        case 1: return emIPv6Enable;
        case 5: return emCommEnableEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmCommEnableEvt>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmCommEnableEvt>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmCommEnableEvt>() {
            public EmCommEnableEvt findValueByNumber(int number) {
              return EmCommEnableEvt.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(323);
    }

    private static final EmCommEnableEvt[] VALUES = values();

    public static EmCommEnableEvt valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmCommEnableEvt(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmCommEnableEvt)
  }

  /**
   * Protobuf enum {@code mt.EmSysPathPrefix}
   */
  public enum EmSysPathPrefix
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emSysPathConf = 0;</code>
     */
    emSysPathConf(0, 0),
    /**
     * <code>emSysPathLog = 1;</code>
     */
    emSysPathLog(1, 1),
    /**
     * <code>emSysPathData = 2;</code>
     */
    emSysPathData(2, 2),
    ;

    /**
     * <code>emSysPathConf = 0;</code>
     */
    public static final int emSysPathConf_VALUE = 0;
    /**
     * <code>emSysPathLog = 1;</code>
     */
    public static final int emSysPathLog_VALUE = 1;
    /**
     * <code>emSysPathData = 2;</code>
     */
    public static final int emSysPathData_VALUE = 2;


    public final int getNumber() { return value; }

    public static EmSysPathPrefix valueOf(int value) {
      switch (value) {
        case 0: return emSysPathConf;
        case 1: return emSysPathLog;
        case 2: return emSysPathData;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmSysPathPrefix>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmSysPathPrefix>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmSysPathPrefix>() {
            public EmSysPathPrefix findValueByNumber(int number) {
              return EmSysPathPrefix.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(324);
    }

    private static final EmSysPathPrefix[] VALUES = values();

    public static EmSysPathPrefix valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmSysPathPrefix(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmSysPathPrefix)
  }

  /**
   * Protobuf enum {@code mt.EmAPIVersionType}
   *
   * <pre>
   *获取API版本信息类型
   * </pre>
   */
  public enum EmAPIVersionType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emVcAPIVersion = 0;</code>
     *
     * <pre>
     *会控API
     * </pre>
     */
    emVcAPIVersion(0, 0),
    /**
     * <code>emMcAPIVersion = 1;</code>
     *
     * <pre>
     *会管API
     * </pre>
     */
    emMcAPIVersion(1, 1),
    /**
     * <code>emEqpAPIVersion = 2;</code>
     *
     * <pre>
     *电视墙API
     * </pre>
     */
    emEqpAPIVersion(2, 2),
    /**
     * <code>emSystemAPIVersion = 3;</code>
     *
     * <pre>
     *登录认证API
     * </pre>
     */
    emSystemAPIVersion(3, 3),
    /**
     * <code>emAmcAPIVersion = 4;</code>
     *
     * <pre>
     *获取账号API
     * </pre>
     */
    emAmcAPIVersion(4, 4),
    /**
     * <code>emVrsAPIVersion = 5;</code>
     *
     * <pre>
     *VRS API
     * </pre>
     */
    emVrsAPIVersion(5, 5),
    ;

    /**
     * <code>emVcAPIVersion = 0;</code>
     *
     * <pre>
     *会控API
     * </pre>
     */
    public static final int emVcAPIVersion_VALUE = 0;
    /**
     * <code>emMcAPIVersion = 1;</code>
     *
     * <pre>
     *会管API
     * </pre>
     */
    public static final int emMcAPIVersion_VALUE = 1;
    /**
     * <code>emEqpAPIVersion = 2;</code>
     *
     * <pre>
     *电视墙API
     * </pre>
     */
    public static final int emEqpAPIVersion_VALUE = 2;
    /**
     * <code>emSystemAPIVersion = 3;</code>
     *
     * <pre>
     *登录认证API
     * </pre>
     */
    public static final int emSystemAPIVersion_VALUE = 3;
    /**
     * <code>emAmcAPIVersion = 4;</code>
     *
     * <pre>
     *获取账号API
     * </pre>
     */
    public static final int emAmcAPIVersion_VALUE = 4;
    /**
     * <code>emVrsAPIVersion = 5;</code>
     *
     * <pre>
     *VRS API
     * </pre>
     */
    public static final int emVrsAPIVersion_VALUE = 5;


    public final int getNumber() { return value; }

    public static EmAPIVersionType valueOf(int value) {
      switch (value) {
        case 0: return emVcAPIVersion;
        case 1: return emMcAPIVersion;
        case 2: return emEqpAPIVersion;
        case 3: return emSystemAPIVersion;
        case 4: return emAmcAPIVersion;
        case 5: return emVrsAPIVersion;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmAPIVersionType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmAPIVersionType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmAPIVersionType>() {
            public EmAPIVersionType findValueByNumber(int number) {
              return EmAPIVersionType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(325);
    }

    private static final EmAPIVersionType[] VALUES = values();

    public static EmAPIVersionType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmAPIVersionType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmAPIVersionType)
  }

  /**
   * Protobuf enum {@code mt.EmMoonCameraStatus}
   */
  public enum EmMoonCameraStatus
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emCameraClose = 0;</code>
     *
     * <pre>
     * 关闭
     * </pre>
     */
    emCameraClose(0, 0),
    /**
     * <code>emCameraOpen = 1;</code>
     *
     * <pre>
     * 开启
     * </pre>
     */
    emCameraOpen(1, 1),
    ;

    /**
     * <code>emCameraClose = 0;</code>
     *
     * <pre>
     * 关闭
     * </pre>
     */
    public static final int emCameraClose_VALUE = 0;
    /**
     * <code>emCameraOpen = 1;</code>
     *
     * <pre>
     * 开启
     * </pre>
     */
    public static final int emCameraOpen_VALUE = 1;


    public final int getNumber() { return value; }

    public static EmMoonCameraStatus valueOf(int value) {
      switch (value) {
        case 0: return emCameraClose;
        case 1: return emCameraOpen;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmMoonCameraStatus>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmMoonCameraStatus>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmMoonCameraStatus>() {
            public EmMoonCameraStatus findValueByNumber(int number) {
              return EmMoonCameraStatus.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(326);
    }

    private static final EmMoonCameraStatus[] VALUES = values();

    public static EmMoonCameraStatus valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmMoonCameraStatus(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmMoonCameraStatus)
  }

  /**
   * Protobuf enum {@code mt.emConnection}
   */
  public enum emConnection
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>EmPub = 0;</code>
     */
    EmPub(0, 0),
    /**
     * <code>EmSub = 1;</code>
     */
    EmSub(1, 1),
    /**
     * <code>EmAssPub = 2;</code>
     */
    EmAssPub(2, 2),
    /**
     * <code>EmAssSub = 3;</code>
     */
    EmAssSub(3, 3),
    /**
     * <code>EmConnEnd = 4;</code>
     */
    EmConnEnd(4, 4),
    ;

    /**
     * <code>EmPub = 0;</code>
     */
    public static final int EmPub_VALUE = 0;
    /**
     * <code>EmSub = 1;</code>
     */
    public static final int EmSub_VALUE = 1;
    /**
     * <code>EmAssPub = 2;</code>
     */
    public static final int EmAssPub_VALUE = 2;
    /**
     * <code>EmAssSub = 3;</code>
     */
    public static final int EmAssSub_VALUE = 3;
    /**
     * <code>EmConnEnd = 4;</code>
     */
    public static final int EmConnEnd_VALUE = 4;


    public final int getNumber() { return value; }

    public static emConnection valueOf(int value) {
      switch (value) {
        case 0: return EmPub;
        case 1: return EmSub;
        case 2: return EmAssPub;
        case 3: return EmAssSub;
        case 4: return EmConnEnd;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<emConnection>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<emConnection>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<emConnection>() {
            public emConnection findValueByNumber(int number) {
              return emConnection.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(327);
    }

    private static final emConnection[] VALUES = values();

    public static emConnection valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private emConnection(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.emConnection)
  }

  /**
   * Protobuf enum {@code mt.EmRtcAlgType}
   */
  public enum EmRtcAlgType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>emRtcNone = 0;</code>
     */
    emRtcNone(0, 0),
    /**
     * <code>emRtcMd2 = 1;</code>
     */
    emRtcMd2(1, 1),
    /**
     * <code>emRtcMd5 = 2;</code>
     */
    emRtcMd5(2, 2),
    /**
     * <code>emRtcSM3 = 3;</code>
     */
    emRtcSM3(3, 3),
    /**
     * <code>emRtcSM4 = 4;</code>
     */
    emRtcSM4(4, 4),
    /**
     * <code>emRtcSHA1 = 5;</code>
     */
    emRtcSHA1(5, 5),
    /**
     * <code>emRtcSHA224 = 6;</code>
     */
    emRtcSHA224(6, 6),
    /**
     * <code>emRtcSHA256 = 7;</code>
     */
    emRtcSHA256(7, 7),
    /**
     * <code>emRtcSHA384 = 8;</code>
     */
    emRtcSHA384(8, 8),
    /**
     * <code>emRtcSHA512 = 9;</code>
     */
    emRtcSHA512(9, 9),
    ;

    /**
     * <code>emRtcNone = 0;</code>
     */
    public static final int emRtcNone_VALUE = 0;
    /**
     * <code>emRtcMd2 = 1;</code>
     */
    public static final int emRtcMd2_VALUE = 1;
    /**
     * <code>emRtcMd5 = 2;</code>
     */
    public static final int emRtcMd5_VALUE = 2;
    /**
     * <code>emRtcSM3 = 3;</code>
     */
    public static final int emRtcSM3_VALUE = 3;
    /**
     * <code>emRtcSM4 = 4;</code>
     */
    public static final int emRtcSM4_VALUE = 4;
    /**
     * <code>emRtcSHA1 = 5;</code>
     */
    public static final int emRtcSHA1_VALUE = 5;
    /**
     * <code>emRtcSHA224 = 6;</code>
     */
    public static final int emRtcSHA224_VALUE = 6;
    /**
     * <code>emRtcSHA256 = 7;</code>
     */
    public static final int emRtcSHA256_VALUE = 7;
    /**
     * <code>emRtcSHA384 = 8;</code>
     */
    public static final int emRtcSHA384_VALUE = 8;
    /**
     * <code>emRtcSHA512 = 9;</code>
     */
    public static final int emRtcSHA512_VALUE = 9;


    public final int getNumber() { return value; }

    public static EmRtcAlgType valueOf(int value) {
      switch (value) {
        case 0: return emRtcNone;
        case 1: return emRtcMd2;
        case 2: return emRtcMd5;
        case 3: return emRtcSM3;
        case 4: return emRtcSM4;
        case 5: return emRtcSHA1;
        case 6: return emRtcSHA224;
        case 7: return emRtcSHA256;
        case 8: return emRtcSHA384;
        case 9: return emRtcSHA512;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<EmRtcAlgType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static com.google.protobuf.Internal.EnumLiteMap<EmRtcAlgType>
        internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<EmRtcAlgType>() {
            public EmRtcAlgType findValueByNumber(int number) {
              return EmRtcAlgType.valueOf(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      return getDescriptor().getValues().get(index);
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return EnumPB.getDescriptor().getEnumTypes().get(328);
    }

    private static final EmRtcAlgType[] VALUES = values();

    public static EmRtcAlgType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      return VALUES[desc.getIndex()];
    }

    private final int index;
    private final int value;

    private EmRtcAlgType(int index, int value) {
      this.index = index;
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:mt.EmRtcAlgType)
  }


  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    String[] descriptorData = {
      "\n\nenum.proto\022\002mt*\360\001\n\016EmAiMtFunction\022\017\n\013e" +
      "mVoiceAide\020\000\022\020\n\014emConfRecord\020\001\022\016\n\nemFace" +
      "Sign\020\002\022\024\n\020emPeopleCounting\020\003\022\021\n\remPeople" +
      "Lable\020\004\022\017\n\013emNamePlate\020\005\022\020\n\014emGuideVideo" +
      "\020\006\022\021\n\remConfCaption\020\007\022\020\n\014emFaceUnLock\020\010\022" +
      "\025\n\021emAdaptiveFraming\020\t\022\021\n\remIntellTrack\020" +
      "\n\022\020\n\014EmAiMtFunEnd\020\024*K\n\020EmAiFaceSignMode\022" +
      "\022\n\016emAiAllHasSign\020\000\022\022\n\016emAiAllNotSign\020\001\022" +
      "\017\n\013emAiAllSign\020\002*\370\014\n\nEmHintCode\022\017\n\013emHin" +
      "tBegin\020\000\022\024\n\020emFailtoSendDual\020\001\022\024\n\020emFail",
      "toRecvDual\020\002\022\024\n\020emFailtoVodLogin\020\003\022\021\n\rem" +
      "DHCPTimeOut\020\004\022\026\n\022emPPPoEAuthorError\020\005\022\025\n" +
      "\021emPPPoEAgentError\020\006\022\027\n\023emPPPoETimeOutEr" +
      "ror\020\007\022\030\n\024emPPPoELinkDownError\020\010\022\027\n\023emPPP" +
      "oEGeneralError\020\t\022\034\n\030emFailtoSendDualAsRe" +
      "ject\020\n\022\033\n\027emCallRateNotValidForMc\020\013\022\034\n\030e" +
      "mDualResNotMatchConfRes\020\014\022\027\n\023emSuccedeto" +
      "SendDual\020\r\022\027\n\023emSuccedetoRecvDual\020\016\022\033\n\027e" +
      "mSateMtNoP2pPermission\020\017\022$\n emH323UpLoad" +
      "BitrateLessThan64Ind\020\020\022&\n\"emH323DownLoad",
      "BitrateLessThan64Ind\020\021\022\027\n\023emAssVidHasNoS" +
      "ignal\020\022\022\032\n\026emNotRegedToCallFailed\020\023\022\022\n\016e" +
      "mBePolledNext\020\036\022!\n\035emHintNoOpenDSChnnlNo" +
      "nSpeaker\020\037\022\035\n\031emHintNoOpenDSChnnlNonCap\020" +
      " \022\036\n\032emHintNoOpenDSChnnlBRLow64\020!\022\036\n\032emH" +
      "intNoOpenDSChnnlFECType\020\"\022\034\n\030emHintNoOpe" +
      "nDSChnnlNonMp\020#\022\"\n\036emHintNoOpenDSChnnlEn" +
      "cryptMode\020$\022)\n%emHintNoOpenDSChnnlOverSa" +
      "tDCastChnNum\020%\022\035\n\031emHintNoOpenFSChnnlNon" +
      "Cap\020&\022\036\n\032emHintNoOpenFSChnnlBRLow64\020\'\022\"\n",
      "\036emHintNoOpenFSChnnlEncrpytMode\020(\022\036\n\032emH" +
      "intNoOpenFSChnnlFECType\020)\022\034\n\030emHintNoOpe" +
      "nFSChnnlNonMp\020*\022!\n\035emHintNoOpenFSChnnlBR" +
      "Overflow\020+\022#\n\037emHintNoOpenFSChnnlBothH26" +
      "3plus\020,\022\035\n\031emHintNoOpenFSChnnlFormat\020-\022\032" +
      "\n\026emHintNoOpenFSChnnlFPS\020.\022\030\n\024emHintBRLe" +
      "ssThanConf\020/\022\032\n\026emHintBRLargerThanConf\0200" +
      "\022\037\n\033emHintNoSupportOprForNoAuth\0201\022\037\n\033emH" +
      "intQueueConfNoIdleServer\0202\022\"\n\036emHintQueu" +
      "eConfAllocatedServer\0203\022#\n\037emHintOldStack",
      "NotSupportSpecVip\0204\022&\n\"emHintOldStackNot" +
      "SupportModifyDumb\0205\022)\n%emHintOldStackNot" +
      "SupportModifyConfPwd\0206\022/\n+emHintOldStack" +
      "NotSupportModifyConfNoDisturb\0207\022*\n&emHin" +
      "tOldStackNotSupportModifyDuration\0208\022*\n&e" +
      "mHintOldStackNotSupportModifyConfName\0209\022" +
      "/\n+emHintOldStackNotSupportSetAssStreamS" +
      "endMod\020:\022 \n\034emHintAssVideoSourceIsSwitch" +
      "\020;\022\"\n\036emHintNoSendAssOnVodPlayStatus\020<\022#" +
      "\n\037emHintNoSendAssOnEnterPwdStatus\020=*\315\003\n\025",
      "EmStackInitFailReason\022\025\n\021emH323InitSucce" +
      "ss\020\001\022\"\n\036emH323InitFailed_MemoryProblem\020\002" +
      "\022\"\n\036emH323InitFailed_ConfigProblem\020\003\022#\n\037" +
      "emH323InitFailed_NetWorkProblem\020\004\022\036\n\032emH" +
      "323InitFailed_InitAgain\020\005\022\"\n\036emH323InitF" +
      "ailed_GenConfigFail\020\006\022 \n\034emH323InitFaile" +
      "d_InitSemFail\020\007\022$\n emH323InitFailed_NewC" +
      "onnInfoFail\020\010\022\036\n\032emH323InitFailed_SetCBF" +
      "ail\020\t\022\034\n\030emH323InitFailed_Unknown\020\n\022\024\n\020e" +
      "mSipInitSuccess\020\036\022\023\n\017emSipInitFailed\020\037\022\033",
      "\n\027emH323PxyClient_Running\0202\022\036\n\032emH323Pxy" +
      "Client_NotRunning\0203*\254\001\n\014EmKdvMtModel\022\023\n\017" +
      "emKdvMtModelBeg\020\000\022\026\n\022emKdvMtModelX500TI\020" +
      "\001\022\024\n\020emKdvMtModelX700\020\002\022\024\n\020emKdvMtModelX" +
      "300\020\003\022\026\n\022emKdvMtModelSky300\020\004\022\026\n\022emKdvMt" +
      "ModelSky100\020\005\022\023\n\017emKdvMtModelEnd\020\t*\322\r\n\tE" +
      "mMtModel\022\020\n\014emModelBegin\020\000\022\020\n\014emSkyWindo" +
      "ws\020\001\022\r\n\temSkyIPad\020\002\022\017\n\013emSkyIPhone\020\003\022\023\n\017" +
      "emSkyAndroidPad\020\007\022\025\n\021emSkyAndroidPhone\020\010" +
      "\022\022\n\016emX500_1080P60\020\t\022\022\n\016emX500_1080P30\020\n",
      "\022\021\n\remX500_720P60\020\013\022\023\n\017emX500_mo_1080P\020\014" +
      "\022\022\n\016emX500_mo_720P\020\r\022\024\n\020emX500_oem_1080P" +
      "\020\016\022\027\n\023emX500_oem_mo_1080P\020\017\022\016\n\nemTrueLin" +
      "k\020\020\022\023\n\017emTrueTouchIpad\020\021\022\025\n\021emTrueTouchI" +
      "phone\020\022\022\033\n\027emTrueTouchAndroidPhone\020\023\022\031\n\025" +
      "emTrueTouchAndroidPad\020\024\022\022\n\016emH950_1080P6" +
      "0\020\025\022\020\n\014emTrueLinkTV\020\026\022\017\n\013emX700_4k30\020\027\022\023" +
      "\n\017emX700_oem_4k30\020\030\022\017\n\013emX500_4k30\020\031\022\023\n\017" +
      "emX500_oem_4k30\020\032\022\022\n\016emX300_1080P60\020\033\022\022\n" +
      "\016emX300_1080P30\020\034\022\021\n\remX300_720P60\020\035\022\026\n\022",
      "emX300_oem_1080P60\020\036\022\023\n\017emX500_1080P_60\020" +
      "\037\022\023\n\017emX500_1080P_30\020 \022\027\n\023emX500_oem_108" +
      "0P_60\020!\022\021\n\rem300_1080P30\020\"\022\020\n\014em300_720P" +
      "60\020#\022\025\n\021em300_oem_1080P30\020$\022\022\n\016em300L_10" +
      "80P30\020%\022\021\n\rem300L_720P60\020&\022\026\n\022em300L_oem" +
      "_1080P30\020\'\022\021\n\rem300_1080P60\020(\022\020\n\014em300_7" +
      "20P30\020)\022\022\n\016em300L_1080P60\020*\022\021\n\rem300L_72" +
      "0P30\020+\022\021\n\remX300_720P30\020,\022\022\n\016emX500_720P" +
      "_30\020-\022\022\n\016emX500_720P_60\020.\022\025\n\021em100_1080P" +
      "30_12X\020/\022\024\n\020em100_1080P30_3X\0200\022\017\n\013em100L",
      "_720P\0201\022\030\n\024em100_oem_1080P30_3X\0202\022\022\n\016emS" +
      "kyWindows_s\0203\022\017\n\013emSkyIPad_s\0204\022\021\n\remSkyI" +
      "Phone_s\0205\022\025\n\021emSkyAndroidPad_s\0206\022\027\n\023emSk" +
      "yAndroidPhone_s\0207\022\024\n\020emX300_1080P60_s\0208\022" +
      "\024\n\020emX500_1080P60_s\0209\022\023\n\017em300_1080P60_s" +
      "\020:\022\014\n\010emX700_s\020;\022\017\n\013emX500_4K_s\020<\022\027\n\023em1" +
      "00_1080P30_12X_s\020=\022\025\n\021emX300_1080P60_cs\020" +
      ">\022\025\n\021emX500_1080P60_cs\020?\022\024\n\020em300_1080P6" +
      "0_cs\020@\022\r\n\temX700_cs\020A\022\020\n\014emX500_4K_cs\020B\022" +
      "\030\n\024em100_1080P30_12X_cs\020C\022\030\n\024em100_1080P",
      "30_12X_H5\020D\022\027\n\023em100_1080P30_3X_H5\020E\022\030\n\024" +
      "em100_DX_1080P30_12X\020F\022\027\n\023em100_DX_1080P" +
      "30_3X\020G\022\022\n\016em100L_DX_720P\020H\022\022\n\016emX310_10" +
      "80P60\020I\022\024\n\020emX310_1080P60_S\020J\022\022\n\016emX310_" +
      "1080P30\020K\022\022\n\016emX510_1080P60\020L\022\024\n\020emX510_" +
      "1080P60_S\020M\022\022\n\016emX510_1080P30\020N\022\r\n\temX51" +
      "0_4K\020O\022\017\n\013emX510_4K_S\020P\022\026\n\022em310I_1080P6" +
      "0_12X\020Q\022\030\n\024em310I_1080P60_12X_S\020R\022\025\n\021em3" +
      "10_1080P30_12X\020S\022\027\n\023em310_1080P30_12X_S\020" +
      "T\022\024\n\020em310_1080P30_5X\020U*\\\n\016EmConfProtoco",
      "l\022\023\n\017emProtocolBegin\020\000\022\t\n\005em323\020\001\022\t\n\005ems" +
      "ip\020\002\022\t\n\005emsat\020\003\022\t\n\005emtip\020\004\022\t\n\005emrtc\020\005*\330\002" +
      "\n\020EmCodecComponent\022\024\n\020emVidMainEncoder\020\000" +
      "\022\024\n\020emVidMainDecoder\020\001\022\024\n\020emAudMainEncod" +
      "er\020\002\022\024\n\020emAudMainDecoder\020\003\022\022\n\016emAudMainM" +
      "ixer\020\004\022\022\n\016emVidMainMixer\020\005\022\023\n\017emVidAssEn" +
      "coder\020\006\022\023\n\017emVidAssDecoder\020\007\022\023\n\017emAudAss" +
      "Encoder\020\010\022\023\n\017emAudAssDecoder\020\t\022\021\n\remAudA" +
      "ssMixer\020\n\022\021\n\remVidAssMixer\020\013\022\032\n\026emVidMai" +
      "nSecondEncoder\020\014\022\032\n\026emVidMainSecondDecod",
      "er\020\r\022\022\n\016emCodecInvalid\020\024*z\n\025EmCodecCompo" +
      "nentIndex\022\t\n\005em1st\020\000\022\t\n\005em2nd\020\001\022\t\n\005em3rd" +
      "\020\002\022\t\n\005em4th\020\003\022\t\n\005em5th\020\004\022\t\n\005em6th\020\005\022\t\n\005e" +
      "m7th\020\006\022\t\n\005em8th\020\007\022\t\n\005em9th\020\010*y\n\013EmVidFor" +
      "mat\022\013\n\007emVH261\020\000\022\013\n\007emVH262\020\001\022\013\n\007emVH263" +
      "\020\002\022\017\n\013emVH263plus\020\003\022\013\n\007emVH264\020\004\022\014\n\010emVM" +
      "PEG4\020\005\022\013\n\007emVH265\020\006\022\n\n\006emVEnd\020\007*\321\001\n\013EmAu" +
      "dFormat\022\014\n\010emAG711a\020\000\022\014\n\010emAG711u\020\001\022\013\n\007e" +
      "mAG722\020\002\022\014\n\010emAG7231\020\003\022\013\n\007emAG728\020\004\022\013\n\007e" +
      "mAG729\020\005\022\n\n\006emAMP3\020\006\022\013\n\007emAG721\020\007\022\014\n\010emA",
      "G7221\020\010\022\013\n\007emAG719\020\t\022\020\n\014emAMpegAACLC\020\n\022\020" +
      "\n\014emAMpegAACLD\020\013\022\013\n\007emAOpus\020\014\022\014\n\010emAudEn" +
      "d\020\r*4\n\014EmEncodeMode\022\022\n\016emQualityFirst\020\000\022" +
      "\020\n\014emSpeedFirst\020\001*:\n\020EmTermSwitchMode\022\017\n" +
      "\013emModeBegin\020\000\022\025\n\021emAudioAndAssMode\020\001*\210\t" +
      "\n\016EmMtResolution\022\017\n\013emMtResAuto\020\000\022\r\n\temM" +
      "tSQCIF\020\001\022\014\n\010emMtQCIF\020\002\022\013\n\007emMtCIF\020\003\022\014\n\010e" +
      "mMt2CIF\020\004\022\014\n\010emMt4CIF\020\005\022\r\n\temMt16CIF\020\006\022\022" +
      "\n\016emMtVGA352x240\020\007\022\014\n\010emMt2SIF\020\010\022\022\n\016emMt" +
      "VGA704x480\020\t\022\022\n\016emMtVGA640x480\020\n\022\022\n\016emMt",
      "VGA800x600\020\013\022\023\n\017emMtVGA1024x768\020\014\022\r\n\temM" +
      "tVWCIF\020\r\022\024\n\020emMtVSQCIF112x96\020\016\022\023\n\017emMtVS" +
      "QCIF96x80\020\017\022\016\n\nemMtVW4CIF\020\020\022\026\n\022emMtHD720" +
      "p1280x720\020\021\022\024\n\020emMtVGA1280x1024\020\022\022\024\n\020emM" +
      "tVGA1600x1200\020\023\022\030\n\024emMtHD1080i1920x1080\020" +
      "\024\022\030\n\024emMtHD1080p1920x1080\020\025\022\023\n\017emMtVGA12" +
      "80x800\020\026\022\023\n\017emMtVGA1440x900\020\027\022\023\n\017emMtVGA" +
      "1280x960\020\030\022\021\n\remMtV1440x816\020\031\022\020\n\014emMt128" +
      "0x720\020\032\022\020\n\014emMtV960x544\020\033\022\020\n\014emMtV640x36" +
      "8\020\034\022\020\n\014emMtV480x272\020\035\022\017\n\013emMt384x272\020\036\022\017",
      "\n\013emMt640x544\020\037\022\017\n\013emMt320x272\020 \022\024\n\020emMt" +
      "_720_960x544\020!\022\024\n\020emMt_720_864x480\020\"\022\024\n\020" +
      "emMt_720_640x368\020#\022\024\n\020emMt_720_432x240\020$" +
      "\022\024\n\020emMt_720_320x192\020%\022\022\n\016emMtVGA480x352" +
      "\020&\022\025\n\021emMtHD480i720x480\020\'\022\025\n\021emMtHD480p7" +
      "20x480\020(\022\025\n\021emMtHD576i720x576\020)\022\025\n\021emMtH" +
      "D576p720x576\020*\022\023\n\017emMtVGA1280x768\020+\022\023\n\017e" +
      "mMtVGA1366x768\020,\022\023\n\017emMtVGA1280x854\020-\022\024\n" +
      "\020emMtVGA1680x1050\020.\022\024\n\020emMtVGA1920x1200\020" +
      "/\022\022\n\016emMtV3840x2160\0200\022\020\n\014emMt1280x600\0201\022",
      "\020\n\014emMt1360x768\0202\022\025\n\021emMtVRes3840x2160\0203" +
      "\022\025\n\021emMtVRes4096x2048\0204\022\025\n\021emMtVRes4096x" +
      "2160\0205\022\025\n\021emMtVRes4096x2304\0206\022\017\n\013emMt960" +
      "x540\0207\022\017\n\013emMt480x270\0208\022\017\n\013emMtVResEnd\020d" +
      "*\205\001\n\tEmVidPort\022\023\n\017emH600VidInHDMI\020\000\022\022\n\016e" +
      "mH600VidInVGA\020\001\022\020\n\014emH600VidInC\020\002\022\023\n\017emH" +
      "600VidOutDVI\020\003\022\024\n\020emH600VidOutHDMI\020\004\022\022\n\016" +
      "emH700VidInDVI\020\005*4\n\tEmAudPort\022\022\n\016emH600A" +
      "udInRCA\020\000\022\023\n\017emH600AudOutRCA\020\001*i\n\022EmLost" +
      "PackStrategy\022\025\n\021emLPSQualityFirst\020\000\022\022\n\016e",
      "mLPSSpeedSlow\020\001\022\024\n\020emLPSSpeedNormal\020\002\022\022\n" +
      "\016emLPSSpeedFast\020\003*&\n\014EmIpAddrType\022\n\n\006emI" +
      "pV4\020\000\022\n\n\006emIpV6\020\001*P\n\nEmStopBits\022\016\n\nem0St" +
      "opBit\020\000\022\016\n\nem1StopBit\020\001\022\016\n\nem2StopBit\020\002\022" +
      "\022\n\016em1HalfStopBit\020\003*?\n\rEmParityCheck\022\r\n\t" +
      "emNoCheck\020\000\022\016\n\nemOddCheck\020\001\022\017\n\013emEvenChe" +
      "ck\020\002*z\n\014EmSerialType\022\013\n\007emRS232\020\000\022\013\n\007emR" +
      "S422\020\001\022\013\n\007emRS485\020\002\022\024\n\020emSerialInfrared\020" +
      "\003\022\016\n\nemHDBaseT1\020\004\022\016\n\nemHDBaseT2\020\005\022\r\n\temR" +
      "S232_2\020\006*;\n\016EmDisplayRatio\022\014\n\010emDR4to3\020\000",
      "\022\r\n\temDR16to9\020\001\022\014\n\010emDRAuto\020\002*T\n\014EmAnswe" +
      "rMode\022\024\n\020emAnswerModeAuto\020\000\022\024\n\020emAnswerM" +
      "odeManu\020\001\022\030\n\024emAnswerModeNegative\020\002*U\n\025E" +
      "mH264AdditionalModes\022\016\n\nemModeNone\020\000\022\016\n\n" +
      "emModeRCD0\020@\022\r\n\temModeSBP\020 \022\r\n\temModeSHP" +
      "\020\020*\202\001\n\rEmH264Profile\022\r\n\temInvalid\020\000\022\016\n\ne" +
      "mBaseline\020\001\022\n\n\006emMain\020\002\022\016\n\nemExtended\020\004\022" +
      "\n\n\006emHigh\020\010\022\014\n\010emHigh10\020\020\022\r\n\temHigh422\020 " +
      "\022\r\n\temHigh444\020@*O\n\rEmH265Profile\022\021\n\remPr" +
      "ofileMain\020\000\022\023\n\017emProfileMain10\020\001\022\026\n\022emPr",
      "ofileMainStill\020\002*N\n\013EmDirection\022\010\n\004emUP\020" +
      "\000\022\n\n\006emDown\020\001\022\n\n\006emLeft\020\002\022\013\n\007emRight\020\003\022\020" +
      "\n\014emDirInvalid\020\n*\372\001\n\021EmFeccPTFZRequest\022\030" +
      "\n\024emFeccRequestInvalid\020\000\022\022\n\remFeccPanLef" +
      "t\020\200\001\022\023\n\016emFeccPanRight\020\300\001\022\020\n\014emFeccTiltU" +
      "p\0200\022\022\n\016emFeccTiltDown\020 \022\021\n\remFeccFocusIn" +
      "\020\003\022\022\n\016emFeccFocusOut\020\002\022\020\n\014emFeccZoomIn\020\014" +
      "\022\021\n\remFeccZoomOut\020\010\022\026\n\022emFeccBrightnessU" +
      "p\020\001\022\030\n\024emFeccBrightnessDown\020\004*\220\002\n\014EmFecc" +
      "Action\022\027\n\023emFeccActionInvalid\020\000\022\025\n\021emFec",
      "cActionStart\020\001\022\030\n\024emFeccActionContinue\020\002" +
      "\022\024\n\020emFeccActionStop\020\003\022!\n\035emFeccActionSe" +
      "lectVideoSource\020\004\022#\n\037emFeccActionVideoSo" +
      "urceSwitched\020\005\022\035\n\031emFeccActionStoreAsPre" +
      "set\020\006\022\036\n\032emFeccActionActivatePreset\020\007\022\031\n" +
      "\025emFeccActionAutoFocus\020\021*\236\001\n\020EmFeccCMEMs" +
      "gType\022\024\n\020emFeccCMEInvalid\020\000\022\033\n\027emFeccCME" +
      "ClientListInfo\020\001\022\036\n\032emFeccCMEClientListC" +
      "ommond\020\002\022\031\n\025emFeccCMEExtraCapInfo\020\003\022\034\n\030e" +
      "mFeccCMEExtraCapCommond\020\004*z\n\017EmMtSysStar",
      "tMod\022\030\n\024emSysStartMod_By_lib\020\000\022\030\n\024emSysS" +
      "tartMod_By_Dll\020\001\022\034\n\030emSysStartMod_By_Pro" +
      "cess\020\002\022\025\n\021emSysStartMod_End\020\003*]\n\025EmMtSys" +
      "StartModFromUI\022\025\n\021emSysStart_By_Dll\020\000\022\031\n" +
      "\025emSysStart_By_Process\020\001\022\022\n\016emSysStart_E" +
      "nd\020\002*\215\001\n\017EmMtSysSrvState\022\026\n\022emSysSrvStat" +
      "e_Idle\020\000\022\030\n\024emSysSrvState_Binded\020\001\022\031\n\025em" +
      "SysSrvState_Running\020\002\022\026\n\022emSysSrvState_S" +
      "top\020\003\022\025\n\021emSysSrvState_Err\020\004*\\\n\024EmMtSysK" +
      "eepLiveState\022\026\n\022emSysKLState_Ready\020\000\022\026\n\022",
      "emSysKLState_Alive\020\001\022\024\n\020emSysKLState_Err" +
      "\020\002*\245\002\n\014EmMtChanType\022\023\n\017emChanSendAudio\020\000" +
      "\022\023\n\017emChanRecvAudio\020\001\022\023\n\017emChanSendVideo" +
      "\020\002\022\023\n\017emChanRecvVideo\020\003\022\026\n\022emChanSendAss" +
      "Audio\020\004\022\026\n\022emChanRecvAssAudio\020\005\022\026\n\022emCha" +
      "nSendAssVideo\020\006\022\026\n\022emChanRecvAssVideo\020\007\022" +
      "\022\n\016emChanSendFecc\020\010\022\022\n\016emChanRecvFecc\020\t\022" +
      "\022\n\016emChanSendT120\020\n\022\022\n\016emChanRecvT120\020\013\022" +
      "\021\n\remChanTypeEnd\020\014*R\n\021EmMtAssStreamType\022" +
      "\024\n\020emAssStreamBegin\020\000\022\021\n\remPcAssStream\020\001",
      "\022\024\n\020emVideoAssStream\020\002*f\n\014EmMtVidLabel\022\021" +
      "\n\remVidLabBegin\020\000\022\024\n\020emPcStreamVidLab\020\024\022" +
      "\027\n\023emVideoStreamVidLab\020\025\022\024\n\020emQkStreamVi" +
      "dLab\020\026*!\n\014EmMtAudLabel\022\021\n\remAudLabBegin\020" +
      "\000*:\n\014EmMtConfType\022\024\n\020emConfType_Video\020\000\022" +
      "\024\n\020emConfType_Audio\020\001*i\n\rEmMtMediaType\022\020" +
      "\n\014emMediaBegin\020\000\022\020\n\014emMediaVideo\020\001\022\020\n\014em" +
      "MediaAudio\020\002\022\r\n\temMediaAV\020\003\022\023\n\017emMediaAs" +
      "sVideo\020\004*\224\001\n\016EmMediaModeDef\022\023\n\017emMediaMd" +
      "oeNone\020\000\022\024\n\020emMediaMdoeVideo\020\001\022\024\n\020emMedi",
      "aMdoeAudio\020\002\022\023\n\017emMediaMdoeBoth\020\003\022\023\n\017emM" +
      "ediaMdoeData\020\004\022\027\n\023emMediaMdoeSecvideo\020\005*" +
      "#\n\006EmSite\022\013\n\007emLocal\020\000\022\014\n\010emRemote\020\001*P\n\022" +
      "EmMtMediaDirection\022\024\n\020emDirectionBegin\020\000" +
      "\022\021\n\remChannelSend\020\001\022\021\n\remChannelRecv\020\002*\211" +
      "\001\n\014EmAacChnlNum\022\017\n\013emCnNumCust\020\000\022\014\n\010emCn" +
      "Num1\020\001\022\014\n\010emCnNum2\020\002\022\014\n\010emCnNum3\020\004\022\014\n\010em" +
      "CnNum4\020\010\022\014\n\010emCnNum5\020\020\022\020\n\014emCnNum5dot1\020 " +
      "\022\020\n\014emCnNum7dot1\020@*\316\001\n\rEmAacSampFreq\022\016\n\n" +
      "emASF96000\020\000\022\016\n\nemASF88200\020\001\022\016\n\nemASF640",
      "00\020\002\022\016\n\nemASF48000\020\003\022\016\n\nemASF44100\020\004\022\016\n\n" +
      "emASF32000\020\005\022\016\n\nemASF24000\020\006\022\016\n\nemASF220" +
      "50\020\007\022\016\n\nemASF16000\020\010\022\016\n\nemASF12000\020\t\022\016\n\n" +
      "emASF11025\020\n\022\r\n\temASF8000\020\013*4\n\rEmMtChanS" +
      "tate\022\016\n\nemChanIdle\020\000\022\023\n\017emChanConnected\020" +
      "\001*V\n\017EmMtCallingType\022\016\n\nemJoinConf\020\000\022\020\n\014" +
      "emCreateConf\020\001\022\r\n\temOutCall\020\002\022\022\n\016emIncom" +
      "ingCall\020\003*\324\001\n\rEmMtCallState\022\016\n\nemCallIdl" +
      "e\020\000\022\030\n\024emCallRasConfJoining\020\001\022\031\n\025emCallR" +
      "asConfCreating\020\002\022\020\n\014emCallOuting\020\003\022\022\n\016em",
      "CallIncoming\020\004\022\022\n\016emCallAccepted\020\005\022\021\n\rem" +
      "CallHanging\020\006\022\023\n\017emCallConnected\020\007\022\r\n\tem" +
      "CallP2P\020\010\022\r\n\temCallMCC\020\t*\333\001\n\017EmH323ChanS" +
      "tate\022\023\n\017emChanStateIdle\020\000\022\027\n\023emChanState" +
      "Creating\020\001\022\026\n\022emChanStateOpening\020\002\022\027\n\023em" +
      "ChanStateRejected\020\003\022\027\n\023emChanStateOfferi" +
      "ng\020\004\022\030\n\024emChanStateConnected\020\005\022\030\n\024emChan" +
      "StateReopening\020\006\022\034\n\030emChanStateDisconnec" +
      "ting\020\007*\231\002\n\017EmH323CallState\022\023\n\017emCallStat" +
      "eIdle\020\000\022\025\n\021emCallState460Out\020\001\022\027\n\023emCall",
      "StateCreating\020\002\022\032\n\026emCallStateArqOutgoin" +
      "g\020\003\022\031\n\025emCallStateCallOuting\020\004\022\033\n\027emCall" +
      "StateCallincoming\020\005\022\033\n\027emCallStateCallAc" +
      "cepted\020\006\022\030\n\024emCallStateHanguping\020\007\022\030\n\024em" +
      "CallStateConnected\020\010\022\034\n\030emCallStateOpenC" +
      "hanReady\020\t*n\n\016EmEndpointType\022\031\n\025emEndpoi" +
      "ntTypeUnknown\020\000\022\024\n\020emEndpointTypeMT\020\001\022\025\n" +
      "\021emEndpointTypeMCU\020\002\022\024\n\020emEndpointTypeGK" +
      "\020\004*t\n\tEmSMSType\022\023\n\017emSMSSingleLine\020\000\022\022\n\016" +
      "emSMSPageTitle\020\001\022\022\n\016emSMSRollTitle\020\002\022\024\n\020",
      "emSMSStaticTitle\020\003\022\024\n\020emSMSUpRollTitle\020\004" +
      "*t\n\016EmRollMsgSpeed\022\022\n\016emROLL_SPEED_1\020\001\022\022" +
      "\n\016emROLL_SPEED_2\020\002\022\022\n\016emROLL_SPEED_3\020\003\022\022" +
      "\n\016emROLL_SPEED_4\020\004\022\022\n\016emROLL_SPEED_5\020\005*\252" +
      "\005\n\rEmMtVideoPort\022\022\n\016emMtVidInvalid\020\000\022\024\n\020" +
      "emMtVidMultiView\020\001\022\026\n\022emMtVidInnerCamera" +
      "\020\002\022\017\n\013emMtVidDVI1\020\003\022\017\n\013emMtVidDVI2\020\004\022\017\n\013" +
      "emMtVidDVI3\020\005\022\017\n\013emMtVidDVI4\020\006\022\020\n\014emMtVi" +
      "dHDMI1\020\007\022\020\n\014emMtVidHDMI2\020\010\022\020\n\014emMtVidHDM" +
      "I3\020\t\022\020\n\014emMtVidHDMI4\020\n\022\021\n\remMtVidYPbPr1\020",
      "\013\022\021\n\remMtVidYPbPr2\020\014\022\021\n\remMtVidYPbPr3\020\r\022" +
      "\021\n\remMtVidYPbPr4\020\016\022\017\n\013emMtVidVGA1\020\017\022\017\n\013e" +
      "mMtVidVGA2\020\020\022\017\n\013emMtVidVGA3\020\021\022\017\n\013emMtVid" +
      "VGA4\020\022\022\r\n\temMtVidC1\020\023\022\r\n\temMtVidC2\020\024\022\r\n\t" +
      "emMtVidC3\020\025\022\r\n\temMtVidS1\020\026\022\r\n\temMtVidS2\020" +
      "\027\022\r\n\temMtVidS3\020\030\022\023\n\017emMtVidHDBaseT1\020\031\022\023\n" +
      "\017emMtVidHDBaseT2\020\032\022\023\n\017emMtVidHDBaseT3\020\033\022" +
      "\023\n\017emMtVidHDBaseT4\020\034\022\017\n\013emMtVidSDI1\020\035\022\017\n" +
      "\013emMtVidSDI2\020\036\022\017\n\013emMtVidSDI3\020\037\022\017\n\013emMtV" +
      "idSDI4\020 \022\027\n\023emMtVidInnerCamera2\020!\022\027\n\023emM",
      "tVidInnerCamera3\020\"\022\027\n\023emMtVidInnerCamera" +
      "4\020#*\253\005\n\025EmMtJoinCreateConfRsp\022\027\n\023emJoinC" +
      "reat_Success\020\000\022\031\n\025emJoinCreat_Serdb_err\020" +
      "\001\022\033\n\027emJoinCreat_Timeout_err\020\002\022\033\n\027emJoin" +
      "Creat_Note164_err\020\003\022\030\n\024emJoinCreat_Data_" +
      "err\020\004\022\035\n\031emJoinCreat_Mcu_noidlevpu\020\005\022&\n\"" +
      "emJoinCreat_Mcu_minimediaconfmtnum\020\006\022\036\n\032" +
      "emJoinCreat_Mcu_maxconfnum\020\007\022\036\n\032emJoinCr" +
      "eat_Mcu_encrypeerr\020\010\022 \n\034emJoinCreat_Mcu_" +
      "confnotexist\020\t\022\035\n\031emJoinCreat_Mcu_undefi",
      "ned\020\n\022$\n emJoinCreat_Gk_mpcd_disconnecte" +
      "d\020\013\022\034\n\030emJoinCreat_Mcu_maxmtnum\020\014\022\032\n\026emJ" +
      "oinCreat_Mcu_pwderr\020\r\022\033\n\027emJoinCreat_Mcu" +
      "_nsatpms\020\016\022\035\n\031emJoinCreat_Mcu_nsatdaddr\020" +
      "\017\022\033\n\027emJoinCreat_E164_repeat\020\020\022 \n\034emJoin" +
      "Creat_CallerNum_exceed\020\021\022#\n\037emJoinCreat_" +
      "Mcu_NoDisturbReject\020\022\022 \n\034emJoinCreat_Mcu" +
      "_ConfResuming\020\023\022 \n\034emJoinCreat_Mcu_NoPer" +
      "mission\020\024*\340\001\n\021EmMtConfDetailErr\022\034\n\030emCon" +
      "fDetail_Err_Success\020\000\022\033\n\027emConfDetail_Er",
      "r_Ser_db\020\001\022\034\n\030emConfDetail_Err_Timeout\020\002" +
      "\022\034\n\030emConfDetail_Err_Note164\020\003\022\031\n\025emConf" +
      "Detail_Err_Data\020\004\022\033\n\027emConfDetail_Err_Is" +
      "over\020\005\022\034\n\030emConfDetail_Err_Unknown\020\006*]\n\014" +
      "EmMtDualMode\022\030\n\024MT_DUAL_MODE_SPEAKER\020\000\022\031" +
      "\n\025MT_DUAL_MODE_EVERYONE\020\001\022\030\n\024MT_DUAL_MOD" +
      "E_INVALID\020\002*\207\002\n\017EmMtPollModeDef\022\024\n\020emPOL" +
      "L_MODE_NONE\020\000\022\024\n\020emOLL_MODE_VIDEO\020\001\022\027\n\023e" +
      "mPOLL_MODE_SPEAKER\020\002\022\031\n\025emPOLL_MODE_VIDE" +
      "O_SPY\020\003\022\033\n\027emPOLL_MODE_SPEAKER_SPY\020\004\022\032\n\026",
      "emPOLL_MODE_VIDEO_BOTH\020\005\022\034\n\030emPOLL_MODE_" +
      "SPEAKER_BOTH\020\006\022\036\n\032emPOLL_MODE_VIDEO_CHAI" +
      "RMAN\020\007\022\035\n\031emPOLL_MODE_BOTH_CHAIRMAN\020\010*\266\002" +
      "\n\031EmMtPairTalkOperationType\022\"\n\036emMtPairT" +
      "alkOperationTypeBegin\020\000\022\'\n#emMtPairTalkO" +
      "perationTypeChairStart\020\001\022&\n\"emMtPairTalk" +
      "OperationTypeChairStop\020\002\022&\n\"emMtPairTalk" +
      "OperationTypeChairJoin\020\003\022&\n\"emMtPairTalk" +
      "OperationTypeChairQuit\020\004\022)\n%emMtPairTalk" +
      "OperationTypeAudienceJoin\020\005\022)\n%emMtPairT",
      "alkOperationTypeAudienceQuit\020\006*6\n\014EmMtCa" +
      "llMode\022\n\n\006emJoin\020\000\022\014\n\010emCreate\020\001\022\014\n\010emIn" +
      "vite\020\002*K\n\014EmMtConfMode\022\016\n\nemConfNone\020\000\022\r" +
      "\n\temP2PConf\020\001\022\r\n\temMCCConf\020\002\022\r\n\temFXOCon" +
      "f\020\003*\304\001\n\020EmMtLogChnnlType\022\025\n\021emMt_LOGCHL_" +
      "VIDEO\020\001\022\025\n\021emMt_LOGCHL_AUDIO\020\002\022\030\n\024emMt_L" +
      "OGCHL_SECVIDEO\020\003\022\030\n\024emMt_LOGCHL_T120DATA" +
      "\020\004\022\030\n\024emMt_LOGCHL_H224DATA\020\005\022\030\n\024emMt_LOG" +
      "CHL_MMCUDATA\020\006\022\032\n\026emMt_LOGCHL_VIDEO_BOTH" +
      "\020\007*\224\006\n\024EmMtMcu2MtNtfMsgType\022\021\n\remMt_NONE",
      "_NTF\020\001\022\033\n\027emMt_BE_POLLED_NEXT_NTF\020\002\022#\n\037e" +
      "mMt_NO_OPEN_DSCHNNL_NONSPEAKER\020\013\022\036\n\032emMt" +
      "_NO_OPEN_DSCHNNLNONCAP\020\014\022\037\n\033emMt_NO_OPEN" +
      "_DSCHNNLBRLOW64\020\r\022\037\n\033emMt_NO_OPEN_DSCHNN" +
      "LFECTYPE\020\016\022\035\n\031emMt_NO_OPEN_DSCHNNLNONMP\020" +
      "\017\022#\n\037emMt_NO_OPEN_DSCHNNLENCRYPTMODE\020\020\022*" +
      "\n&emMt_NO_OPEN_DSCHNNLOVERSATDCASTCHNNUM" +
      "\020\021\022\037\n\033emMt_NO_OPEN_FSCHNNL_NONCAP\020\037\022!\n\035e" +
      "mMt_NO_OPEN_FSCHNNL_BR_LOW64\020 \022%\n!emMt_N" +
      "O_OPEN_FSCHNNL_ENCRPYT_MODE\020!\022 \n\034emMt_NO",
      "_OPEN_FSCHNNL_FECTYPE\020\"\022\036\n\032emMt_NO_OPEN_" +
      "FSCHNNL_NONMP\020#\022$\n emMt_NO_OPEN_FSCHNNL_" +
      "BR_OVERFLOW\020$\022&\n\"emMt_NO_OPEN_FSCHNNL_BO" +
      "TH_H263PLUS\020%\022\037\n\033emMt_NO_OPEN_FSCHNNL_FO" +
      "RMAT\020&\022\034\n\030emMt_NO_OPEN_FSCHNNL_FPS\020\'\022&\n\"" +
      "emMt_CALL_FAILED_BR_LESS_THAN_CONF\0203\022(\n$" +
      "emMt_CALL_FAILED_BR_LARGER_THAN_CONF\0204\022\"" +
      "\n\036emMt_NO_SUPPORT_OPR_FOR_NOAUTH\0205\022%\n!em" +
      "Mt_NO_IN_MIXGRP_APPLY_INTERRUPT\0206*\227\001\n\017Em" +
      "GetListRspErr\022\023\n\017emList_Finished\020\000\022\027\n\023em",
      "List_Not_Finished\020\001\022\026\n\022emList_UnComplete" +
      "d\020\002\022\023\n\017emList_SerDbErr\020\003\022\022\n\016emList_Timeo" +
      "ut\020\004\022\025\n\021emList_UnknownErr\020\005*6\n\rEmConfSpe" +
      "cial\022\020\n\014emNormalConf\020\000\022\023\n\017emSatelliteCon" +
      "f\020\001*s\n\016EmConfListType\022\027\n\023emConfListType_" +
      "Hold\020\000\022\027\n\023emConfListType_Book\020\001\022\027\n\023emCon" +
      "fListType_Temp\020\002\022\026\n\022emConfListType_End\020\003" +
      "*\177\n\013EmMtClarity\022\020\n\014EmMt_HD_MODE\020\001\022\020\n\014EmM" +
      "t_SD_MODE\020\002\022\024\n\020EmMt_FLUENT_MODE\020\003\022\020\n\014EmM" +
      "t_UD_MODE\020\004\022\021\n\rEmMt_FHD_MODE\020\005\022\021\n\rEmMt_U",
      "HD_MODE\020\006*\230\001\n\010EmMtType\022\020\n\014EmMt_Type_Mt\020\000" +
      "\022\023\n\017EmMt_Type_PHONE\020\001\022\022\n\016EmMt_Type_SATD\020" +
      "\002\022\022\n\016EmMt_Type_MMCU\020\003\022\022\n\016EmMt_Type_SMCU\020" +
      "\004\022\024\n\020EmMt_Type_VRSREC\020\005\022\023\n\017EmMt_Type_Oth" +
      "er\020\n*\177\n\014EmMtAddrType\022\014\n\010emAddrIP\020\000\022\016\n\nem" +
      "AddrE164\020\001\022\017\n\013emAddrAlias\020\002\022\r\n\temDialNum" +
      "\020\003\022\r\n\temSipAddr\020\004\022\016\n\nemAddrMoid\020\005\022\022\n\016emN" +
      "oSysMailbox\020\006*\242\002\n\026EmMtModifyConfInfoType" +
      "\022\023\n\017MT_MODIFY_BEGIN\020\000\022\033\n\027MT_MODIFY_CONF_" +
      "NAMETYPE\020\001\022\037\n\033MT_MODIFY_CONF_DURATIONTYP",
      "E\020\002\022\032\n\026MT_MODIFY_CONF_PWDTYPE\020\003\022 \n\034MT_MO" +
      "DIFY_CONF_DUAL_MODETYPE\020\004\022#\n\037MT_MODIFY_C" +
      "ONF_SHOW_MEMBERALIAS\020\005\022\033\n\027MT_MODIFY_CONF" +
      "_OPENMODE\020\006\022\027\n\023MT_MODIFY_CONF_DUMB\020\007\022\034\n\030" +
      "MT_MODIFY_CONF_NoDisturb\020\010*\240\005\n\025EmMtConfF" +
      "ailureReason\022(\n$emFAIL_REASON_DIFF_CONF_" +
      "ENCRYPT_MODE\020\001\022$\n emFAIL_REASON_MT_NOT_J" +
      "OINED_CONF\020\002\022#\n\037emFAIL_REASON_CONF_IS_NO" +
      "T_CPING\020\003\022!\n\035emFAIL_REASON_MT_IS_NOT_CHA" +
      "IR\020\004\022)\n%emFAIL_REASON_CONF_IS_NOT_DIALOG",
      "_MODE\020\005\022\'\n#emFAIL_REASON_NO_IDLE_CONF_RE" +
      "SOURCE\020\006\022$\n emFAIL_REASON_CONF_RESOURCE_" +
      "LACK\020\007\022\036\n\032emFAIL_REASON_MT_IN_DIALOG\020\010\022+" +
      "\n\'emFAIL_REASON_SEL_MT_VID_OVER_CHNNL_NU" +
      "M\020\t\022+\n\'emFAIL_REASON_SEL_MT_AUD_OVER_CHN" +
      "NL_NUM\020\n\022,\n(emFAIL_REASON_SEL_MT_BOTH_OV" +
      "ER_CHNNL_NUM\020\013\0224\n0emFAIL_REASON_CAN_NOT_" +
      "JION_VMP_BY_OVER_CHNNL_NUM\020\014\0224\n0emFAIL_R" +
      "EASON_CAN_NOT_JION_MIX_BY_OVER_CHNNL_NUM" +
      "\020\r\022&\n\"emFAIL_REASON_CHANGE_VMP_ASK_FALSE",
      "\020\016\0229\n5emFAIL_REASON_CAN_NOT_JION_CTRY_VM" +
      "P_BY_OVER_CHNNL_NUM\020\017*R\n\026EmMtConfRelease" +
      "ModeDef\022\033\n\027emCONF_RELEASEMODE_NONE\020\000\022\033\n\027" +
      "emCONF_RELEASEMODE_NOMT\020\001*Z\n\rEmMtAliasTy" +
      "pe\022\013\n\007emBegin\020\000\022\n\n\006emE164\020\001\022\013\n\007emAlias\020\002" +
      "\022\013\n\007emEmail\020\003\022\n\n\006emEpID\020\004\022\n\n\006emGKID\020\005*,\n" +
      "\014EmMtOpenMode\022\r\n\temMt_OPEN\020\001\022\r\n\temMt_Hid" +
      "e\020\002*U\n\013EmMtVmpMode\022\026\n\022emMt_VMP_MODE_NONE" +
      "\020\000\022\026\n\022emMt_VMP_MODE_CTRL\020\001\022\026\n\022emMt_VMP_M" +
      "ODE_AUTO\020\002*|\n\013EmMtMixType\022\016\n\nemMcuNoMix\020",
      "\000\022\021\n\remMcuWholeMix\020\001\022\020\n\014emMcuPartMix\020\002\022\017" +
      "\n\013emMcuVacMix\020\003\022\024\n\020emMcuVacWholeMix\020\004\022\021\n" +
      "\remMcuSmartMix\020\005*\371\013\n\021EmMtCallDisReason\022\025" +
      "\n\021emDisconnect_Busy\020\000\022\027\n\023emDisconnect_No" +
      "rmal\020\001\022\031\n\025emDisconnect_Rejected\020\002\022\034\n\030emD" +
      "isconnect_Unreachable\020\003\022\026\n\022emDisconnect_" +
      "Local\020\004\022\030\n\024emDisconnect_Unknown\020\005\022\035\n\031emD" +
      "isconnect_AdaptiveBusy\020\007\022\027\n\023emDisconnect" +
      "_Occupy\020\010\022 \n\034emDisconnect_Joinconftimeou" +
      "t\020\024\022\"\n\036emDisconnect_Createconftimeout\020\025\022",
      " \n\034emDisconnect_Nomediaresource\020\026\022%\n!emD" +
      "isconnect_Exceedmaxinconfmtnum\020\027\022!\n\035emDi" +
      "sconnect_Exceedmaxconfnum\020\030\022\033\n\027emDisconn" +
      "ect_EncrypeErr\020\031\022\033\n\027emDisconnect_P2Ptime" +
      "out\020\032\022\030\n\024emDisconnect_MccDrop\020\033\022\032\n\026emDis" +
      "connect_ChairDrop\020\034\022\031\n\025emDisconnect_MMcu" +
      "Drop\020\035\022\034\n\030emDisconnect_ConfRelease\020\036\022\033\n\027" +
      "emDisconnect_PeerInConf\020\037\022\036\n\032emDisconnec" +
      "t_PeerNoDisturb\020 \022!\n\035emDisconnect_NotInP" +
      "eerContact\020!\022$\n emDisconnect_PeerNoP2PPe",
      "rmission\020\"\022\037\n\033emDisconnect_PeerOnSleepin" +
      "g\020#\022 \n\034emDisconnect_ConfAutoRelease\020$\022\037\n" +
      "\033emDisconnect_REASON_BUSYEXT\020%\022\'\n#emDisc" +
      "onnect_REASON_REMOTERECONNECT\020&\022\036\n\032emDis" +
      "Connect_CallNumExceed\020\'\022%\n!emDisConnect_" +
      "NotRegedToCallFailed\020(\022 \n\034emDisConnect_L" +
      "ocalVodPlaying\020)\022\036\n\032emDisConnect_SecCrtN" +
      "otFind\020*\022!\n\035emDisConnect_SecCrtVerifyFai" +
      "l\020+\022\036\n\032emDisConnect_SecCrtExpired\020,\022\"\n\036e" +
      "mDisConnect_SecCrtFormatError\020-\022\"\n\036emDis",
      "Connect_SecLoadCertFailed\020.\022 \n\034emDisConn" +
      "ect_SecEncTypeError\020/\022\"\n\036emDisConnect_Au" +
      "thenticationErr\0200\022\034\n\030emDisConnect_MtHasI" +
      "nConf\0201\022\033\n\027emDisConnect_MtEviction\0202\022%\n!" +
      "emDisConnect_SoftIntegrityTestErr\0203\022\032\n\026e" +
      "mDisConnect_GmTestErr\0204\022!\n\035emDisConnect_" +
      "RandomNumTestErr\0205\022\'\n#emDisConnect_Stron" +
      "gAuthButIpCallErr\0206\022\036\n\032emDisConnect_Chan" +
      "nelNoAuth\0207\022(\n$emDisConnect_QtCallButNot" +
      "GetPeerE164\0208\022\037\n\033emDisconnect_CancleInpu",
      "tPwd\0209\022\024\n\020emDisconnect_End\020d*W\n\023EmUnRegF" +
      "ailedReason\022\020\n\014emURJRecived\020\000\022\023\n\017emURQSe" +
      "ndFailed\020\001\022\031\n\025emURQCreateHRASFailed\020\002*\363\004" +
      "\n\021EmRegFailedReason\022\023\n\017emGKFailedBegin\020\000" +
      "\022\023\n\017emGKUnReachable\020\001\022\023\n\017emInvalidAliase" +
      "\020\002\022\016\n\nemDupAlias\020\003\022\030\n\024emInvalidCallAddre" +
      "ss\020\004\022\031\n\025emResourceUnavailable\020\005\022\023\n\017emReg" +
      "NumberFull\020\007\022\026\n\022emGKSecurityDenial\020\010\022\020\n\014" +
      "emGKDismatch\020\t\022\020\n\014emUnRegGKReq\020\n\022\031\n\025emRR" +
      "QCreateHRASFailed\020\013\022\023\n\017emRRQSendFailed\020\014",
      "\022\024\n\020emSipFailedBegin\0202\022\031\n\025emSipLocalNorm" +
      "alUnreg\0203\022#\n\037emSipInvalidUserNameAndPass" +
      "word\0204\022\035\n\031emSipRegistrarUnReachable\0205\022\025\n" +
      "\021emSipInvalidAlias\0206\022\026\n\022emSipUnknownReas" +
      "on\0207\022\027\n\023emSipRegisterFailed\0208\022\030\n\024emSipRe" +
      "gisterNameDup\0209\022\023\n\017emSecCrtNotFind\020:\022\026\n\022" +
      "emSecCrtVerifyFail\020;\022\023\n\017emSecCrtExpired\020" +
      "<\022\027\n\023emSecCrtFormatError\020=\022\027\n\023emSecLoadC" +
      "ertFailed\020>\022\016\n\nemUnRegSuc\020Z*v\n\023EmEncrypt" +
      "Arithmetic\022\021\n\remEncryptNone\020\000\022\t\n\005emDES\020\001",
      "\022\t\n\005emAES\020\002\022\t\n\005emSM1\020\003\022\t\n\005emSM4\020\004\022\t\n\005emS" +
      "M2\020\005\022\t\n\005emSM3\020\006\022\n\n\006emAuto\020\n*\224\024\n\014EmMtVmpS" +
      "tyle\022\023\n\017emInvalid_Style\020\000\022\032\n\026emMt_VMP_ST" +
      "YLE_DYNAMIC\020\001\022\024\n\020emMt_VMP_STYLE_1\020\002\022\030\n\024e" +
      "mMt_VMP_STYLE_2_1X2\020\003\022\034\n\030emMt_VMP_STYLE_" +
      "2_B1_S1RD\020\004\022\035\n\031emMt_VMP_STYLE_3_1U_2D1X2" +
      "\020\005\022\037\n\033emMt_VMP_STYLE_3_B1L_S2R2X1\020\006\022\035\n\031e" +
      "mMt_VMP_STYLE_3_1L_2R2X1\020\007\022\037\n\033emMt_VMP_S" +
      "TYLE_3_B1_S2LD1X2\020\010\022\030\n\024emMt_VMP_STYLE_3_" +
      "3X1\020\t\022\030\n\024emMt_VMP_STYLE_4_2X2\020\n\022\037\n\033emMt_",
      "VMP_STYLE_4_B1L_S3R3X1\020\013\022\037\n\033emMt_VMP_STY" +
      "LE_4_B1U_S3D1X3\020\014\022\037\n\033emMt_VMP_STYLE_5_B1" +
      "L_S4R4X1\020\r\022\037\n\033emMt_VMP_STYLE_5_B1U_S4D1X" +
      "4\020\016\022\"\n\036emMt_VMP_STYLE_5_B2U1X2_S3D1X3\020\017\022" +
      "(\n$emMt_VMP_STYLE_6_B1LU_S2RU2X1_S3D1X3\020" +
      "\020\022\"\n\036emMt_VMP_STYLE_6_B2U1X2_S4D1X4\020\021\022\030\n" +
      "\024emMt_VMP_STYLE_6_2X3\020\022\022\037\n\033emMt_VMP_STYL" +
      "E_6_B1U_S5D1X5\020\023\022(\n$emMt_VMP_STYLE_7_B2U" +
      "1X2_B1LD_S4RD2X2\020\024\0220\n,emMt_VMP_STYLE_7_S" +
      "2LU2X1_B1MU_S2RU2X1_B2D1X2\020\025\022\037\n\033emMt_VMP",
      "_STYLE_7_B1U_S6D1X6\020\026\022(\n$emMt_VMP_STYLE_" +
      "8_B1LU_S3RU3X1_S4D1X4\020\027\022\"\n\036emMt_VMP_STYL" +
      "E_8_B4L2X2_S4R4X1\020\030\022\030\n\024emMt_VMP_STYLE_9_" +
      "3X3\020\031\022&\n\"emMt_VMP_STYLE_9_S4U1X4_B1M_S4D" +
      "1X4\020\032\022#\n\037emMt_VMP_STYLE_10_B2L2X1_S8R4X2" +
      "\020\033\022#\n\037emMt_VMP_STYLE_10_B2U1X2_S8D2X4\020\034\022" +
      "*\n&emMt_VMP_STYLE_10_S4U1X4_B2M1X2_S4D1X" +
      "4\020\035\022*\n&emMt_VMP_STYLE_10_S4L4X1_B2M2X1_S" +
      "4R4X1\020\036\022\'\n#emMt_VMP_STYLE_11_S5U1X5_B1M_" +
      "S5D1X5\020\037\022!\n\035emMt_VMP_STYLE_11_B1U_S10D2X",
      "5\020 \022)\n%emMt_VMP_STYLE_12_B2U1X2_B1LD_S9R" +
      "D3X3\020!\022)\n%emMt_VMP_STYLE_12_B1LU_S5RU4X1" +
      "_S6D1X6\020\"\022)\n%emMt_VMP_STYLE_13_B1LU_S4RU" +
      "2X2_S8D2X4\020#\0228\n4emMt_VMP_STYLE_13_S4U1X4" +
      "_S2LM2X1_B1MM_S2LM2X1_S4D1X4\020$\022,\n(emMt_V" +
      "MP_STYLE_13_B4LU2X2_S4RU4X1_S5D1X5\020%\022-\n)" +
      "emMt_VMP_STYLE_14_B2LU1X2_S2RU2X1_S10D2X" +
      "5\020&\0225\n1emMt_VMP_STYLE_14_S5U1X5_B1LM_S2M" +
      "M2X1_B1RM_S5D1X5\020\'\022$\n emMt_VMP_STYLE_15_" +
      "B3U1X3_S12D2X6\020(\0228\n4emMt_VMP_STYLE_15_S4",
      "U1X4_S3LM3X1_B1MM_S3RM3X1_S4D1X4\020)\022\031\n\025em" +
      "Mt_VMP_STYLE_16_4X4\020*\022)\n%emMt_VMP_STYLE_" +
      "16_B1LU_S7RU7X1_S8D1X8\020+\0228\n4emMt_VMP_STY" +
      "LE_17_S5U1X5_S3LM3X1_B1MM_S3RM3X1_S5D1X5" +
      "\020,\022*\n&emMt_VMP_STYLE_17_B1LU_S6RU3X2_S10" +
      "D2X5\020-\022$\n emMt_VMP_STYLE_17_B2U1X2_S15D3" +
      "X5\020.\022*\n&emMt_VMP_STYLE_18_S6U1X6_B6M2X3_" +
      "S6D1X6\020/\022$\n emMt_VMP_STYLE_18_B6U2X3_S12" +
      "D2X6\0200\022*\n&emMt_VMP_STYLE_18_S6L6X1_B6M3X" +
      "2_S6R6X1\0201\022-\n)emMt_VMP_STYLE_19_B2LU1X2_",
      "S2RU2X1_S15D3X5\0202\022-\n)emMt_VMP_STYLE_19_B" +
      "2LU2X1_S12RU4X3_S5D1X5\0203\022$\n emMt_VMP_STY" +
      "LE_20_B2U1X2_S18D3X6\0204\022+\n\'emMt_VMP_STYLE" +
      "_20_S6U1X6_B2M1X2_S12D2X6\0205\0228\n4emMt_VMP_" +
      "STYLE_21_S6U1X6_S4LM4X1_B1MM_S4RM4X1_S6D" +
      "1X6\0206\022*\n&emMt_VMP_STYLE_21_B1LU_S8RU4X2_" +
      "S12D2X6\0207\022*\n&emMt_VMP_STYLE_22_B1LU_S6RU" +
      "2X3_S15D3X5\0208\022(\n$emMt_VMP_STYLE_23_4U1X4" +
      "_15M3X5_4D1X4\0209\0229\n5emMt_VMP_STYLE_23_B2U" +
      "1X2_S4LM2X2_B1MM_S4RM2X2_S12D2X6\020:\022;\n7em",
      "Mt_VMP_STYLE_24_S6U1X6_S4LM4X1_B4MM2X2_S" +
      "4RM4X1_S6D1X6\020;\022\031\n\025emMt_VMP_STYLE_25_5X5" +
      "\020<\0222\n.emMt_VMP_STYLE_25_S3LU3X1_B1MU_S3R" +
      "U3X1_S18D3X6\020=\022\034\n\030emMt_VMP_STYLE_2_B1_S1" +
      "RU\020>\022\034\n\030emMt_VMP_STYLE_2_B1_S1LD\020?\022\033\n\027em" +
      "Mt_VMP_STYLE_2_B1_S1L\020@\022\031\n\025emMt_VMP_STYL" +
      "E_20_5X4\020d*x\n\023EmMtMemberStatusDef\022\024\n\020emM" +
      "T_STATUS_NULL\020\000\022\030\n\024emMT_STATUS_AUDIENCE\020" +
      "\001\022\030\n\024emMT_STATUS_CHAIRMAN\020\002\022\027\n\023emMT_STAT" +
      "US_SPEAKER\020\003*\310\001\n\016EmMtVMPMmbType\022\025\n\021emVmp",
      "MmbType_NULL\020\000\022\023\n\017emVMPMmbMCSspec\020\001\022\023\n\017e" +
      "mVMPMmbSpeaker\020\002\022\024\n\020emVMPMmbChairman\020\003\022\020" +
      "\n\014emVMPMmbPoll\020\004\022\017\n\013emVMPMmbVAC\020\005\022\023\n\017emV" +
      "MPMmbCHLPOLL\020\006\022\023\n\017emVMPMmbDSTREAM\020\007\022\022\n\016e" +
      "mVMPMmbVCSPEC\020\010*Q\n\010EmAction\022\021\n\remActionB" +
      "egin\020\000\022\013\n\007emStart\020\001\022\n\n\006emStop\020\002\022\013\n\007emPau" +
      "se\020\003\022\014\n\010emResume\020\004*$\n\tEmFileSys\022\013\n\007emRAW" +
      "FS\020\000\022\n\n\006emTFFS\020\001*+\n\005EmQoS\022\016\n\nemDiffServ\020" +
      "\000\022\022\n\016emIPPrecedence\020\001*f\n\005EmTOS\022\r\n\temTOSN" +
      "one\020\000\022\020\n\014emTOSMinCost\020\001\022\024\n\020emTOSMaxRelia",
      "ble\020\002\022\023\n\017emTOSMaxThruput\020\003\022\021\n\remTOSMinDe" +
      "lay\020\004*\223\002\n\014EmCodecEvent\022\020\n\014emAudSpkMute\020\000" +
      "\022\020\n\014emAudMicMute\020\001\022\025\n\021emAudMicVolChange\020" +
      "\002\022\025\n\021emAudSpkVolChange\020\003\022\023\n\017emAudAecInva" +
      "lid\020\004\022\017\n\013emVidChange\020\006\022\024\n\020emNetLostPackL" +
      "v1\020\007\022\024\n\020emNetLostPackLv2\020\010\022\024\n\020emNetLostP" +
      "ackLv3\020\t\022\021\n\remNoVidCapDev\020\n\022\021\n\remNoAudCa" +
      "pDev\020\013\022\021\n\remNoAudPlyDev\020\014\022\020\n\014emOtherEven" +
      "t\020\r*?\n\tEmMtcType\022\r\n\temUnkownT\020\000\022\n\n\006emMtc" +
      "T\020\001\022\013\n\007emPcdvT\020\002\022\n\n\006emNctT\020\003*w\n\016EmMtSlee",
      "pState\022\014\n\010emWakeup\020\000\022\017\n\013emCountDown\020\001\022\020\n" +
      "\014emStandbyIng\020\002\022\r\n\temStandby\020\003\022\017\n\013emWake" +
      "uping\020\004\022\024\n\020emStandbyProtect\020\005*\367\002\n\014EmMtPo" +
      "rtType\022\021\n\remPortInvalid\020\000\022\024\n\020emPortTcpFo" +
      "rH323\020\001\022\014\n\010emPortMP\020\002\022\026\n\022emPortAudioEnco" +
      "der\020\003\022\026\n\022emPortAudioDecoder\020\004\022\026\n\022emPortV" +
      "ideoEncoder\020\005\022\026\n\022emPortVideoDecoder\020\006\022\030\n" +
      "\024emPortFwdPcAssStream\020\007\022\026\n\022emPortFwdAudi" +
      "oLoop\020\010\022\026\n\022emPortFwdVedioLoop\020\t\022\016\n\nemMcN" +
      "etBuf\020\n\022\017\n\013emPortMcVmp\020\013\022\021\n\remPortMcMixe",
      "r\020\014\022\026\n\022emPortInnerMcAudio\020\r\022\026\n\022emPortInn" +
      "erMcVedio\020\016\022\014\n\010emPortMc\020\017\022\024\n\020emPortInner" +
      "Proxy\020\020*Y\n\013EmLabelType\022\017\n\013emLabelAuto\020\000\022" +
      "\022\n\016emLabelUserDef\020\001\022\025\n\021emLabelUserDefPic" +
      "\020\002\022\016\n\nemLabelOff\020\003*b\n\016EmLabelPosType\022\r\n\t" +
      "emTopLeft\020\000\022\016\n\nemTopRight\020\001\022\020\n\014emBottomL" +
      "eft\020\002\022\021\n\remBottomRight\020\003\022\014\n\010emCustom\020\004*\212" +
      "\001\n\023EmDualVideoShowMode\022\034\n\030emDualVideoOnS" +
      "igleScreen\020\001\022\030\n\024emEachVideoOwnScreen\020\002\022\034" +
      "\n\030emTripleVideoOnSingleScn\020\003\022\035\n\031emThreeV",
      "ideoOnThreeScreen\020\004*\374\001\n\tEmPiPMode\022\020\n\014emP" +
      "ipInvalid\020\000\022\016\n\nemPiPClose\020\001\022\022\n\016emPIPLeft" +
      "Right\020\002\022\024\n\020emPiPRightBottom\020\003\022\023\n\017emPiPLe" +
      "ftBottom\020\004\022\020\n\014emPiPLeftTop\020\005\022\021\n\remPiPRig" +
      "htTop\020\006\022\035\n\031emPiPTwoSmallLeftInOneBig\020\007\022\036" +
      "\n\032emPiPTwoSmallRightInOneBig\020\010\022\032\n\026emPiPO" +
      "neBigAndTwoSmall\020\t\022\016\n\nemPiPThree\020\n*+\n\023Em" +
      "DisplayDeviceType\022\t\n\005emCRT\020\001\022\t\n\005emLCD\020\002*" +
      "=\n\017EmOsdScreenMode\022\014\n\010emSimple\020\001\022\014\n\010emNo" +
      "rmal\020\002\022\016\n\nemAdvanced\020\003*\235\001\n\010EmMtRing\022\016\n\ne",
      "mRingNone\020\000\022\013\n\007emRing1\020\001\022\013\n\007emRing2\020\002\022\013\n" +
      "\007emRing3\020\003\022\013\n\007emRing4\020\004\022\013\n\007emRing5\020\005\022\013\n\007" +
      "emRing6\020\006\022\013\n\007emRing7\020\007\022\013\n\007emRing8\020\010\022\013\n\007e" +
      "mRing9\020\t\022\014\n\010emRing10\020\n*\270\001\n\014EmMtPathType\022" +
      "\021\n\remPathTypeBgn\020\001\022\022\n\016emMtPathConfig\020\002\022\017" +
      "\n\013emMtPathLog\020\003\022\017\n\013emMtDataLog\020\004\022\017\n\013emMt" +
      "PathSec\020\005\022\021\n\remMtPathSecMT\020\006\022\022\n\016emMtPath" +
      "SecEnc\020\007\022\023\n\017emMtPathSecSign\020\010\022\022\n\remPathT" +
      "ypeEnd\020\377\001*\326\001\n\017EmMtOnlineState\022\024\n\020em_stat" +
      "e_invalid\020\000\022\024\n\020em_state_offline\020\001\022\022\n\016em_",
      "state_leave\020\002\022\023\n\017em_state_online\020\003\022\027\n\023em" +
      "_state_no_disturb\020\004\022\027\n\023em_state_conferen" +
      "ce\020\005\022\023\n\017em_state_hidden\020\006\022\025\n\021em_state_lo" +
      "gining\020\007\022\020\n\014em_state_end\020\010*\261\002\n\022EmMtImTer" +
      "minalType\022\026\n\022im_mt_type_unknown\020\000\022\030\n\024im_" +
      "mt_type_true_link\020\001\022\037\n\033im_mt_type_true_t" +
      "ouch_phone\020\002\022\035\n\031im_mt_type_true_touch_pa" +
      "d\020\003\022\030\n\024im_mt_type_true_sens\020\004\022#\n\037im_mt_t" +
      "ype_true_touch_phone_ios\020\005\022%\n!im_mt_type" +
      "_true_touch_pad_android\020\006\022\022\n\016im_mt_type_",
      "web\020\007\022\033\n\027im_mt_type_true_link_tv\020\010\022\022\n\016im" +
      "_mt_type_end\020\t*\205\004\n\010EmMtFile\022\021\n\remMtFileB" +
      "egin\020\000\022\022\n\016emMtConfigFile\020\001\022\027\n\023emMtDebugC" +
      "onfigFile\020\002\022\025\n\021emMtStaticPicFile\020\003\022\030\n\024em" +
      "MtUpgradeStateFile\020\004\022\025\n\021emMtMcLicenseFil" +
      "e\020\005\022\025\n\021emMtKdvlogCfgFile\020\006\022\031\n\025emMtCorrup" +
      "tConfigFile\020\007\022\025\n\021emMtExceptionFile\020\010\022\017\n\013" +
      "emMtLogFile\020\t\022\032\n\026emMtLocalCARASCertFile\020" +
      "\n\022\032\n\026emMtLocalCASM2CertFile\020\013\022\025\n\021emMtSec" +
      "CACertFile\020\014\022\031\n\025emMtSecDeviceCertFile\020\r\022",
      "\026\n\022emMtSecPrivkeyFile\020\016\022\027\n\023emMtSecSignCe" +
      "rtFile\020\017\022\032\n\026emMtSecSignPrivKeyFile\020\020\022\026\n\022" +
      "emMtSecEncCertFile\020\021\022\031\n\025emMtSecEncPrivKe" +
      "yFile\020\022\022\033\n\027emMtAgentTerLicenseFile\020\023\022\020\n\013" +
      "emMtFileEnd\020\377\001*\264\001\n\020EImDeclineReason\022\035\n\031i" +
      "m_decline_reason_unknown\020\001\022/\n+im_decline" +
      "_reason_max_persistent_room_count\020\002\022.\n*i" +
      "m_decline_reason_max_temporary_room_coun" +
      "t\020\003\022 \n\034im_decline_reason_from_weibo\020\004*_\n" +
      "\014EImCharState\022\030\n\024im_char_state_active\020\000\022",
      "\033\n\027im_char_state_composing\020\001\022\030\n\024im_char_" +
      "state_paused\020\002*{\n\016EmMtMemberType\022\025\n\021em_m" +
      "ember_invalid\020\000\022\023\n\017em_member_im_id\020\001\022\027\n\023" +
      "em_member_telephone\020\002\022\021\n\rem_member_fxo\020\003" +
      "\022\021\n\rem_member_jid\020\004*s\n\021EmMtMultiChatType" +
      "\022\030\n\024em_multichat_invalid\020\000\022\027\n\023em_multich" +
      "at_normal\020\001\022\025\n\021em_multichat_conf\020\002\022\024\n\020em" +
      "_multichat_end\020\003*\351\003\n\027EmRestMeetingNotify" +
      "Type\022\"\n\036emRestMeetingNotifyTypeUnknown\020\000" +
      "\022\023\n\017emCreateMeeting\020f\022\023\n\017emUpdateMeeting",
      "\020g\022\023\n\017emDeleteMeeting\020h\022\023\n\017emCreateRegul" +
      "ar\020i\022\023\n\017emUpdateRegular\020j\022\023\n\017emDeleteReg" +
      "ular\020k\022\037\n\033emUpdateMeetingCancelPerson\020l\022" +
      "\024\n\020emAheadOfMeeting\020m\022\020\n\014emCancelRoom\020n\022" +
      "\025\n\021emDeadLineChanged\020o\022\024\n\020emUserFeedback" +
      "ed\020p\022\023\n\017emForbiddenRoom\020q\022\020\n\014emDeleteRoo" +
      "m\020r\022\026\n\022emStartTimeAchieve\020s\022\021\n\remNormalS" +
      "tart\020t\022\030\n\024emStartMeetingRemind\020u\022\030\n\024emSt" +
      "artBeforeMeeting\020v\022 \n\034emParticipant_Meet" +
      "ing_Remind\020w\022\016\n\nemLive_URL\020x*v\n\023EmMtOper",
      "ateUserInfo\022\024\n\020emOperateUserAdd\020\001\022\027\n\023emO" +
      "perateUserDelete\020\002\022\027\n\023emOperateUserModif" +
      "y\020\003\022\027\n\023emOperateUserSearch\020\004*h\n\rEmH323Sr" +
      "vType\022\025\n\021emH323SrvH323None\020\001\022\024\n\020emH323Sr" +
      "vH323Pxy\020\002\022\025\n\021emH323SrvH323H460\020\003\022\023\n\017emH" +
      "323SrvH323Gk\020\004*3\n\014EmSipSrvType\022\022\n\016emSipS" +
      "rvServer\020\001\022\017\n\013emSipSrvPxy\020\002*^\n\007APIType\022\020" +
      "\n\014emUnknownAPI\020\000\022\021\n\remPlatformAPI\020\001\022\016\n\ne" +
      "mWeiboAPI\020\002\022\020\n\014emMeetingAPI\020\003\022\014\n\010emAppAP" +
      "I\020\004*.\n\nEmChatType\022\020\n\014emChatNormal\020\000\022\016\n\ne",
      "mChatAuto\020\001*\251\001\n\014EmRtspStatus\022\016\n\nemRtspIn" +
      "it\020\001\022\022\n\016emRtspPreReady\020\002\022\017\n\013emRtspReady\020" +
      "\003\022\021\n\remRtspPlaying\020\004\022\017\n\013emRtspPause\020\005\022\020\n" +
      "\014emRtspResume\020\006\022\025\n\021emRtspAdjustSpeed\020\007\022\027" +
      "\n\023emRtspAdjustProcess\020\010*E\n\020EmServerAddrT" +
      "ype\022\030\n\024emSrvAddrTypeDefault\020\000\022\027\n\023emSrvAd" +
      "drTypeCustom\020\001*\333\001\n\024EmVMeetingVideoModel\022" +
      ")\n%emMeeting_vmeeting_video_model_fluent" +
      "\020\001\0221\n-emMeeting_vmeeting_video_model_nor" +
      "mal_quality\020\002\022/\n+emMeeting_vmeeting_vide",
      "o_model_high_quality\020\003\0224\n0emMeeting_vmee" +
      "ting_video_model_full_high_quality\020\004*g\n\023" +
      "EmDesktopShareLimit\022)\n%emMeeting_desktop" +
      "_share_limit_speaker\020\000\022%\n!emMeeting_desk" +
      "top_share_limit_all\020\001*[\n\016EmVMeetingMode\022" +
      "#\n\037emMeeting_vmeeting_mode_discuss\020\000\022$\n " +
      "emMeeting_vmeeting_mode_training\020\001*\310\001\n\016E" +
      "mCallDuration\022&\n\"emMeeting_call_duration" +
      "_very_short\020\000\022!\n\035emMeeting_call_duration" +
      "_short\020\001\022\"\n\036emMeeting_call_duration_norm",
      "al\020\002\022 \n\034emMeeting_call_duration_long\020\003\022%" +
      "\n!emMeeting_call_duration_very_long\020\004*5\n" +
      "\tEmNetType\022\016\n\nemInternet\020\000\022\r\n\temSpecial\020" +
      "\001\022\t\n\005emVPN\020\002*d\n\021EmUpgradeVerLevel\022\030\n\024emU" +
      "pgradeLevelForced\020\000\022\033\n\027emUpgradeLevelSug" +
      "gested\020\001\022\030\n\024emUpgradeLevelNormal\020\002*u\n\024Em" +
      "UpgradeReleaseAttr\022\021\n\remUpgradeAttr\020\000\022\027\n" +
      "\023emUpgradeAttrCommon\020\001\022\032\n\026emUpgradeAttrR" +
      "ecommend\020\002\022\025\n\021emUpgradeAttrGray\020\004*j\n\014EmM" +
      "tPortrait\022\020\n\014mtportrait32\020\000\022\020\n\014mtportrai",
      "t40\020\001\022\020\n\014mtportrait64\020\002\022\021\n\rmtportrait128" +
      "\020\003\022\021\n\rmtportrait256\020\004*<\n\010EmMCMode\022\016\n\nemM" +
      "cSpeech\020\000\022\017\n\013emMcDiscuss\020\001\022\017\n\013emMcInvali" +
      "d\020\002*\347\001\n\014EmServerType\022\t\n\005emAPS\020\000\022\t\n\005emXNU" +
      "\020\001\022\t\n\005emSUS\020\002\022\t\n\005emNMS\020\003\022\t\n\005emNTS\020\004\022\t\n\005e" +
      "mSIP\020\005\022\r\n\temNonH323\020\006\022\r\n\temStdH323\020\007\022\t\n\005" +
      "emNTP\020\010\022\t\n\005emVOD\020\t\022\017\n\013emMoMeeting\020\n\022\020\n\014e" +
      "mMoPlatform\020\013\022\t\n\005emVRS\020\014\022\t\n\005emDCS\020\r\022\010\n\004e" +
      "mNS\020\016\022\t\n\005emKIS\020\017\022\023\n\017emServerTypeEnd\020\020*\212\001" +
      "\n\rEmServerState\022\n\n\006emIdle\020\000\022\021\n\remDnsQuer",
      "ying\020\001\022\020\n\014emLogging_In\020\002\022\020\n\014emLogin_Succ" +
      "\020\003\022\021\n\remLogging_Out\020\004\022\022\n\016emDisconnected\020" +
      "\005\022\017\n\013emLogin_Err\020\006*J\n\022EmMtCallRecordType" +
      "\022\014\n\010emCallIn\020\000\022\r\n\temCallOut\020\001\022\014\n\010emMisse" +
      "d\020\002\022\t\n\005emAll\020\003*5\n\014EmMtCallType\022\013\n\007emVide" +
      "o\020\000\022\013\n\007emAudio\020\001\022\013\n\007emPhone\020\002*\372\003\n\rEmMtRe" +
      "cordErr\022\017\n\013emRecord_Ok\020\000\022\026\n\022emRecord_Err" +
      "_Index\020\001\022$\n emRecord_Err_No_Marching_Rec" +
      "ords\020\002\022!\n\035emRecord_Err_No_Marching_Type\020" +
      "\003\022\037\n\033emRecord_Err_CallRecordType\020\004\022\031\n\025em",
      "Record_Err_CallType\020\005\022\031\n\025emRecord_Err_De" +
      "scribe\020\006\022\031\n\025emRecord_Err_AddrType\020\007\022\025\n\021e" +
      "mRecord_Err_Addr\020\010\022\025\n\021emRecord_Err_Rate\020" +
      "\t\022\033\n\027emRecord_Err_PackageNum\020\n\022\'\n#emReco" +
      "rd_Err_Over_MaxLocalRecordNum\020\013\022\037\n\033emRos" +
      "ter_Err_GroupName_NULL\020d\022\030\n\024emRoster_Err" +
      "_GroupSn\020e\022\036\n\032emRoster_Err_ParentGroupSn" +
      "\020f\022\031\n\025emRoster_Err_RosterSn\020g\022\033\n\027emRoste" +
      "r_Err_RosterName\020h*L\n\024EmMtRecordSearchTy" +
      "pe\022\024\n\020emCallRecordType\020\000\022\016\n\nemCallType\020\001",
      "\022\016\n\nemDescribe\020\002*d\n\026EmMtAudPrecedenceLev" +
      "el\022\026\n\022emAudPrecedenceLow\020\000\022\031\n\025emAudPrece" +
      "denceMiddle\020\001\022\027\n\023emAudPrecedenceHigh\020\002*t" +
      "\n\014EmAlarmLevel\022\021\n\remAlarmNormal\020\000\022\022\n\016emA" +
      "larmGeneral\020\001\022\024\n\020emAlarmImportant\020\002\022\023\n\017e" +
      "mAlarmCritical\020\003\022\022\n\016emAlarmUnknown\020\004*3\n\014" +
      "EmAlarmState\022\020\n\014emStateAlarm\020\000\022\021\n\remStat" +
      "eNormal\020\001*}\n\013EmAlarmCode\022\026\n\021emAlarmFileS" +
      "ysErr\020\362\007\022\023\n\016emAlarmSysBusy\020\363\007\022\022\n\remAlarm" +
      "FanErr\020\370\007\022\024\n\017emAlarmTempHigh\020\371\007\022\027\n\022emAla",
      "rmVoltageHigh\020\372\007*<\n\014EmDLProtocol\022\t\n\005emPP" +
      "P\020\000\022\n\n\006emHDLC\020\001\022\013\n\007emPPPOE\020\002\022\010\n\004emMP\020\003*W" +
      "\n\024EmAuthenticationType\022\024\n\020emE1AuthTypeNo" +
      "ne\020\000\022\023\n\017emE1AuthTypePAP\020\001\022\024\n\020emE1AuthTyp" +
      "eCHAP\020\002*?\n\021EmApsLoginErrcode\022\020\n\014emApsLog" +
      "inOk\020\000\022\030\n\024emApsLoginErrUnknown\020\001*\202\002\n\nEmP" +
      "ortType\022\022\n\016emConfChanPort\020\000\022\014\n\010emImPort\020" +
      "\001\022\r\n\temVodPort\020\002\022\014\n\010emMcPort\020\003\022\025\n\021emH323" +
      "CallingPort\020\004\022\025\n\021emH323TcpBasePort\020\005\022\024\n\020" +
      "emH323TcpEndPort\020\006\022\025\n\021emH323pxyBasePort\020",
      "\007\022\024\n\020emH323pxyEndPort\020\010\022\021\n\remSipBfcpPort" +
      "\020\t\022\r\n\temMTCPort\020\n\022\014\n\010emGKPort\020\013\022\024\n\020emSip" +
      "CallingPort\020\014*_\n\013EmVideoType\022\023\n\017em1stPri" +
      "omVideo\020\000\022\023\n\017em2ndPriomVideo\020\001\022\023\n\017em3rdP" +
      "riomVideo\020\002\022\021\n\remSecondVideo\020\n*\376\006\n\021EmVid" +
      "eoOutPutMode\022\023\n\017emVOM_HD_ORIGIN\020\000\022\025\n\021emV" +
      "OM_HD_1080p_24\020\001\022\025\n\021emVOM_HD_1080p_25\020\002\022" +
      "\025\n\021emVOM_HD_1080p_30\020\003\022\025\n\021emVOM_HD_1080p" +
      "_50\020\004\022\027\n\023emVOM_HD_1080p_60hz\020\005\022\030\n\024emVOM_" +
      "HD_1080p_60fps\020\006\022\025\n\021emVOM_HD_1080i_50\020\007\022",
      "\025\n\021emVOM_HD_1080i_60\020\010\022\024\n\020emVOM_HD_720p_" +
      "50\020\t\022\026\n\022emVOM_HD_720p_60hz\020\n\022\027\n\023emVOM_HD" +
      "_720p_60fps\020\013\022\024\n\020emVOM_HD_576i_50\020\014\022\025\n\021e" +
      "mVOM_HD_1080p_29\020\r\022\025\n\021emVOM_HD_1080p_59\020" +
      "\016\022\021\n\remVOM_HD_576p\020\017\022\030\n\024emVOM_HD_1080p_2" +
      "9_97\020\020\022\030\n\024emVOM_HD_1080p_59_94\020\021\022\023\n\017emVO" +
      "M_HD_VGA_60\020\022\022\023\n\017emVOM_HD_VGA_75\020\023\022\024\n\020em" +
      "VOM_HD_SVGA_60\020\024\022\024\n\020emVOM_HD_SVGA_75\020\025\022\023" +
      "\n\017emVOM_HD_XGA_60\020\026\022\023\n\017emVOM_HD_XGA_75\020\027" +
      "\022\024\n\020emVOM_HD_SXGA_60\020\030\022\034\n\030emVOM_HD_WXGA1",
      "280x768_60\020\031\022\034\n\030emVOM_HD_WXGA1280x768_75" +
      "\020\032\022\034\n\030emVOM_HD_WXGA1280x800_60\020\033\022\034\n\030emVO" +
      "M_HD_WXGA1280x800_75\020\034\022\034\n\030emVOM_HD_WXGA1" +
      "366x768_60\020\035\022\035\n\031emVOM_HD_UXGA1600x1200_6" +
      "0\020\036\022\035\n\031emVOM_HD_WSXGA1440x900_60\020\037\022!\n\035em" +
      "VOM_HD_SXGAPLUS1680x1050_60\020 \022\033\n\027emVOM_H" +
      "D_4k3860x2160_30\020!\022\033\n\027emVOM_HD_4k3860x21" +
      "60_60\020\"*C\n\013EmTextAlign\022\017\n\013emAlignLeft\020\000\022" +
      "\021\n\remAlignCenter\020\001\022\020\n\014emAlignRight\020\002*L\n\n" +
      "EmRollMode\022\014\n\010emStatic\020\000\022\020\n\014emRight2Left",
      "\020\001\022\r\n\temDown2Up\020\002\022\017\n\013emScollPage\020\003*c\n\013Em" +
      "RollSpeed\022\020\n\014emRollSlower\020\000\022\016\n\nemRollSlo" +
      "w\020\001\022\020\n\014emRollNormal\020\002\022\016\n\nemRollFast\020\003\022\020\n" +
      "\014emRollFaster\020\004*\220\003\n\rEmHDAudPortIn\022\022\n\016emH" +
      "DAudInBegin\020\000\022\022\n\016emHDAudInDMic1\020\001\022\022\n\016emH" +
      "DAudInDMic2\020\002\022\020\n\014emHDAudInXLR\020\003\022\022\n\016emHDA" +
      "udInWMic1\020\004\022\022\n\016emHDAudInWMic2\020\005\022\022\n\016emHDA" +
      "udInWMic3\020\006\022\020\n\014emHDAudInRCA\020\007\022\023\n\017emHDAud" +
      "InTRS3_5\020\010\022\022\n\016emHDAudInHDMI1\020\t\022\022\n\016emHDAu" +
      "dInHDMI2\020\n\022\022\n\016emHDAudInHDMI3\020\013\022\022\n\016emHDAu",
      "dInDHDMI\020\014\022\021\n\remHDAudInSDI1\020\r\022\021\n\remHDAud" +
      "InSDI2\020\016\022\025\n\021emHDAudInHDBaseT1\020\017\022\025\n\021emHDA" +
      "udInHDBaseT2\020\020\022\024\n\020emHDAudInDsiMic1\020\021\022\024\n\020" +
      "emHDAudInDsiMic2\020\022*\341\001\n\016EmHDAudPortOut\022\023\n" +
      "\017emHDAudOutBegin\020\000\022\021\n\remHDAudOutRCA\020\001\022\024\n" +
      "\020emHDAudOutTRS6_5\020\002\022\024\n\020emHDAudOutTRS3_5\020" +
      "\003\022\024\n\020emHDAudOutDHDMI1\020\004\022\024\n\020emHDAudOutDHD" +
      "MI2\020\005\022\022\n\016emHDAudOutHDMI\020\006\022\021\n\remHDAudOutS" +
      "DI\020\007\022\023\n\017emHDAudOutHDMI1\020\010\022\023\n\017emHDAudOutH" +
      "DMI2\020\t*V\n\024EmHDMultiVideoSwitch\022\026\n\022emHDMu",
      "ltiVideoStop\020\000\022\021\n\remHDMultiView\020\001\022\023\n\017emH" +
      "DMultiStream\020\002*\371\001\n\017EmHDMultiViewMP\022\030\n\024em" +
      "MVMP_LeftRight_One\020\000\022\035\n\031emMVMP_BigSmall_" +
      "RightDown\020\001\022\034\n\030emMVMP_BigSmall_LeftDown\020" +
      "\002\022\032\n\026emMVMP_BigSmall_LeftUp\020\003\022\033\n\027emMVMP_" +
      "BigSmall_RightUp\020\004\022\033\n\027emMVMP_3View_1Big2" +
      "Small\020\005\022\034\n\030emMVMP_3View_1Top2Bottom\020\006\022\033\n" +
      "\027emMVMP_SingleView_Close\020\007*u\n\021EmHDVideoP" +
      "ortMode\022\021\n\remVPM_Invalid\020\000\022\016\n\nemVPM_Auto" +
      "\020\001\022\016\n\nemVPM_HDMI\020\002\022\r\n\temVPM_DVI\020\003\022\017\n\013emV",
      "PM_YPBPR\020\004\022\r\n\temVPM_VGA\020\005*\237\003\n\024EmHDVideoO" +
      "utPortType\022\021\n\remVOT_Invalid\020\000\022\016\n\nemVOT_D" +
      "VI1\020\001\022\016\n\nemVOT_DVI2\020\002\022\016\n\nemVOT_DVI3\020\003\022\016\n" +
      "\nemVOT_DVI4\020\004\022\017\n\013emVOT_HDMI1\020\005\022\017\n\013emVOT_" +
      "HDMI2\020\006\022\017\n\013emVOT_HDMI3\020\007\022\017\n\013emVOT_HDMI4\020" +
      "\010\022\020\n\014emVOT_YPbPr1\020\t\022\020\n\014emVOT_YPbPr2\020\n\022\020\n" +
      "\014emVOT_YPbPr3\020\013\022\020\n\014emVOT_YPbPr4\020\014\022\016\n\nemV" +
      "OT_VGA1\020\r\022\016\n\nemVOT_VGA2\020\016\022\016\n\nemVOT_VGA3\020" +
      "\017\022\016\n\nemVOT_VGA4\020\020\022\016\n\nemVOT_SDI1\020\021\022\016\n\nemV" +
      "OT_SDI2\020\022\022\016\n\nemVOT_SDI3\020\023\022\016\n\nemVOT_SDI4\020",
      "\024\022\014\n\010emVOT_C1\020\025\022\014\n\010emVOT_C2\020\026\022\014\n\010emVOT_C" +
      "3\020\027*\325\006\n\023EmHDVideoSourceType\022\020\n\014emVS_Inva" +
      "lid\020\000\022\017\n\013emVS_1stDec\020\001\022\017\n\013emVS_2ndDec\020\002\022" +
      "\017\n\013emVS_3rdDec\020\003\022\017\n\013emVS_4thDec\020\004\022\017\n\013emV" +
      "S_5thDec\020\005\022\017\n\013emVS_6thDec\020\006\022\017\n\013emVS_7thD" +
      "ec\020\007\022\017\n\013emVS_8thDec\020\010\022\017\n\013emVS_9thDec\020\t\022\020" +
      "\n\014emVS_10thDec\020\n\022\031\n\025emVS_MtVidInnerCamer" +
      "a\020\013\022\022\n\016emVS_MtVidDVI1\020\014\022\022\n\016emVS_MtVidDVI" +
      "2\020\r\022\022\n\016emVS_MtVidDVI3\020\016\022\022\n\016emVS_MtVidDVI" +
      "4\020\017\022\023\n\017emVS_MtVidHDMI1\020\020\022\023\n\017emVS_MtVidHD",
      "MI2\020\021\022\023\n\017emVS_MtVidHDMI3\020\022\022\023\n\017emVS_MtVid" +
      "HDMI4\020\023\022\024\n\020emVS_MtVidYPbPr1\020\024\022\024\n\020emVS_Mt" +
      "VidYPbPr2\020\025\022\024\n\020emVS_MtVidYPbPr3\020\026\022\024\n\020emV" +
      "S_MtVidYPbPr4\020\027\022\022\n\016emVS_MtVidVGA1\020\030\022\022\n\016e" +
      "mVS_MtVidVGA2\020\031\022\022\n\016emVS_MtVidVGA3\020\032\022\022\n\016e" +
      "mVS_MtVidVGA4\020\033\022\020\n\014emVS_MtVidC1\020\034\022\020\n\014emV" +
      "S_MtVidC2\020\035\022\020\n\014emVS_MtVidC3\020\036\022\020\n\014emVS_Mt" +
      "VidS1\020\037\022\020\n\014emVS_MtVidS2\020 \022\020\n\014emVS_MtVidS" +
      "3\020!\022\026\n\022emVS_MtVidHDBaseT1\020\"\022\026\n\022emVS_MtVi" +
      "dHDBaseT2\020#\022\026\n\022emVS_MtVidHDBaseT3\020$\022\026\n\022e",
      "mVS_MtVidHDBaseT4\020%\022\022\n\016emVS_MtVidSDI1\020&\022" +
      "\022\n\016emVS_MtVidSDI2\020\'\022\022\n\016emVS_MtVidSDI3\020(\022" +
      "\022\n\016emVS_MtVidSDI4\020)*b\n\017EmHDLastDisplay\022\022" +
      "\n\016emLD_LastFrame\020\000\022\023\n\017emLD_BlueScreen\020\001\022" +
      "\022\n\016emLD_StaticBMP\020\002\022\022\n\016emLD_CustomBMP\020\003*" +
      "\211\001\n\016EmHDImageNoise\022\030\n\024emImageNoise_Disab" +
      "le\020\000\022\024\n\020emImageNoise_Low\020\001\022\024\n\020emImageNoi" +
      "se_Med\020\002\022\025\n\021emImageNoise_High\020\003\022\032\n\026emIma" +
      "geNoise_UltraHigh\020\004*S\n\033EmHDImageDeformat" +
      "ionTensile\022\030\n\024emImageDT_Transverse\020\000\022\032\n\026",
      "emImageDT_Longitudinal\020\001*\257\001\n\020EmEthnetWor" +
      "kMode\022\021\n\remEthModeAuto\020\000\022\024\n\020emEthMode10M" +
      "Full\020\001\022\024\n\020emEthMode10MHalf\020\002\022\025\n\021emEthMod" +
      "e100MFull\020\003\022\025\n\021emEthMode100MHalf\020\004\022\026\n\022em" +
      "EthMode1000MFull\020\005\022\026\n\022emEthMode1000MHalf" +
      "\020\006*m\n\022EmEthInterfaceMode\022\034\n\030emEthInterfa" +
      "ceModeBackup\020\000\022\033\n\027emEthInterfaceModeMult" +
      "i\020\001\022\034\n\030emEthInterfaceModeSingle\020\002*C\n\022EmE" +
      "thStartupResult\022\027\n\023emEthStartupSuccess\020\000" +
      "\022\024\n\020emEthStartupFail\020\001*\216\001\n\020EmPPPoELinkSt",
      "ate\022\030\n\024emPPPoELinkStateIdle\020\000\022\036\n\032emPPPoE" +
      "LinkStateConnecting\020\001\022!\n\035emPPPoELinkStat" +
      "eDisConnecting\020\002\022\035\n\031emPPPoELinkStateConn" +
      "ected\020\003*\352\001\n\024EmPPPoELinkErrReason\022\035\n\031emPP" +
      "PoELinkErrReason_None\020\000\022&\n\"emPPPoELinkEr" +
      "rReason_UsrOrPwdError\020\001\022 \n\034emPPPoELinkEr" +
      "rReason_Timeout\020\002\022!\n\035emPPPoELinkErrReaso" +
      "n_Linkdown\020\003\022$\n emPPPoELinkErrReason_NoI" +
      "SPServer\020\004\022 \n\034emPPPoELinkErrReason_Unkno" +
      "wn\020\005*a\n\016EmWifiWorkMode\022\027\n\023emWifiWorkMode",
      "Close\020\000\022\034\n\030emWifiWorkModeWifiClient\020\001\022\030\n" +
      "\024emWifiWorkModeWifiAp\020\002*\203\001\n\rEmWifiKeyTyp" +
      "e\022\025\n\021emWifiKeyTypeNone\020\000\022\024\n\020emWifiKeyTyp" +
      "eWPA\020\001\022\025\n\021emWifiKeyTypeWPA2\020\002\022\030\n\024emWifiK" +
      "eyTypeWPAWPA2\020\003\022\024\n\020emWifiKeyTypeWEP\020\004*\230\001" +
      "\n\021EmWifiSignalLevel\022\031\n\025emWifiSignalLevel" +
      "None\020\000\022\031\n\025emWifiSignalLevelLess\020\001\022\030\n\024emW" +
      "ifiSignalLevelLow\020\002\022\030\n\024emWifiSignalLevel" +
      "Mid\020\003\022\031\n\025emWifiSignalLevelHigh\020\004*\211\003\n\017EmW" +
      "ifiLinkState\022\027\n\023emWifiLinkStateIdle\020\000\022!\n",
      "\035emWifiLinkStateAuthentication\020\001\022\032\n\026emWi" +
      "fiLinkStateBlocked\020\002\022\034\n\030emWifiLinkStateC" +
      "onnected\020\003\022\035\n\031emWifiLinkStateConnecting\020" +
      "\004\022\037\n\033emWifiLinkStateDisConnected\020\005\022 \n\034em" +
      "WifiLinkStateDisConnecting\020\006\022\031\n\025emWifiLi" +
      "nkStateFailed\020\007\022\"\n\036emWifiLinkStateObtain" +
      "ingIpAddr\020\010\022\033\n\027emWifiLinkStateScanning\020\t" +
      "\022\034\n\030emWifiLinkStateSuspended\020\n\022$\n emWifi" +
      "LinkStateVerifyingPoorLink\020\013*\225\001\n\023EmWifiL" +
      "inkErrReason\022\034\n\030emWifiLinkErrReason_None",
      "\020\000\022\036\n\032emWifiLinkErrReason_Failed\020\001\022\037\n\033em" +
      "WifiLinkErrReason_Timeout\020\002\022\037\n\033emWifiLin" +
      "kErrReason_Unknown\020\003*C\n\017EmWifiApKeyType\022" +
      "\027\n\023emWifiApKeyTypeNone\020\000\022\027\n\023emWifiApKeyT" +
      "ypeWPA2\020\001*_\n\027EmWifiFrequencyBandType\022!\n\035" +
      "emWifiFrequencyBandType_24GHz\020\000\022!\n\035emWif" +
      "iFrequencyBandType_50GHz\020\001*\305\002\n\025EmMobileD" +
      "ataLinkState\022\037\n\033emMobileDataLinkStateUnU" +
      "sed\020\000\022\035\n\031emMobileDataLinkStateIdle\020\001\022#\n\037" +
      "emMobileDataLinkStateConnecting\020\002\022&\n\"emM",
      "obileDataLinkLinkStateConnected\020\003\022&\n\"emM" +
      "obileDataLinkLinkStateSuspended\020\004\022&\n\"emM" +
      "obileDataLinkStateDisConnecting\020\005\022)\n%emM" +
      "obileDataLinkLinkStateDisConnected\020\006\022$\n " +
      "emMobileDataLinkLinkStateUnknown\020\007*\263\001\n\031E" +
      "mMobileDataLinkErrReason\022\"\n\036emMobileData" +
      "LinkErrReason_None\020\000\022$\n emMobileDataLink" +
      "ErrReason_Failed\020\001\022%\n!emMobileDataLinkEr" +
      "rReason_Timeout\020\002\022%\n!emMobileDataLinkErr" +
      "Reason_Unknown\020\003*\274\001\n\027EmMobileDataSignalL",
      "evel\022\037\n\033emMobileDataSignalLevelNone\020\000\022\037\n" +
      "\033emMobileDataSignalLevelLess\020\001\022\036\n\032emMobi" +
      "leDataSignalLevelLow\020\002\022\036\n\032emMobileDataSi" +
      "gnalLevelMid\020\003\022\037\n\033emMobileDataSignalLeve" +
      "lHigh\020\004*\202\002\n\024EmNetAdapterWorkType\022\035\n\031emNe" +
      "tAdapterWorkType_None\020\000\022\035\n\031emNetAdapterW" +
      "orkType_Wifi\020\001\022\036\n\032emNetAdapterWorkType_P" +
      "PPoE\020\002\022#\n\037emNetAdapterWorkType_MobileDat" +
      "a\020\003\022$\n emNetAdapterWorkType_EthnetCard1\020" +
      "\004\022$\n emNetAdapterWorkType_EthnetCard2\020\005\022",
      "\033\n\027emNetAdapterWorkType_E1\020\006*\215\001\n\023EmMobil" +
      "eDataNetType\022\034\n\030emMobileDataNetType_None" +
      "\020\000\022\034\n\030emMobileDataNetType_CMCC\020\001\022\034\n\030emMo" +
      "bileDataNetType_CUCC\020\002\022\034\n\030emMobileDataNe" +
      "tType_CTCC\020\003*\271\001\n\035EmMobileDataNetGenerati" +
      "onType\022&\n\"emMobileDataNetGenerationType_" +
      "None\020\000\022$\n emMobileDataNetGenerationType_" +
      "2G\020\001\022$\n emMobileDataNetGenerationType_3G" +
      "\020\002\022$\n emMobileDataNetGenerationType_4G\020\003" +
      "*v\n\021EmEthnetParamType\022\027\n\023emType_SetIpAnd",
      "Mask\020\000\022\030\n\024emType_SetMacAddress\020\001\022\026\n\022emTy" +
      "pe_SetAllParam\020\002\022\026\n\022emType_SetSecondIp\020\003" +
      "*B\n\021EmE1InterfaceType\022\025\n\021emE1IfType_Seri" +
      "al\020\000\022\026\n\022emE1IfType_Virtual\020\001*9\n\rEmE1Cloc" +
      "kType\022\023\n\017emClockType_Dce\020\000\022\023\n\017emClockTyp" +
      "e_Dte\020\001*l\n\020EmE1ChainOptType\022\025\n\021emType_Op" +
      "enSingle\020\000\022\026\n\022emType_CloseSingle\020\001\022\023\n\017em" +
      "Type_OpenMult\020\002\022\024\n\020emType_CloseMult\020\003*\363\003" +
      "\n\021EmE1LinkErrReason\022\017\n\013emE1ErrNone\020\000\022\031\n\025" +
      "emE1ErrParamException\020\001\022\032\n\026emE1ErrSerial",
      "IdInvalid\020\002\022\026\n\022emE1ErrE1IdInvalid\020\003\022\032\n\026e" +
      "mE1ErrE1TsMaskInvalid\020\004\022\036\n\032emE1ErrE1Chai" +
      "nGroupInvalid\020\005\022$\n emE1ErrSerialProtocol" +
      "TypeInvalid\020\006\022$\n emE1ErrSerialEchoInterv" +
      "alInvalid\020\007\022$\n emE1ErrSerialEchoMaxRetry" +
      "Invalid\020\010\022\034\n\030emE1ErrStringLenOverflow\020\t\022" +
      "\024\n\020emE1ErrNipOptErr\020\n\022\031\n\025emE1ErrChainNot" +
      "Config\020\013\022\030\n\024emE1ErrChainConflict\020\014\022\035\n\031em" +
      "E1ErrPppAuthTypeInvalid\020\r\022\032\n\026emE1ErrPppF" +
      "ragTooShort\020\016\022\025\n\021emE1ParamCheckErr\020\017\022\025\n\021",
      "emE1ParamConflict\020\020*Z\n\rEmPingErrcode\022\017\n\013" +
      "emPingReply\020\000\022\021\n\remPingTimeout\020\001\022\017\n\013emPi" +
      "ngError\020\002\022\024\n\020emPingNetUnreach\020\003*X\n\rEmUpg" +
      "radeType\022\020\n\014emSusUpgrade\020\001\022\022\n\016emLocalUpg" +
      "rade\020\002\022\020\n\014emMtcUpgrade\020\003\022\017\n\013emMtUpgrade\020" +
      "\004*\253\002\n\017EmUpgradeNotify\022\022\n\016emFileCheckBgn\020" +
      "\000\022\025\n\021emWholeUpgradeBgn\020\001\022\026\n\022emFileCheckS" +
      "uccess\020\002\022\031\n\025emWholeUpgradeSuccess\020\003\022\020\n\014e" +
      "mUnknownErr\020\004\022\024\n\020emInvalidFileErr\020\005\022\024\n\020e" +
      "mLoadXmlFileErr\020\006\022\022\n\016emFileCheckErr\020\007\022\024\n",
      "\020emSysMountBakErr\020\010\022\034\n\030emUpgradeDriverMo" +
      "duleErr\020\t\022\031\n\025emUpgradeAppModuleErr\020\n\022\031\n\025" +
      "emUpgradeExeModuleErr\020\013*t\n\021EmNetConflict" +
      "Type\022\027\n\023emConflictType_None\020\000\022\025\n\021emConfl" +
      "ictType_Ip\020\001\022\026\n\022emConflictType_Mac\020\002\022\027\n\023" +
      "emConflictType_Both\020\003*Y\n\013EmHDMicGain\022\020\n\014" +
      "emMicGainOff\020\000\022\020\n\014emMicGainLow\020\001\022\023\n\017emMi" +
      "cGainMiddle\020\002\022\021\n\remMicGainHigh\020\003*=\n\017EmPP" +
      "PoEDialMode\022\025\n\021emPPPoEDialManual\020\000\022\023\n\017em" +
      "PPPoEDialAuto\020\001*\237\001\n\024EmEquipmentUpgrading",
      "\022\r\n\temEUbegin\020\000\022\r\n\temEUHD120\020\001\022\r\n\temEUHD" +
      "200\020\002\022\016\n\nemEUHD120E\020\003\022\016\n\nemEUHD200E\020\004\022\016\n" +
      "\nemEUMoon50\020\005\022\024\n\020emEUMoon50_1080p\020\006\022\024\n\020e" +
      "mEUMoon70_1080p\020\007*-\n\tEmUartNum\022\017\n\013emUart" +
      "DMIC1\020\000\022\017\n\013emUartDMIC2\020\001*$\n\013EmPicFormat\022" +
      "\n\n\006emJPEG\020\000\022\t\n\005emBMP\020\001*l\n\nEmImgParam\022\t\n\005" +
      "emHue\020\000\022\022\n\016emWhiteBalance\020\001\022\016\n\nemContras" +
      "t\020\002\022\020\n\014emSaturation\020\003\022\017\n\013emSharpness\020\004\022\014" +
      "\n\010emBright\020\005*P\n\nEmFxoState\022\r\n\temFxoIdle\020" +
      "\000\022\017\n\013emFxoCallIn\020\001\022\020\n\014emFxoCalling\020\002\022\020\n\014",
      "emFxoConnect\020\003*A\n\nEmSdiInOut\022\r\n\temSdiNon" +
      "e\020\000\022\016\n\nemSdiTwoIn\020\001\022\024\n\020emSdiOneInOneOut\020" +
      "\002*N\n\017EmMsgFromSource\022\024\n\020emMsgFromInvalid" +
      "\020\000\022\023\n\017emMsgFromWebMtc\020\001\022\020\n\014emMsgFromOsd\020" +
      "\002*\227\001\n\020EmNmsLoginResult\022\026\n\022emNmsLogin_Suc" +
      "cess\020\000\022\026\n\022emNmsLogin_ErrorID\020\001\022\032\n\026emNmsL" +
      "ogin_RepeatLogin\020\002\022\033\n\027emNmsLogin_ErrorDe" +
      "vType\020\003\022\032\n\025emNmsLogin_DisConnect\020\377\001*\214\005\n\n" +
      "EmTimeZone\022\022\n\016emTimeZone_GMT\020\000\022\022\n\016emTime" +
      "Zone_UTC\020\001\022\022\n\016emTimeZone_ECT\020\002\022\022\n\016emTime",
      "Zone_EET\020\003\022\022\n\016emTimeZone_ART\020\004\022\022\n\016emTime" +
      "Zone_EAT\020\005\022\022\n\016emTimeZone_MET\020\006\022\022\n\016emTime" +
      "Zone_NET\020\007\022\022\n\016emTimeZone_PLT\020\010\022\022\n\016emTime" +
      "Zone_IST\020\t\022\022\n\016emTimeZone_BST\020\n\022\022\n\016emTime" +
      "Zone_VST\020\013\022\022\n\016emTimeZone_CTT\020\014\022\022\n\016emTime" +
      "Zone_JST\020\r\022\022\n\016emTimeZone_ACT\020\016\022\022\n\016emTime" +
      "Zone_AET\020\017\022\022\n\016emTimeZone_SST\020\020\022\022\n\016emTime" +
      "Zone_NST\020\021\022\022\n\016emTimeZone_MIT\020\022\022\022\n\016emTime" +
      "Zone_HST\020\023\022\022\n\016emTimeZone_AST\020\024\022\022\n\016emTime" +
      "Zone_PST\020\025\022\022\n\016emTimeZone_PNT\020\026\022\022\n\016emTime",
      "Zone_MST\020\027\022\022\n\016emTimeZone_CST\020\030\022\022\n\016emTime" +
      "Zone_EST\020\031\022\022\n\016emTimeZone_IET\020\032\022\022\n\016emTime" +
      "Zone_PRT\020\033\022\022\n\016emTimeZone_CNT\020\034\022\022\n\016emTime" +
      "Zone_AGT\020\035\022\022\n\016emTimeZone_BET\020\036\022\022\n\016emTime" +
      "Zone_CAT\020\037*\205\001\n\023EmMtSmoothSendLevel\022\031\n\025em" +
      "SmoothSendLevel_Off\020\000\022\032\n\026emSmoothSendLev" +
      "el_High\020\001\022\034\n\030emSmoothSendLevel_Middle\020\002\022" +
      "\031\n\025emSmoothSendLevel_Low\020\003*S\n\016EmRestDual" +
      "Mode\022\026\n\022emRestDual_Speaker\020\000\022\022\n\016emRestDu" +
      "al_any\020\001\022\025\n\021emRestDual_assign\020\002*Q\n\025EmRes",
      "tMeetingSafeType\022\034\n\030emRestMeetingType_Pu" +
      "blic\020\000\022\032\n\026emRestMeetingType_Port\020\001*L\n\022Em" +
      "RestVideoQuality\022\033\n\027emRestQualityPrecede" +
      "nce\020\000\022\031\n\025emRestSpeedPrecedence\020\001*F\n\021EmRe" +
      "stCascadeMode\022\030\n\024emRestCascade_Simple\020\000\022" +
      "\027\n\023emRestCascade_Merge\020\001*\311\001\n\014EmRemoteTyp" +
      "e\022\027\n\023emRemoteTypeUnknown\020\000\022\032\n\026emRemoteTy" +
      "peShortBlack\020\001\022\031\n\025emRemoteTypeLongBlack\020" +
      "\002\022\026\n\022emRemoteTypeSilver\020\003\022\031\n\025emRemoteTyp" +
      "eV3CamCtrl\020\004\022\031\n\025emRemoteTypeSkyWalker\020\005\022",
      "\033\n\027emRemoteTypeIRLongBlack\020\006*\357\t\n\020EmRemot" +
      "eScanCode\022\017\n\013emScanCode0\020\000\022\017\n\013emScanCode" +
      "1\020\001\022\017\n\013emScanCode2\020\002\022\017\n\013emScanCode3\020\003\022\017\n" +
      "\013emScanCode4\020\004\022\017\n\013emScanCode5\020\005\022\017\n\013emSca" +
      "nCode6\020\006\022\017\n\013emScanCode7\020\007\022\017\n\013emScanCode8" +
      "\020\010\022\017\n\013emScanCode9\020\t\022\023\n\017emScanCodePoint\020\n" +
      "\022\023\n\017emScanCodeSharp\020\013\022\022\n\016emScanCodeMenu\020" +
      "\014\022\027\n\023emScanCodeBackspace\020\r\022\023\n\017emScanCode" +
      "Enter\020\016\022\020\n\014emScanCodeUp\020\017\022\022\n\016emScanCodeD" +
      "own\020\020\022\022\n\016emScanCodeLeft\020\021\022\023\n\017emScanCodeR",
      "ight\020\022\022\023\n\017emScanCodePower\020\023\022\026\n\022emScanCod" +
      "eMainVSrc\020\024\022\020\n\014emScanCodeAV\020\025\022\025\n\021emScanC" +
      "odeFarCtrl\020\026\022\022\n\016emScanCodeMute\020\027\022\023\n\017emSc" +
      "anCodeQuiet\020\030\022\021\n\remScanCodeVGA\020\031\022\017\n\013emSc" +
      "anCodeS\020\032\022\026\n\022emScanCodeShotSnap\020\033\022\026\n\022emS" +
      "canCodeVolumeUp\020\034\022\030\n\024emScanCodeVolumeDow" +
      "n\020\035\022\025\n\021emScanCodeConnect\020\036\022\030\n\024emScanCode" +
      "Disconnect\020\037\022\027\n\023emScanCodeDirectory\020 \022\027\n" +
      "\023emScanCodePipEnable\020!\022\027\n\023emScanCodePipA" +
      "djust\020\"\022\026\n\022emScanCodeSelfTest\020#\022\027\n\023emSca",
      "nCodeAutoFocus\020$\022\026\n\022emScanCodeNearZoom\020%" +
      "\022\025\n\021emScanCodeFarZoom\020&\022\025\n\021emScanCodePre" +
      "Save\020\'\022\025\n\021emScanCodePreMove\020(\022\026\n\022emScanC" +
      "odeChairReq\020)\022\026\n\022emScanCodeSpeakReq\020*\022\025\n" +
      "\021emScanCodeQuitReq\020+\022\023\n\017emScanCodeState\020" +
      ",\022\025\n\021emScanCodeHotLeft\020-\022\027\n\023emScanCodeHo" +
      "tCenter\020.\022\026\n\022emScanCodeHotRight\020/\022\022\n\016emS" +
      "canCodeHelp\0200\022\026\n\022emScanCodeBrightUp\0201\022\030\n" +
      "\024emScanCodeBrightDown\0202\022\022\n\016emScanCodeDua" +
      "l\0203\022\024\n\020emScanCodeReturn\0204\022\022\n\016emScanCodeF",
      "unc\0205\022\024\n\020emScanCodeSearch\0206\022\026\n\022emScanCod" +
      "eImixMenu\0207\022\022\n\016emScanCodeNull\020b\022\025\n\021emSca" +
      "nCodeInvalid\020c*x\n\025EmParticipantResponse\022" +
      "\030\n\024emResponseNoFeedback\020\000\022\024\n\020emResponseR" +
      "eject\020\001\022\031\n\025emResponseParticipant\020\002\022\024\n\020em" +
      "ResponseCustom\020\003*F\n\017EmClosedMeeting\022\031\n\025e" +
      "mClosedMeeting_Close\020\000\022\030\n\024emClosedMeetin" +
      "g_Open\020\001*G\n\rEmCameraSpeed\022\020\n\014emCameraSlo" +
      "w\020\000\022\022\n\016emCameraNormal\020\001\022\020\n\014emCameraFast\020" +
      "\002*}\n\014EmCameraView\022\027\n\023emRestoreCameraView",
      "\020\000\022\023\n\017em1stCameraView\020\001\022\023\n\017em2ndCameraVi" +
      "ew\020\002\022\025\n\021emCameraMultiView\020\003\022\023\n\017em3rdCame" +
      "raView\020\004*\234\001\n\020EmRestNotifyType\022\021\n\remUnkno" +
      "wnType\020\000\022\014\n\010emNewFan\020\001\022\r\n\temNewFeed\020\002\022\021\n" +
      "\remNewRemindMe\020\003\022\016\n\nemNewReply\020\004\022\021\n\remGr" +
      "oupInvite\020\005\022\r\n\temNewLike\020\006\022\023\n\017emNewPriva" +
      "teMsg\020\007*K\n\023EmVidRationStrategy\022\017\n\013EmAssV" +
      "idPri\020\000\022\020\n\014EmMainVidPri\020\001\022\021\n\rEmUserDefin" +
      "ed\020\002*Y\n\020EmSystemFileType\022\020\n\014emFileNormal" +
      "\020\000\022\023\n\017emFileDirectory\020\001\022\016\n\nemFileLink\020\002\022",
      "\016\n\nemFilePipe\020\003*I\n\016EmSaveJpegType\022\017\n\013emS" +
      "JMonitor\020\000\022\021\n\remSJPresetPos\020\001\022\023\n\017emSJFtp" +
      "Snapshot\020\002*\342\002\n\021EmSleepFailReason\022\020\n\014emSF" +
      "RNoError\020\000\022\027\n\023emSFRProtectionTime\020\001\022\020\n\014e" +
      "mSFRMonitor\020\002\022\017\n\013emSFRInConf\020\003\022\r\n\temSFRL" +
      "oop\020\004\022\023\n\017emSFRRibbonTest\020\005\022\021\n\remSFRSnapV" +
      "iew\020\006\022\014\n\010emSFRVrs\020\007\022\020\n\014emSFRUpgrade\020\010\022\023\n" +
      "\017emSFRSusUpgrade\020\t\022\017\n\013emSFRNetCap\020\n\022\021\n\re" +
      "mSFRAddrbook\020\013\022\023\n\017emSFRSnapExport\020\014\022\026\n\022e" +
      "mSFRCameraUpgrade\020\r\022\030\n\024emSFRMicPhoneUpgr",
      "ade\020\016\022\022\n\016emSFRMtRecorde\020\017\022\024\n\020emSFRMtAssS" +
      "tream\020\020*F\n\014EmResizeMode\022\017\n\013emBlackEdge\020\000" +
      "\022\r\n\temCutEdge\020\001\022\026\n\022emNoProportionally\020\002*" +
      "I\n\020EmLocalSoundType\022\014\n\010emLSRing\020\000\022\017\n\013emL" +
      "SKeyTone\020\001\022\026\n\022emLSSpecialEffects\020\002*\243\001\n\021E" +
      "mLocalSoundIndex\022\016\n\nemSound1st\020\000\022\016\n\nemSo" +
      "und2nd\020\001\022\016\n\nemSound3rd\020\002\022\016\n\nemSound4th\020\003" +
      "\022\016\n\nemSound5th\020\004\022\016\n\nemSound6th\020\005\022\016\n\nemSo" +
      "und7th\020\006\022\016\n\nemSound8th\020\007\022\016\n\nemSound9th\020\010" +
      "*\221\001\n\rEmFileCopyErr\022\021\n\remCopySuccess\020\000\022\024\n",
      "\020emCopyUnknownErr\020\001\022\021\n\remCopyNoSpace\020\002\022\031" +
      "\n\025emCopySrcFileNotFound\020\003\022\031\n\025emCopyDstPa" +
      "thNotFound\020\004\022\016\n\nemCopyStop\020\005*\205\002\n\nEmMicDe" +
      "vId\022\017\n\013emWiredMic0\020\000\022\017\n\013emWiredMic1\020\001\022\022\n" +
      "\016emWirelessMic0\020\002\022\022\n\016emWirelessMic1\020\003\022\022\n" +
      "\016emWirelessMic2\020\004\022\027\n\023emWiredMic0Cascade1" +
      "\020\005\022\027\n\023emWiredMic0Cascade2\020\006\022\027\n\023emWiredMi" +
      "c1Cascade1\020\007\022\027\n\023emWiredMic1Cascade2\020\010\022\021\n" +
      "\remBuiltinMic0\020\t\022\021\n\remBuiltinMic1\020\n\022\017\n\013e" +
      "mMicDevEnd\020\013*\266\001\n\024EmTemplateAccoutType\022\021\n",
      "\remAccountNone\020\000\022\021\n\remAccountMoid\020\001\022\020\n\014e" +
      "mAccountAny\020\003\022\027\n\023emAccountNonSysMail\020\004\022\021" +
      "\n\remAccountE164\020\005\022\025\n\021emAccountTelPhone\020\006" +
      "\022\017\n\013emAccountIP\020\007\022\022\n\016emAccountAlias\020\010*\256\001" +
      "\n\014EmPingUserId\022\020\n\014emPingUidLan\020\000\022\025\n\021emPi" +
      "ngUidInternet\020\001\022\020\n\014emPingUidDns\020\002\022\023\n\017emP" +
      "ingUidServer\020\003\022\016\n\nemPingUid4\020\004\022\016\n\nemPing" +
      "Uid5\020\005\022\016\n\nemPingUid6\020\006\022\016\n\nemPingUid7\020\007\022\016" +
      "\n\nemPingUid8\020\010*\250\001\n\021EmMicUpgradeState\022\022\n\016" +
      "emUploadEnable\020\000\022\017\n\013emUploading\020\001\022\021\n\remI",
      "nstallable\020\002\022\020\n\014emInstalling\020\003\022\024\n\020emUpgr" +
      "adeSuccess\020\004\022\023\n\017emLatestVersion\020\005\022\016\n\nemR" +
      "eserve1\020\006\022\016\n\nemReserve2\020\007*\307\001\n\026EmAudioDel" +
      "ayCheckState\022\025\n\021emAudioDelayBegin\020\000\022\030\n\024e" +
      "mAudioDelayChecking\020\001\022\027\n\023emAudioDelayChe" +
      "cked\020\002\022\027\n\023emAudioDelayTimeout\020\003\022\026\n\022emAud" +
      "ioDelayFailed\020\004\022\030\n\024emAudioDelayReserve1\020" +
      "\005\022\030\n\024emAudioDelayReserve2\020\006*\207\001\n\026EmCamera" +
      "UpgradeErrCode\022\017\n\013emCUSuccess\020\000\022\021\n\remCUU" +
      "pgrading\020\001\022\017\n\013emCUErrType\020\002\022\020\n\014emCUNoDev",
      "ice\020\003\022\025\n\021emCUNoUpgradeFile\020\004\022\017\n\013emCUFail" +
      "ure\020\005*N\n\024EmUpgradeExitErrCode\022\026\n\022emUpgra" +
      "deForceExit\020\000\022\036\n\032emUpgradeNetWorkDisconn" +
      "ect\020\001*O\n\016EmGeneralLevel\022\023\n\017emGeneralLeve" +
      "l0\020\000\022\023\n\017emGeneralLevel1\020\001\022\023\n\017emGeneralLe" +
      "vel2\020\002*j\n\005EmISO\022\r\n\temISOAuto\020\000\022\013\n\007emISO8" +
      "0\020\001\022\014\n\010emISO100\020\002\022\014\n\010emISO200\020\003\022\014\n\010emISO" +
      "400\020\004\022\014\n\010emISO800\020\005\022\r\n\temISO1250\020\006*z\n\016Em" +
      "ExposureMode\022\017\n\013emExMManual\020\000\022\r\n\temExMAu" +
      "to\020\001\022\024\n\020emExMAperturePri\020\002\022\023\n\017emExMShutt",
      "erPri\020\003\022\020\n\014emExLowLight\020\004\022\013\n\007emExHDR\020\005*w" +
      "\n\nEmAperture\022\n\n\006emF1p2\020\000\022\n\n\006emF1p6\020\001\022\n\n\006" +
      "emF1p8\020\002\022\n\n\006emF2p0\020\003\022\n\n\006emF2p8\020\004\022\n\n\006emF4" +
      "p0\020\005\022\n\n\006emF5p6\020\006\022\n\n\006emF8p0\020\007\022\t\n\005emF11\020\010*" +
      "?\n\rEmShutterType\022\027\n\023emShutterTypeManual\020" +
      "\000\022\025\n\021emShutterTypeAuto\020\001*\324\001\n\016EmShutterLe" +
      "vel\022\016\n\nemShutter8\020\000\022\017\n\013emShutter15\020\001\022\017\n\013" +
      "emShutter30\020\002\022\017\n\013emShutter60\020\003\022\020\n\014emShut" +
      "ter100\020\004\022\020\n\014emShutter125\020\005\022\020\n\014emShutter2" +
      "50\020\006\022\020\n\014emShutter500\020\007\022\021\n\remShutter1000\020",
      "\010\022\021\n\remShutter2000\020\t\022\021\n\remShutter4000\020\n*" +
      "\312\001\n\tEmWBAMode\022\r\n\temWBAAuto\020\000\022\014\n\010emWBADay" +
      "\020\001\022\017\n\013emWBACloudy\020\002\022\016\n\nemWBAShade\020\003\022\024\n\020e" +
      "mWBAFluorescent\020\004\022\021\n\remWBATUngsten\020\005\022\r\n\t" +
      "emWBAWarm\020\006\022\021\n\remWBAStandard\020\007\022\020\n\014emWBAN" +
      "atural\020\010\022\021\n\remWBASunlight\020\t\022\017\n\013emWBAManu" +
      "al\020\n*@\n\021EMWBAModeGainType\022\024\n\020emWBAModeGa" +
      "inRed\020\000\022\025\n\021emWBAModeGainBlue\020\001*`\n\013EmScen" +
      "eMode\022\016\n\nemSceneOff\020\000\022\020\n\014emSceneNight\020\001\022" +
      "\017\n\013emSceneAuto\020\002\022\016\n\nemSceneWDR\020\003\022\016\n\nemSc",
      "eneHCT\020\004*,\n\010EmNFType\022\017\n\013emNFType_2D\020\000\022\017\n" +
      "\013emNFType_3D\020\001*C\n\010EmNFMode\022\014\n\010emNF_Off\020\000" +
      "\022\014\n\010emNF_Low\020\001\022\014\n\010emNF_Mid\020\002\022\r\n\temNF_Hig" +
      "h\020\003*A\n\025EmBrightnessDirection\022\022\n\016emBright" +
      "nessUp\020\000\022\024\n\020emBrightnessDown\020\001*\231\005\n\013EmIsp" +
      "ImgInf\022\023\n\017IspImgInf_Noise\020\000\022\027\n\023IspImgInf" +
      "_Sharpness\020\001\022\021\n\rIspImgInf_ISO\020\002\022\032\n\026IspIm" +
      "gInf_ExposureMode\020\003\022\026\n\022IspImgInf_Apertur" +
      "e\020\004\022\025\n\021IspImgInf_Shutter\020\005\022\031\n\025IspImgInf_" +
      "Brightnesss\020\006\022\032\n\026IspImgInf_WhiteBalance\020",
      "\007\022\026\n\022IspImgInf_Noise_2D\020\010\022\026\n\022IspImgInf_N" +
      "oise_3D\020\t\022\036\n\032IspImgInf_BrightnesssValue\020" +
      "\n\022\026\n\022IspImgInf_Contrast\020\013\022\030\n\024IspImgInf_S" +
      "aturation\020\014\022\035\n\031IspImgInf_Sharpness_Value" +
      "\020\r\022\021\n\rIspImgInf_Hue\020\016\022\034\n\030IspImgInf_BackL" +
      "ight_Type\020\017\022\035\n\031IspImgInf_BackLight_Value" +
      "\020\020\022\025\n\021IspImgInf_RedGain\020\021\022\026\n\022IspImgInf_B" +
      "lueGain\020\022\022\036\n\032IspImgInf_AotoExposureGain\020" +
      "\023\022 \n\034IspImgInf_ManualExposureGain\020\024\022\026\n\022I" +
      "spImgInf_ImgGamma\020\025\022\026\n\022IspImgInf_ImgDefo",
      "g\020\026\022\032\n\026IspImgInf_DigDynSwitch\020\027\022\031\n\025IspIm" +
      "gInf_DigDynLevel\020\030*R\n\026EmExposureModeGain" +
      "Type\022\032\n\026emExposureModeGainAuto\020\000\022\034\n\030emEx" +
      "posureModeGainManual\020\001*\216\002\n\032EmExposureMod" +
      "eGainRestrict\022\024\n\020emGainRestrict15\020\000\022\024\n\020e" +
      "mGainRestrict18\020\001\022\024\n\020emGainRestrict21\020\002\022" +
      "\024\n\020emGainRestrict24\020\003\022\024\n\020emGainRestrict2" +
      "7\020\004\022\024\n\020emGainRestrict30\020\005\022\024\n\020emGainRestr" +
      "ict33\020\006\022\024\n\020emGainRestrict36\020\007\022\024\n\020emGainR" +
      "estrict39\020\010\022\024\n\020emGainRestrict42\020\t\022\024\n\020emG",
      "ainRestrict45\020\n*9\n\013EmFocusMode\022\025\n\021emFocu" +
      "sModeManual\020\000\022\023\n\017emFocusModeAuto\020\001*>\n\tEm" +
      "ImgMode\022\021\n\remImgStandard\020\000\022\r\n\temImgSoft\020" +
      "\001\022\017\n\013emImgBright\020\002*\311\003\n\017EmIspActionType\022\024" +
      "\n\020IspActSetZoomOut\020\000\022\023\n\017IspActSetZoomIn\020" +
      "\001\022\025\n\021IspActSetZoomStop\020\002\022\025\n\021IspActSetZoo" +
      "mAuto\020\003\022\026\n\022IspActSetZoomSpeed\020\004\022\026\n\022IspAc" +
      "tSetZoomLimit\020\005\022\031\n\025IspActSetZoomPosition" +
      "\020\006\022\031\n\025IspActGetZoomPosition\020\007\022\026\n\022IspActS" +
      "etFocusNear\020\010\022\025\n\021IspActSetFocusFar\020\t\022\026\n\022",
      "IspActSetFocusStop\020\n\022\026\n\022IspActSetFocusAu" +
      "to\020\013\022\032\n\026IspActSetFocusPosition\020\014\022\032\n\026IspA" +
      "ctGetFocusPosition\020\r\022\025\n\021IspActSetApertur" +
      "e\020\016\022\030\n\024IspActSetPiCalibrate\020\017\022\026\n\022IspActS" +
      "etCameraStd\020\020\022\027\n\023IspActSetCameraFlip\020\021*\331" +
      "\001\n\016EmCameraVidStd\022\021\n\remCamera_Auto\020\000\022\025\n\021" +
      "emCamera_1080p_25\020\001\022\025\n\021emCamera_1080p_30" +
      "\020\002\022\025\n\021emCamera_1080p_50\020\003\022\025\n\021emCamera_10" +
      "80p_60\020\004\022\025\n\021emCamera_1080i_50\020\005\022\025\n\021emCam" +
      "era_1080i_60\020\006\022\024\n\020emCamera_720p_50\020\007\022\024\n\020",
      "emCamera_720p_60\020\010*[\n\nEmFilpType\022\016\n\nemFl" +
      "ip_OFF\020\000\022\023\n\017emFlip_Vertical\020\001\022\025\n\021emFlip_" +
      "Horizontal\020\002\022\021\n\remFlip_Center\020\003*H\n\tEmVmp" +
      "Mode\022\017\n\013emScreenVmp\020\000\022\025\n\021emCustomScreenV" +
      "mp\020\001\022\023\n\017emAutoScreenVmp\020\002*U\n\nEmPollMode\022" +
      "\023\n\017emPollModeBegin\020\000\022\017\n\013emVideoPoll\020\001\022\020\n" +
      "\014emReserveTwo\020\002\022\017\n\013emAudioPoll\020\003*\201\002\n\016EmS" +
      "treamNumber\022\017\n\013emStreamBeg\020\000\022\020\n\014emMainAu" +
      "dEnc\020\001\022\020\n\014emMainAudDec\020\002\022\017\n\013emAssAudEnc\020" +
      "\003\022\017\n\013emAssAudDec\020\004\022\017\n\013em1stVidEnc\020\005\022\017\n\013e",
      "m1stVidDec\020\006\022\017\n\013em2ndVidEnc\020\007\022\017\n\013em2ndVi" +
      "dDec\020\010\022\017\n\013em3rdVidEnc\020\t\022\017\n\013em3rdVidDec\020\n" +
      "\022\017\n\013emAssVidEnc\020\013\022\017\n\013emAssVidDec\020\014\022\020\n\013em" +
      "StreamEnd\020\200\001*\\\n\nEmCtrlType\022\022\n\016emAudioEnc" +
      "Type\020\000\022\022\n\016emAudioDecType\020\001\022\022\n\016emVideoEnc" +
      "Type\020\002\022\022\n\016emVideoDecType\020\003*\236\005\n\025EmVideoRe" +
      "cordErrorNum\022\022\n\016emErrorNoError\020\000\022\027\n\023emEr" +
      "rorFileNotFound\020\001\022\031\n\025emErrorInvalidASFFi" +
      "le\020\002\022\031\n\025emErrorObjectNotFound\020\003\022\023\n\017emErr" +
      "orBadIndex\020\004\022\030\n\024emErrorValueNotFound\020\005\022\026",
      "\n\022emErrorBadArgument\020\006\022\023\n\017emErrorReadOnl" +
      "y\020\007\022\031\n\025emErrorNotEnoughSpace\020\010\022\030\n\024emErro" +
      "rInternalError\020\t\022\030\n\024emErrorReadFileError" +
      "\020\n\022\031\n\025emErrorWriteFileError\020\013\022\030\n\024emError" +
      "SeekFileError\020\014\022\032\n\026emErrorCreateFileErro" +
      "r\020\r\022\034\n\030emErrorCreateThreadError\020\016\022\032\n\026emE" +
      "rrorObjectNULLError\020\017\022\036\n\032emErrorTooMuchV" +
      "ideoStrream\020\020\022\034\n\030emErrorNotSupportedCode" +
      "c\020\021\022\022\n\016emErrorFileEnd\020\022\022\027\n\023emErrorUnknow" +
      "nError\020\023\022\030\n\024emErrorWriteMemError\020\024\022\030\n\024em",
      "ErrorFileNameEmpty\020\025\022\021\n\remErrorNotDir\020\026\022" +
      "\017\n\013emErrorLoop\020\027\022\021\n\remErrorAccess\020\030\022\026\n\022e" +
      "mErrorNameTooLong\020\031*>\n\nEmKeyState\022\013\n\007emK" +
      "eyUp\020\000\022\r\n\temKeyDown\020\001\022\024\n\020emKeyLongPresse" +
      "d\020\002*`\n\023EmVideoRecordStatus\022\025\n\021emVideoRec" +
      "ordIdle\020\000\022\032\n\026emVideoRecordRecording\020\001\022\026\n" +
      "\022emVideoRecordPause\020\002*T\n\025EmWirelessScree" +
      "nState\022\034\n\030emWirelessScreen_enabled\020\000\022\035\n\031" +
      "emWirelessScreen_disabled\020\001*\263\001\n\031EmWirele" +
      "ssScreenErrReason\022\"\n\036emWirelessScreenErr",
      "Reason_None\020\000\022$\n emWirelessScreenErrReas" +
      "on_Failed\020\001\022%\n!emWirelessScreenErrReason" +
      "_Timeout\020\002\022%\n!emWirelessScreenErrReason_" +
      "Unknown\020\003*\177\n\014EmMtWarnType\022\021\n\remMtWarnBeg" +
      "in\020\000\022\020\n\014emMtWarnTemp\020\001\022\024\n\020emMtWarnFanSpe" +
      "ed\020\002\022\017\n\013emMtWarnCpu\020\004\022\020\n\014emMtWarnVolt\020\010\022" +
      "\021\n\013emMtWarnEnd\020\200\200\002*j\n\017EmLimitedIpType\022\035\n" +
      "\031emLimitedIpType_WhiteList\020\000\022\035\n\031emLimite" +
      "dIpType_BlackList\020\001\022\031\n\025emLimitedIpType_R" +
      "eset\020\002*Z\n\031EmTerControlCameraOsdType\022\023\n\017e",
      "mCameraOsdMenu\020\000\022\021\n\remCameraOsdOk\020\001\022\025\n\021e" +
      "mCameraOsdReture\020\002*$\n\014EmDigestType\022\t\n\005em" +
      "Sm3\020\000\022\t\n\005emMd5\020\001*$\n\014EmPubPriType\022\t\n\005emRs" +
      "a\020\001\022\t\n\005emSm2\020\002*\213\002\n\020EmSrtpCryptoType\022\024\n\020e" +
      "mSrtpCryptoNone\020\000\022\032\n\026emSrtpCryptoAES_CM_" +
      "128\020\001\022\032\n\026emSrtpCryptoAES_CM_192\020\002\022\032\n\026emS" +
      "rtpCryptoAES_CM_256\020\003\022\033\n\027emSrtpCryptoAES" +
      "_GCM_128\020\004\022\033\n\027emSrtpCryptoAES_GCM_192\020\005\022" +
      "\033\n\027emSrtpCryptoAES_GCM_256\020\006\022\032\n\026emSrtpCr" +
      "yptoSM4_CM_128\020\007\022\032\n\026emSrtpCryptoSM1_CM_1",
      "28\020\010*{\n\016EmSrtpAuthType\022\022\n\016emSrtpAuthNone" +
      "\020\000\022\023\n\017emSrtpAuthTag_8\020\001\022\024\n\020emSrtpAuthTag" +
      "_16\020\002\022\024\n\020emSrtpAuthTag_32\020\003\022\024\n\020emSrtpAut" +
      "hTag_80\020\004*h\n\020EmSipConnectType\022\023\n\017emSipUd" +
      "pConnect\020\000\022\023\n\017emSipTcpConnect\020\001\022\023\n\017emSip" +
      "TlsConnect\020\002\022\025\n\021emSipGMTlsConnect\020\003*\224\001\n\017" +
      "EmSecCertFormat\022\031\n\025emSecCertFormart_NULL" +
      "\020\000\022\030\n\024emSecCertFormart_PEM\020\001\022\030\n\024emSecCer" +
      "tFormart_DER\020\002\022\030\n\024emSecCertFormart_PFX\020\003" +
      "\022\030\n\024emSecCertFormart_B64\020\004*S\n\014EmRecordTy",
      "pe\022\025\n\021emStartRecordType\020\000\022\026\n\022emConferenc" +
      "eRecord\020\001\022\024\n\020emTerminalRecord\020\002*8\n\rEmPub" +
      "lishMode\022\024\n\020emNotPublishMode\020\000\022\021\n\remPubl" +
      "ishMode\020\001*_\n\014EmRecordMode\022\027\n\023emDisableRe" +
      "cordMode\020\000\022\020\n\014emRecordMode\020\001\022\016\n\nemLiveMo" +
      "de\020\002\022\024\n\020emRecordLiveMode\020\003*T\n\nEmCallMode" +
      "\022\021\n\remMannualCall\020\000\022\016\n\nemAutoCall\020\001\022\020\n\014e" +
      "mTimingCall\020\002\022\021\n\remChasingCall\020\003*n\n\rEmRe" +
      "cordState\022\021\n\remDoNotRecord\020\000\022\017\n\013emRecord" +
      "ing\020\001\022\023\n\017emSuspendRecord\020\002\022\017\n\013emCallingM",
      "T\020\003\022\023\n\017emPrepareRecord\020\004*J\n\013EmRecordCmd\022" +
      "\022\n\016emRecordCmdBak\020\000\022\021\n\remPauseRecord\020\001\022\024" +
      "\n\020emContinueRecord\020\002*\371\001\n\013EmMtDcsType\022\021\n\r" +
      "emTypeUnknown\020\000\022\022\n\016emTypeTrueLink\020\001\022\033\n\027e" +
      "mTypeTrueTouchPhoneIOS\020\002\022\031\n\025emTypeTrueTo" +
      "uchPadIOS\020\003\022\037\n\033emTypeTrueTouchPhoneAndro" +
      "id\020\004\022\035\n\031emTypeTrueTouchPadAndroid\020\005\022\022\n\016e" +
      "mTypeTrueSens\020\006\022\016\n\nemTypeIMIX\020\007\022\027\n\023emTyp" +
      "eThirdPartyTer\020\010\022\016\n\nemTypeButt\020\t*N\n\013EmMt" +
      "DcsRole\022\020\n\014emRoleManage\020\000\022\016\n\nemRoleOper\020",
      "\001\022\016\n\nemRoleUser\020\002\022\r\n\temRoleErr\020\n*O\n\017EmMt" +
      "DcsConfMode\022\022\n\016emConfModeStop\020\000\022\024\n\020emCon" +
      "fModeManage\020\001\022\022\n\016emConfModeAuto\020\002*7\n\017EmM" +
      "tDcsConfType\022\021\n\remConfTypeP2P\020\000\022\021\n\remCon" +
      "fTypeMCC\020\001*0\n\rEmMtDcsWbMode\022\016\n\nemWbModeW" +
      "B\020\000\022\017\n\013emWBModeDOC\020\001*c\n\016EmWbEntityType\022\014" +
      "\n\010emUnknow\020\000\022\n\n\006emLine\020\001\022\014\n\010emCircle\020\002\022\014" +
      "\n\010emPencil\020\003\022\016\n\nemColorPen\020\004\022\013\n\007emImage\020" +
      "\005*\337\001\n\016EmWbImageState\022\033\n\027emImageStateDown" +
      "loading\020\000\022\034\n\030emImageStateDownLoadFail\020\001\022",
      "!\n\035emImageStateOwnerAlreadyLeave\020\002\022\032\n\026em" +
      "ImageStateDownLoadOk\020\003\022\024\n\020emImageStateIn" +
      "it\020\004\022\033\n\027emImageStateConvertFail\020\005\022 \n\034emI" +
      "mageStateSelfAlreadyLeave\020\006*G\n\010EmWBMode\022" +
      "\022\n\016emWbModeUnkown\020\000\022\026\n\022emWbModeWhiteBoar" +
      "d\020\001\022\017\n\013emWbModeDOC\020\002*9\n\020EmDcsConnectType" +
      "\022\022\n\016emConnectLogin\020\000\022\021\n\remConnectConf\020\001*" +
      "\377\003\n\tEmDcsOper\022\024\n\020emWbLineOperInfo\020\000\022\026\n\022e" +
      "mWbCircleOperInfo\020\001\022\031\n\025emWbRectangleOper" +
      "Info\020\002\022\026\n\022emWbPencilOperInfo\020\003\022\030\n\024emWbCo",
      "lorPenOperInfo\020\004\022\025\n\021emWbImageOperInfo\020\005\022" +
      "\026\n\022emWbAddSubPageInfo\020\006\022\025\n\021emWbEraseOper" +
      "Info\020\007\022\020\n\014emWbZoomInfo\020\010\022\014\n\010emWbUndo\020\t\022\014" +
      "\n\010emWbRedo\020\n\022\022\n\016emWbRotateLeft\020\013\022\023\n\017emWb" +
      "RotateRight\020\014\022\023\n\017emWbClearScreen\020\r\022\024\n\020em" +
      "WbScrollScreen\020\016\022\022\n\016emWbFullScreen\020\017\022\033\n\027" +
      "emWb100ProportionScreen\020\020\022\022\n\016emWbReginEr" +
      "ase\020\021\022\021\n\remWbInsertPic\020\022\022\024\n\020emWbPitchPic" +
      "Zoom\020\023\022\026\n\022emWbPitchPicRotate\020\024\022\024\n\020emWbPi" +
      "tchPicDrag\020\025\022\023\n\017emWbPitchPicDel\020\026*\216\001\n\023Em",
      "DcsConnectErrCode\022\021\n\remConfSuccess\020\001\022\020\n\014" +
      "emConfFailed\020\002\022\024\n\020emConfDisconnect\020\003\022\022\n\016" +
      "emLoginSuccess\020\004\022\021\n\remLoginFailed\020\005\022\025\n\021e" +
      "mLoginDisconnect\020\006*\351\001\n\032EmDcsAdpRejectJoi" +
      "nConfCode\022\032\n\026emRejectJoinConf_start\020\001\022\031\n" +
      "\025emRejectJoinConf_busy\020\002\022\033\n\027emRejectJoin" +
      "Conf_normal\020\003\022\035\n\031emRejectJoinConf_reject" +
      "ed\020\004\022 \n\034emRejectJoinConf_unreachable\020\005\022\034" +
      "\n\030emRejectJoinConf_unknown\020\006\022\030\n\024emReject" +
      "JoinConf_end\020\007*C\n\rEmSecAutState\022\020\n\014emSec",
      "Autidle\020\000\022\017\n\013emSecAuting\020\001\022\017\n\013emSecAutsu" +
      "c\020\002*t\n\022EmAuthCancelReason\022\024\n\020emSecAuth_C" +
      "ancel\020\001\022\031\n\025emSecAuth_ErrOverTime\020\002\022\024\n\020em" +
      "SecAut_TimeOut\020\003\022\027\n\023emSecAut_ErrConnect\020" +
      "\004*U\n\022EmSecKeyUpdateMode\022\036\n\032EmSecKeyUpdat" +
      "eModeByPeriod\020\000\022\037\n\033EmSecKeyUpdateModeByP" +
      "ackage\020\001*6\n\020EmCameraCtrlType\022\020\n\014emIspImg" +
      "Ctrl\020\001\022\020\n\014emSerialCtrl\020\002*,\n\rEmVersionTyp" +
      "e\022\r\n\temChannel\020\000\022\014\n\010emOthers\020\001*Z\n\026EmLice" +
      "nseKeyCheckValue\022\016\n\nemWrongKey\020\000\022\016\n\nemRi",
      "ghtKey\020\001\022\016\n\nemNotExist\020\002\022\020\n\014emParseError" +
      "\020\003*\376\001\n\021EmCameraErrorType\022\035\n\031EmCameraErro" +
      "rType_unknown\020\000\022\037\n\033EmCameraErrorType_Zoo" +
      "minEnd\020\001\022 \n\034EmCameraErrorType_ZoomoutEnd" +
      "\020\002\022\037\n\033EmCameraErrorType_TiltUpEnd\020\003\022!\n\035E" +
      "mCameraErrorType_TiltDownEnd\020\004\022 \n\034EmCame" +
      "raErrorType_PanLeftEnd\020\005\022!\n\035EmCameraErro" +
      "rType_PanRightEnd\020\006*\240\001\n\021EmCameraSceneMod" +
      "e\022\036\n\032EmCameraSceneMode_Standard\020\000\022\037\n\033EmC" +
      "ameraSceneMode_Projector\020\001\022#\n\037EmCameraSc",
      "eneMode_Peoplefeature\020\002\022%\n!EmCameraScene" +
      "Mode_Peoplebacklight\020\003*5\n\017EmMtVConfStatu" +
      "s\022\020\n\014emVConf_Idle\020\000\022\020\n\014emVConf_Busy\020\001*_\n" +
      "\rEmMtMaxJoinMt\022\021\n\remMaxJoinMt_8\020\000\022\022\n\016emM" +
      "axJoinMt_32\020\001\022\022\n\016emMaxJoinMt_64\020\002\022\023\n\017emM" +
      "axJoinMt_192\020\003*\370\001\n\022EmMtVConfResources\022\031\n" +
      "\025emVConfResource_8_720\020\001\022\032\n\026emVConfResou" +
      "rce_8_1080\020\002\022\032\n\026emVConfResource_32_720\020\003" +
      "\022\033\n\027emVConfResource_32_1080\020\004\022\032\n\026emVConf" +
      "Resource_64_720\020\005\022\033\n\027emVConfResource_64_",
      "1080\020\006\022\033\n\027emVConfResource_192_720\020\007\022\034\n\030e" +
      "mVConfResource_192_1080\020\010*2\n\013EmMtFecMode" +
      "\022\021\n\remMtFec_Close\020\000\022\020\n\014emMtFec_Open\020\001*J\n" +
      "\nEmPlatform\022\022\n\016emOLD_PLATFORM\020\000\022\023\n\017emBUS" +
      "S_PLATFORM\020\001\022\023\n\017emCOMM_PLATFORM\020\002*\251\002\n\014Em" +
      "MtChipType\022\021\n\remMtChip_Main\020\000\022\024\n\020emMtChi" +
      "p_VidEnc1\020\001\022\024\n\020emMtChip_VidEnc2\020\002\022\024\n\020emM" +
      "tChip_VidEnc3\020\003\022\024\n\020emMtChip_VidEnc4\020\004\022\024\n" +
      "\020emMtChip_VidEnc5\020\005\022\024\n\020emMtChip_VidDec1\020" +
      "\006\022\024\n\020emMtChip_VidDec2\020\007\022\024\n\020emMtChip_VidD",
      "ec3\020\010\022\024\n\020emMtChip_VidDec4\020\t\022\024\n\020emMtChip_" +
      "VidDec5\020\n\022\024\n\020emMtChip_AudEnc1\020\013\022\024\n\020emMtC" +
      "hip_AudDec1\020\014*\242\002\n\017EmClientAppType\022\022\n\016emC" +
      "lientAppOsd\020\000\022\031\n\025emClientAppWebService\020\001" +
      "\022\027\n\023emClientAppSkyShare\020\002\022\030\n\024emClientApp" +
      "SkyRemote\020\003\022\025\n\021emClientAppSkyMTC\020\004\022\031\n\025em" +
      "ClientAppSkyWindows\020\005\022\031\n\025emClientAppSkyA" +
      "ndroid\020\006\022\025\n\021emClientAppSkyIOS\020\007\022\031\n\025emCli" +
      "entAppThirdParty\020\010\022\027\n\023emClientAppNexViso" +
      "n\020\t\022\025\n\021emClientAppMTCEnd\020\n*Y\n\nEmAuthType",
      "\022\025\n\021emUserNamePwdAuth\020\000\022\022\n\016emInnerPwdAut" +
      "h\020\001\022\021\n\remDynamicAuth\020\002\022\r\n\temAuthEnd\020\003*]\n" +
      "\021EmLoginFailReason\022\014\n\010emPwdErr\020\001\022\021\n\remTe" +
      "rStarting\020\002\022\022\n\016emTerUpgrading\020\003\022\023\n\017emFai" +
      "lReasonEnd\020\n*`\n\021EmVConfCreateType\022\026\n\022emC" +
      "reateNormalConf\020\000\022\027\n\023emCreateVirtualConf" +
      "\020\001\022\032\n\026emCreateConfByTemplate\020\002*\231\001\n\tEmQkS" +
      "tate\022\014\n\010emUsbOff\020\000\022\013\n\007emUsbOn\020\001\022\016\n\nemUpd" +
      "ating\020\002\022\t\n\005emWps\020\003\022\r\n\temWpsSucc\020\004\022\014\n\010emA" +
      "pLink\020\005\022\013\n\007emApOff\020\006\022\r\n\temQkStart\020\007\022\013\n\007e",
      "mQkOff\020\010\022\020\n\014emWpsTimeOut\020\t*`\n\016EmResource" +
      "Type\022\031\n\025emResourceType_LimitP\020\000\022\032\n\026emRes" +
      "ourceType_LimitPR\020\001\022\027\n\023emResourceType_No" +
      "ne\020\002*J\n\024EmAgentPackFileState\022\022\n\016emPackNo" +
      "tStart\020\000\022\r\n\temPacking\020\001\022\017\n\013emPackError\020\002" +
      "*\305\002\n\020EmMtUpgradeState\022\034\n\030emMtUpgradeStat" +
      "e_Invalid\020\000\022\037\n\033emMtUpgradeState_WaitingT" +
      "ar\020\001\022\033\n\027emMtUpgradeState_Taring\020\002\022#\n\037emM" +
      "tUpgradeState_WaitingUpgrade\020\003\022\036\n\032emMtUp" +
      "gradeState_Upgrading\020\004\022%\n!emMtUpgradeSta",
      "te_FileCheckSuccess\020\005\022\"\n\036emMtUpgradeStat" +
      "e_FileCheckFail\020\006\022#\n\037emMtUpgradeState_Up" +
      "gradeSuccess\020\007\022 \n\034emMtUpgradeState_Upgra" +
      "deFail\020\010*\342\003\n\020EmCodecBoardType\022\021\n\rem_H600" +
      "_Board\020\001\022\021\n\rem_H700_Board\020\002\022\021\n\rem_H900_B" +
      "oard\020\003\022\021\n\rem_HDU2_Board\020\004\022\021\n\rem_MPU2_Boa" +
      "rd\020\005\022\021\n\rem_APU2_Board\020\006\022\023\n\017em_HDU2_Board" +
      "_S\020\007\022\021\n\rem_X500_Board\020\010\022\021\n\rem_T300_Board" +
      "\020\t\022\027\n\023em_MIC3D_WIRE_Board\020\n\022\033\n\027em_MIC3D_" +
      "WIRELESS_Board\020\013\022\033\n\027em_TrueVoc3D_WIRE_Bo",
      "ard\020\014\022\021\n\rem_X700_Board\020\r\022\021\n\rem_X300_Boar" +
      "d\020\016\022\023\n\017em_SKY300_Board\020\017\022\023\n\017em_SKY100_Bo" +
      "ard\020\020\022\027\n\023em_SKY300_Board_650\020\021\022\024\n\020em_SKY" +
      "D510_Board\020\022\022\021\n\rem_X510_Board\020\023\022\021\n\rem_X3" +
      "10_Board\020\024\022\023\n\017em_Sky310_Board\020\025\022\024\n\020em_In" +
      "valid_Board\020 *\250\002\n\022EmFtSerialBandrate\022\030\n\024" +
      "emSerialBandrate_300\020\000\022\031\n\025emSerialBandra" +
      "te_1200\020\001\022\031\n\025emSerialBandrate_2400\020\002\022\031\n\025" +
      "emSerialBandrate_4800\020\003\022\031\n\025emSerialBandr" +
      "ate_9600\020\004\022\032\n\026emSerialBandrate_19200\020\005\022\032",
      "\n\026emSerialBandrate_38400\020\006\022\032\n\026emSerialBa" +
      "ndrate_57600\020\007\022\033\n\027emSerialBandrate_11520" +
      "0\020\010\022\033\n\027emSerialBandrate_230400\020\t*v\n\022EmFt" +
      "SerialFunction\022\023\n\017emSerialConsole\020\000\022\022\n\016e" +
      "mInfraredCtrl\020\001\022\021\n\remSerialVisca\020\002\022\020\n\014em" +
      "RemoteCtrl\020\003\022\022\n\016emSerialDigMic\020\004*q\n\013EmFt" +
      "NetType\022\014\n\010emEth10M\020\000\022\r\n\temEth100M\020\001\022\016\n\n" +
      "emEth1000M\020\002\022\013\n\007emPppoe\020\003\022\r\n\temWifi24G\020\004" +
      "\022\014\n\010emWifi5G\020\005\022\013\n\007emNetE1\020\006*\'\n\013EmFtUsbTy" +
      "pe\022\013\n\007emUsb20\020\000\022\013\n\007emUsb30\020\001*]\n\022EmFtDual",
      "StreamType\022\025\n\021emDualStream_Hard\020\000\022\025\n\021emD" +
      "ualStream_Soft\020\001\022\031\n\025emDualStream_Wireles" +
      "s\020\002*\255\003\n\024EmFtVideoInportGroup\022\027\n\023emVideoI" +
      "nportGroup1\020\000\022\027\n\023emVideoInportGroup2\020\001\022\027" +
      "\n\023emVideoInportGroup3\020\002\022\027\n\023emVideoInport" +
      "Group4\020\003\022\027\n\023emVideoInportGroup5\020\004\022\027\n\023emV" +
      "ideoInportGroup6\020\005\022\027\n\023emVideoInportGroup" +
      "7\020\006\022\027\n\023emVideoInportGroup8\020\007\022\027\n\023emVideoI" +
      "nportGroup9\020\010\022\030\n\024emVideoInportGroup10\020\t\022" +
      "\030\n\024emVideoInportGroup11\020\n\022\030\n\024emVideoInpo",
      "rtGroup12\020\013\022\030\n\024emVideoInportGroup13\020\014\022\030\n" +
      "\024emVideoInportGroup14\020\r\022\030\n\024emVideoInport" +
      "Group15\020\016\022\030\n\024emVideoInportGroup16\020\017*O\n\016E" +
      "mFtSdiUseType\022\020\n\014emSdiInvalid\020\000\022\024\n\020emSdi" +
      "Replaceable\020\001\022\025\n\021emSdiConfigurable\020\002*G\n\r" +
      "EmSdiUseState\022\021\n\remSdiNotExist\020\000\022\020\n\014emSd" +
      "iAsInput\020\001\022\021\n\remSdiAsOutput\020\002*G\n\016EmFtCut" +
      "OutType\022\021\n\remFpgaNothing\020\000\022\020\n\014emFpgaCutO" +
      "ut\020\001\022\020\n\014emAlphaLayer\020\002*\310\004\n\016EmFtStreamTyp" +
      "e\022\031\n\025emStreamType_Send_Aud\020\000\022\032\n\026emStream",
      "Type_Send_Main\020\001\022\036\n\032emStreamType_Send_Vi" +
      "deoAss\020\002\022\033\n\027emStreamType_Send_PcAss\020\003\022\037\n" +
      "\033emStreamType_Send_Mul_Main1\020\004\022\037\n\033emStre" +
      "amType_Send_Mul_Main2\020\005\022\037\n\033emStreamType_" +
      "Send_Mul_Main3\020\006\022\"\n\036emStreamType_Send_Mu" +
      "l_VideoAss\020\007\022\037\n\033emStreamType_Send_Mul_Pc" +
      "Ass\020\010\022\031\n\025emStreamType_Recv_Aud\020\n\022\032\n\026emSt" +
      "reamType_Recv_Main\020\013\022\036\n\032emStreamType_Rec" +
      "v_VideoAss\020\014\022\033\n\027emStreamType_Recv_PcAss\020" +
      "\r\022\037\n\033emStreamType_Recv_Mul_Main1\020\016\022\037\n\033em",
      "StreamType_Recv_Mul_Main2\020\017\022\037\n\033emStreamT" +
      "ype_Recv_Mul_Main3\020\020\022\"\n\036emStreamType_Rec" +
      "v_Mul_VideoAss\020\021\022\037\n\033emStreamType_Recv_Mu" +
      "l_PcAss\020\022*7\n\021EmFtAudFileFormat\022\020\n\014emAudF" +
      "ileBit\020\001\022\020\n\014emAudFilePcm\020\002*\274\001\n\020EmFtFirmw" +
      "areType\022\020\n\014emFwMtHwType\020\001\022\017\n\013emFwMtHwVer" +
      "\020\002\022\017\n\013emFwMtSwVer\020\003\022\014\n\010emFwMtSn\020\004\022\014\n\010emF" +
      "wFpga\020\005\022\014\n\010emFwCpld\020\006\022\013\n\007emFwPtz\020\007\022\016\n\nem" +
      "FwCamera\020\010\022\020\n\014emFwInfrared\020\t\022\013\n\007emFwMic\020" +
      "\n\022\016\n\nemFwRemote\020\013*\315\003\n\rEmFtResetType\022\027\n\023e",
      "mFtCallAndResponse\020\001\022\024\n\020emFtCallProtocol" +
      "\020\002\022\026\n\022emFtNetworkService\020\003\022\027\n\023emFtNetAda" +
      "ptAndPort\020\004\022\030\n\024emFtDualStreamFormat\020\005\022\017\n" +
      "\013emFtStandby\020\006\022\016\n\nemFtSafety\020\007\022\016\n\nemFtMt" +
      "cBox\020\010\022\016\n\nemFtSerial\020\t\022\027\n\023emFtSoundAndDi" +
      "splay\020\n\022\030\n\024emFtVolumeAndQuality\020\013\022\r\n\temF" +
      "tVideo\020\023\022\026\n\022emFtVidDisplayMode\020\024\022\033\n\027emFt" +
      "PreferredResolution\020\025\022\030\n\024emFtOutputResol" +
      "ution\020\026\022\024\n\020emFtVidSourceTag\020\027\022\027\n\023emFtVid" +
      "DisplayRatio\020\030\022\023\n\017emFtImageAdjust\020\031\022\026\n\022e",
      "mFtImageParameter\020\032\022\024\n\020emFtImageQuality\020" +
      "\033*=\n\022EmFtOsdScalingType\022\021\n\remFpgaScaling" +
      "\020\001\022\024\n\020emMasterCtrlPlay\020\002*e\n\rEmFtMaxVidSr" +
      "c\022\026\n\022emMaxVidSrcInvalid\020\001\022\023\n\017emMaxVidSrc" +
      "720p\020\002\022\024\n\020emMaxVidSrc1080p\020\003\022\021\n\remMaxVid" +
      "Src4k\020\004*\\\n\016EmFtCameraType\022\023\n\017emCameraGen" +
      "eral\020\000\022\021\n\remCameraInner\020\001\022\020\n\014emCameraMoo" +
      "n\020\002\022\020\n\014emCameraSony\020\003*j\n\022EmFtCameraCtrlT" +
      "ype\022\016\n\nemCtrlNone\020\000\022\020\n\014emCtrlIspImg\020\001\022\017\n" +
      "\013emCtrlVisca\020\002\022\020\n\014emCtrlBrdPtz\020\003\022\017\n\013emCt",
      "rlPelco\020\004*\276\004\n\017EmFtUpgradeType\022\022\n\016emUpgra" +
      "de_None\020\000\022\023\n\017emUpgrade_UgDtb\020\001\022\026\n\022emUpgr" +
      "ade_UbootBin\020\002\022\026\n\022emUpgrade_UbootImg\020\003\022\021" +
      "\n\remUpgrade_Mlo\020\004\022\027\n\023emUpgrade_FpgaX500a" +
      "\020\005\022\023\n\017emUpgrade_UgPic\020\006\022\023\n\017emUpgrade_UgI" +
      "os\020\007\022\024\n\020emUpgrade_UgVcmt\020\010\022\023\n\017emUpgrade_" +
      "UgApp\020\t\022\030\n\024emUpgrade_UgRecovery\020\n\022\024\n\020emU" +
      "pgrade_Ugboot\020\013\022\031\n\025emUpgrade_UgBaseparam" +
      "\020\014\022\027\n\023emUpgrade_UgPqparam\020\r\022\021\n\remUpgrade" +
      "_Scm\020\016\022\024\n\020emUpgrade_Camera\020\017\022\026\n\022emUpgrad",
      "e_Boot3519\020\020\022\026\n\022emUpgrade_Boot3536\020\021\022\023\n\017" +
      "emUpgrade_Fpga0\020\022\022\023\n\017emUpgrade_Fpga1\020\023\022\023" +
      "\n\017emUpgrade_Fpga2\020\024\022\023\n\017emUpgrade_Fpga3\020\025" +
      "\022\023\n\017emUpgrade_Fpga4\020\026\022\023\n\017emUpgrade_Fpga5" +
      "\020\027\022\026\n\022emUpgrade_JedFpga0\020\030*\277\001\n\024EmFtUpgra" +
      "deCondition\022\026\n\022emCondition_Always\020\000\022\027\n\023e" +
      "mCondition_Changed\020\001\022\026\n\022emCondition_Hwve" +
      "r0\020\002\022\026\n\022emCondition_Hwver1\020\003\022\026\n\022emCondit" +
      "ion_Hwver2\020\004\022\026\n\022emCondition_Hwver3\020\005\022\026\n\022" +
      "emCondition_Hwver4\020\006*Y\n\017EmFtOpticalZoom\022",
      "\031\n\025emOpticalZoom_Invalid\020\000\022\025\n\021emOpticalZ" +
      "oom_12X\020\001\022\024\n\020emOpticalZoom_5X\020\002*\313\006\n\014EmFt" +
      "InfoType\022\021\n\remFtInfoBegin\020\000\022\022\n\016emFtCamer" +
      "aCtrl\020\001\022\024\n\020emFtDeviceSerial\020\002\022\022\n\016emFtSup" +
      "portNet\020\003\022\021\n\remFtDeviceUsb\020\004\022\022\n\016emFtDual" +
      "Stream\020\005\022\022\n\016emFtSupportFxo\020\006\022\021\n\remFtAudi" +
      "oInfo\020\007\022\023\n\017emFtVideoInList\020\010\022\023\n\017emFtVide" +
      "oInPort\020\t\022\024\n\020emFtVideoOutPort\020\n\022\023\n\017emFtS" +
      "diinoutGet\020\013\022\016\n\nemFtOsdCut\020\014\022\031\n\025emFtOutp" +
      "utModeDisplay\020\r\022\032\n\026emFtSourceToOutputMod",
      "e\020\016\022\026\n\022emFtMediaCapbility\020\017\022\026\n\022emFtVidEn" +
      "cRestrict\020\020\022\033\n\027emFtMultiVideoCapbility\020\021" +
      "\022\030\n\024emFtSupportMaxVidSrc\020\022\022\032\n\026emFtInnerC" +
      "amStdSupport\020\023\022\030\n\024emFtMaxOsdSupportRes\020\024" +
      "\022\024\n\020emFtAudPlyFormat\020\025\022\024\n\020emFtFirmwareIn" +
      "fo\020\026\022\023\n\017emFtReleaseInfo\020\027\022\021\n\remFtResetIn" +
      "fo\020\030\022\024\n\020emFtShortMsgInfo\020\031\022\020\n\014emFtOsdSca" +
      "le\020\032\022\027\n\023emFtH323StandardPro\020\033\022\024\n\020emFtTer" +
      "minalInfo\020\034\022\025\n\021emFtSupportMicNum\020\035\022\024\n\020em" +
      "FtMtUpgradeCfg\020\036\022\025\n\021emFtMtVerRestrict\020\037\022",
      "\026\n\022emFtMediaBoardInfo\020 \022\024\n\020emFtSrvLoginI" +
      "nfo\020!\022\026\n\022emFtLimitAttribute\020\"\022\025\n\021emFtUID" +
      "isplayInfo\020#\022\027\n\023emFtInnerCameraList\020$*h\n" +
      "\021EmShortCutKeyType\022\014\n\010emUnkown\020\000\022\024\n\020emRe" +
      "dShortCutKey\020\001\022\027\n\023emYellowShortCutKey\020\002\022" +
      "\026\n\022emGreenShortCutKey\020\003*\256\001\n\020EmShortCutKe" +
      "yFuc\022\016\n\nemFucBegin\020\000\022\n\n\006emLoop\020\001\022\020\n\014emAp" +
      "plyChair\020\002\022\022\n\016emApplySpeaker\020\003\022\024\n\020emShow" +
      "SystemInfo\020\004\022\016\n\nemFullMute\020\005\022\022\n\016emSpeech" +
      "Helper\020\006\022\021\n\remFaceCheckIn\020\007\022\013\n\007emClose\020\024",
      "*f\n\nEmHwStatus\022\021\n\remNotDetected\020\000\022\021\n\remU" +
      "nsupported\020\001\022\030\n\024emSupportedAndOpened\020\002\022\030" +
      "\n\024emSupportedAndClosed\020\003*\237\r\n\020EmDefaultCf" +
      "gType\022\022\n\016emCfgInfoBegin\020\000\022\027\n\023emCfgPriVid" +
      "EncParam\020\001\022\027\n\023emCfgAssVidEncParam\020\002\022\024\n\020e" +
      "mCfgPriVidPrior\020\003\022\026\n\022emCfgPcAssVidPrior\020" +
      "\004\022\027\n\023emCfgVidAssVidPrior\020\005\022\r\n\temCfgPort\020" +
      "\006\022\024\n\020emCfgHDResOutput\020\007\022\026\n\022emCfgMtcBanne" +
      "rInfo\020\010\022\026\n\022emCfgOsdBannerInfo\020\t\022\027\n\023emCfg" +
      "AudOutPortList\020\n\022\026\n\022emCfgAudInPortList\020\013",
      "\022\030\n\024emCfgPri1stVidInPort\020\014\022\030\n\024emCfgPri2n" +
      "dVidInPort\020\r\022\030\n\024emCfgPri3rdVidInPort\020\016\022\025" +
      "\n\021emCfgAssVidInPort\020\017\022\023\n\017emCfgMultiVideo" +
      "\020\020\022\032\n\026emCfgVideoMatrixScheme\020\021\022\023\n\017emCfgS" +
      "erialList\020\022\022\032\n\026emCfgSerialMonitorList\020\023\022" +
      "\024\n\020emCfgVideoSrcTag\020\024\022\024\n\020emCfgVideoOutTa" +
      "g\020\025\022\023\n\017emCfgCameraList\020\026\022\030\n\024emCfgVidInPo" +
      "rtBright\020\027\022\032\n\026emCfgVidInPortContrast\020\030\022\034" +
      "\n\030emCfgVidInPortSaturation\020\031\022\023\n\017emCfgAns" +
      "werMode\020\032\022\021\n\remCfgAutoCall\020\033\022\025\n\021emCfgBan",
      "dWithTest\020\034\022\024\n\020emCfgCallBitrate\020\035\022\027\n\023emC" +
      "fgkeepAliveItrvl\020\036\022\032\n\026emCfgSipkeepAliveI" +
      "trvl\020\037\022\022\n\016emCfgStaticPic\020 \022\020\n\014emCfgAutoP" +
      "ip\020!\022\033\n\027emCfgAutoSendSharedCont\020\"\022\030\n\024emC" +
      "fgDualStramSrcAdj\020#\022\025\n\021emCfgCallProtocol" +
      "\020$\022\023\n\017emCfgAudioPrior\020%\022\020\n\014emCfgH264Svc\020" +
      "&\022\r\n\temCfgH323\020\'\022\014\n\010emCfgSip\020(\022\022\n\016emCfgL" +
      "abelInfo\020)\022\023\n\017emCfgCallInRing\020*\022\024\n\020emCfg" +
      "CallOutRing\020+\022\025\n\021emCfgKeyboardRing\020,\022\024\n\020" +
      "emCfgShowAppTips\020-\022\026\n\022emCfgShowInOutConf",
      "\020.\022\017\n\013emCfgAiInfo\020/\022\021\n\remCfgShortMsg\0200\022\022" +
      "\n\016emCfgAutoSleep\0201\022\020\n\014emCfgSysTime\0202\022\021\n\r" +
      "emCfgAudVolIn\0203\022\020\n\014emCfgMicGain\0204\022\022\n\016emC" +
      "fgAudVolOut\0205\022\014\n\010emCfgAns\0206\022\014\n\010emCfgAgc\020" +
      "7\022\014\n\010emCfgAec\0208\022\024\n\020emCfgLastDisplay\0209\022\025\n" +
      "\021emCfgVidBitRation\020:\022\030\n\024emCfgImageNoiseL" +
      "evel\020;\022\025\n\021emCfgVidEncQcMode\020<\022\032\n\026emCfgLo" +
      "adAdaptiveVideo\020=\022\027\n\023emCfgVGAImageAdjust" +
      "\020>\022\026\n\022emCfgAsymmetricNet\020?\022\014\n\010emCfgFEC\020@" +
      "\022\030\n\024emCfgAudioPrecedence\020A\022\026\n\022emCfgLostP",
      "ktResend\020B\022\025\n\021emCfgTRtpSamePort\020C\022\027\n\023emC" +
      "fgSnapShotFtpCfg\020D\022\026\n\022emCfgSipConnection" +
      "\020E\022\020\n\014emCfgUseHTTP\020F\022\014\n\010emCfgCSU\020G\022\014\n\010em" +
      "CfgLog\020H\022\024\n\020emCfgShortCutKey\020I\022\026\n\022emCfgA" +
      "iFuncCfgList\020J\022\032\n\026emCfgAiWakeupOrSleepMt" +
      "\020K*{\n\024EmPltSupportConfType\022\030\n\024emPltConfT" +
      "ypeInvalid\020\000\022\026\n\022emSupportMediaConf\020\001\022\025\n\021" +
      "emSupportPortConf\020\002\022\032\n\026emSupportMediaPor" +
      "tConf\020\003*>\n\016EmFunctionIcon\022\027\n\023emFunctionI" +
      "conBegin\020\000\022\023\n\017emFaceCheckIcon\020\001*I\n\017EmCom",
      "mEnableEvt\022\017\n\013emBweEnable\020\000\022\020\n\014emIPv6Ena" +
      "ble\020\001\022\023\n\017emCommEnableEnd\020\005*I\n\017EmSysPathP" +
      "refix\022\021\n\remSysPathConf\020\000\022\020\n\014emSysPathLog" +
      "\020\001\022\021\n\remSysPathData\020\002*\221\001\n\020EmAPIVersionTy" +
      "pe\022\022\n\016emVcAPIVersion\020\000\022\022\n\016emMcAPIVersion" +
      "\020\001\022\023\n\017emEqpAPIVersion\020\002\022\026\n\022emSystemAPIVe" +
      "rsion\020\003\022\023\n\017emAmcAPIVersion\020\004\022\023\n\017emVrsAPI" +
      "Version\020\005*9\n\022EmMoonCameraStatus\022\021\n\remCam" +
      "eraClose\020\000\022\020\n\014emCameraOpen\020\001*O\n\014emConnec" +
      "tion\022\t\n\005EmPub\020\000\022\t\n\005EmSub\020\001\022\014\n\010EmAssPub\020\002",
      "\022\014\n\010EmAssSub\020\003\022\r\n\tEmConnEnd\020\004*\250\001\n\014EmRtcA" +
      "lgType\022\r\n\temRtcNone\020\000\022\014\n\010emRtcMd2\020\001\022\014\n\010e" +
      "mRtcMd5\020\002\022\014\n\010emRtcSM3\020\003\022\014\n\010emRtcSM4\020\004\022\r\n" +
      "\temRtcSHA1\020\005\022\017\n\013emRtcSHA224\020\006\022\017\n\013emRtcSH" +
      "A256\020\007\022\017\n\013emRtcSHA384\020\010\022\017\n\013emRtcSHA512\020\t" +
      "B+\n!com.kedacom.mt.netmanage.protobufB\006E" +
      "numPB"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
      new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
        public com.google.protobuf.ExtensionRegistry assignDescriptors(
            com.google.protobuf.Descriptors.FileDescriptor root) {
          descriptor = root;
          return null;
        }
      };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
        }, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
